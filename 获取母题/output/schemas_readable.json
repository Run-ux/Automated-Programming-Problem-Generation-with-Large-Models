[
  {
    "title": "万灵之树",
    "slug": "cnHoX6",
    "schema": {
      "Input Structure": [
        "长度为 n 的数组 gem[1..n]，表示每颗幻境宝石的数值",
        "gem[i] ∈ [0, 10^9]，整数，可重复",
        "二叉树中：所有叶子节点必须使用且仅使用一次 gem 中的元素（顺序与分配可变）",
        "非叶子节点为无限供应的链接节点，每个非叶子节点有恰好两个子节点",
        "最终构成一棵满二叉树（full binary tree），叶子数为 n，内部节点数为 n - 1"
      ],
      "Core Constraint": [
        "树结构必须是满二叉树（每个非叶节点有两个子节点）",
        "遍历规则固定：从根开始，首次访问记 '1'，若是叶节点则追加其数值，回溯时记 '9' 并返回父节点",
        "遍历路径唯一确定（优先走左子，未访问子节点存在时必走；否则回溯）",
        "最终生成的数字序列由树结构和叶子赋值共同决定",
        "不同的树结构或不同位置的宝石分配均视为不同方案"
      ],
      "Objective Function": "计数：满足 (生成的整数 num) mod p == target 的二叉树组装方案总数",
      "Algorithmic Invariant": [
        "满二叉树的结构可通过递归划分叶子集合来枚举：任意将叶子集划分为非空左右两子集，分别构建左右子树",
        "对每个子树，其 DFS 遍历字符串可独立构造（形如 '1' + left_str + right_str + '9' 或直接为叶节点值）",
        "模运算下字符串拼接可用数学方式合并：若左部分对应数 x，长度 L_x，右部分 y，则拼接结果为 x * 10^{len(y)} + y",
        "动态规划状态可定义为：dp[S][r] 表示使用叶子集合 S 构成的子树，其生成数 mod p = r 的方案数",
        "状态转移基于子集划分：S = L ∪ R，L ≠ ∅, R ≠ ∅，枚举所有合法划分"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前 n ≤ 9 → 可暴力枚举子集划分或卡特兰数相关结构；可扩展至 n=15（需优化 DP）或更高（需生成函数）",
        "值域范围：gem[i] 可达 10^9 → 影响拼接后数字长度与模运算处理方式；可改为小值域以允许字符串缓存",
        "模数 p 是否为素数：当前保证为素数 → 可用逆元等数论工具；可取消此约束变为一般模数",
        "target 范围：限定在 [0, p)，可改为多目标查询或区间判定",
        "是否要求输出方案而非计数：可变换为目标函数为‘构造一组解’",
        "输入形式：当前为离线一次性输入；可改为在线流式添加宝石（挑战结构动态性）",
        "树类型限制：当前为满二叉树；可推广为 k-叉树或允许单子节点（改变结构空间）",
        "遍历规则变化：如取消左右优先级、改为随机选择、引入标记等 → 改变路径不变量"
      ]
    }
  },
  {
    "title": "与非的谜题",
    "slug": "ryfUiz",
    "schema": {
      "Input Structure": [
        "一维数组 arr[0..n-1]，长度为 n，每个元素是 k 位非负整数（0 <= arr[i] < 2^k）",
        "操作序列 operations，每个操作为 [type, x, y]",
        "k 为二进制位数（1 <= k <= 30）",
        "type = 0 表示修改：将 arr[x] 更新为 y",
        "type = 1 表示运算：对初始值 y 执行 x*n 次 NAND 操作，依次与 arr[i % n] 进行 NAND"
      ],
      "Core Constraint": [
        "NAND 操作具有非线性、不可交换但可顺序定义的性质：a NAND b = NOT(a AND b)",
        "每次 type=1 的运算需遍历谜题数组 arr 多轮（共 x 轮，每轮 n 步），依赖当前 arr 的实时状态",
        "修改操作会影响后续所有运算操作的结果",
        "由于 x 可达 1e9，直接模拟 x*n 次操作不可行，必须寻找周期性或状态压缩规律"
      ],
      "Objective Function": "将所有 type=1 运算操作的结果按顺序进行 XOR 异或，输出最终异或值",
      "Algorithmic Invariant": [
        "k 位二进制下，NAND 序列在固定数组 arr 上具有状态循环性：从任意起始值 y 出发，经过若干轮完整 arr 的 NAND 后，状态会进入循环",
        "每轮完整的 arr 遍历可视为一个变换函数 f: {0,1}^k → {0,1}^k，该函数确定且可预计算",
        "利用函数迭代的快速幂思想（倍增 / 环检测），可在 O(k * 2^k + log x) 时间内计算 x 轮后的结果",
        "维护 arr 的实时状态，支持单点更新（type=0），并能重新生成变换函数"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^4",
        "operations 长度": "1 <= len(operations) <= 10^4",
        "x 的范围": "1 <= x < 10^9（决定是否需要周期优化）",
        "k 的取值": "1 <= k <= 30（影响状态空间大小和可行性）",
        "arr 是否有序": "无序，动态变化",
        "是否循环访问": "是，使用 i % n 循环遍历",
        "是否多组输入": "否（单次输入）",
        "是否在线": "是，操作按顺序执行，修改影响后续",
        "操作类型分布": "混合型（支持修改与查询）",
        "输出形式": "单个整数（所有运算结果的异或）",
        "是否允许负数": "否，所有值非负且限定在 k 位内"
      }
    }
  },
  {
    "title": "生物进化录",
    "slug": "qoQAMX",
    "schema": {
      "Input Structure": {
        "type": "Tree (represented by parent array)",
        "description": "An integer array `parents` of length n, where `parents[i]` denotes the parent node of node i. The root node has `parents[i] = -1`. Nodes are numbered from 0 to n-1, and it is guaranteed that `parents[i] < i` for all i > 0, ensuring a valid rooted tree construction order."
      },
      "Core Constraint": {
        "constraint": "The traversal must simulate a pointer moving on the tree: '0' appends a child and moves forward; '1' moves back to the parent. Each edge from parent to child must be traversed exactly once in the forward direction (via '0'), but backward moves ('1') can occur multiple times as needed. All nodes must be created in the order of their appearance in the evolution process.",
        "implication": "The string encodes a DFS-like walk on the tree, starting at the root, creating children via '0', and returning via '1'. Every non-root node is introduced by a '0' under its parent. The entire structure is uniquely determined by the sequence of expansions and backtracks."
      },
      "Objective Function": {
        "goal": "Construct the lexicographically smallest 01-string that generates the given tree",
        "type": "String minimization (lex order) under structural constraints"
      },
      "Algorithmic Invariant": {
        "invariant": "At any node, the choice of which child to expand next affects lex order: to minimize the global string, we should delay '1's as much as possible — i.e., recursively generate subtrees in increasing order of their resulting string representation (not by node index).",
        "strategy": "Use post-order DFS with greedy merging: for each node, collect the strings generated by each subtree, then sort these strings lexicographically before concatenating them with surrounding '0' and '1' markers. This ensures that smaller subtrees are expanded earlier, yielding a globally minimal string.",
        "proof_basis": "Lexicographic composition is monotonic: if A < B, then 0 + A + 1 + C < 0 + B + 1 + C when other parts are fixed. Thus, locally sorting child sequences yields optimal global result."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "Tree representation",
            "options": [
              "parent array",
              "edge list",
              "children list",
              "adjacency list"
            ]
          },
          {
            "name": "Output objective",
            "options": [
              "lex smallest 01-string",
              "lex largest",
              "shortest length",
              "count valid sequences"
            ]
          },
          {
            "name": "Traversal constraint",
            "options": [
              "must return to root",
              "can end anywhere",
              "must visit nodes in specific order"
            ]
          },
          {
            "name": "String alphabet",
            "options": [
              "0/1 commands",
              "custom symbols",
              "multi-character operations"
            ]
          },
          {
            "name": "Node creation rule",
            "options": [
              "only via '0'",
              "allow batch creation",
              "require explicit labeling"
            ]
          },
          {
            "name": "Data scale",
            "n_range": "1 <= n <= 1e4",
            "possible_change": "up to 1e5 or online variant"
          },
          {
            "name": "Input type",
            "variation": [
              "static offline",
              "dynamic updates (node addition)",
              "partial parents given"
            ]
          },
          {
            "name": "Lexicographic base",
            "variation": "Compare by length first, then lex; or weight '0' and '1' differently"
          }
        ]
      }
    }
  },
  {
    "title": "提取咒文",
    "slug": "kjpLFZ",
    "schema": {
      "Input Structure": [
        "二维字符矩阵 matrix[0..m-1][0..n-1], 其中 m, n ≥ 1",
        "字符串 mantra[0..k-1], k ≥ 1",
        "matrix 和 mantra 均由小写字母组成",
        "提取装置起始于 [0,0]"
      ],
      "Core Constraint": [
        "每次操作可移动至上/下/左/右相邻格子，或提取当前格子的字母",
        "提取必须严格按照 mantra 中字符的顺序依次进行",
        "同一位置可重复提取，每次提取视为一次操作",
        "字符提取可在任意时刻进行，只要当前位置字符等于目标字符"
      ],
      "Objective Function": "求构成整个 mantra 所需的最少操作次数（移动 + 提取），若无法完成则返回 -1",
      "Algorithmic Invariant": [
        "状态可表示为 (i, j, p)：当前位置为 (i,j)，已成功提取 mantra[0..p-1]，下一个需提取 mantra[p]",
        "从状态 (i, j, p) 转移到 (i', j', p) 的代价是曼哈顿距离或 BFS 步数（实际为单源最短路径）",
        "当 matrix[i][j] == mantra[p] 时，可转移到 (i, j, p+1)，代价为 1（提取操作）",
        "使用多层 BFS 或动态规划结合 Dijkstra：按 p 分层，每层内用最短路算法计算到达各位置的最小操作数",
        "一旦某一层中所有能到达的位置都无法匹配下一字符，则整体无解"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "matrix dimensions": "1 ≤ m, n ≤ 100",
          "mantra length": "1 ≤ k ≤ 100"
        },
        "字符集": "是否扩展至大写字母、数字或其他符号",
        "初始位置": "是否固定为 [0,0]，或作为输入参数给出",
        "是否允许对角移动": false,
        "操作代价是否可变": "移动和提取是否具有不同代价（当前均为1）",
        "是否在线查询": false,
        "是否多组数据": false,
        "是否循环矩阵": false,
        "是否带障碍物": false,
        "是否限制总操作数": false,
        "目标形式变化": [
          "判定是否存在可行方案",
          "计数满足条件的操作序列数量",
          "输出具体路径"
        ]
      }
    }
  },
  {
    "title": "城墙防线",
    "slug": "Nsibyl",
    "schema": {
      "Input Structure": [
        "二维数组 rampart[1..n]，其中 rampart[i] = [x_i, y_i]",
        "表示第 i 段城墙的初始区间，满足 x_i < y_i",
        "所有区间按左端点升序排列，且相邻区间不重叠：y_i <= x_{i+1}",
        "n >= 3，数据规模：3 <= n <= 10^4",
        "坐标值域：0 <= x_i < y_i <= 10^8"
      ],
      "Core Constraint": [
        "城墙只能在原有基础上向左、右或双向扩展其长度，扩展量为非负实数",
        "膨胀后任意两段城墙不能发生重叠（即闭区间无交）",
        "所有城墙的膨胀总量（总扩展长度）必须相等",
        "两端城墙（首尾）可无限向外膨胀，仅受限于邻接段",
        "中间城墙之间的空隙是膨胀资源的唯一来源"
      ],
      "Objective Function": "最大化每段城墙可以膨胀的总长度（即求最大公共膨胀值）",
      "Algorithmic Invariant": [
        "问题具有单调性：若能膨胀 k 单位，则对任意 k' < k 也能实现 → 可使用二分答案",
        "对于给定的膨胀值 k，判断是否可行时，采用贪心策略从左到右分配空隙：",
        "  - 第一段城墙只需考虑向右预留空间",
        "  - 中间每段城墙接收来自左侧剩余空隙，并尽可能少地向右预留以满足下一段",
        "  - 状态可递推，局部决策不影响全局可行性",
        "验证函数 f(k) 的设计基于‘最左适配’贪心原则，保证指针推进过程中的不变性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "3 <= n <= 10^4（可调整至 10^5 要求 O(n log n) 或 O(n) 解法）",
        "值域范围": "坐标可达 10^8（支持二分 + 贪心而不允许枚举）",
        "是否有序": "输入默认有序（可设为无序要求预处理排序 → 增加分类讨论）",
        "是否循环": "否（可改编为环形城墙遗迹，首尾相连 → 改变边界条件）",
        "是否多组输入": "单组（可改为多测）",
        "是否在线": "离线处理（可设计动态插入/删除城墙段的版本）",
        "膨胀规则变化": [
          "约束反转：由‘最大膨胀值’改为‘至少膨胀 k 是否可行’（判定问题）",
          "目标变换：由‘最大值’变为‘总膨胀容量计数’或‘方案构造’",
          "输入维度变换：从一维区间扩展到二维矩形膨胀防重叠问题",
          "隐藏条件引入：不显式给出顺序，需自行排序并处理边界"
        ]
      }
    }
  },
  {
    "title": "符文储备",
    "slug": "W2ZX4X",
    "schema": {
      "Input Structure": [
        "一维数组 runes[1..n]",
        "runes[i] 是非负整数，表示第 i 枚符文的魔力值",
        "数组长度 n 满足 1 <= n <= 10^4",
        "元素值域：0 <= runes[i] <= 10^4",
        "数组可含重复元素"
      ],
      "Core Constraint": [
        "所选符文可以任意重新排列",
        "最终序列中任意相邻两元素之差的绝对值不超过 1",
        "即：若排序后为 [a_1, a_2, ..., a_k]，则对所有 i 有 |a_{i+1} - a_i| <= 1",
        "等价于选出的元素在排序后构成一个‘准连续’序列（允许重复、允许差为0或1）"
      ],
      "Objective Function": "最大化所选符文的数量（即求最长满足条件的子序列长度，可重排）",
      "Algorithmic Invariant": [
        "排序后，问题转化为：在有序数组中寻找最长的子序列，使得相邻元素差 <= 1",
        "由于可重排，最优解必然是某个数值区间 [x, x+k] 内的所有出现值的总频次",
        "对于任意起点 x，以 x 为最小值的最长合法序列长度 = 所有值在 [x, x+d] 范围内（d任意）且满足最大值 - 最小值 <= 当前跨度 的元素总数，但关键性质是：若选择的集合最大值与最小值之差为 d，则必须覆盖中间所有整数？不必要 —— 但只要相邻差<=1，则整个集合的极差可以大于1，只要能连通即可",
        "修正不变量：若将选取的数排序后满足相邻差≤1，则这些数形成一条‘链’，其值域是连续整数的一个子集（不一定全取），但最大值与最小值之差可以任意大，只要中间无断层超过1",
        "因此，最优子结构具有如下不变性：存在一个最优解，其值域落在某个连续整数区间 [x, y] 上，且其中每个值 v ∈ [x,y] 可选可不选，但一旦选择 v，则贡献 count[v]",
        "算法核心不变量：枚举每个可能的起始值 x，向右扩展至 y，使得所有 v ∈ [x,y] 满足 y - x + 1 >= 1 且中间无 >1 的跳跃 —— 实际上只需统计连续段",
        "更精确不变量：将所有数字按值排序并去重后，用滑动窗口或枚举连续段的方式，合并值差 ≤1 的相邻组，每组内总频次即为候选答案"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1e3",
            "1e4",
            "1e5",
            "1e6"
          ],
          "值域范围": [
            "0~1e4",
            "0~1e5",
            "-1e4~1e4"
          ]
        },
        "输入形式": [
          "是否已排序",
          "是否允许多组测试数据",
          "是否在线输入（动态添加符文）"
        ],
        "约束条件": [
          "相邻差限制从 <=1 改为 <=k（k≥1）",
          "改为严格等于1",
          "改为不能相等（即只能差1，不能差0）",
          "加入携带总数上限限制"
        ],
        "目标函数变化": [
          "改为求最大总魔力值（而非数量）",
          "改为计数有多少种不同方案",
          "是否存在长度≥K的可行方案（判定问题）"
        ],
        "结构变换": [
          "从一维数组变为二维网格上的符文（需路径连通）",
          "变为图结构中选取路径，节点值差≤1",
          "变为环形排列"
        ],
        "隐藏条件": [
          "输入看似无序，实则隐含频率单调性",
          "值域非常大但实际 distinct 数很少（适合桶压缩）"
        ]
      }
    }
  },
  {
    "title": "魔法棋盘",
    "slug": "1ybDKD",
    "schema": {
      "Input Structure": [
        "二维字符矩阵 chessboard[1..n][1..m]",
        "每个元素 ∈ {'.', 'B', 'R', '?'}",
        "n * m <= 30",
        "表示棋盘上每格的状态：空、黑棋、红棋、待定"
      ],
      "Core Constraint": [
        "魔法共鸣条件为：两颗异色棋子（B 和 R）位于同一行或同一列，且中间恰好只有一颗棋子（可以是任意类型，包括空位）",
        "共鸣禁止约束：最终棋盘中不能存在任何一对满足上述条件的异色棋子",
        "问号 '?' 可以被替换为 '.'（空）、'B'（黑棋）或 'R'（红棋）",
        "初始确定状态（B/R/.）不可更改"
      ],
      "Objective Function": "计数 —— 统计所有合法的问号赋值方案数量，使得整个棋盘不产生任何魔法共鸣",
      "Algorithmic Invariant": [
        "共鸣检测具有局部性：只需检查每一行和每一列中所有可能的三元组位置（i, j, k），其中 j 在 i 和 k 中间，且 |i - k| = 2",
        "由于 n*m ≤ 30，总变量规模小，可枚举所有问号的取值组合并剪枝验证",
        "状态独立性：每一行和每一列的共鸣检查可分解处理，但需全局一致",
        "无后效性：一旦某组赋值在某行/列产生共鸣，则该方案整体非法"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n * m 的范围": [
            "≤ 30（当前）",
            "→ 扩展至 ≤ 100（需优化算法）"
          ],
          "行数与列数比例": [
            "方阵 / 长条形"
          ]
        },
        "输入形式": [
          "是否允许其他颜色棋子（如 G/Y）",
          "是否支持更多通配符（如 '*' 表示多个可变格）",
          "输入是否按行给出字符串数组"
        ],
        "约束条件": [
          "共鸣距离从 '恰好间隔一个棋子' 改为 '间隔 K 个位置'",
          "共鸣触发条件改为同色棋子",
          "增加对角线方向的共鸣检测",
          "允许多重共鸣但限制总数"
        ],
        "目标函数变换": [
          "判定是否存在至少一种合法方案",
          "求最大/最小放置棋子数的合法方案",
          "构造字典序最小的解"
        ],
        "是否多组数据": false,
        "是否在线": false,
        "是否循环结构": false
      }
    }
  },
  {
    "title": "传送卷轴",
    "slug": "rdmXM7",
    "schema": {
      "Input Structure": [
        "二维字符矩阵 maze[0..n-1][0..n-1]，表示 n×n 正方形迷宫",
        "每个元素为 '.'（空地）、'#'（墙）、'S'（起点）、'T'（终点）",
        "n ∈ [4, 200]，且 maze.length == maze[i].length"
      ],
      "Core Constraint": [
        "传送只能在空地 '.' 上触发，由守护者决定是否使用卷轴",
        "传送目标为当前行的水平镜像位置或当前列的竖直镜像位置（相对于中心轴对称）",
        "传送后位置不能是墙，否则该传送不合法",
        "小扣和守护者均采用最优策略：小扣最小化后续移动步数，守护者最大化小扣从传送点到终点的距离（若能阻止则优先阻止）",
        "传送仅可发生一次或零次"
      ],
      "Objective Function": [
        "求小扣在被传送后，仍能到达 T 的前提下，所需移动的最少步数",
        "若无论是否被传送都无法安全抵达，则返回 -1",
        "这是一个极小化目标函数（minimize），但内嵌一个极大化对抗行为（maximize 阻碍效果）"
      ],
      "Algorithmic Invariant": [
        "反向 BFS 不变性：从终点 T 出发预计算所有点到 T 的最短距离",
        "守护者的最优决策依赖于每个可能传送点的两个候选结果：max(水平镜像可达性与代价, 竖直镜像可达性与代价)",
        "小扣路径上所有空地点均可作为潜在传送点，需枚举并评估守护者响应后的最坏情况下的最小剩余代价",
        "一旦确定传送发生，状态演化不可逆：问题分解为‘传送前路径’ + ‘传送后残余距离’"
      ],
      "Transformable Parameters": {
        "n 的数量级": "4 <= n <= 200；可扩展至更大规模以要求 O(n^2) 解法",
        "地形结构": "是否保证 S 和 T 连通；是否存在多条路径",
        "传送规则": [
          "镜像方式：中心对称 / 轴对称 / 自定义映射",
          "是否允许多次传送",
          "是否可选择不触发（守护者策略自由度）"
        ],
        "对抗模型": [
          "是否双方博弈：可改为单方控制",
          "守护者目标可变为最小化代价（合作模式）或随机触发（非最优）"
        ],
        "输入形式": [
          "静态一次性输入 → 在线更新迷宫（动态障碍）",
          "是否提供多个 S 或 T"
        ],
        "输出要求": [
          "仅返回步数 → 返回具体路径或传送位置",
          "是否要求判定传送是否发生"
        ],
        "扩展维度": [
          "从 2D 平面扩展到 3D 立方体迷宫",
          "加入时间维度（每步消耗时间不同）"
        ]
      }
    }
  },
  {
    "title": "最强祝福力场",
    "slug": "xepqZ5",
    "schema": {
      "Input Structure": [
        "给定一个列表 forceField，其中每个元素为 [x, y, side] 的三元组",
        "表示以坐标 (x, y) 为中心、边长为 side 的闭区间正方形区域",
        "坐标和边长均为整数，且值域较大（x, y 可达 1e9，side 可达 1e9）",
        "正方形四边与坐标轴平行"
      ],
      "Core Constraint": [
        "力场覆盖是静态的、可叠加的，任意点的力场强度等于覆盖它的正方形数量",
        "由于正方形区域连续，最大强度一定出现在某个边界或交点附近，但全局最大值可通过离散化关键坐标后扫描获得",
        "问题本质是二维区间叠加计数，需处理几何重叠"
      ],
      "Objective Function": "求平面上所有点中最大的力场强度（即被最多正方形覆盖的点的覆盖数）",
      "Algorithmic Invariant": [
        "使用扫描线算法：沿 x 或 y 方向扫描，维护当前横截线上各区间覆盖次数",
        "事件点为所有正方形的左右（或上下）边界，按坐标排序后依次处理",
        "在每对相邻事件点之间，覆盖情况保持不变，可用差分数组 + 坐标离散化统计区间覆盖频次",
        "最大覆盖深度即为所求答案"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "forceField.length": "1 <= n <= 100（小规模，允许 O(n^2 log n) 解法）",
          "坐标范围": "0 <= x, y <= 1e9（需离散化）",
          "边长范围": "1 <= side <= 1e9"
        },
        "输入形式": [
          "是否允许多组测试数据",
          "是否在线添加/删除正方形（动态版本）"
        ],
        "区域形状": [
          "正方形 → 矩形",
          "轴对齐 → 旋转45度或其他角度",
          "闭区间（包含边界）→ 开区间"
        ],
        "维度扩展": [
          "二维 → 三维（立方体覆盖）",
          "二维 → 一维（区间覆盖，退化为经典问题）"
        ],
        "目标函数变化": [
          "求最大覆盖数 → 求达到最大覆盖的区域面积",
          "求是否存在强度 ≥ K 的点（判定问题）",
          "求强度大于阈值的所有连通区域个数"
        ],
        "约束条件变化": [
          "每个力场有不同权重 → 求加权覆盖最大值",
          "力场随时间变化 → 引入时间维度成为时空覆盖问题"
        ]
      }
    }
  },
  {
    "title": "探险营地",
    "slug": "0Zeoeg",
    "schema": {
      "Input Structure": [
        "字符串数组 expeditions[0..n-1]",
        "每个元素为由 '->' 连接的营地名称序列（大小写字母组成）",
        "expeditions[0] 表示初始已知的所有营地",
        "n = len(expeditions), 1 <= n <= 1000",
        "每个字符串长度 0 <= |expeditions[i]| <= 1000"
      ],
      "Core Constraint": [
        "新发现的营地是指在当前探险中首次出现、且未在之前所有探险（包括 expeditions[0] 到 expeditions[i-1]）中出现过的营地",
        "营地名称区分大小写",
        "同一个探险路径中重复的营地只算一次到访，但不影响‘是否为新’的判断（即重复不新增）",
        "必须按索引顺序处理探险记录，不能跳过"
      ],
      "Objective Function": [
        "最大化单次探险中新发现营地的数量",
        "若存在多个最大值，返回索引最小的那个",
        "若没有任何一次探险发现新营地，返回 -1",
        "目标类型：判定 + 构造（输出最优索引）"
      ],
      "Algorithmic Invariant": [
        "维护一个全局已知营地的集合 known_camps，随探险进程单调递增（只增不减）",
        "对于第 i 次探险（i > 0），解析出本次访问的所有营地集合 current_camps",
        "新发现营地数 = current_camps - known_camps",
        "每次处理完后更新 known_camps = known_camps ∪ current_camps",
        "指针推进顺序不可逆，状态演化具有前缀依赖性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "expeditions.length": "1 ~ 1000",
          "字符串总长度": "每项 ≤ 1000"
        },
        "输入形式": {
          "是否允许空字符串": true,
          "是否允许多重连续 ->": false,
          "分隔符固定为 \"->\"": true
        },
        "字符集": {
          "仅限大小写字母": true,
          "是否区分大小写": true
        },
        "多组数据": false,
        "在线/离线": "离线处理全部输入",
        "可变约束点": [
          "改变分隔符（如 ',' 或 '|'）→ 形式变换题",
          "允许模糊匹配（如忽略大小写）→ 隐式等价类问题",
          "加入删除操作：某些营地被废弃 → 破坏单调性，需动态集合",
          "要求输出所有最大索引而非最小索引 → 输出形式变化",
          "改为累计新营地总数 → 目标函数变为前缀和"
        ]
      }
    }
  },
  {
    "title": "补给马车",
    "slug": "hqCnmP",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "positive_integer",
        "size_range": [
          2,
          1000
        ],
        "initial_length": "n",
        "target_length": "floor(n / 2)"
      },
      "Core Constraint": {
        "merge_rule": "只能合并相邻的两辆马车",
        "selection_criterion": "每次选择物资之和最小的相邻对，若有多个相同和，取下标最小的一对",
        "irreversible_operation": "一旦合并，原两个元素被新元素替代，数组长度减一",
        "sequential_dependency": "每轮合并影响后续相邻关系，必须顺序执行"
      },
      "Objective Function": {
        "goal": "构造最终车队的物资分布",
        "output_type": "array",
        "objective_category": "construction"
      },
      "Algorithmic Invariant": {
        "greedy_choice_validity": "局部最优（最小和、最左）可导致全局合法结果",
        "state_progression": "每步操作后，问题规模严格递减（长度 -1），且仍保持相同结构",
        "neighborhood_preservation": "除合并位置外，其余相邻关系仅受索引偏移影响，结构不变",
        "deterministic_transition": "在给定规则下，每一步的状态转移是唯一确定的"
      },
      "Transformable Parameters": {
        "n_value_range": [
          2,
          1000
        ],
        "element_value_range": [
          1,
          1000
        ],
        "merge_target_length": "floor(n / k) 或固定目标长度",
        "merge_condition": "由 '最小和' 改为 '最大和' / '绝对差最小' 等",
        "merge_scope": "允许非相邻合并（需额外约束）或限制合并区间",
        "input_form": "单组输入 → 多组测试用例",
        "data_update_mode": "静态一次性输入 → 动态插入/删除/修改后重新模拟",
        "output_requirement": "仅最终状态 → 输出每步合并的位置或中间状态",
        "tie_breaking_rule": "最小下标 → 最大下标 / 靠近中心优先等"
      }
    }
  },
  {
    "title": "集水器",
    "slug": "kskhHQ",
    "schema": "{\n  \"Input Structure\": [\n    \"二维字符数组 shape[1..n][1..m]\",\n    \"shape[i][j] ∈ {'l', 'r', '.'}\",\n    \"表示一个 n 行 m 列的矩阵结构集水器\",\n    \"每个格子为左斜隔板('l')、右斜隔板('r')或无隔板('.')\",\n    \"n, m ≥ 1 且 ≤ 50\"\n  ],\n  \"Core Constraint\": [\n    \"隔板具有透气性：空气可穿透，但水不能穿过\",\n    \"水只能被完全封闭的空间保留（与外部连通则流失）\",\n    \"初始时整个结构浸泡在水中，取出后仅密闭区域存水\",\n    \"每个存水的完整方格蓄水量为 2\",\n    \"‘l’ 和 ‘r’ 隔板方向固定，构成潜在边界\"\n  ],\n  \"Objective Function\": \"计算最终能保留的总蓄水量（即内部密闭且不与外界连通的方格数 × 2）\",\n  \"Algorithmic Invariant\": [\n    \"使用多源 BFS 或 DFS 从所有外边界出发，标记所有能‘接触外界’的单元格\",\n    \"未被标记的内部单元格即为密闭存水区域\",\n    \"倾斜隔板的方向决定了水流是否可通过相邻格子逸出\",\n    \"状态传播满足连通性不变性：若某格可排水到边界，则其影响区域一致\",\n    \"图遍历过程中，移动方向需根据当前格子的隔板类型判断是否可通行\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n, m 的范围\": [1, 50],\n      \"可扩展至更大网格（如 1e3×1e3）以考察性能\"\n    },\n    \"隔板类型\": {\n      \"是否允许新类型隔板\": false,\n      \"例如双向挡水、可渗透等变形\": \"可作为参数化扩展\"\n    },\n    \"输入形式\": {\n      \"是否为静态离线输入\": true,\n      \"可改为在线逐行输入或动态修改操作\": \"支持题目变形\"\n    },\n    \"输出目标\": [\n      \"总蓄水量（当前）\",\n      \"可变为：最大连通存水区域大小、需删除最少隔板使不存水等\"\n    ],\n    \"连通定义\": {\n      \"四连通还是八连通\": \"当前为四连通，可作为变换参数\",\n      \"隔板穿行规则是否对称\": \"可调整以生成变体\"\n    },\n    \"是否多组测试数据\": false,\n    \"是否循环结构\": false,\n    \"是否有时间维度演化\": false\n  }\n}"
  },
  {
    "title": "沙地治理",
    "slug": "XxZZjK",
    "schema": {
      "Input Structure": {
        "structure": "正三角形网格划分",
        "grid_rows": "size 行，第 i 行有 2i - 1 个小三角形",
        "coordinate_system": "二维坐标 (i, j)，其中 i 表示行号（1-indexed），j 表示该行中的位置（1-indexed）",
        "initial_state": "所有位置初始为沙地",
        "adjacency_rule": "两个子区域共用一条边视为相邻；具体邻接关系依赖于三角形排列的拓扑结构"
      },
      "Core Constraint": {
        "conversion_rule": "一片沙地若与至少两片绿地相邻，则自动转化为绿地",
        "propagation_effect": "转化是传播性的：新转化的绿地可进一步促使其他沙地转化",
        "dependency_structure": "状态演化具有时序依赖性，后续状态由前一轮相邻绿地数量决定",
        "topology_dependence": "邻接关系非标准四连通或六连通，而是基于正三角形剖分的独特连接方式"
      },
      "Objective Function": "求最小化初始种植沙柳树的绿地数量，并返回任意一种最优初始种植方案的坐标集合",
      "Algorithmic Invariant": {
        "invariant_1": "最终必须覆盖整个 size × (2i-1) 结构的所有小三角形",
        "invariant_2": "初始选择的绿地集合应最大化传播链长度和广度",
        "invariant_3": "存在一种贪心构造策略：通过在每行特定奇偶位置放置绿地以触发最大连锁反应",
        "invariant_4": "可证明某些模式（如首尾列优先、中间稀疏布局）能最小化种子数且保证全覆盖"
      },
      "Transformable Parameters": {
        "size_range": "1 <= size <= 1000",
        "output_form": "返回初始种植坐标的列表，格式为 [[row, col], ...]",
        "solution_uniqueness": "允许多种最优解，只需输出任意一种",
        "input_type": "单组输入，离线处理",
        "variant_potential": [
          "是否允许对角相邻也算邻接（改变邻接定义）",
          "将传播条件从‘至少两片’改为‘恰好两片’或‘至少三片’",
          "加入成本权重：不同位置种植代价不同",
          "要求输出所有可能的最优方案（计数或枚举）",
          "在线扩展：逐步增加 size，支持动态更新方案"
        ]
      }
    }
  },
  {
    "title": "Hello LeetCode!",
    "slug": "rMeRt2",
    "schema": {
      "Input Structure": [
        "数组 words，其中 words[i] 是一个长度为 m 的字符串",
        "每个字符串由小写字母组成",
        "1 <= n <= 24（单词个数）",
        "1 <= m <= 8（每个单词长度）"
      ],
      "Core Constraint": [
        "从单词中取第 j 个字母的代价 = (左边剩余字母数) * (右边剩余字母数)",
        "每个字母只能被取一次",
        "取出的字母必须恰好拼成 'helloleetcode'（共13个字符，含重复）",
        "可以跨多个单词选取字母，但代价独立累加",
        "目标是总代价最小化"
      ],
      "Objective Function": "最小化取卡过程中的代币总消耗量；若无法集齐所需字母，则返回 -1",
      "Algorithmic Invariant": [
        "对于固定单词和待取字母集合，其最优取法顺序可通过状态压缩动态规划确定：即枚举删除顺序，并利用子集结构避免重复计算",
        "在单个单词内，任意删除序列的代价仅依赖于删除顺序，且具有子结构性质",
        "全局最优解可分解为：对每个单词选择一个子集字母进行提取，所有子集并集正好覆盖目标字符需求，且总代价最小",
        "问题满足贪心不可分性，但满足状态可枚举性和子问题重叠性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可变范围 [1, 24] → 可扩展至更大或限制更小",
        "m 的值域": "当前 [1,8] → 可改为更大或固定长度",
        "目标字符串": "'helloleetcode' 是固定的 → 可替换为任意模式串（如通用 t 中字符计数）",
        "是否多组输入": "当前为单次输入 → 可支持多测例批量处理",
        "是否在线": "离线输入 → 可设计为逐步添加单词的在线版本",
        "字母表范围": "当前仅为小写字母 → 可扩展至大写/数字",
        "操作约束": "每个字母仅能取一次 → 可加入冷却时间或多轮抽取机制",
        "代价函数形式": "当前为 left_count * right_count → 可变换为 abs(left - right) 或 max(left, right) 等变形"
      }
    }
  },
  {
    "title": "美观的花束",
    "slug": "1GxJYY",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "flowers[1..n]",
        "element_type": "integer",
        "constraints": [
          "flowers[i] ≥ 1",
          "n ≥ 1",
          "array is one-dimensional and ordered (left-to-right)"
        ],
        "value_range": {
          "n": "1 <= n <= 10^5",
          "flowers[i]": "1 <= flowers[i] <= 10^5",
          "cnt": "1 <= cnt <= 10^5"
        }
      },
      "Core Constraint": {
        "description": "任何选定区间内，每种鲜花品种的出现次数不得超过给定阈值 cnt",
        "key_property": "局部约束 per variety in subarray: frequency(v) ≤ cnt",
        "structure_implication": "一旦某品种在窗口中频次超过 cnt，所有包含该窗口的更大区间均不合法"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计所有满足「美观」条件的连续子数组（区间）的数量",
        "output_semantics": "返回符合条件的区间个数，不要求构造具体方案"
      },
      "Algorithmic Invariant": {
        "technique": "sliding window with two pointers",
        "invariants": [
          "右指针扩展时动态维护各品种频次计数",
          "左指针收缩直到窗口重新满足所有品种频次 ≤ cnt",
          "对于每个右端点 R，存在最远左端点 L_min(R)，使得 [L_min(R), R] 是以 R 结尾的最大合法左边界",
          "所有以 R 结尾的合法区间为：从 L ∈ [L_current, R] 到 R 的区间，共 R - L_current + 1 个"
        ],
        "monotonicity": "随着右指针右移，合法左边界单调不减（即窗口左边界不会左移）"
      },
      "Transformable Parameters": {
        "constraint_variants": [
          "cnt 变为 per-variety different limits (e.g., map of max counts)",
          "改为至少达到 cnt（≥ cnt）才美观 → 完全不同结构"
        ],
        "input_variants": [
          "flowers 允许负值或零（语义变化）",
          "二维花田（2D grid）→ 矩形区域选择",
          "环形排列（首尾相连）"
        ],
        "data_flow": [
          "离线批量处理 → 在线流式输入，支持查询当前前缀下的美观区间数"
        ],
        "output_variants": [
          "仅统计最长/最短美观区间",
          "要求输出所有美观区间的具体位置",
          "多组测试数据输入"
        ],
        "additional_operations": [
          "支持插入、删除、修改花朵的操作（动态版本）"
        ],
        "scale": {
          "small_n": "n <= 1000 → 可接受 O(n^2) 解法",
          "large_n": "n ~ 1e5 → 必须 O(n) 或 O(n log n)"
        }
      }
    }
  },
  {
    "title": "装饰树",
    "slug": "KnLfVT",
    "schema": {
      "Input Structure": "二叉树 root，其中每个节点具有整数值，定义为递归结构：TreeNode{val: int, left: TreeNode | null, right: TreeNode | null}；val ∈ [0, 1000]；节点数量 n ∈ [1, 10^5]",
      "Core Constraint": "装饰规则是结构性插入约束：在每一个父节点与其子节点之间的边中插入一个值为 -1 的新节点，且该灯饰节点成为原父节点的同侧子节点，原子节点则成为灯饰节点的同侧子节点；整个变换仅依赖树的拓扑结构与父子关系，不依赖节点值大小",
      "Objective Function": "构造并返回完成装饰后的二叉树根节点（即执行所有边上的插入操作后的新树）",
      "Algorithmic Invariant": "树的遍历过程中，每处理一条从父到子的边时，均可独立进行结构重写：若存在左/右子节点，则将 (父 → 子) 替换为 (父 → -1 → 子)，且此局部重构不影响其他分支的处理；使用 DFS 先序遍历可保证所有边被恰好访问一次，且子树结构在重连前已被递归处理完毕",
      "Transformable Parameters": {
        "n 的数量级": "1e5 可扩展至 1e6（测试递归深度或迭代实现需求）",
        "值域变化": "灯饰值 -1 是否可参数化为变量 k（如题目改为插入值为 k 的节点）",
        "插入逻辑变形": "是否仅对左子树/右子树插入；或根据父子节点值奇偶性决定是否插入",
        "多组输入": "是否支持批量处理多个二叉树",
        "在线构造": "是否要求动态插入灯饰（边构建原树边装饰）",
        "输出形式": "返回树根 / 输出层序遍历数组 / 验证结果序列"
      }
    }
  },
  {
    "title": "最小展台数量",
    "slug": "600YaG",
    "schema": {
      "Input Structure": [
        "二维字符数组 demand[1..n][*]",
        "n 表示天数，每行 demand[i] 表示第 i 天所需的展台类型序列",
        "每个元素 demand[i][j] ∈ {a-z}",
        "每行长度可变，但均在 [1, 100] 范围内"
      ],
      "Core Constraint": [
        "同一展台（同一字符）可在不同天重复使用",
        "每天的需求是独立的多重集（multiset）",
        "最终展台集合必须能覆盖每一天中各字符出现次数的最大需求"
      ],
      "Objective Function": "最小化所需展台总数（即：所有字符 c 的最大频次之和）",
      "Algorithmic Invariant": [
        "对于每个字符 c，其所需数量由其在所有天中出现频次的最大值决定",
        "跨天的使用不产生冲突，因展台可复用",
        "全局最优解 = 各字符局部最大需求之和，子问题可分离"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": [
            1,
            100
          ],
          "单日展台数量范围": [
            1,
            100
          ]
        },
        "字符集": [
          "仅小写字母 → 可扩展为大写、数字或任意符号"
        ],
        "是否有序": false,
        "是否多组数据": false,
        "是否在线": false,
        "输入形式变化": [
          "字符串数组 → 列表的列表 / 频次矩阵输入",
          "静态输入 → 动态追加展览需求"
        ],
        "约束变化": [
          "展台不可复用（需每日独立配置）→ 完全不同模型",
          "引入展台转换成本 → 变为动态规划或网络流问题",
          "加入展台容量限制或类型配比约束"
        ],
        "目标函数变化": [
          "最小展台数 → 最小新增展台数（已有库存）",
          "计数 → 构造具体展台组合方案",
          "判定是否存在可用展台分配"
        ]
      }
    }
  },
  {
    "title": "弹珠游戏",
    "slug": "EXvqDp",
    "schema": {
      "Input Structure": [
        "二维字符网格 plate[0..m-1][0..n-1]，其中 m = len(plate), n = len(plate[0])",
        "每个单元格内容 ∈ { 'O', 'W', 'E', '.' }",
        "输入参数 num：表示弹珠最多前进步数（正整数）",
        "初始方向由打入位置自动确定：从上/下/左/右边缘垂直向内"
      ],
      "Core Constraint": [
        "弹珠只能从四边非角落的 '.' 格子垂直向内打入",
        "弹珠运动受格子类型动态影响：遇到 'W' 逆时针转 90°，遇到 'E' 顺时针转 90°，遇到 'O' 停止并成功入洞，遇到边界且方向出界则失败",
        "弹珠每移动一个格子算一步，转向不消耗步数",
        "四角禁止作为起点，非 '.' 边缘格也不能作为起点",
        "状态演化具有确定性：同一位置、方向、剩余步数下的行为唯一"
      ],
      "Objective Function": [
        "枚举所有合法起始位置（行索引, 列索引），使得从该位置沿垂直方向打入的弹珠在 ≤ num 步内落入 'O' 中",
        "目标函数为构造型：返回所有满足条件的坐标对列表",
        "不要求顺序"
      ],
      "Algorithmic Invariant": [
        "弹珠路径是确定性的有限状态迁移：状态 = (r, c, dr, dc, steps_used)，可模拟但不可回溯优化剪枝依赖于 visited 状态去重（若允许循环则需防无限）",
        "每一步移动或转向都保持方向一致性，方向仅通过旋转更新",
        "一旦进入 'O' 即成功终止；一旦出界或超步数即失败终止",
        "由于 grid 规模较小（≤1000×1000），而 num 可达 1e6，路径可能循环，因此需检测状态环以提前终止"
      ],
      "Transformable Parameters": [
        "网格大小 m × n 的数量级：可变至 1e3 或更小",
        "num 的范围：[1, 1e6]，可调整为更小（如 100）以支持暴力模拟",
        "是否允许四角作为起点（布尔开关）",
        "转向器行为是否可叠加（例如连续多次经过同一 'W' 是否每次都转向）",
        "是否加入新元素（如传送门、反射镜、多层网格）",
        "是否支持多阶段查询（在线模式：每次修改 grid 后查询可行入口）",
        "是否要求统计方案数而非输出具体位置",
        "是否限制路径不能重复经过同一格子",
        "是否将 'O' 改为必须恰好第 num 步进入才有效（时间约束变形）",
        "输入形式：plate 是否压缩为一维数组？是否按行拼接？"
      ]
    }
  },
  {
    "title": "二叉树灯饰",
    "slug": "U7WvvU",
    "schema": {
      "Input Structure": "二叉树 root，每个节点具有值 0（关）或 1（开），节点数 n ∈ [1, 1e5]；结构为标准二叉树链式存储，无显式父指针。",
      "Core Constraint": "三种开关操作具有不同作用范围：\n- 开关1：仅切换当前节点；\n- 开关2：切换以当前节点为根的整棵子树；\n- 开关3：切换当前节点及其直接左右子节点（若存在）；\n操作可重复使用，且每次操作计为一次；最终目标是所有节点变为 0；\n操作之间具有叠加性和可交换性（在状态空间中为异或运算）。",
      "Objective Function": "求最小操作次数，使得整棵树所有节点灯的状态均为关闭（即值为 0）。",
      "Algorithmic Invariant": "采用树形动态规划（Tree DP）结合状态压缩的思想：\n- 每个节点维护多个状态，表示从叶子向上传递时，当前子树达到全关所需的操作组合代价；\n- 状态设计需考虑父层对当前节点的影响是否已应用（如开关3来自父节点或祖父节点的影响）；\n- 利用异或性质与操作的可逆性，合并子问题解时不丢失最优性；\n- 自底向上推导保证局部最优可合并为全局最优。",
      "Transformable Parameters": [
        "节点值域：是否允许大于1的状态（如多级亮度）",
        "操作类型数量：是否增加更多区域型开关（如祖先路径、兄弟子树等）",
        "目标状态：是否要求全开，或特定模式",
        "是否支持在线修改树结构",
        "树的形态约束：是否为完全二叉树、平衡树、链状等",
        "是否允许多次经过同一节点的操作叠加限制",
        "数据规模：节点数从 1e3 → 1e5，影响算法复杂度边界",
        "是否输出方案路径而非仅次数"
      ]
    }
  },
  {
    "title": "舒适的湿度",
    "slug": "3aqs1c",
    "schema": {
      "Input Structure": [
        "一维数组 operate[1..n]",
        "operate[i] 是正整数，表示第 i 条指令增加湿度的大小",
        "1 <= n <= 1000",
        "1 <= operate[i] <= 1000"
      ],
      "Core Constraint": [
        "每条指令可以保持为正（增湿）或取反为负（减湿），数值绝对值不变",
        "控制器会选择任意一段连续子数组执行操作",
        "某段连续操作的「不适宜度」定义为该子数组元素和的绝对值",
        "「整体不适宜度」是所有连续子数组中最大的「不适宜度」",
        "目标是在所有翻转方案中，最小化这个最大绝对值子段和"
      ],
      "Objective Function": "在所有可能的符号翻转方案中，求最小化的「整体不适宜度」——即最小化最大连续子数组和的绝对值",
      "Algorithmic Invariant": [
        "最优解中，最终数组的最大子段绝对值具有单调可枚举性",
        "可以通过二分答案控制「整体不适宜度」的上界 D，并验证是否存在一种符号分配方式，使得所有连续子数组的和的绝对值都不超过 D",
        "验证过程使用动态规划：设 dp[i][s] 表示前 i 个元素是否能以最后一个位置符号为 s（+/-）且所有前缀相关约束满足的方式构造出来，状态转移依赖于前缀和的可行区间",
        "对于固定的 D，若存在一种赋号方案使得整个序列的所有子段和 ∈ [-D, D]，则 D 可行",
        "该判定问题可通过维护前缀和的可行区间进行线性推进（区间传播）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1e3",
            "可扩展至 1e5（若允许近似或特殊结构）"
          ],
          "operate[i] 值域": [
            "[1, 1000]",
            "可改为 [-K, K]",
            "可允许 0"
          ]
        },
        "输入形式": {
          "是否有序": false,
          "是否循环": false,
          "是否多组数据": false,
          "是否在线": false
        },
        "约束变化": {
          "翻转操作限制": [
            "无限制（当前题型）",
            "最多 k 次翻转",
            "必须成块翻转"
          ],
          "目标函数变形": [
            "最小化最大子段绝对值和（当前）",
            "最小化子段方差",
            "计数满足条件的方案数"
          ],
          "子数组类型": [
            "任意连续子数组（当前）",
            "仅固定长度子数组",
            "仅前缀/后缀"
          ]
        },
        "模型扩展": {
          "维度提升": [
            "2D 网格上的区域操作",
            "树形结构路径上的操作"
          ],
          "操作模式": [
            "支持修改操作（带修版本）",
            "在线查询不同翻转策略下的结果"
          ]
        }
      }
    }
  },
  {
    "title": "交通枢纽",
    "slug": "D9PW8w",
    "schema": {
      "Input Structure": {
        "type": "directed graph",
        "representation": "edge list",
        "edges": "path[i] = [a, b], where a -> b is a directed edge",
        "node_domain": "non-negative integers from 0 to at most 1000",
        "constraints": [
          "1 <= path.length <= 1000",
          "path[i][0] != path[i][1]"
        ]
      },
      "Core Constraint": {
        "in_degree_condition": "all nodes except the hub must have a direct edge pointing to the hub",
        "out_degree_condition": "the hub must have out-degree 0",
        "global_uniqueness_implication": "if such a hub exists, it must be unique due to full in-coverage and zero out-links"
      },
      "Objective Function": {
        "type": "decision_and_search",
        "goal": "find the unique node that satisfies: (1) in-degree = total_number_of_nodes - 1, (2) out-degree = 0",
        "output": "return the hub node if exists, otherwise return -1"
      },
      "Algorithmic Invariant": {
        "invariant_1": "a valid hub must be pointed to by every other distinct node exactly once (directly)",
        "invariant_2": "the hub cannot appear as a source in any edge",
        "invariant_3": "once we collect all in-degrees and out-degrees, candidate set is restricted to nodes with out-degree 0",
        "invariant_4": "among out-degree-zero nodes, only one can have in-degree = n - 1 (n = total number of distinct nodes)"
      },
      "Transformable Parameters": {
        "n_value_range": "number of edges up to 1000, number of nodes up to ~1001",
        "node_labels": "non-negative integers, not necessarily contiguous",
        "input_form": "list of edges; can be transformed into adjacency list or degree maps",
        "multiple_queries": false,
        "online_edges": false,
        "graph_modification": false,
        "relax_directness": "could become undirected variant (not applicable here but possible transformation)",
        "relax_hub_requirements": [
          "allow indirect paths instead of direct edges (would change algorithm drastically)",
          "require only majority in-links instead of all",
          "allow limited out-links from hub"
        ],
        "additional_constraints": [
          "whether node ids are dense or sparse",
          "whether input is sorted or shuffled"
        ]
      }
    }
  },
  {
    "title": "气温变化趋势",
    "slug": "6CE719",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": [
          {
            "name": "temperatureA",
            "domain": "integer",
            "range": [
              -20,
              40
            ],
            "length": "n",
            "constraints": "1D array of integers, length >= 2"
          },
          {
            "name": "temperatureB",
            "domain": "integer",
            "range": [
              -20,
              40
            ],
            "length": "n",
            "constraints": "1D array of integers, same length as temperatureA"
          }
        ]
      },
      "Core Constraint": {
        "description": "气温变化趋势由相邻两日温差决定，趋势相同当且仅当两地对应区间的每日趋势（上升/平稳/下降）完全一致。",
        "trend_rule": "对于第 i 天到第 i+1 天：若 temp[i+1] > temp[i] → 上升；== → 平稳；< → 下降",
        "alignment_condition": "两地在连续区间 [i, j] 内每一对相邻天的趋势必须逐位相等"
      },
      "Objective Function": {
        "type": "maximization",
        "goal": "求最大连续天数 n，使得从某一天 i 开始的连续 n+1 天中，两地的 n 段趋势完全相同",
        "output_semantics": "返回的是趋势段的数量（即连续天数减一），但题目定义为‘连续天数’，实际是趋势匹配的最长连续区间长度（以趋势对数计）"
      },
      "Algorithmic Invariant": {
        "invariant_type": "sliding window with local comparison",
        "properties": [
          "趋势序列可通过一次遍历预处理为符号数组（+1/0/-1）",
          "两个趋势数组的最长连续公共子串长度即为所求",
          "使用双指针或单次扫描维护当前连续匹配长度，可实现 O(n) 时间推进",
          "当前匹配中断时，重新从下一位置开始累计，无需回溯（最优子结构）"
        ],
        "monotonicity": "当前连续匹配长度随扫描单调增减，无后效性"
      },
      "Transformable Parameters": {
        "n_range": [
          2,
          1000
        ],
        "value_domain": [
          -20,
          40
        ],
        "ordering": "unsorted",
        "data_form": "offline batch input",
        "multi_case": true,
        "online_query": false,
        "modifications": {
          "allow_updates": false,
          "dynamic_arrays": false
        },
        "derived_variants": [
          "输入变为趋势已编码的 +1/0/-1 数组",
          "目标函数改为计数所有相同趋势段的总数（非最大连续）",
          "二维扩展：多个地区求共同趋势时间段",
          "加入容忍机制：允许最多 k 次趋势不同",
          "循环时间序列：首尾相连判断最大连续趋势"
        ]
      }
    }
  },
  {
    "title": "积木拼接",
    "slug": "De4qBB",
    "schema": {
      "Input Structure": [
        "给定6个二维字符矩阵 shapes[0..5]",
        "每个 shapes[i] 是一个 N×N 的字符串数组（3 ≤ N ≤ 10）",
        "矩阵元素为 '0' 或 '1'，其中 '1' 表示有积木部分，'0' 表示空缺",
        "所有 shapes[i] 尺寸相同，即统一为 N×N",
        "每片积木内部 (N-2)×(N-2) 区域全为 '1'（无空心）",
        "每片积木的所有 '1' 格子在四连通意义下连通"
      ],
      "Core Constraint": [
        "每片积木必须恰好对应正方体的一个面",
        "积木可进行旋转（90°倍数）和翻面操作（水平或垂直镜像）",
        "拼接时两个相邻面的公共边必须完全吻合：即边缘上每一格的 '1'/'0' 必须一一对应",
        "每片积木的中心点必须与目标面中心重合（不可平移），因此其几何中心固定",
        "正方体每个面大小一致，且六个面无缝闭合成一个封闭立体"
      ],
      "Objective Function": "判定是否存在一种方式将6片积木分配给正方体的6个面，并通过旋转/翻面使得所有相邻边完美匹配，从而构成严丝合缝的正方体",
      "Algorithmic Invariant": [
        "正方体拓扑结构不变：6个面之间有固定的邻接关系（如立方体展开图的相对位置约束）",
        "每片积木经过有限次变换（最多8种：4个旋转 × 2种翻转）得到规范形式集合，状态空间有限",
        "一旦某片积木被指派到某个面并选定朝向，其四条边的轮廓即确定，可用于约束邻居",
        "搜索过程中可通过剪枝避免重复枚举：如使用排列+回溯控制积木分配，利用边匹配条件提前终止无效分支",
        "边匹配具有对称性和传递性：若 A 的右边界等于 B 的左边界，则它们可在该边拼接；此关系不依赖全局构造顺序"
      ],
      "Transformable Parameters": {
        "n_size": "3 <= N <= 10, 可调节矩阵边长",
        "allow_hollow": "是否允许内部有空心区域（当前题目中禁止，可作为变形放开）",
        "connectivity_constraint": "是否要求所有 '1' 连通（当前题目保证，可改为不保证以增加难度）",
        "number_of_pieces": "是否固定为6片（可扩展为多组测试或多块拼接问题）",
        "operation_set": "允许的操作类型：仅旋转 / 允许翻转 / 是否允许缩放或裁剪",
        "output_type": [
          "bool: 能否拼成正方体（当前）",
          "count: 满足条件的方案数",
          "construct: 输出具体拼法（哪个积木放哪个面，如何旋转）"
        ],
        "input_format": [
          "一次性输入6片（当前）",
          "在线流式输入，逐步判断是否仍可能完成拼接"
        ],
        "dimension_extension": "是否推广至更高维度（如超立方体表面拼接）",
        "tolerance_mismatch": "是否允许一定程度的边不匹配（模糊拼接）"
      }
    }
  },
  {
    "title": "力扣泡泡龙",
    "slug": "WInSav",
    "schema": {
      "Input Structure": "二叉树 root，每个节点具有整数值；节点数 n 满足 2 <= n <= 1e5，节点值范围 [-10000, 10000]",
      "Core Constraint": "只能移除至多一个子节点的节点；移除后其子树整体上移一层（即原子女成为父节点的直接子女），导致各层节点分布变化；层和由 BFS 层序遍历决定，且修改操作会影响后续所有层的结构与和",
      "Objective Function": "最大化操作后（或不操作）的所有层中最大的「层和」",
      "Algorithmic Invariant": "1. 层序结构可通过 BFS 预处理得到每层节点集合及其深度\n2. 移除一个满足条件的节点时，其子节点将提升一层，从而影响原深度+1 层的组成\n3. 对任意可删除节点，其对层和的影响是局部可计算的：仅影响其原所在层（被移除）与其子节点所加入的新层（+1 层）\n4. 最优解必然出现在：不删除任何节点，或删除某个度 ≤1 的节点两种情况之一",
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 1e5，支持大规模树",
        "值域": "节点值 ∈ [-10000, 10000]，允许负值",
        "是否有序": "树无序，结构任意",
        "是否循环": "否，为普通二叉树",
        "是否多组输入": "单组输入，但可扩展为多测",
        "是否在线": "离线处理，完整树已知",
        "可变操作限制": [
          "可改为删除 k 个节点（k>1）并满足相同子节点约束",
          "可要求必须删除一个节点",
          "可改为最小化最大层和",
          "可改为查询删除后第 d 层的层和",
          "可加入删除代价函数"
        ],
        "输出形式变化": [
          "返回最大层和（当前题型）",
          "返回达到最大层和的删除节点值",
          "返回方案路径"
        ]
      }
    }
  },
  {
    "title": "搭桥过河",
    "slug": "NfY1m5",
    "schema": {
      "Input Structure": {
        "river_length": "num ∈ [1, 10^9]",
        "floating_woods": "List of intervals wood[i] = [start_i, end_i], where 1 <= start_i <= end_i <= num",
        "structure_type": "One-dimensional interval array",
        "constraints_on_intervals": "Each interval represents the initial coverage of a log on the river; intervals may overlap or be disjoint"
      },
      "Core Constraint": {
        "connectivity_condition": "Two logs are connected if their intervals overlap (i.e., max(start_i, start_j) <= min(end_i, end_j))",
        "movement_rule": "Logs can only be moved on land (before entering water), each unit move costs 1 'natural force'",
        "movement_effect": "Moving a log shifts its entire interval by ±1 per unit cost; relative order of logs cannot change along the river",
        "path_requirement": "A valid path must form a continuous chain from left bank (position 0?) to right bank (position num?), using overlapping logs"
      },
      "Objective Function": "Minimize total movement cost (sum of absolute displacements of all logs) such that there exists a connected path from river start to end through overlapping logs",
      "Algorithmic Invariant": {
        "invariant_1": "Optimal alignment tends to merge intervals into a common overlapping region or bridge gaps with minimal shift",
        "invariant_2": "There exists an optimal solution where all logs align within a contiguous segment [x, x+L] for some x, minimizing gap-filling cost",
        "invariant_3": "The problem reduces to choosing target positions for each log under connectivity constraints, with cost = Σ |original_midpoint - new_position| (or similar separable convex cost)",
        "invariant_4": "Connectivity is preserved under monotonic transformation: if logs are sorted by position, dynamic programming over intervals maintains reachability states"
      },
      "Transformable Parameters": {
        "n_logs": "1 <= len(wood) <= 10^5 → scalable input size",
        "river_scale": "num up to 1e9 → coordinate compression needed",
        "interval_density": "Sparse vs dense configurations affect greedy feasibility",
        "overlap_mode": "Whether multiple logs can occupy same space (yes, per Example 2)",
        "movement_restrictions": [
          "Can logs only move one direction?",
          "Is reordering allowed? (No — physical order fixed)"
        ],
        "output_type": [
          "Min cost (scalar)",
          "Also output final configuration?",
          "Or count number of moves?"
        ],
        "input_variants": [
          "Are logs initially sorted by position?",
          "Allow deletion/insertion of logs?",
          "Online version: add logs incrementally?"
        ],
        "objective_transforms": [
          "Change from minimize total move to minimize max single move (minimax)",
          "Change to counting feasible configurations within budget K",
          "Constraint inversion: given budget K, determine whether crossing is possible"
        ],
        "dimension_extension": "Extend to 2D river grid — logs as rectangles, movement in two directions"
      }
    }
  },
  {
    "title": "打地鼠",
    "slug": "ZbAuEH",
    "schema": {
      "Input Structure": {
        "type": "event_sequence",
        "description": "给定一个事件序列 moles，其中 moles[i] = [t, x, y] 表示在第 t 秒，地鼠出现在坐标 (x, y) 的格子上，持续时间为第 t 秒（至第 t+1 秒前消失）",
        "grid_size": "3x3 fixed grid",
        "start_position": "(1,1)",
        "time_domain": "non-negative integers, up to 1e9",
        "events_per_time": "at most one mole per cell per time"
      },
      "Core Constraint": {
        "movement_rule": "锤子每秒可上下左右移动一格或静止，移动一步耗时1秒",
        "hit_rule": "敲击不耗时，仅能敲击当前所在格子且当前时刻存在的地鼠",
        "temporal_order": "事件按时间顺序发生，不可逆时间流",
        "reachability": "从 (x1,y1) 到 (x2,y2) 所需最短时间为曼哈顿距离：|x1-x2| + |y1-y2|",
        "initial_state": "第 0 秒锤子位于中心 (1,1)，所有操作从 t=0 开始推进"
      },
      "Objective Function": "最大化可敲击的地鼠数量（计数型优化问题：Maximization / Counting）",
      "Algorithmic Invariant": {
        "dp_state_invariant": "若按时间排序处理地鼠事件，则能否到达某个事件点只依赖于前一个可达事件的位置与时间差",
        "transition_condition": "对于两个事件 i 和 j（ti <= tj），可以从事件 i 转移到事件 j 当且仅当：tj - ti >= |xi - xj| + |yi - yj|",
        "monotonicity": "时间单调递增；一旦错过某事件，后续无法回溯",
        "optimal_substructure": "以每个地鼠事件为状态节点，构建最长路径 DAG：最大击打数等于从初始状态出发的最长路径长度",
        "pruning_rule": "相同时间点的多个事件中，只需考虑所有可能位置；但可通过状态压缩减少冗余计算"
      },
      "Transformable Parameters": {
        "n_moles": "1 <= n <= 1e5",
        "time_range": "[0, 1e9], large sparse time domain",
        "grid_dimensions": "fixed 3x3 → can be generalized to m x m",
        "start_position": "can vary: e.g., corner, random, or multiple starting points",
        "movement_speed": "current: 1 step/sec → can change to k steps/sec or variable speed",
        "duration_of_mole": "currently 1 second → can extend to d seconds (interval instead of point)",
        "input_form": [
          "offline batch input (given all moles at once)",
          "online query version: moles arrive dynamically"
        ],
        "output_form": [
          "maximum count (current)",
          "construct the actual path / sequence of hits"
        ],
        "additional_constraints": [
          "limit on total moves",
          "energy cost per move",
          "rewards vary by position/time"
        ],
        "temporal_density": "sparse events in large time span → enables coordinate compression and DP with sorting"
      }
    }
  },
  {
    "title": "信物传送",
    "slug": "6UEx57",
    "schema": {
      "Input Structure": {
        "type": "2D grid",
        "dimensions": "matrix[i][j] where 0 < i <= 100, 0 < j <= 100",
        "values": [
          "'^'",
          "'v'",
          "'<'",
          "'>'"
        ],
        "start": "[i, j]",
        "end": "[i, j]",
        "description": "二维字符矩阵表示传送带方向，起点和终点为坐标点"
      },
      "Core Constraint": {
        "constraint": "信物沿当前格子传送方向移动；每次施法可临时改变一个格子的方向（仅作用一次），之后恢复原方向",
        "movement_rule": "若不施法，则信物严格按照 matrix[i][j] 指定的方向从当前位置移动到下一位置",
        "change_rule": "每次施法操作允许修改任意一个格子的传送方向一次，用于本次移动路径中，不影响后续状态",
        "path_dependency": "路径选择依赖于局部方向决策，且存在环路可能，需避免无限循环"
      },
      "Objective Function": "求将信物从 start 传送到 end 所需的最少施法操作次数（最小化整数）",
      "Algorithmic Invariant": {
        "invariant_type": "状态扩展下的最短路径不变性",
        "details": [
          "每个状态 (i, j) 的最小施法次数可通过松弛更新得到",
          "使用 0-1 BFS 或 Dijkstra 维护：当沿原方向移动时，代价为 0；当反向施法改变方向时，代价为 1",
          "一旦某状态 (i, j) 以更小代价被访问，则后续更高代价路径可剪枝",
          "图中边权仅为 0 或 1，满足 0-1 BFS 的单调性条件"
        ],
        "monotonicity": "累计施法次数随搜索过程单调不减（在优先队列或双端队列中维护）"
      },
      "Transformable Parameters": {
        "grid_size": "n × m, 可调整至 1e3 或支持动态增长",
        "value_domain": "传送方向种类：可扩展为更多符号或斜向传送（如 '↖', '↗'）",
        "operation_cost": "施法代价是否对称（例如某些方向变更代价为 2）",
        "multiple_queries": "是否多组 start → end 查询（离线/在线）",
        "persistent_change": "施法后是否永久更改方向（变为状态演化问题）",
        "time_limit": "加入时间步限制，要求在 T 步内到达",
        "obstacles": "引入不可通行格子",
        "dynamic_grid": "传送带周期性变化（在线输入流）",
        "output_type": "返回最小操作数 / 构造方案 / 判断可行性"
      }
    }
  },
  {
    "title": "采集果实",
    "slug": "PTXy4P",
    "schema": {
      "Input Structure": {
        "time": "Array of positive integers, length n (1 <= n <= 100), time[i] represents the time cost to collect 1~limit fruits of type i",
        "fruits": "List of batches, each batch fruits[j] = [type, num], where type is integer in [0, n), num is the number of fruits to collect (1 <= num < 1000)",
        "limit": "Positive integer (1 <= limit <= 100), maximum number of fruits that can be collected per operation"
      },
      "Core Constraint": {
        "sequential_processing": "Batches must be processed in the given order; no parallel or out-of-order collection allowed",
        "reset_after_batch": "Backpack is cleared after each batch; leftover fruits do not carry over",
        "fixed_per_type_time": "Each fruit type has a fixed time cost per operation, independent of quantity collected in that operation (as long as <= limit)",
        "operation_model": "Each operation collects between 1 and 'limit' fruits of a single type; multiple operations may be needed for one batch"
      },
      "Objective Function": "Minimize total time spent to complete all fruit collection batches in sequence",
      "Algorithmic Invariant": {
        "greedy_operations_per_batch": "For each batch [type, num], the minimal number of operations required is ceil(num / limit), and each operation takes time[ty pe]",
        "additive_total_time": "Total time is sum over batches of: ceil(num_j / limit) * time[type_j]",
        "no_state_dependency": "Each batch is independent due to backpack reset; optimal substructure holds per batch"
      },
      "Transformable Parameters": {
        "n_value_range": "Size of 'time' array (number of fruit types), currently up to 100",
        "fruits_length": "Number of batches, currently up to 1000",
        "num_value_range": "Amount of fruits per batch, currently less than 1000",
        "limit_value": "Max fruits per operation, affects operation count; can vary from 1 to 100",
        "time_values": "Per-type time costs, positive integers up to 100",
        "input_order_significance": "Order of 'fruits' matters due to sequential constraint",
        "online_offline": "Offline input assumed; could generalize to online batch arrival",
        "carry_over_allowed": "Current schema assumes no carry-over; variant could allow partial carry if backpack not cleared",
        "multiple_fruit_types_per_operation": "Currently only one type per operation; could relax this constraint",
        "variable_limit_per_type": "Currently global limit; could make limit dependent on fruit type"
      }
    }
  },
  {
    "title": "夺回据点",
    "slug": "s5kipK",
    "schema": {
      "Input Structure": {
        "type": "graph",
        "representation": "undirected graph via edge list",
        "nodes": "n nodes labeled 0 to n-1",
        "edges": "roads[i] = [x, y], no self-loops or multiple edges",
        "node_property": "cost array where cost[j] is the resource to initially seize node j",
        "constraints": {
          "n": "number of nodes, 1 <= n <= 10^5",
          "m": "number of edges, 1 <= m <= 10^5",
          "cost_value_range": "1 <= cost[i] <= 1e9"
        }
      },
      "Core Constraint": {
        "initial_condition": "all nodes are connected initially",
        "seizure_rules": [
          "can spend cost[j] to seize node j at any time (but optimal to do so only at start or when forced)",
          "after each seizure, remaining monster-held nodes must remain connected (without passing through reclaimed nodes)"
        ],
        "propagation_rule": "can freely seize a node adjacent to already reclaimed set without cost, provided it doesn't disconnect the remaining monster network"
      },
      "Objective Function": "minimize total initial resource cost spent on directly seizing nodes such that all nodes are eventually reclaimed while maintaining connectivity of unreclaimed subgraph after every step",
      "Algorithmic Invariant": {
        "key_insight": "the final set of nodes seized with cost corresponds to a vertex cover over the 'critical disconnection points' in the graph",
        "structural_invariant": "the optimal solution only needs to pay for nodes that are articulation points (or part of biconnected decomposition) in a strategic way",
        "greedy_principle": "non-articulation points can be taken for free during propagation if their removal does not disconnect the remaining graph",
        "dfs_tree_property": "in DFS traversal, a non-root node u can be avoided paying only if none of its children subtrees are disconnected upon u's removal — i.e., u is not an articulation point",
        "root_special_case": "the root of DFS tree may require payment only if it has two or more independent children (making it an articulation point)"
      },
      "Transformable Parameters": {
        "graph_type": [
          "tree",
          "general connected graph",
          "biconnected graph",
          "cycle",
          "grid-like"
        ],
        "connectivity_requirement": [
          "remain connected",
          "can have up to k components",
          "must stay 2-edge-connected"
        ],
        "seizure_propagation": [
          "only one per turn",
          "any number as long as adjacency holds"
        ],
        "cost_model": [
          "static cost",
          "dynamic cost based on degree/time",
          "binary cost (0/1)"
        ],
        "input_form": [
          "edge list",
          "adjacency list",
          "adjacency matrix"
        ],
        "data_mode": [
          "single instance",
          "multiple test cases",
          "online queries with updates"
        ],
        "operation_support": [
          "static graph",
          "support edge addition/deletion",
          "node cost updates"
        ],
        "output_requirement": [
          "return minimum cost",
          "also return set of initially seized nodes",
          "reclamation sequence"
        ]
      }
    }
  },
  {
    "title": "守护太空城",
    "slug": "EJvmW4",
    "schema": {
      "Input Structure": [
        "一维时间序列 events，其中每个事件为 (time[i], position[i])",
        "time 是长度为 n 的整数数组，1 <= time[i] <= 5",
        "position 是长度为 n 的整数数组，0 <= position[i] <= 100",
        "n <= 500"
      ],
      "Core Constraint": [
        "屏障可在单个舱室或相邻两个舱室上开启",
        "屏障一旦开启，可维持多个时刻，每多维持一时刻消耗能量 1",
        "同一时刻一个舱室只能被一个屏障覆盖",
        "陨石只在到达时刻对指定位置产生影响，需在该时刻有屏障覆盖",
        "不同时间点的覆盖需求相互独立，但可通过持续屏障连接"
      ],
      "Objective Function": "最小化总能量消耗以覆盖所有陨石冲击事件",
      "Algorithmic Invariant": [
        "按时间分层处理：每个时刻的防护决策依赖于前一时刻的屏障状态",
        "状态压缩 DP：用掩码表示当前时刻哪些舱室被屏障覆盖（联合/单独）",
        "局部最优可扩展：若某舱室区间在当前时刻被覆盖，且下一时刻仍需部分覆盖，则延续屏障可能更优",
        "贪心可优化：对于连续时间出现的相邻舱室需求，优先考虑联合屏障+维持策略"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 <= n <= 500",
          "time_range": "1 <= time[i] <= T（可变，如扩展至 1e5）",
          "position_range": "0 <= position[i] <= M（当前 ≤100，可扩大）"
        },
        "输入形式": [
          "是否按 time 排序（当前无序，可要求预处理）",
          "是否多组测试数据",
          "是否在线输入事件流"
        ],
        "屏障规则变化": [
          "能量成本参数化：单舱室 a，双舱室 b，维持 c（原题 a=2, b=3, c=1）",
          "允许多段联合屏障（如跨度 >2）",
          "禁止重复开启同一屏障（增加状态约束）"
        ],
        "时间维度变化": [
          "T 很大时转为事件驱动模拟",
          "引入时间间隔权重"
        ],
        "空间结构变化": [
          "舱室成环形排列",
          "二维舱室网格布局"
        ],
        "目标函数变化": [
          "求是否存在解（判定型）",
          "最大化节省能量",
          "构造具体方案"
        ]
      }
    }
  },
  {
    "title": "二叉搜索树染色",
    "slug": "QO5KpG",
    "schema": {
      "Input Structure": [
        "二叉搜索树 root，节点值唯一且非负",
        "每个节点的值 ∈ [0, 10^9]",
        "给定操作序列 ops，其中 ops[i] = [type, x, y]",
        "type ∈ {0, 1}，表示染蓝（0）或染红（1）",
        "x, y 为树中实际存在的节点值，且 x ≤ y"
      ],
      "Core Constraint": [
        "操作按顺序执行，后执行的操作会覆盖之前对同一节点的颜色",
        "由于是二叉搜索树，值域有序，区间 [x, y] 对应树中一组可被路径连通的节点",
        "颜色只由最后一次染色操作决定（具有时间上的覆盖性）",
        "查询区间 [x, y] 在 BST 上可通过中序性质高效定位"
      ],
      "Objective Function": "统计经过所有操作后，最终为红色（type=1）的节点总数",
      "Algorithmic Invariant": [
        "逆序处理操作序列时，一旦某个节点被染色（无论红蓝），其最终颜色已确定，无需后续处理",
        "利用并查集或集合合并思想：维护尚未被确定最终颜色的节点集合；每次操作仅作用于当前仍‘自由’的节点子集",
        "基于值域的离散化 + 区间覆盖追踪：可用有序集合（如平衡树、TreeSet）维护未被锁定的值区间",
        "BST 的中序遍历提供有序值列表，支持在 O(n) 预处理后进行 O(log n) 的区间查找"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "节点数量范围": "1 <= n <= 10^5",
          "操作数量范围": "1 <= ops.length <= 10^5",
          "值域范围": "0 <= 节点值 <= 10^9"
        },
        "输入形式": [
          "root 以指针/引用形式给出（结构体 TreeNode）",
          "ops 以二维数组形式按时间顺序给出"
        ],
        "是否多组数据": false,
        "是否在线": false,
        "颜色模型变化": [
          "可扩展为多色染色（type ≥ 2）",
          "目标函数改为统计某种颜色连通分量数"
        ],
        "操作类型变形": [
          "加入撤销操作（undo last op）",
          "改为仅染叶子节点 / 子树根节点等限定范围"
        ],
        "树结构变形": [
          "推广至普通二叉树（失去值域有序性，则需暴力遍历）",
          "推广至动态插入节点的 BST（在线建树）"
        ],
        "约束隐式化": [
          "x, y 不保证存在于树中 → 需先查询前驱后继",
          "区间变为开区间 (x, y)"
        ],
        "输出形式变化": [
          "输出最终每个红色节点的路径",
          "输出最后一次染红的操作编号之和"
        ]
      }
    }
  },
  {
    "title": "烹饪料理",
    "slug": "UEcfPD",
    "schema": {
      "Input Structure": {
        "materials": "Array[int] of length 5, representing available quantities of 5 types of ingredients",
        "cookbooks": "Matrix[int] of size m×5, where cookbooks[i][j] is the amount of ingredient j required to make dish i",
        "attribute": "Matrix[int] of size m×2, where attribute[i] = [x, y] represents deliciousness x and fullness y of dish i",
        "limit": "int, minimum required fullness"
      },
      "Core Constraint": {
        "constraint": "Each dish can be made at most once; total consumption of each ingredient cannot exceed available materials",
        "dependency": "Dish selection is combinatorial and constrained by multi-dimensional resource limits (ingredients)",
        "combinatorial_feasibility": "Feasible subset of dishes must satisfy: for each ingredient j, sum over selected dishes i of cookbooks[i][j] ≤ materials[j]"
      },
      "Objective Function": {
        "goal": "Maximize total deliciousness",
        "condition": "Subject to total fullness ≥ limit",
        "output": "Return maximum deliciousness if feasible; otherwise return -1"
      },
      "Algorithmic Invariant": {
        "search_space_invariant": "The set of all subsets of dishes (power set) forms the solution space, size 2^m with m ≤ 8 → exhaustive search feasible",
        "pruning_invariant": "If current partial selection already exceeds material limits, further expansion is invalid (early pruning in DFS or bitmask iteration)",
        "optimality_invariant": "Maximum deliciousness under fullness constraint can be tracked globally during enumeration; no greedy choice preserves optimality due to conflicting objectives"
      },
      "Transformable Parameters": {
        "n_dishes": "m ∈ [1, 8], currently small enough for bitmask/DFS; could scale to DP with state compression if increased slightly",
        "n_ingredients": "Fixed at 5; generalizable to k-dimensional resource vector",
        "value_range": "Ingredients and cookbook values in [0,20]; limit in [1,100]",
        "input_form": "Batch input; could transform to online version: dishes revealed sequentially requiring immediate accept/reject decision",
        "constraints_modification": [
          "Change fullness constraint from ≥ limit to exact = limit (exact cover variant)",
          "Allow multiple uses of same dish (unbounded knapsack-like)",
          "Add dependency between dishes (e.g., dish A must be made before dish B)"
        ],
        "objective_transformations": [
          "Maximize fullness given minimum deliciousness threshold",
          "Count number of valid schemes achieving max deliciousness",
          "Multi-objective: maximize (deliciousness, fullness) lexicographically"
        ],
        "data_structure_variation": "Replace cookbooks matrix with list of maps (sparse representation) if ingredients become high-dimensional"
      }
    }
  },
  {
    "title": "宝石补给",
    "slug": "WHnhjV",
    "schema": {
      "Input Structure": {
        "gem": "一维数组 gem[0..n-1]，其中 n >= 2，元素为非负整数，表示每位勇者的初始宝石数量",
        "operations": "二维数组 operations[0..m-1]，每个操作为 [x, y]，满足 0 <= x, y < n 且 x != y，表示将第 x 位勇者一半（向下取整）的宝石赠送给第 y 位勇者",
        "数据类型": "整数数组，操作序列按顺序执行"
      },
      "Core Constraint": {
        "顺序依赖性": "赠送操作必须按给定顺序逐步进行，不能并行或重排",
        "状态更新即时性": "每次操作后 gem 数组立即改变，后续操作基于最新状态",
        "资源守恒偏差": "由于向下取整，总宝石数可能减少（不可逆损耗）",
        "局部修改全局影响": "单次操作只影响两个元素，但极值可能发生变化"
      },
      "Objective Function": {
        "目标类型": "数值计算",
        "具体目标": "在所有操作完成后，求拥有最多宝石的勇者与最少宝石的勇者之间的宝石数量之差（max - min）"
      },
      "Algorithmic Invariant": {
        "模拟不变性": "每一步操作中，执行 gem[y] += floor(gem[x] / 2); gem[x] -= floor(gem[x] / 2) 可正确反映状态转移",
        "极值可延迟维护": "最大值和最小值无需在每次操作后立即更新，可在最终状态一次性计算",
        "操作原子性": "每个 operation 是原子的，且仅依赖当前状态，无分支或回溯需求"
      },
      "Transformable Parameters": {
        "数据规模": {
          "n": "gem.length ∈ [2, 10^3]",
          "m": "operations.length ∈ [0, 10^4]"
        },
        "值域范围": "gem[i] ∈ [0, 10^3]，中间过程可能增大（接收多次赠送）",
        "是否有序": "输入数组无序，不影响逻辑",
        "是否循环": "否；但可改编为循环索引或环形操作",
        "是否多组数据": "原题为单组输入，可扩展为多测例批量处理",
        "是否在线": "原始为离线操作序列；可变形为在线流式操作输入",
        "操作规则变化": [
          "向下取整 → 向上取整 / 四舍五入",
          "赠送一半 → 赠送固定比例或常数",
          "单向赠送 → 双向交换",
          "允许 self-gift（x == y）"
        ],
        "输出形式变化": [
          "返回差值 → 返回 max 和 min 的索引",
          "返回最终数组 → 返回过程中极差的最大值"
        ]
      }
    }
  },
  {
    "title": "自行车炫技赛场",
    "slug": "kplEvH",
    "schema": {
      "Input Structure": [
        "二维数组 terrain[0..n-1][0..m-1]，表示场地高度，terrain[i][j] ≥ 0",
        "二维数组 obstacle[0..n-1][0..m-1]，表示减速值，obstacle[i][j] ≥ 0",
        "起始位置 position = [r0, c0]，满足 0 <= r0 < n, 0 <= c0 < m",
        "初始速度为 1",
        "n, m ∈ [1, 100]"
      ],
      "Core Constraint": [
        "移动仅允许上下左右四个方向的相邻格子",
        "从 (r1, c1) 移动到 (r2, c2) 的速度变化为：Δv = terrain[r1][c1] - terrain[r2][c2] - obstacle[r2][c2]",
        "骑行过程中任意时刻速度必须 > 0（不能为零或负值）",
        "目标是找出所有可以从起点出发、经过若干步后**恰好到达且速度刚好为 1**的位置"
      ],
      "Objective Function": [
        "构造一个二维数组，包含所有满足条件的位置 [i, j]，使得从 position 出发存在一条路径，在该位置结束时速度恰好为 1",
        "输出按行坐标升序排列，行相同则按列坐标升序排列"
      ],
      "Algorithmic Invariant": [
        "状态可定义为 (r, c, v)：当前位于 (r, c)，速度为 v",
        "使用 BFS 或 Dijkstra 风格的状态扩展：每个状态只在首次以某一速度到达 (r,c) 时被处理（避免重复计算）",
        "速度具有正整数约束，且受地形和障碍限制，不会无限增长（上界可估计）",
        "一旦某个位置 (r, c) 被以速度 1 到达过，则它应被记录进答案（但允许多次访问不同速度）",
        "状态转移是确定性的：给定当前速度和边权（由高度差与目标点障碍决定），下一速度唯一确定"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 的范围": "[1, 100]",
          "值域范围": "terrain[i][j], obstacle[i][j] ∈ [0, 100]"
        },
        "输入形式": {
          "是否多组数据": false,
          "是否在线查询": false,
          "初始速度是否可变": true,
          "终点速度目标是否可变": true
        },
        "图结构变形": {
          "维度变换": "2D → 1D 或环形网格（如首尾相连）",
          "连通性约束": "八方向移动 / 只允许部分方向"
        },
        "约束变化": {
          "速度非负改为允许瞬时为零": false,
          "加入最大速度限制": false
        },
        "目标函数变形": {
          "求是否存在路径": false,
          "求最小/最大路径长度": false,
          "计数问题：有多少条路径能回到速度1": false,
          "构造方案：输出完整路径": false
        },
        "动态更新支持": {
          "支持修改 terrain 或 obstacle": false,
          "支持多次查询不同起点": false
        }
      }
    }
  },
  {
    "title": "无限棋局",
    "slug": "fsa7oZ",
    "schema": {
      "Input Structure": "二维坐标点集 pieces，其中 pieces[i] = [x, y, color]，表示在无限大棋盘上的一个棋子；x, y ∈ [-10^9, 10^9]，color ∈ {0, 1}（0: 黑棋，1: 白棋）；无重复坐标；初始状态无胜者",
      "Core Constraint": "胜负判定基于是否存在任意方向（行、列、对角线）上连续5个同色棋子；黑棋先行，双方均采用最优策略进行最多三步博弈（黑→白→黑）；每步可在任意空位落子；胜负在首次达成五连时立即终止",
      "Objective Function": "判断在三步之内（按黑、白、黑顺序）是否必出现黑棋胜、白棋胜或仍无胜者；输出对应结果字符串：'Black' / 'White' / 'None'",
      "Algorithmic Invariant": "博弈树深度受限为3层（B-W-B），可通过极小化极大搜索（Minimax）配合剪枝求解；每个状态的后续动作空间可被启发式限制于关键邻域区域（如已有棋子周围）；局部连通性不变量支持方向扩展检测（上下、左右、主副对角线）；对手最优反应下，当前玩家仅需找到一条必胜路径即判定胜利",
      "Transformable Parameters": {
        "n": "pieces.length，范围 [0, 1000]",
        "coordinate_range": "[-10^9, 10^9]，支持稀疏大坐标",
        "color_convention": "0 表示黑棋先手，1 表示白棋",
        "move_limit": "固定为三步（黑、白、黑），可变参数为步数 k 或先后顺序",
        "win_condition": "连续5颗同色棋子获胜，可改为 N 连珠（N ≥ 5）",
        "board_boundary": "无边界限制，可变换为有界棋盘",
        "game_rules": "允许在线落子模拟、是否允许多步回溯、是否加入禁手规则",
        "output_type": "返回胜方名称，也可改为返回获胜位置序列或构造反例",
        "strategy_assumption": "双方均按最优策略行动，可变为一方随机或次优策略"
      }
    }
  },
  {
    "title": "志愿者调配",
    "slug": "05ZEDJ",
    "schema": {
      "Input Structure": [
        "n个节点的无向图，节点编号0到n-1",
        "边集edges: edges[i] = [x, y] 表示无向边连接节点x和y",
        "初始总人数totalNum（整数）",
        "最终人数数组finalCnt，长度为n-1，表示第1到第n-1个场馆的最终人数",
        "操作序列plans: plans[i] = [num, idx]，表示对节点idx执行第num种操作",
        "每个节点初始人数未知，需推断；第0个节点的最终人数丢失"
      ],
      "Core Constraint": [
        "三种操作具有确定性且可逆：",
        "  1. 减半操作（类型1）→ 可通过乘2逆向恢复",
        "  2. 向邻居加自身值（类型2）→ 逆向时从邻居减去当前值",
        "  3. 从邻居减去自身值（类型3）→ 逆向时向邻居加上当前值",
        "操作顺序可逆，因此可以从终态反推初态",
        "所有操作均为线性变换，整体系统保持线性可解性",
        "第0个节点的最终状态缺失，但可通过totalNum与其余节点终态反推"
      ],
      "Objective Function": "构造",
      "Algorithmic Invariant": [
        "逆向模拟不变性：从最终状态出发，按操作逆序执行逆操作，能唯一恢复初始状态",
        "总人数在逆向过程中可逐步重构：设finalCnt已知n-1个节点终值，第0个节点终值 = totalNum - sum(finalCnt)",
        "每一步逆操作仅依赖当前各节点人数，且变换是确定性的",
        "图结构固定，邻居关系在逆向中保持不变",
        "类型1操作的逆要求原值为偶数（题目保证），确保乘2合法"
      ],
      "Transformable Parameters": {
        "n的数量级": "2 <= n <= 5*10^4",
        "plans长度": "1 <= m <= 10，极小，支持逆向模拟",
        "值域范围": "初始人数 <= 10^9，totalNum < 5*10^13，使用长整型",
        "图结构特性": [
          "无自环、无重边",
          "是否连通（题目未强制，但操作只涉及邻居，实际不影响）"
        ],
        "输入形式": "离线批量输入",
        "是否多组数据": "否（单实例）",
        "是否在线": "否",
        "操作类型集合": "固定三种操作，可扩展为更多线性操作",
        "缺失信息模式": "可变为缺失多个节点终值，或缺失totalNum",
        "操作可逆性假设": "若类型1不保证偶数，则无法逆向，破坏不变性"
      }
    }
  },
  {
    "title": "玩具套圈",
    "slug": "vFjcfV",
    "schema": {
      "Input Structure": [
        "二维平面上的一组圆形玩具 toys[i] = [xi, yi, ri], 其中 i ∈ [0, n-1]",
        "二维平面上的一组圈 circles[j] = [xj, yj], 其中 j ∈ [0, m-1]",
        "所有圈具有相同的固定半径 r",
        "n = len(toys) ≤ 1e4, m = len(circles) ≤ 1e4",
        "坐标范围：0 ≤ xi, yi, xj, yj ≤ 1e9",
        "玩具半径 ri 和圈半径 r 均为小整数，1 ≤ ri, r ≤ 10"
      ],
      "Core Constraint": [
        "一个玩具被套中当且仅当其整个圆（包括边界）被至少一个圈完全包含",
        "即：对于玩具 (xt, yt, rt) 和圈 (xc, yc, r)，满足欧几里得距离 d = √[(xt - xc)² + (yt - yc)²] ≤ r - rt",
        "若 r - rt < 0，则该玩具不可能被任何圈套中",
        "每个玩具最多被计数一次，即使被多个圈覆盖"
      ],
      "Objective Function": "计数 —— 统计最多能被套中的不同玩具的数量",
      "Algorithmic Invariant": [
        "由于 r 和 rt 很小（≤10），可以枚举每个玩具，并快速判断是否存在某个圈能将其完全覆盖",
        "对每个玩具，只需检查是否存在圈使得 dist(圈心, 玩具心) ≤ r - rt",
        "一旦找到一个有效圈即可标记该玩具为已套中，无需继续搜索",
        "利用几何剪枝：若 r - rt < 0 则跳过；否则基于整数坐标和小半径特性避免高精度浮点运算（可用平方比较）",
        "算法正确性不依赖于 circles 的顺序，满足‘存在性判定’的短路性质"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "toys.length": "1 ~ 10^4",
          "circles.length": "1 ~ 10^4",
          "坐标值域": "0 ~ 1e9"
        },
        "半径约束": {
          "r 和 ri 的上界": "可扩展至更大值（如 1e5），或设为变量数组",
          "是否所有圈半径相同": "可改为 circles 带独立半径 → 变为通用圆包含问题"
        },
        "输入形式": [
          "是否在线输入 circles 或 toys",
          "是否支持动态添加/删除圈"
        ],
        "覆盖规则变化": [
          "从‘完全覆盖’变为‘部分重叠即算’（目标函数仍为计数）",
          "从‘玩具是圆’变为‘点玩具’或‘矩形玩具’"
        ],
        "输出形式": [
          "仅返回总数",
          "返回每个被套中的玩具索引",
          "要求最大匹配方案（考虑圈资源有限时）"
        ],
        "多组数据": "是否处理 T 组独立测试用例",
        "精度要求": "是否强制使用浮点距离计算 vs 整数平方比较优化"
      }
    }
  },
  {
    "title": "黑白翻转棋",
    "slug": "fHi6rV",
    "schema": {
      "Input Structure": [
        "二维字符矩阵 chessboard[0..n-1][0..m-1]",
        "n, m ∈ [1, 8]",
        "每个元素为 'X'（黑棋）、'O'（白棋）或 '.'（空位）",
        "初始状态无合法翻转动作，但存在至少一个空位"
      ],
      "Core Constraint": [
        "翻转规则：新落子与同色棋子在行、列或对角线方向上完全包围一段连续异色棋子（中间无空格），则可翻转该段",
        "包围必须是双向延伸的直线（共8个方向）",
        "翻转具有连锁性：新生成的黑棋可能触发后续可翻转局面，需递归处理直至稳定"
      ],
      "Objective Function": "最大化通过一次落子（放置一枚黑棋）所能翻转的白棋总数（包括连锁反应中翻转的所有白棋）",
      "Algorithmic Invariant": [
        "每条直线上翻转的连续白棋段必须满足：两端为黑棋（含新落子），中间全为白棋且无空缺",
        "状态演化单调：每次翻转只增加黑棋数量，不减少；游戏状态向终止收敛",
        "对于每个候选落子位置，模拟过程独立且可并行计算",
        "最优解来自某个空位上的全局最大连锁翻转结果"
      ],
      "Transformable Parameters": {
        "棋盘规模": {
          "当前值": "n, m ≤ 8",
          "可变范围": "1×1 到 20×20；是否允许超大规模（>100）并要求优化算法）"
        },
        "颜色角色": {
          "当前值": "固定落黑子，翻转白子",
          "可变换": "改为落白子 / 翻转黑子 / 双方交替决策"
        },
        "翻转规则": {
          "当前值": "8方向直线包围",
          "可变形": "仅4方向 / 曲线包围 / 非连续包围 / 多层嵌套翻转"
        },
        "连锁机制": {
          "当前值": "允许递归翻转直到无法继续",
          "可关闭": "仅执行单轮翻转"
        },
        "输入形式": {
          "当前值": "静态离线输入",
          "可扩展": "在线查询多个残局 / 支持修改操作 / 动态添加棋子"
        },
        "输出目标": {
          "当前值": "最大翻转数",
          "可变换": "构造方案 / 计数所有可行位置 / 判定是否存在 ≥K 的解"
        },
        "初始状态约束": {
          "当前值": "初始无可翻转棋子",
          "可放松": "允许初始存在可翻转状态"
        }
      }
    }
  },
  {
    "title": "无人机方阵",
    "slug": "0jQkd0",
    "schema": {
      "Input Structure": "二维数组 source[1..n][1..m] 和 target[1..n][1..m]，其中 n, m ≥ 1；元素为正整数，表示灯光颜色编号；1 <= source[i][j], target[i][j] <= 10^4",
      "Core Constraint": "无人机的位置可以任意重新排列（即行、列顺序可任意调整），但每架无人机只能对应目标中的一个位置；颜色切换代价独立于位置调整，且仅当某无人机最终展示的颜色与目标不符时才产生代价",
      "Objective Function": "最小化需要切换灯光颜色的无人机数量（即最小化颜色不匹配的数量）",
      "Algorithmic Invariant": "最优解中，尽可能多地将 source 中的颜色实例直接映射到 target 中相同颜色的实例上；未被匹配的颜色必须通过切换实现，因此最少切换次数 = 总无人机数 - source 与 target 颜色多重集的最大匹配数",
      "Transformable Parameters": {
        "数据规模": "n, m 的范围：原始为 1<=n,m<=100；可扩展至更大规模或单维情况（如 M=1 变为一维）",
        "值域范围": "颜色编号范围：原始为 [1, 10^4]；可改为更大值域或允许负数",
        "是否有序": "原始无序，位置可重排；可变体可限制部分行列不可移动",
        "输入形式": "是否保证 source 和 target 大小相同；可设计为不同大小并引入增删操作",
        "多组数据": "是否处理多组测试用例（竞赛常见）",
        "在线/离线": "是否支持动态更新 source 或 target 并查询最小切换次数",
        "约束变化": "从‘最小切换’变为‘判定是否存在无需切换的方案’或‘计数所有零切换重排方案’"
      }
    }
  },
  {
    "title": "心算挑战",
    "slug": "uOAnQW",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element": "integer",
        "size": "n",
        "value_range": "[1, 1000]",
        "sorted": false,
        "duplicates_allowed": true,
        "description": "一维数组 cards[1..n]，表示卡牌上的数字；给定整数 cnt 表示需选出的卡牌数量"
      },
      "Core Constraint": {
        "constraint": "选出的 cnt 张卡牌数字总和必须为偶数",
        "implication": "总和的奇偶性由所选数字中奇数个数的奇偶性决定；偶数个奇数之和为偶数，奇数个奇数之和为奇数",
        "structure_impact": "在固定选取数量 cnt 下，选择策略需平衡奇偶数的组合以满足偶数和约束"
      },
      "Objective Function": {
        "goal": "最大化有效得分",
        "validity_condition": "仅当选出的 cnt 张卡牌数字总和为偶数时，方案有效",
        "output": "返回最大有效得分；若无有效方案，返回 0"
      },
      "Algorithmic Invariant": {
        "invariant": "贪心构造下的最优子结构：优先选取最大值，再通过局部调整（替换最小奇/偶数）满足偶性约束",
        "procedure": [
          "将卡牌按数值降序排序",
          "先取前 cnt 大的元素，计算其和 sum",
          "若 sum 为偶数，直接返回",
          "若 sum 为奇数，则尝试用已选集合中的最小奇数与未选集合中的最大偶数交换，或用已选中的最小偶数与未选中的最大奇数交换",
          "每次交换改变总和奇偶性，且应使总和下降最小"
        ],
        "monotonicity": "排序后贪心选择具有单调最优性，局部调整方向唯一（减小损失）"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "cnt",
            "type": "integer",
            "range": "1 <= cnt <= n",
            "slot": "number_of_selections"
          },
          {
            "name": "n",
            "type": "integer",
            "range": "[1, 10^5]",
            "slot": "input_size"
          },
          {
            "name": "cards[i]",
            "type": "positive integer",
            "range": "[1, 1000]",
            "slot": "value_domain"
          },
          {
            "name": "objective",
            "options": [
              "maximize even sum",
              "minimize odd sum",
              "count valid combinations"
            ],
            "current": "maximize even sum",
            "transformable": true
          },
          {
            "name": "parity_constraint",
            "options": [
              "even sum",
              "odd sum"
            ],
            "current": "even sum",
            "transformable": true
          },
          {
            "name": "input_order",
            "options": [
              "unsorted",
              "sorted"
            ],
            "default": "unsorted",
            "transformable": true
          },
          {
            "name": "data_streaming",
            "options": [
              "offline",
              "online_query"
            ],
            "default": "offline",
            "transformable": true
          },
          {
            "name": "multiple_test_cases",
            "type": "boolean",
            "default": false,
            "transformable": true
          },
          {
            "name": "allow_negative_values",
            "type": "boolean",
            "default": false,
            "transformable": true
          },
          {
            "name": "card_modification",
            "options": [
              "static",
              "dynamic_insert_delete"
            ],
            "default": "static",
            "transformable": true
          }
        ]
      }
    }
  },
  {
    "title": "十字路口的交通",
    "slug": "Y1VbOX",
    "schema": {
      "Input Structure": [
        "长度为 4 的一维字符串数组 directions[0..3]",
        "directions[0] 表示东侧车道车辆（从近到远）",
        "directions[1] 表示南侧车道车辆（从近到远）",
        "directions[2] 表示西侧车道车辆（从近到远）",
        "directions[3] 表示北侧车道车辆（从近到远）",
        "每个字符串由字符 'E', 'N', 'W', 'S' 组成，表示该位置车辆的行驶目标方向",
        "各车道车辆顺序为：最靠近路口的在字符串首位",
        "0 <= len(directions[i]) <= 20"
      ],
      "Core Constraint": [
        "每秒只能从每个方向最多放行一辆车驶出",
        "每秒每个目标方向最多只能有一辆车驶入（即不能有两个车同时进入同一方向车道）",
        "同一秒内，所有被放行车的路径不能相交",
        "路径相交定义：两辆车的行驶路线在十字路口内部发生交叉（如直行与对角左转冲突等）",
        "不允许掉头（输入保证无此情况）",
        "车辆一旦驶出，即离开系统，不参与后续状态"
      ],
      "Objective Function": "最小化总时间（秒数），使得所有车道上的车辆全部驶离路口",
      "Algorithmic Invariant": [
        "每一秒的选择必须满足：被选车辆的目标方向互不冲突（即路径不相交且不违反出入规则）",
        "状态可建模为四维状态 (i, j, k, l) 表示四个方向已处理前 i/j/k/l 辆车",
        "BFS 或 Dijkstra 在状态空间中搜索最小步数可达终态 (len(E), len(S), len(W), len(N))",
        "每一步转移对应一个合法的子集放行方案（非空），且该子集满足：",
        "  - 每个方向至多一辆车",
        "  - 所有被放行车的目的地方向互不重复（避免同一方向多车驶入）",
        "  - 路径之间无几何交叉（例如：EW 与 NS 冲突；EN 与 WS 不冲突等，需预定义冲突关系）",
        "可证明：若某组车辆路径集合无冲突，则它们可在同一秒内同时通行"
      ],
      "Transformable Parameters": {
        "n 的数量级": "各方向车辆数 ≤ 20，总状态数 ≤ 21^4 ≈ 2e5，适合 BFS + 状态压缩",
        "值域": "方向字符仅限 {'E','N','W','S'}，路径冲突规则固定",
        "是否有序": "是，字符串顺序表示距路口远近，队列结构",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "可变约束点": [
          "路径冲突规则是否可修改（例如允许部分交叉）",
          "是否允许多车同时进入同一目标方向",
          "是否加入优先级限制（如紧急车辆）",
          "是否扩展为 8 向（含左转/右转/直行区分）",
          "是否变为动态来车（在线模式）",
          "目标函数变化：从最小时间 → 最大吞吐量 / 可行性判定 / 方案构造"
        ]
      }
    }
  },
  {
    "title": "开幕式焰火",
    "slug": "sZ59z6",
    "schema": {
      "Input Structure": "二叉树 root，其中每个节点包含一个整数值；节点个数 n 满足 1 <= n <= 1000，节点值 val 满足 1 <= val <= 1000",
      "Core Constraint": "颜色的唯一性由节点值的数值决定；不同子树之间可能存在重复颜色，需跨整个树结构去重统计",
      "Objective Function": "计数：统计整棵树中不同颜色（即不同节点值）的种类总数",
      "Algorithmic Invariant": "遍历过程中维护一个已见颜色的集合（如哈希集），每次访问节点时判断其值是否已出现，确保每种颜色仅被计数一次；树的结构无序性不影响最终计数结果",
      "Transformable Parameters": {
        "数据规模": "节点个数范围可调整（例如扩展至 1e5 或更小）",
        "值域范围": "Node.val 的取值范围可变（如 [-1000, 1000] 或更大）",
        "输入形式": "是否给出层序数组表示 / 指针结构；是否多组测试数据",
        "在线性": "是否支持动态插入/删除节点后的实时颜色种类查询（在线版本）",
        "约束条件": "是否要求仅统计满足某种结构条件的颜色（如只在叶子节点或特定深度）",
        "输出形式": "是否返回具体颜色列表而非数量"
      }
    }
  },
  {
    "title": "入场安检",
    "slug": "oPs9Bm",
    "schema": {
      "Input Structure": [
        "数组 capacities[0..N-1]，表示 N 个安检室的容量",
        "每个 capacities[i] 是正整数，1 <= capacities[i] <= 200",
        "总人数为 M + 1，其中 M = sum(capacities)",
        "观众编号从 0 到 M，共 M+1 人",
        "给定目标观众编号 k（0 <= k <= M）"
      ],
      "Core Constraint": [
        "观众必须依次进入安检室 0，并逐级向后传递至最后一个安检室",
        "每个安检室在满员时，新观众进入前需根据其类型弹出一人：FIFO 弹出最早进入者，LIFO 弹出最晚进入者",
        "只有当第 i 个安检室未满时，观众才能直接进入；否则必须先弹出一人再进入",
        "观众一旦离开第 i 个安检室，立即进入第 i+1 个（i < N-1）",
        "最终目标是判断编号 k 的观众是否能第一个从最后一个安检室（N-1）中走出",
        "可自由设定每个安检室为 FIFO 或 LIFO 类型"
      ],
      "Objective Function": "计数：有多少种设定安检室类型（FIFO/LIFO）的方案，使得观众 k 是第一个通过最后一个安检室的人（即第一个从第 N-1 个安检室走出的人）",
      "Algorithmic Invariant": [
        "最后一个安检室的第一个出站观众，完全由前面各安检室的排队与弹出机制决定",
        "对于任意安检室 i，若其类型为 FIFO，则先进入者先被弹出；若为 LIFO，则后进入者先被弹出",
        "整个过程可建模为状态传播：每个观众能否‘存活’到下一级，取决于他在每一级是否被提前弹出",
        "关键观察：观众 k 要成为最后一个安检室的第一个出站者，必须满足：在他之前的所有观众都在到达最后一关前被全部弹出，且他本人未被弹出",
        "递推不变量：设 dp[i][j] 表示前 i 个安检室处理完后，当前队列中最小观众编号为 j 的合法方案数（或类似状态压缩形式）",
        "每层安检室的操作等价于一个受限栈/队列操作序列，其保留的最小编号具有单调演化性质"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "N": "1 <= N <= 200",
          "capacities[i]": "1 <= capacities[i] <= 200",
          "k": "0 <= k <= sum(capacities)"
        },
        "输入形式": "单组输入，离线处理",
        "是否有序": "观众编号天然有序（按入场顺序）",
        "是否循环": false,
        "是否多组数据": false,
        "是否在线": false,
        "值域变化可能": [
          "capacities 是否允许为 0（边界情况）",
          "k 是否超出合理范围",
          "是否扩展至多个目标观众（如前 K 个）",
          "是否要求输出具体方案而非计数"
        ],
        "结构变形": [
          "安检室连接方式改为图结构（非链式）",
          "观众可分批入场（非一次性）",
          "允许中途退出或跳过安检室"
        ],
        "约束变形": [
          "固定某些安检室类型（部分不可选）",
          "增加时间维度限制",
          "引入优先级而非仅 FIFO/LIFO"
        ]
      }
    }
  },
  {
    "title": "环形闯关游戏",
    "slug": "K8GULz",
    "schema": {
      "Input Structure": [
        "环形一维数组 challenge[0..n-1]",
        "每个元素 challenge[i] 为正整数，表示第 i 个关卡的最低积分要求",
        "数组长度 n 满足 1 <= n <= 5 * 10^4",
        "值域：challenge[i] ∈ [1, 10^14]"
      ],
      "Core Constraint": [
        "关卡呈环形结构，编号 0 与 n-1 相邻",
        "初始可任选一个关卡开启",
        "挑战关卡 i 需当前积分 >= challenge[i]",
        "挑战成功后积分更新为 score | challenge[i]",
        "挑战后相邻两个关卡（左右）被开启（若未开启）",
        "开启状态传播具有不可逆性和连通扩展性",
        "OR 运算具有单调不减性（即 score ≤ score | x）"
      ],
      "Objective Function": "求最小的初始积分，使得存在一种合法挑战顺序，可以完成所有关卡的挑战",
      "Algorithmic Invariant": [
        "积分只增不减（由位或运算决定）",
        "一旦某个位被置1，则永久保留",
        "开启状态从初始点向外扩散，形成连续段（在环上）",
        "若某位置被开启且其积分要求已被满足，则后续总能挑战（因积分非降）",
        "最优解对应的初始积分一定是某个 challenge[i] 的子集或特定组合的下界",
        "可通过枚举起始点 + 贪心扩展（双指针式推进）验证可行性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n_range": "[1, 5*10^4]",
          "value_range": "[1, 1e14]"
        },
        "输入形式": "单组输入 / 可拓展为多组测试数据",
        "是否环形": true,
        "是否允许负值": false,
        "操作类型": "静态一次性输入",
        "在线查询": false,
        "修改操作": false,
        "目标函数变体": [
          "判断是否存在可行解（判定问题）",
          "计算最少挑战步数（构造路径）",
          "输出具体挑战顺序",
          "最大化最终积分与初始积分之差"
        ],
        "约束变形": [
          "改为 AND / XOR 更新规则",
          "相邻三个关卡开启",
          "需要连续挑战才能维持开启状态",
          "加入冷却时间或限制挑战次数"
        ],
        "结构变形": [
          "线性数组（非环形）",
          "树形连接结构",
          "二维网格上的关卡传播"
        ]
      }
    }
  },
  {
    "title": "省份数量",
    "slug": "bLyHh0",
    "schema": {
      "Input Structure": "n x n 矩阵 isConnected，其中 n 表示城市数量；isConnected[i][j] ∈ {0,1}，表示城市 i 与城市 j 是否直接相连；对称矩阵（isConnected[i][j] == isConnected[j][i]），且对角线元素为 1（每个城市自连）",
      "Core Constraint": "省份定义为极大连通子图（即城市之间的连通性满足传递闭包），组内城市通过直接或间接路径相连，组间无连接；问题本质是求无向图中连通分量的数量",
      "Objective Function": "计算连通分量（省份）的数量",
      "Algorithmic Invariant": "使用并查集（Union-Find）时：每次合并操作保持各连通分量的代表元唯一，路径压缩与按秩合并不改变连通性结构；使用 DFS/BFS 时：从任意未访问节点出发遍历可访问所有属于同一连通分量的节点，访问标记确保每个节点仅被归属一次",
      "Transformable Parameters": [
        "n 的数量级：如 n ≤ 200（当前）、n ≤ 1e5（需优化存储与算法）",
        "图的表示形式：邻接矩阵 → 邻接表 → 边列表",
        "是否允许自环（当前固定有）",
        "是否对称（当前固定对称，即无向图；可变换为有向图变体：强连通分量计数）",
        "是否多组数据输入",
        "是否在线添加边或查询当前连通分量数（动态连通性问题）",
        "值域变化：isConnected[i][j] 是否可为浮点权重（转为带权图聚类问题）",
        "目标函数变换：从计数 → 输出每个省份包含的城市列表 / 最大省份大小 / 最小生成树数量等"
      ]
    }
  },
  {
    "title": "不同路径",
    "slug": "2AoeFn",
    "schema": {
      "Input Structure": "二维网格 grid[m][n]，其中 m 和 n 为正整数；机器人从 (0,0) 出发，目标为 (m-1, n-1)；每次只能向右或向下移动一步。",
      "Core Constraint": "路径必须由恰好 (m-1) 次向下和 (n-1) 次向右的移动组成；所有路径均为简单路径（无回溯），且移动方向受限导致状态转移具有前向依赖性。",
      "Objective Function": "计算从左上角到右下角的不同路径总数（计数类问题）。",
      "Algorithmic Invariant": "到达任意位置 (i,j) 的路径数 = 到达 (i-1,j) 的路径数 + 到达 (i,j-1) 的路径数；该递推关系在整个网格中保持不变，支持动态规划或组合数学推导。",
      "Transformable Parameters": {
        "网格规模": "1 <= m, n <= 100；可扩展至更大规模并考虑高精度计算",
        "移动规则": "可修改为允许对角线移动、向上/向左移动等（如限制步数或引入障碍）",
        "是否存在障碍": "是否引入障碍物（变为 LeetCode 63 题）",
        "是否多组输入": "是否处理多组 (m,n) 查询，需预处理组合数表",
        "数据流形式": "是否在线输入 m 和 n，要求快速响应查询",
        "输出形式": "输出总路径数，或要求输出所有具体路径方案（构造型）",
        "值域特性": "路径数可能很大，是否取模；当前保证结果 <= 2e9"
      }
    }
  },
  {
    "title": "组合",
    "slug": "uUsW3B",
    "schema": {
      "Input Structure": {
        "type": "Integer Range",
        "description": "两个整数 n 和 k，表示从有序整数集合 {1, 2, ..., n} 中选取元素",
        "constraints": [
          "n 是正整数，1 <= n <= 20",
          "k 是正整数，1 <= k <= n",
          "输入为标量参数，非数组形式直接给出"
        ]
      },
      "Core Constraint": {
        "description": "组合不考虑顺序，即 [1,2] 与 [2,1] 视为相同，仅保留字典序升序排列的结果",
        "key_property": "无序选择下的唯一表示（按升序构造避免重复）",
        "combinatorial_rule": "每次选择的数必须大于前一个，保证结果唯一且不重复"
      },
      "Objective Function": {
        "type": "Construction",
        "goal": "生成所有可能的 k 个数的组合方案",
        "output_form": "返回二维列表，每个子列表是一个长度为 k 的升序整数组合"
      },
      "Algorithmic Invariant": {
        "invariant_type": "递归/回溯路径不变性",
        "properties": [
          "在构建当前组合 path 时，后续可选数字均大于 path 中最后一个数字",
          "搜索过程中维护起始位置 start，确保不重复访问较小数字以避免重复组合",
          "深度优先搜索中，每层递归决策是否选择当前数字，并保持字典序增长"
        ],
        "optimization_condition": "剪枝：若剩余可选数字不足 (n - start + 1) < (k - path.length)，则提前终止分支"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n_value_range",
            "description": "n 的数量级，当前为小规模（≤20），可扩展至支持更大值或动态范围",
            "possible_transforms": [
              "增加到 30（需剪枝优化）",
              "改为变量流式输入"
            ]
          },
          {
            "name": "k_constraint",
            "description": "k 是否固定、可变或作为查询参数",
            "possible_transforms": [
              "多组查询不同 k 值",
              "k 上限约束变化"
            ]
          },
          {
            "name": "ordering_requirement",
            "description": "输出是否必须按字典序排列",
            "possible_transforms": [
              "允许任意顺序输出",
              "要求逆字典序或其他排序"
            ]
          },
          {
            "name": "input_structure_form",
            "description": "从连续整数集选择 → 从任意数组中选 k 个组合",
            "possible_transforms": [
              "输入变为数组 A[1..n]，从中取 k 元组合",
              "元素可重复（有放回组合）"
            ]
          },
          {
            "name": "duplicate_elements",
            "description": "原始集合是否有重复元素",
            "possible_transforms": [
              "去重处理",
              "转化为‘组合总和 II’类问题"
            ]
          },
          {
            "name": "online_query",
            "description": "是否支持在线查询某个索引对应的组合（组合编号问题）",
            "possible_transforms": [
              "支持第 i 个组合的快速计算（数学法 / 进制映射）"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "子集",
    "slug": "TVdhkn",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中 n >= 1；元素互不相同；值域：-10 <= nums[i] <= 10",
      "Core Constraint": "子集由原数组中任意组合的元素构成，且不允许重复子集；由于元素互不相同，每个元素只有‘选’或‘不选’两种状态，可独立决策",
      "Objective Function": "生成数组的所有可能子集（幂集），即所有元素组合的集合，包含空集和全集",
      "Algorithmic Invariant": "通过递归/回溯或位掩码枚举的方式，每一步决策只依赖当前元素是否加入子集，已生成的部分不会影响后续构造的完整性与唯一性；状态空间呈二叉树结构，左子树表示不选当前元素，右子树表示选当前元素",
      "Transformable Parameters": {
        "数据规模": "n 的数量级：1 <= n <= 10（当前为小规模，可扩展至支持更大 n 或在线生成）",
        "元素性质": "是否允许重复元素（若允许，则需去重处理，变为子集 II 类问题）",
        "有序性要求": "输出子集是否需要按字典序排列",
        "输入形式": "是否多组输入 / 是否在线查询单个子集",
        "操作类型": "是否支持动态添加/删除元素后的子集更新",
        "输出限制": "是否仅返回特定大小的子集（如 k-subsets），或仅非空子集"
      }
    }
  },
  {
    "title": "合并 K 个升序链表",
    "slug": "vvXgSW",
    "schema": {
      "Input Structure": [
        "数组 lists，包含 k 个链表：lists[0..k-1]",
        "每个链表 lists[i] 是一个升序排列的单向链表",
        "节点值为整数，范围 [-10^4, 10^4]",
        "k >= 0，单个链表长度 >= 0",
        "所有链表节点总数 <= 10^4"
      ],
      "Core Constraint": [
        "所有输入链表内部已有序（非递减）",
        "不同链表之间无共享节点",
        "合并后必须保持全局升序",
        "只能通过比较节点值决定顺序，不能重排原链表结构"
      ],
      "Objective Function": "将 k 个升序链表合并为一个升序链表，返回合并后的头节点（构造方案类问题）",
      "Algorithmic Invariant": [
        "维护一个优先队列（最小堆），存储当前各链表未处理的最小节点",
        "每次从堆中取出值最小的节点加入结果链表，并将其后继节点入堆",
        "堆的大小始终 <= k，保证每一步选择都是全局最优",
        "指针推进不回溯：一旦某节点被取出，其前驱状态不再影响后续决策"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "k 的数量级": [
            "k <= 10",
            "k <= 100",
            "k <= 10^4"
          ],
          "总节点数限制": [
            "<= 10^3",
            "<= 10^4",
            "无显式限制"
          ]
        },
        "链表特性": [
          "是否允许空链表",
          "是否允许重复值",
          "是否循环链表（变形）",
          "是否双向链表"
        ],
        "输入形式": [
          "离线批量输入（全部给出）",
          "在线流式输入（逐个提供链表）"
        ],
        "输出要求": [
          "仅返回头节点",
          "返回整个序列数组",
          "要求原地合并（复用原有节点）"
        ],
        "约束变化": [
          "目标变为降序合并",
          "增加权重因素（带权合并）",
          "限定空间复杂度 O(1) → 强制使用分治"
        ],
        "算法路径分支": [
          "使用最小堆（推荐解法）",
          "分治法：两两合并（递归/迭代）",
          "暴力扫描：每次找最小头（低效但可行）"
        ]
      }
    }
  },
  {
    "title": "排序链表",
    "slug": "7WHec2",
    "schema": {
      "Input Structure": "单链表 ListNode *head，节点数 n ∈ [0, 5×10⁴]，每个节点值 val ∈ [-10⁵, 10⁵]",
      "Core Constraint": "链表结构不支持随机访问，仅能通过指针顺序遍历；要求在 O(n log n) 时间内完成排序，进阶要求常数级额外空间",
      "Objective Function": "返回按升序排列后的链表头节点",
      "Algorithmic Invariant": "归并排序的分治结构：可通过快慢指针将链表从中点分割，递归排序后合并两个有序链表；合并过程中维护已排序部分的尾指针，确保连接正确性；若使用自底向上归并，则通过子链长度迭代控制合并范围，避免递归栈开销",
      "Transformable Parameters": [
        "n 的数量级：[0, 5×10⁴]（可调整至更大以禁止 O(n²) 算法）",
        "是否允许负值：是（可改为非负整数限制）",
        "链表是否循环：否（可设计环形链表变形）",
        "是否双向链表：否（若为双向可启用其他排序策略）",
        "是否要求稳定排序：隐式要求（相同值相对顺序不变）",
        "是否在线输入：否（可改为数据流式插入排序）",
        "空间复杂度约束：O(1) 辅助空间（进阶条件，决定必须用自底向上归并）",
        "是否多组测试数据：是（默认竞赛环境设定）"
      ]
    }
  },
  {
    "title": "数组中的第 K 个最大元素",
    "slug": "xx4gT2",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "元素为整数，可能重复",
        "1 <= n <= 10^4",
        "值域：-10^4 <= nums[i] <= 10^4"
      ],
      "Core Constraint": [
        "第 k 个最大元素的位置依赖于全局排序信息",
        "局部极值无法直接确定全局排名",
        "但可通过划分（partition）逐步缩小搜索范围"
      ],
      "Objective Function": "返回数组中第 k 个最大的元素（即降序排列下索引为 k-1 的元素）",
      "Algorithmic Invariant": [
        "使用快速选择（Quickselect）时，每次划分后基准元素位置 pos 确定其在排序后的最终位置",
        "若 pos == k-1，则找到答案",
        "若 pos < k-1，继续在右子数组查找",
        "若 pos > k-1，继续在左子数组查找",
        "维护区间 [l, r] 包含第 k 大元素的不变性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "10^4（当前）",
            "可扩展至 10^5 或 10^6"
          ],
          "k 的范围": [
            "1 <= k <= n",
            "可限制为 k 较小（如 top-k）"
          ]
        },
        "输入形式": [
          "一次性输入（当前）",
          "可变为流式输入（在线求第 k 大）",
          "多组查询（多次不同 k 查询）"
        ],
        "数组性质": [
          "无序（当前）",
          "是否部分有序",
          "是否允许重复元素（当前允许）",
          "是否为正整数"
        ],
        "输出要求": [
          "仅返回值（当前）",
          "返回索引",
          "返回所有前 k 大元素"
        ],
        "操作类型": [
          "静态查询（当前）",
          "支持插入/删除的动态版本（如用堆或平衡树）"
        ],
        "算法路径": [
          "快速选择（期望 O(n)）",
          "最小堆维护前 k 大（O(n log k)）",
          "二分答案 + 计数（适用于值域小）"
        ]
      }
    }
  },
  {
    "title": "数组的相对排序",
    "slug": "0H97ZC",
    "schema": {
      "Input Structure": [
        "一维数组 arr1[1..n]",
        "一维数组 arr2[1..m]",
        "arr1[i] ∈ [0, 1000], 非负整数",
        "arr2[i] ∈ [0, 1000], 非负整数",
        "arr2 中元素互不相同",
        "arr2 的每个元素都出现在 arr1 中"
      ],
      "Core Constraint": [
        "arr1 中属于 arr2 的元素必须保持在 arr2 中的相对顺序",
        "未出现在 arr2 中的 arr1 元素应按升序排列",
        "排序仅依赖于 arr2 提供的优先级序列和自然数值序的组合"
      ],
      "Objective Function": "构造一个重排后的 arr1，使得：(1) 所有在 arr2 中出现的元素按照 arr2 的相对顺序排列；(2) 所有不在 arr2 中的元素按升序追加到末尾",
      "Algorithmic Invariant": [
        "arr2 定义了一个自定义比较规则：若两个元素都在 arr2 中，则其顺序由在 arr2 中的索引决定",
        "若一个在 arr2、另一个不在，则 arr2 中的元素优先",
        "若两个都不在 arr2 中，则按数值大小升序排列",
        "该比较关系具有全序性和可传递性，支持基于计数或自定义比较的稳定排序"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 数量级": "1 <= n, m <= 1000",
          "值域扩展可能": "可扩展至 1e5 或支持负数"
        },
        "输入形式": [
          "是否保证 arr2 ⊆ arr1",
          "是否允许多次出现（arr1 可重复，arr2 不可）",
          "是否多组测试数据"
        ],
        "排序目标变换": [
          "目标函数可变为：降序放置剩余元素",
          "改为按频率排序未覆盖元素",
          "改为输出字典序最小方案（若有多种合法）"
        ],
        "约束变化": [
          "arr2 不完全包含于 arr1 → 需处理缺失元素",
          "arr2 有重复元素 → 引入多重集匹配问题"
        ],
        "在线化扩展": [
          "支持动态修改 arr2 后重新排序 arr1",
          "流式 arr1 输入，离线 arr2"
        ],
        "结构维度扩展": [
          "二维矩阵中按某行/列顺序相对排序",
          "嵌套数组或结构体字段排序"
        ]
      }
    }
  },
  {
    "title": "合并区间",
    "slug": "SsGoHC",
    "schema": {
      "Input Structure": [
        "一维数组 intervals[1..n]",
        "每个元素为二元组 [start_i, end_i]",
        "0 <= start_i <= end_i",
        "intervals.length >= 1",
        "区间端点为整数，值域范围 [0, 10^4]"
      ],
      "Core Constraint": [
        "两个区间若满足 end_i >= start_j（i < j），则可合并",
        "合并后的区间为 [min(start_i, start_j), max(end_i, end_j)]",
        "最终结果需覆盖所有输入区间且无重叠",
        "顺序无关性：可通过排序使问题具有单调结构"
      ],
      "Objective Function": [
        "合并所有重叠区间",
        "返回一个不重叠的区间数组",
        "构造型目标：输出合并后的完整区间列表"
      ],
      "Algorithmic Invariant": [
        "按 start_i 排序后，遍历过程中只需维护当前合并区间的右边界 cur_end",
        "对于新区间 [s, e]，若 s <= cur_end，则可合并；否则输出当前区间并重新开始",
        "已确定的合并区间不会与后续区间产生新的交集（贪心可扩展性）",
        "状态单向演化：指针前进、区间合并不可逆"
      ],
      "Transformable Parameters": [
        "n 的数量级：1e4（可变至 1e5 或更高以要求 O(n log n)）",
        "是否已排序：输入是否按 start_i 有序",
        "区间开闭性：是否为开区间或半开区间",
        "维度扩展：从 1D 区间 → 2D 矩形合并",
        "数据流化：在线输入区间，支持动态合并",
        "多组数据：处理多个测试用例",
        "目标变换：改为统计合并次数 / 最大合并长度 / 可合并对数",
        "约束反转：不允许合并端点相接（如 [1,4],[4,5] 不再合并）",
        "容差机制：仅当重叠长度 > K 时才合并"
      ]
    }
  },
  {
    "title": "爱吃香蕉的狒狒",
    "slug": "nZZqjQ",
    "schema": {
      "Input Structure": [
        "一维数组 piles[1..n]，表示每堆香蕉的数量",
        "piles[i] ≥ 1，正整数",
        "给定总时间 H（整数），满足 n ≤ H ≤ 10^9"
      ],
      "Core Constraint": [
        "每小时只能选择一堆香蕉吃，最多吃 K 根",
        "若当前堆少于 K 根，则吃完后本小时内不再进食",
        "必须在 H 小时内吃完所有堆",
        "吃香蕉顺序可自由选择，但不能中途切换堆"
      ],
      "Objective Function": "求最小整数速度 K，使得以速度 K 能在 H 小时内吃完所有香蕉",
      "Algorithmic Invariant": [
        "判定函数 feasible(K): 计算以速度 K 吃完所有堆所需时间 total = Σ⌈piles[i]/K⌉",
        "total ≤ H 是单调非增函数：K 增大 ⇒ 所需时间减少",
        "可在 [1, max(piles)] 区间上进行二分查找，寻找满足 feasible(K) 的最小 K",
        "二分过程中，中间值 mid 的判定结果可剪枝搜索空间而不影响最优解"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": "1 <= n <= 10^4",
          "H 的范围": "n <= H <= 10^9",
          "piles[i] 值域": "1 <= piles[i] <= 10^9"
        },
        "输入形式": [
          "是否有序（默认无序）",
          "是否允许负值（否）",
          "是否多组测试数据（可扩展）"
        ],
        "目标函数变体": [
          "最小化 K → 最大化 K（如限制最少使用时间）",
          "计数满足条件的 K 数量",
          "判定是否存在某个 K 满足额外约束"
        ],
        "约束变换": [
          "H 小时限制 → 引入最大连续进食小时数限制",
          "每堆必须连续吃完 → 允许中断堆（增加复杂度）",
          "加入恢复机制：每隔 x 小时必须休息 1 小时"
        ],
        "数据流化": [
          "离线一次性输入 → 在线动态添加香蕉堆",
          "支持修改某堆数量后的快速再计算"
        ],
        "维度扩展": [
          "二维网格上的香蕉分布，移动耗时计入总时间（引入图结构）"
        ]
      }
    }
  },
  {
    "title": "x 的平方根",
    "slug": "jJ0w9p",
    "schema": {
      "Input Structure": "非负整数 x，其中 0 <= x <= 2^31 - 1",
      "Core Constraint": "平方根的整数部分是满足 k^2 <= x 的最大整数 k；函数在正数域上单调递增，因此可以利用单调性进行搜索",
      "Objective Function": "求非负整数 x 的平方根的整数部分（向下取整）",
      "Algorithmic Invariant": "使用二分查找维护区间 [left, right]，使得 left <= sqrt(x) < right 始终成立；每次迭代缩小搜索范围而不丢失解，直到收敛到最大整数 k 满足 k^2 <= x",
      "Transformable Parameters": {
        "数据规模": "x 可扩展至更大范围（如长整型或高精度数值）",
        "输入类型": "可改为实数输入并要求一定精度的小数部分",
        "输出形式": "可要求返回浮点近似值、或保留 n 位小数",
        "是否在线": "可设计为支持连续查询的预处理结构（如打表 + 二分）",
        "约束条件": "可加入不允许使用内置乘法或幂运算的操作限制",
        "多组数据": "可变为多组测试用例批量处理"
      }
    }
  },
  {
    "title": "按权重随机选择",
    "slug": "cuyjEf",
    "schema": {
      "Input Structure": [
        "长度为 n 的正整数数组 w[0..n-1]",
        "w[i] ≥ 1",
        "表示每个下标 i 的权重",
        "需支持多次调用 pickIndex() 方法（在线数据流式查询）"
      ],
      "Core Constraint": [
        "选取下标 i 的概率与 w[i] 成正比，即 P(i) = w[i] / sum(w)",
        "必须在常数或对数时间内完成每次采样，否则无法通过大规模调用",
        "只能使用基于前缀和 + 二分搜索 或别名法等高效加权采样策略"
      ],
      "Objective Function": [
        "构造一个可重复调用的函数 pickIndex()",
        "目标是按权重比例随机返回一个下标 i",
        "输出类型：整数（下标）"
      ],
      "Algorithmic Invariant": [
        "前缀和数组 S 满足 S[i] = w[0] + w[1] + ... + w[i]，且严格单调递增",
        "总权重 total = S[n-1]，采样时生成 [1, total] 范围内的随机数 r",
        "通过二分查找定位最小的 i 使得 S[i] ≥ r，该 i 即为按权重采样的结果",
        "指针移动或查找过程不改变前缀和结构的正确性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": "1 <= n <= 10000",
          "单个 w[i] 值域": "1 <= w[i] <= 1e5",
          "pickIndex 调用次数上限": "<= 10000"
        },
        "输入形式": [
          "初始化时传入权重数组 w",
          "后续连续调用 pickIndex()，无参数"
        ],
        "是否多组数据": false,
        "是否在线": true,
        "是否允许负权重": false,
        "是否动态更新权重": false,
        "输出要求": "每次返回一个下标，不要求输出概率分布",
        "精度要求": "浮点误差可控，使用整型前缀和避免精度问题"
      }
    }
  },
  {
    "title": "有序数组中的单一元素",
    "slug": "skFtm2",
    "schema": {
      "Input Structure": "有序数组 A[1..n]，其中 n 为奇数；每个元素均为非负整数；除一个元素外，其余每个元素恰好出现两次；相同元素在数组中连续分布（因有序）",
      "Core Constraint": "唯一元素的存在破坏了‘每对元素占据两个连续位置’的局部配对结构；在唯一元素左侧，所有成对元素的第一个出现在偶数索引（0-indexed），第二个在奇数索引；在唯一元素右侧，该模式反转",
      "Objective Function": "找出那个只出现一次的元素",
      "Algorithmic Invariant": "利用二分查找维护区间 [l, r]，使得搜索空间始终包含唯一元素；通过检查中点 m 的奇偶性及其与邻居的相等关系，判断唯一元素位于左半或右半；每次缩小一半搜索空间且不丢失解",
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 1e5]，支持 O(log n) 解法",
        "值域": "nums[i] ∈ [0, 1e5]，可扩展至负数或更大范围",
        "是否有序": "关键约束，当前为升序排列；若无序则退化为哈希计数问题",
        "重复次数": "可变为‘其他元素出现 k 次’（如 3 次），改变判定逻辑",
        "输入形式": "单组输入；可改为多组测试数据",
        "在线性": "当前为离线一次性输入；可设计为流式输入并要求实时判断",
        "输出形式": "当前输出唯一元素值；可改为输出其索引或构造方案"
      }
    }
  },
  {
    "title": "山脉数组的峰顶索引",
    "slug": "B1IidL",
    "schema": {
      "Input Structure": "一维数组 arr[1..n]，其中 n >= 3，元素为非负整数；arr 严格先增后减，存在唯一峰值点 i（0 < i < n-1），使得 arr[0] < arr[1] < ... < arr[i] > arr[i+1] > ... > arr[n-1]",
      "Core Constraint": "数组具有唯一的山峰结构（单峰性），且峰值左侧严格递增、右侧严格递减；局部单调性可被利用以排除搜索空间",
      "Objective Function": "返回山峰顶部的下标 i",
      "Algorithmic Invariant": "在二分查找过程中，通过比较 mid 与 mid+1 处的值，可以确定峰值位于左半段或右半段：若 arr[mid] < arr[mid+1]，则峰值在右半段；否则在左半段；每次迭代均保持峰值存在于当前搜索区间内",
      "Transformable Parameters": {
        "数据规模": "n 的数量级可变（如 1e3 → 1e5 → 1e6），支持 O(n) 或强制要求 O(log n) 解法",
        "值域范围": "arr[i] 是否有界（如 0 <= arr[i] <= 1e6）或可扩展至负数",
        "是否多组数据": "可设计为多测案例输入",
        "是否在线": "可改为流式输入场景，要求实时判断趋势变化",
        "输入形式变换": "可从显式山峰数组变为隐式构造（例如函数接口 f(i) 返回 arr[i]，禁止遍历全数组）",
        "约束松弛": "允许平台峰（非严格递增/递减）或多个峰值（转为找第一个/最大下标等）",
        "维度扩展": "可推广至二维网格上的‘山峰单元格’问题"
      }
    }
  },
  {
    "title": "搜索插入位置",
    "slug": "N6YdxV",
    "schema": {
      "Input Structure": "一维有序数组 nums[1..n]，其中 n ≥ 1；nums 中无重复元素，且为非降序排列；元素和 target 均为整数，值域 ∈ [-10^4, 10^4]",
      "Core Constraint": "由于数组有序且无重复，任意位置的相对大小关系可通过二分比较确定；插入位置唯一由第一个 ≥ target 的元素位置决定",
      "Objective Function": "寻找目标值 target 在数组中的下标；若不存在，则返回其应插入的位置（即最左侧满足 nums[i] ≥ target 的索引 i）",
      "Algorithmic Invariant": "维护搜索区间 [left, right)，始终保持 left ≤ 插入位置 ≤ right；每次中点比较后可安全收缩一半空间而不丢失解；循环不变量：nums[left-1] < target ≤ nums[right]",
      "Transformable Parameters": {
        "数据规模": "n 的数量级可变（如 1e4 → 1e6 → 在线流式）",
        "是否多组数据": "可扩展为多组查询（如多个 target 的批量插入位置）",
        "是否在线": "可改为动态插入并实时查询（支持修改操作）",
        "数组性质": "是否允许重复元素（影响最左插入点定义）、是否降序排列",
        "目标函数形式": "输出改为 bool（是否存在）或返回左右边界范围（用于范围查询）",
        "输入维度": "可推广至二维有序矩阵中的插入定位问题"
      }
    }
  },
  {
    "title": "数组中两个数的最大异或值",
    "slug": "ms70jA",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"array\",\n    \"element\": \"integer\",\n    \"size\": \"n\",\n    \"range\": \"0 <= nums[i] < 2^31\",\n    \"dimension\": 1,\n    \"order\": \"unordered\",\n    \"duplicates\": true\n  },\n  \"Core Constraint\": {\n    \"constraint\": \"XOR operation is maximized when bit prefixes diverge earliest in a binary trie\",\n    \"property\": \"bitwise independence: higher bits dominate lower bits in XOR result\",\n    \"structure_requirement\": \"pair (i, j) does not require i ≠ j; self-pair allowed (i == j)\"\n  },\n  \"Objective Function\": {\n    \"type\": \"maximization\",\n    \"target\": \"maximum value of nums[i] XOR nums[j]\",\n    \"scope\": \"over all pairs with 0 <= i <= j < n\"\n  },\n  \"Algorithmic Invariant\": {\n    \"invariant\": \"for each number processed, maintain a binary trie of prefix paths to enable greedy selection of opposite bit at each level\",\n    \"greedy_condition\": \"at each bit position from high to low, prefer taking the branch that flips the current bit to maximize XOR\",\n    \"trie_property\": \"each path from root to leaf represents a number's binary representation (31 bits)\",\n    \"query_rule\": \"for a given num, traverse trie choosing opposite bit if exists, else same bit\",\n    \"optimality_preservation\": \"inserting numbers one by one and querying before insertion ensures O(n) without missing optimal pair\"\n  },\n  \"Transformable Parameters\": {\n    \"n_range\": [1, 2 * 10**5],\n    \"value_domain\": \"non-negative integers up to 2^31 - 1\",\n    \"input_form\": \"single batch array\",\n    \"multiple_queries\": false,\n    \"online_mode\": false,\n    \"dynamic_updates\": false,\n    \"ordered_input\": false,\n    \"signed_numbers\": false,\n    \"bit_width\": 31,\n    \"output_type\": \"scalar maximum XOR value\",\n    \"require_pair_indices\": false,\n    \"constrained_indices\": false,\n    \"k_limited_pairs\": false\n  }\n}"
  },
  {
    "title": " 键值映射",
    "slug": "z1R5dt",
    "schema": {
      "Input Structure": [
        "维护一个动态键值对集合，其中键为字符串（由小写英文字母组成，长度 ≤ 50），值为整数（1 ≤ val ≤ 1000）",
        "支持两种操作：insert(key: string, val: int) 和 sum(prefix: string): int",
        "最多执行 50 次操作（insert 与 sum 的调用总和）"
      ],
      "Core Constraint": [
        "相同 key 插入时会覆盖旧值，而非累加",
        "sum 查询要求快速聚合所有以给定 prefix 开头的 key 对应的 val 总和",
        "前缀匹配具有结构性：若两个字符串共享前缀，则它们在字典序结构中相邻",
        "需要高效处理动态插入与聚合查询，暴力遍历所有已有键不可扩展"
      ],
      "Objective Function": [
        "sum(prefix) 函数目标是：计算并返回所有满足 key.startsWith(prefix) 的键对应的 val 值之和",
        "insert 操作的目标是：完成键值对的插入或更新"
      ],
      "Algorithmic Invariant": [
        "使用 Trie（前缀树）结构组织键字符串，每个节点可维护以该路径为前缀的所有键的 value 总和（子树和不变量）",
        "在 insert 操作中，从根到叶路径上每个节点的 sum 值都更新为当前所有经过该节点的键的 val 总和",
        "当键已存在时，需先减去旧值、再加上新值，保持子树和正确性",
        "查询 sum(prefix) 时，只需定位到 prefix 对应的 Trie 节点，返回其维护的子树和"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n_ops": "最多 50 次操作",
          "key_length": "1 <= length <= 50",
          "val_range": "1 <= val <= 1000"
        },
        "输入形式": [
          "离线操作序列 inputs 表示方法调用顺序",
          "支持重复 key 插入（覆盖语义）"
        ],
        "是否多组数据": false,
        "是否在线": true,
        "Trie 结构变体": [
          "是否压缩（Trie → Radix Tree）",
          "是否持久化（支持历史版本查询）"
        ],
        "value 更新策略": [
          "覆盖模式（本题）",
          "累加模式（如：每次 insert 累加 val）"
        ],
        "查询类型扩展": [
          "精确匹配查询",
          "通配符前缀查询（如 'a?p*'）",
          "区间前缀统计（字典序区间 [p1, p2)）"
        ],
        "空间优化选项": [
          "是否允许哈希表替代 Trie（适用于小规模）",
          "是否使用 unordered_map + 暴力匹配（仅当操作次数极少时可行）"
        ]
      }
    }
  },
  {
    "title": "单词的压缩编码",
    "slug": "iSwD2y",
    "schema": {
      "Input Structure": {
        "type": "array of strings",
        "description": "words[1..n], where each word is a string of lowercase letters",
        "constraints": {
          "n": "1 <= n <= 2000",
          "word_length": "1 <= len(words[i]) <= 7",
          "alphabet": "lowercase English letters only"
        }
      },
      "Core Constraint": {
        "description": "A word does not need to be explicitly included in the encoding if it is a suffix of another word in the list.",
        "key_insight": "If word A is a suffix of word B, then A can be covered by B in the encoded string, so only B needs to be stored as a standalone segment ending with '#'."
      },
      "Objective Function": {
        "type": "minimization",
        "target": "minimum length of the助记字符串 s that can encode all words with '#' termination and valid substring alignment via indices array"
      },
      "Algorithmic Invariant": {
        "invariant": "After reversing all words and sorting in lexicographical order, if a word is a prefix of the next word, then the corresponding original (unreversed) word is a suffix of the next one — thus it can be omitted from explicit storage.",
        "optimality_condition": "Greedy inclusion: only keep words that are not suffixes of any other word; this set uniquely determines the minimal encoding.",
        "data_structure_property": "Trie (prefix tree) on reversed words allows efficient detection of suffix relationships through prefix matching."
      },
      "Transformable Parameters": {
        "n_value_range": "[1, 2000]",
        "string_length_range": "[1, 7]",
        "character_set": "can be extended to uppercase, digits, or arbitrary alphabet",
        "input_form": {
          "single_batch": true,
          "online_queries": false,
          "multiple_test_cases": false
        },
        "output_form": {
          "return_type": "integer (length)",
          "alternative_forms": [
            "return the actual encoded string",
            "return the indices array",
            "count number of segments used"
          ]
        },
        "structural_variation": {
          "suffix_overlap_only": true,
          "general_substring_overlap": false,
          "cyclic_strings": false,
          "multi_dimensional_words": false
        },
        "constraint_modifications": {
          "allow_overlapping_non_suffix": false,
          "require_unique_start_positions": true,
          "limited_number_of_hash_marks": false
        }
      }
    }
  },
  {
    "title": "实现一个魔法字典",
    "slug": "US1pGT",
    "schema": {
      "Input Structure": [
        "字符串数组 dictionary，其中每个字符串由小写英文字母组成",
        "dictionary.length ≤ 100，每个字符串长度 ≤ 100",
        "所有字符串互不相同",
        "查询字符串 searchWord，长度 ≥ 1 且 ≤ 100，仅含小写英文字母",
        "buildDict 调用一次，后续最多 100 次 search 查询"
      ],
      "Core Constraint": [
        "仅允许对 searchWord 进行恰好一次单字符替换（不能插入、删除或零次替换）",
        "替换后的字符串必须与字典中某个完整字符串完全匹配",
        "原始 searchWord 本身若在字典中，不能直接返回 true（必须经过一次修改）"
      ],
      "Objective Function": "判定是否存在一种恰好修改一个字符的方案，使得修改后的字符串存在于字典中（布尔判定问题）",
      "Algorithmic Invariant": [
        "字典一旦构建完成即固定不变（离线预处理可行性）",
        "字符串匹配具有子串独立性：两个字符串能否通过一次替换匹配，等价于它们长度相等且恰好有一个位置字符不同",
        "可利用哈隆签名（wildcard hashing）或 Trie 结构实现模式等价类合并，保持查询时状态无遗漏"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "dictionary.length": "1~100 → 可扩展至 1e4 或更大（影响暴力可行性）",
          "字符串长度": "1~100 → 可支持变长或统一长度约束",
          "search 调用次数": "最多 100 次 → 可改为在线流式查询"
        },
        "操作类型": [
          "是否支持动态增删字典单词",
          "是否支持多字符替换（如 k=2）",
          "是否允许插入/删除操作（编辑距离泛化）"
        ],
        "输入形式": [
          "dictionary 是否有序",
          "是否批量查询",
          "是否区分大小写"
        ],
        "约束条件": [
          "必须恰好修改一次 → 可变为 '最多一次' 或 '至少一次'",
          "仅替换 → 可变为编辑距离 ≤k 的变体",
          "完全匹配 → 可变为前缀匹配或其他模糊匹配"
        ],
        "优化目标": [
          "当前目标为快速判定（bool 输出）→ 可改为计数有多少个可匹配的字典词",
          "或返回所有可行替换方案"
        ],
        "结构变形": [
          "从一维字符串匹配 → 扩展到二维网格单词搜索中的模糊匹配",
          "从静态字典 → 支持分布式或外部存储索引"
        ]
      }
    }
  },
  {
    "title": "单词替换",
    "slug": "UhWRSj",
    "schema": {
      "Input Structure": [
        "dictionary: array of strings, where each string is a root (length ≥ 1, consists of lowercase letters)",
        "sentence: string consisting of lowercase letters and spaces, representing a sequence of words separated by single spaces",
        "Constraints: dictionary.length ∈ [1, 1000], each root.length ∈ [1, 100], sentence.length ∈ [1, 10^6], number of words in sentence ∈ [1, 1000], each word length ∈ [1, 1000]"
      ],
      "Core Constraint": [
        "A successor (word in the sentence) can be replaced by its root if the word starts with that root (prefix match)",
        "If multiple roots form the same successor, the shortest root is chosen (tie-breaking by length)",
        "Replacement is greedy and independent per word — no overlapping or cascading replacements"
      ],
      "Objective Function": "Replace every word in the sentence with the shortest root from the dictionary that is a prefix of the word; if no such root exists, keep the original word",
      "Algorithmic Invariant": [
        "Prefix matching can be efficiently checked using a trie (prefix tree), where insertion and search are linear in key length",
        "Sorting roots by length ensures that shorter roots take precedence when inserted into a set or used in comparison",
        "Each word in the sentence is processed independently, allowing for parallelization or streaming processing",
        "Once a minimal-length valid prefix root is found during traversal (e.g., in a trie), further extension cannot yield a shorter root"
      ],
      "Transformable Parameters": {
        "n_roots": "dictionary size: [1, 1000]",
        "root_length": "individual root length: [1, 100]",
        "sentence_length": "total sentence length: up to 10^6 characters",
        "num_words": "number of words in sentence: [1, 1000]",
        "word_length": "maximum word length: [1, 1000]",
        "ordering_requirement": "whether dictionary is pre-sorted by length or lexicographical order",
        "data_structure_form": "use of trie vs. hash set vs. sorted list for root storage",
        "input_streaming": "offline batch input vs. online word-by-word processing",
        "output_requirement": "return modified sentence vs. return replacement mapping or count of replacements",
        "matching_type": "exact prefix match (current) → substring match / suffix match (variant)",
        "tie_breaking_rule": "shortest root → lexicographically smallest (alternative rule)"
      }
    }
  },
  {
    "title": "查找和最小的 K 对数字",
    "slug": "qn8gGX",
    "schema": {
      "Input Structure": [
        "两个一维升序整数数组 nums1[1..m] 和 nums2[1..n]",
        "nums1[i], nums2[j] ∈ [-10^9, 10^9]",
        "1 <= m, n <= 10^4",
        "1 <= k <= 1000"
      ],
      "Core Constraint": [
        "所有候选数对 (u, v) 满足 u ∈ nums1, v ∈ nums2",
        "由于数组有序，较小的和集中在数组前部，但不能直接枚举所有 m*n 对（规模过大）",
        "每个位置的潜在最优解受其索引位置与和值共同影响",
        "可利用有序性避免全排列生成"
      ],
      "Objective Function": "找出和最小的 k 个数对（按和升序排列，和相同时顺序不限）",
      "Algorithmic Invariant": [
        "使用最小堆维护当前最有希望成为下一个最小和的候选数对",
        "初始将 (nums1[i] + nums2[0], i, 0) 加入堆（每个 nums1 元素对应一个起始列）",
        "每次从堆中弹出最小和数对 (i, j)，然后将 (i, j+1) 推入（若存在）",
        "同一行内 j 递增保证不遗漏且不重复生成",
        "堆的大小可控，状态扩展具有单调推进性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": [
            "10^3",
            "10^4",
            "允许稀疏或稠密"
          ],
          "k 的范围": [
            "k << m*n",
            "k ≈ m*n",
            "k = 1"
          ]
        },
        "输入形式": [
          "是否保证有序（否 → 需预排序）",
          "是否允许重复元素（是 → 注意去重或保留重复）",
          "是否多组查询（固定 nums1, nums2 多次不同 k 查询）",
          "是否在线：nums1, nums2 动态追加"
        ],
        "目标函数变形": [
          "求最大 k 个和 → 最大堆",
          "求第 k 小和 → 可二分答案",
          "计数：有多少对 ≤ threshold → 转判定问题",
          "构造所有满足 sum ≤ T 的对 → 输出全部"
        ],
        "约束变换": [
          "从两个数组 → 三个数组（三元组）",
          "从最小和 → 最小 |u - v| 差值对",
          "加入额外约束：如 u ≤ v 才能配对",
          "权重和：a*u + b*v 最小"
        ],
        "输出形式": [
          "仅返回和值列表",
          "返回索引对 (i,j)",
          "要求去重（相同数值对只保留一次）",
          "要求字典序输出（而非按和）"
        ]
      }
    }
  },
  {
    "title": "实现 Trie (前缀树)",
    "slug": "QC3q1f",
    "schema": {
      "Input Structure": [
        "树形数据结构 Trie，由节点构成，每个节点包含一个字符映射（如数组或哈希表）指向子节点",
        "输入操作序列：包含 'Trie'（初始化）、'insert(word)'、'search(word)'、'startsWith(prefix)'",
        "word 和 prefix 均为字符串，长度 ∈ [1, 2000]",
        "字符集：仅限小写英文字母（a–z）",
        "操作总数 ≤ 3 × 10^4"
      ],
      "Core Constraint": [
        "字符串的前缀共享路径：相同前缀的字符串在 Trie 中共用从根到某一节点的路径",
        "插入与查询的时间复杂度应与字符串长度成线性关系，而非集合中字符串总数",
        "search 要求精确匹配（完整单词存在）",
        "startsWith 要求前缀匹配（路径存在即可，无需标记为单词结尾）",
        "空间可接受冗余以换取时间效率"
      ],
      "Objective Function": [
        "实现三个接口函数的正确行为：",
        " - insert: 构建 Trie 结构，确保后续 search 和 startsWith 可正确响应",
        " - search: 判定是否存在完全匹配的字符串（目标函数：判定存在性）",
        " - startsWith: 判定是否存在以给定字符串为前缀的已插入字符串（目标函数：判定前缀存在性）"
      ],
      "Algorithmic Invariant": [
        "每个节点维护两个状态：",
        " - 是否为某个插入字符串的结尾（isEnd / isWord）",
        " - 子节点映射（children[26] 或 Map<Character, Node>）",
        "插入过程中，沿字符流逐层创建节点，最终标记结尾",
        "查询过程中，路径存在是必要条件；search 额外要求终点节点 isEnd == true",
        "一旦路径中断，则 search 和 startsWith 均返回 false",
        "结构支持增量更新与查询交织（在线操作不变性）"
      ],
      "Transformable Parameters": {
        "字符集范围": [
          "小写字母",
          "扩展至大写、数字、Unicode"
        ],
        "数据规模": {
          "字符串最大长度": "1 ~ 2000（可调）",
          "操作次数上限": "≤ 3×10^4（可扩展至离线批量处理）"
        },
        "是否区分大小写": [
          true,
          false
        ],
        "是否支持删除操作": [
          false,
          true
        ],
        "存储方式": [
          "数组（固定26维）",
          "哈希表（动态扩展）",
          "压缩前缀树（Trie压缩优化）"
        ],
        "是否在线": true,
        "是否多组数据": false,
        "输入形式": "操作序列列表（命令+参数）",
        "输出形式": "各查询操作返回值组成的布尔列表"
      }
    }
  },
  {
    "title": "前 K 个高频元素",
    "slug": "g5c51o",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "整数 k",
        "nums[i] ∈ ℤ",
        "1 <= n <= 10^5",
        "k 满足 1 <= k <= 不同元素个数"
      ],
      "Core Constraint": [
        "元素频率由其在整个数组中出现次数决定",
        "高频元素的排序独立于值本身，仅依赖频次",
        "答案唯一：前 k 高频元素集合唯一"
      ],
      "Objective Function": "返回出现频率最高的 k 个元素（任意顺序）",
      "Algorithmic Invariant": [
        "频率统计后，问题转化为在频次空间中选择 top-k 元素",
        "使用桶排序：频次范围为 [1, n]，可构造大小为 n+1 的桶数组",
        "或使用堆结构维护大小为 k 的最小堆，保持更高频次进入",
        "堆或桶的选择不影响最终结果正确性，但满足 O(n log n) 以下复杂度约束"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的数量级：1e5 或可扩展至 1e6（在线场景）",
        "值域范围": "nums[i] 是否有界（如非负 / 32位整数）",
        "是否有序": "输入数组是否已排序（影响实现细节）",
        "是否多组数据": "是否连续处理多个测试用例",
        "是否在线": "元素流式到达，需支持动态更新频率与 top-k 查询",
        "输出形式": "是否要求按频次降序输出 / 是否允许任意顺序",
        "k 的性质": "k 是静态给定 / 动态查询（如多次不同 k 查询）",
        "频率定义": "是否加权频率 / 时间衰减频率（进阶变体）"
      }
    }
  },
  {
    "title": "数据流中的第 K 大元素",
    "slug": "jBjn9C",
    "schema": {
      "Input Structure": [
        "数据流序列（动态插入） nums",
        "整数 k，表示求第 k 大元素",
        "nums[i] ∈ [-10^4, 10^4]",
        "初始数组长度 ≤ 10^4",
        "add 操作最多调用 10^4 次"
      ],
      "Core Constraint": [
        "只需要维护前 k 大的元素即可确定答案",
        "新元素若小于当前第 k 大，则不影响结果",
        "状态只需保留一个大小为 k 的有序集合",
        "局部信息（最小值）决定是否淘汰"
      ],
      "Objective Function": "在每次插入后，返回当前数据流中第 k 大的元素（排序后从大到小第 k 个）",
      "Algorithmic Invariant": [
        "使用最小堆（大小为 k），堆顶为当前第 k 大元素",
        "堆内维护最大的 k 个元素，堆顶即为所求",
        "插入新元素时：若堆未满则直接加入；若堆已满且 val > 堆顶，则弹出堆顶并插入 val",
        "堆的大小始终 ≤ k，且堆顶始终代表当前第 k 大"
      ],
      "Transformable Parameters": {
        "k 的数量级": "k ≤ 10^4（可扩展至更大）",
        "数据规模": "总操作数 ≤ 10^4 → 可改为 10^6 或更高以区分解法",
        "输入形式": "初始化 + 动态 add 调用（在线模式）",
        "是否多组数据": false,
        "是否在线": true,
        "值域变化": "nums[i] 和 val 是否扩展到 long 范围",
        "堆类型变换": "改为最大堆模拟 / 双堆维护（中位数变体）",
        "目标函数变形": [
          "改为第 k 小元素",
          "改为中位数（k = (n+1)//2）",
          "改为滑动窗口内的第 k 大（加入删除操作）"
        ],
        "数据结构替换": "可用平衡二叉搜索树、Fenwick 树（值域离散化）替代堆",
        "初始化方式": "是否允许空初始化，后续逐步添加"
      }
    }
  },
  {
    "title": "我的日程安排表 I",
    "slug": "fi9suh",
    "schema": {
      "Input Structure": [
        "维护一个动态的日程列表，每个日程为半开区间 [start, end)",
        "start 和 end 为整数，满足 0 <= start < end <= 1e9",
        "输入为一系列在线查询：book(start, end)，最多 1000 次"
      ],
      "Core Constraint": [
        "任意两个日程安排不能有时间交叉（即区间重叠）",
        "区间为半开 [start, end)，意味着 [10,20) 与 [20,30) 不重叠",
        "新日程仅当与所有已有日程无交集时才可添加",
        "决策依赖于已存储区间的全局位置分布"
      ],
      "Objective Function": [
        "判定是否存在与待插入区间重叠的已有区间",
        "若无重叠，则插入并返回 true；否则返回 false",
        "目标函数为布尔判定 + 条件插入（构造）"
      ],
      "Algorithmic Invariant": [
        "已存储的区间集合保持不相交且有序（按 start 排序）",
        "利用区间有序性，可通过二分查找快速定位潜在冲突区间（前驱与后继）",
        "只需检查直接前驱（start ≤ 当前 start 的最大者）和直接后继（start ≥ 当前 end 的最小者）是否冲突即可保证全局无重叠",
        "插入后仍维持有序性与不相交性"
      ],
      "Transformable Parameters": {
        "数据规模": "n ≤ 1000（暴力可过），可扩展至 n ≤ 1e5（需平衡树）",
        "输入形式": "在线查询流，每次 book 调用即时响应",
        "是否多组数据": false,
        "是否有序": "初始无序，但内部维护有序结构（如 TreeSet 或 list 插入排序）",
        "区间类型": "半开区间 [start, end)，可变形为闭区间或开区间",
        "值域范围": "start/end ∈ [0, 1e9]，稀疏分布，适合离散化或树结构",
        "操作类型": "仅支持插入，不可删除或修改（可扩展为支持删除 → MyCalendar II/III）",
        "输出形式": "返回布尔值，可改为返回冲突区间列表或可插入位置"
      }
    }
  },
  {
    "title": "存在重复元素 III",
    "slug": "7WqeDu",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          -2147483648,
          2147483647
        ],
        "constraints": {
          "length_n": "0 <= n <= 2 * 10^4",
          "k_constraint": "0 <= k <= 10^4",
          "t_constraint": "0 <= t <= 2^31 - 1"
        }
      },
      "Core Constraint": {
        "spatial_temporal_window": "abs(i - j) <= k",
        "value_proximity": "abs(nums[i] - nums[j]) <= t",
        "dual_constraint_coupling": "两个约束必须同时满足：下标距离限制与数值差值限制",
        "sliding_window_dependency": "只有当前窗口内的元素可参与比较，超出窗口的元素失效"
      },
      "Objective Function": {
        "type": "decision",
        "goal": "判断是否存在两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t 且 abs(i - j) <= k",
        "output": "boolean (true / false)"
      },
      "Algorithmic Invariant": {
        "main_paradigm": "sliding_window",
        "auxiliary_structure": "ordered_set_or_bst",
        "invariant_rules": [
          "维护一个大小不超过 k 的滑动窗口",
          "窗口内元素按值有序存储（如使用 TreeSet 或等价结构）",
          "对于当前 nums[i]，查询是否存在值在 [nums[i] - t, nums[i] + t] 范围内的元素",
          "每次移动窗口时删除最旧元素（下标 < i - k），保持时间约束有效",
          "利用有序结构的 lower_bound / ceiling 操作实现 O(log k) 查询"
        ],
        "complexity_boundary": {
          "time": "O(n log min(n, k))",
          "space": "O(min(n, k))"
        }
      },
      "Transformable Parameters": {
        "n_scale": [
          "small: <= 100",
          "medium: <= 1e4",
          "large: <= 2e5"
        ],
        "k_value": {
          "range": [
            "0",
            "small",
            "large (~n)",
            "unbounded"
          ],
          "effect": "影响窗口大小和数据结构选择"
        },
        "t_value": {
          "range": [
            "0",
            "positive",
            "very_large"
          ],
          "effect": "决定值域邻域宽度"
        },
        "array_ordering": [
          "unordered",
          "partially_sorted",
          "random"
        ],
        "duplicate_allowed": true,
        "online_offline": {
          "mode": "offline (entire array given)",
          "possible_extension": "online version with stream input and query"
        },
        "multi_query": false,
        "data_modification": {
          "static": true,
          "possible_extension": "support insert/delete/update operations"
        },
        "output_detail": {
          "current": "boolean decision",
          "possible_extensions": [
            "return indices (i, j)",
            "count all valid pairs",
            "find closest pair under constraints"
          ]
        },
        "dimension_extension": {
          "1D_base": true,
          "possible_2D": "e.g., grid with spatial and value proximity"
        },
        "metric_change": {
          "distance_function": "absolute_difference",
          "alternatives": [
            "squared_difference",
            "Manhattan in higher dim"
          ]
        }
      }
    }
  },
  {
    "title": "最长连续序列",
    "slug": "WhsWhI",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "整数元素，可能包含重复值",
        "-10^9 <= nums[i] <= 10^9",
        "数组未排序"
      ],
      "Core Constraint": [
        "连续序列定义为数值上连续的整数集合，如 {x, x+1, x+2, ..., x+k-1}",
        "序列不要求在原数组中连续或相邻",
        "同一个数字在序列中只能使用一次（去重）",
        "最长序列的存在依赖于全局数字的分布而非局部顺序"
      ],
      "Objective Function": "计算最长连续整数序列的长度（最大化）",
      "Algorithmic Invariant": [
        "使用哈希集合存储所有数字，实现 O(1) 查询某个数是否存在",
        "仅当当前数 x 是连续序列的起点（即 x-1 不在集合中）时才开始向右扩展",
        "从起点 x 向右逐个检查 x+1, x+2, ... 是否存在，统计长度",
        "每个数字最多被访问两次（一次插入哈希表，一次遍历扩展），整体时间复杂度 O(n)",
        "遍历过程中已处理的中间数字不会重复作为起点，避免冗余计算"
      ],
      "Transformable Parameters": {
        "数据规模": "n <= 10^4（当前范围），可扩展至 10^5 或更高以测试效率",
        "值域范围": [
          -1000000000,
          1000000000
        ],
        "是否有序": false,
        "是否去重": true,
        "是否多组输入": false,
        "是否在线": false,
        "输入形式": "一次性静态数组",
        "输出形式": "单个整数（最长长度）",
        "约束变形": [
          "要求输出具体序列方案（构造型）",
          "限制内存使用（不允许哈希表）→ 引导排序解法",
          "允许近似解或流式处理（在线模式）",
          "二维推广：网格中寻找最长连续路径"
        ],
        "目标函数变形": [
          "计数：有多少个不同最长连续序列",
          "最小化断裂点数量",
          "带权连续子序列和最大"
        ]
      }
    }
  },
  {
    "title": "两数之和 IV - 输入二叉搜索树",
    "slug": "opLdQZ",
    "schema": {
      "Input Structure": [
        "二叉搜索树（BST）的根节点 root",
        "每个节点的值唯一",
        "节点个数 n ∈ [1, 10^4]",
        "节点值域：-10^4 ≤ Node.val ≤ 10^4",
        "目标整数 k，范围：-10^5 ≤ k ≤ 10^5"
      ],
      "Core Constraint": [
        "二叉搜索树的中序遍历具有单调递增性",
        "两数之和问题的目标值 k 固定，需判断是否存在一对不同节点满足 a + b = k",
        "输入结构为树形而非线性，访问受限于遍历方式",
        "要求在不显式构建所有值列表的前提下高效求解"
      ],
      "Objective Function": [
        "判定是否存在两个不同节点，其值之和等于 k",
        "返回布尔值：true 表示存在，false 表示不存在"
      ],
      "Algorithmic Invariant": [
        "利用 BST 中序遍历的单调性，可构造类双指针机制（前向迭代器 + 反向迭代器）",
        "维护两个遍历状态：一个从最小值开始（正向中序），一个从最大值开始（反向中序）",
        "当前和小于 k 时，前向指针右移（增大）；大于 k 时，反向指针左移（减小）",
        "指针移动过程中保持搜索空间的完整性与不重复性",
        "可在 O(h) 空间内实现双向迭代器（如栈模拟），h 为树高"
      ],
      "Transformable Parameters": [
        "数据规模：n 的数量级（当前为 1e4，可扩展至动态或在线场景）",
        "是否允许节点值重复",
        "是否要求输出具体节点对（而不仅是判定）",
        "是否多组查询（多个 k 值）",
        "输入形式变化：完整数组表示 / 流式插入 / 动态修改",
        "是否离线处理：提前建索引或哈希表",
        "树结构约束变化：普通二叉树（失去单调性）/ 平衡树 / 允许负值",
        "目标函数变换：求最接近 k 的两数和 / 计数满足条件的对数",
        "算法资源限制：是否允许 O(n) 额外空间（决定是否可用哈希表）"
      ]
    }
  },
  {
    "title": "冗余连接",
    "slug": "7LpjUW",
    "schema": {
      "Input Structure": [
        "无向图 G = (V, E)",
        "节点集合 V = {1, 2, ..., n}",
        "边集合 E 由长度为 n 的二维数组 edges 表示，edges[i] = [a_i, b_i]",
        "图初始为一棵树加上一条额外边（即：n 个节点，n 条边）",
        "输入保证图连通、无重边"
      ],
      "Core Constraint": [
        "原图是一棵树（n-1 条边，连通无环），添加一条边后形成唯一一个环",
        "删除的边必须是该环上的一条边，才能恢复为树",
        "若存在多个可行解（多条边在环上），需返回在输入数组中最后出现的边",
        "问题本质依赖于：动态维护连通性 + 环检测"
      ],
      "Objective Function": "在所有构成环的边中，找出在输入序列 edges 中最后出现的那条边，并返回",
      "Algorithmic Invariant": [
        "使用并查集（Union-Find）维护节点间的连通分量",
        "按输入顺序遍历每条边，尝试合并两个端点",
        "当遇到一条边的两个端点已在同一连通分量中时，说明这条边形成了环",
        "由于要求返回最后出现的合法边，因此第一次检测到成环的边即为答案（因为是按输入顺序处理，且只有一条多余边）",
        "并查集的合并与查找操作保持 O(α(n)) 复杂度，确保整体高效"
      ],
      "Transformable Parameters": {
        "n 的数量级": "3 <= n <= 1000（可扩展至 1e5，要求更优数据结构）",
        "图的类型": "无向图 → 可变形为有向图版本（如 DAG 加边）",
        "边的输入顺序": "是否要求返回最早/最晚出现的边（目标函数变化）",
        "输出形式": "返回单条边 → 返回所有可能删去的边（计数或枚举类问题）",
        "是否多组数据": "单次输入 → 多组测试用例",
        "是否在线": "静态图 → 动态加边/删边查询（在线连通性维护，如 LCT 或动态 DSU）",
        "环的数量": "恰好一个环 → 多余多条边（k 条冗余边），变为删除 k 条边使图变树"
      }
    }
  },
  {
    "title": "相似字符串组",
    "slug": "H6lPxb",
    "schema": {
      "Input Structure": [
        "给定一个字符串列表 strs[1..n]",
        "每个字符串 strs[i] 是长度为 m 的小写字母串",
        "所有字符串长度相等，且互为字母异位词（anagram）",
        "1 <= n <= 300, 1 <= m <= 300"
      ],
      "Core Constraint": [
        "两个字符串相似当且仅当它们相等，或可通过交换两个不同位置的字符变为相等",
        "相似关系具有传递性：若 A 与 B 相似，B 与 C 相似，则 A、B、C 属于同一组（连通分量）",
        "判断两字符串是否相似依赖于字符差异位置的数量：最多允许两个位置不同（此时可交换一次）"
      ],
      "Objective Function": "计算相似字符串形成的连通分量数量（即：有多少个相似字符串组）",
      "Algorithmic Invariant": [
        "使用并查集（Union-Find）维护字符串之间的连通性",
        "若两个字符串相似，则将其所属集合合并",
        "遍历所有字符串对 (i, j)，通过相似性判断建立连接",
        "最终统计并查集中根节点的个数即为组数",
        "相似性判定不变量：两字符串间不同字符的位置数等于 0 或 2"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可扩展至 1e3 或更高（影响 O(n^2) 判断对性能的要求）",
        "字符串长度 m": "可变化；若 m 很大但字符集小，可引入哈希优化",
        "是否有序": "输入顺序不影响结果（无序集合）",
        "是否循环": "不适用（非序列结构）",
        "是否多组输入": "可支持多测试用例",
        "是否在线": "可设计为动态添加字符串并实时维护组数",
        "相似定义可变": [
          "交换次数限制：1 次 → k 次",
          "编辑距离替代交换条件",
          "必须相邻交换等变形"
        ],
        "输出形式": [
          "仅组数",
          "输出每组成员",
          "最大/最小组大小"
        ],
        "数据约束放松": [
          "不再要求是字母异位词（增加预判剪枝复杂度）",
          "允许不同长度字符串"
        ]
      }
    }
  },
  {
    "title": "二叉搜索树迭代器",
    "slug": "kTOapQ",
    "schema": {
      "Input Structure": {
        "type": "binary_search_tree",
        "node_count_range": "[1, 1e5]",
        "value_domain": "[0, 1e6]",
        "traversal_order": "inorder",
        "initial_pointer_state": "less_than_min_element"
      },
      "Core Constraint": {
        "constraint": "中序遍历序列具有单调递增性（BST性质）",
        "memory_constraint": "只能使用 O(h) 额外空间，其中 h 是树高",
        "evolution_rule": "指针沿中序序列单向移动，不可回溯",
        "dependency": "当前可访问节点依赖于左子树完全展开的路径"
      },
      "Objective Function": {
        "goal": "迭代器模式下的中序遍历模拟",
        "operations": [
          "next(): 返回中序下一个元素",
          "hasNext(): 判断是否存在下一个元素"
        ],
        "behavior": "构造一次，逐次查询，支持多次 next 调用直至结束"
      },
      "Algorithmic Invariant": {
        "invariant": "维护一个栈，保存从根到当前最左未访问节点的路径",
        "stack_property": "栈顶为下一个将被访问的节点",
        "push_rule": "每次访问一个节点前，将其左链全部压入栈",
        "pop_rule": "弹出节点后，若其有右子树，则立即展开右子树的左链",
        "correctness_guarantee": "栈非空 ⇔ hasNext() 为 true；每次 next() 返回值严格递增"
      },
      "Transformable Parameters": {
        "tree_shape": [
          "balanced",
          "skewed_left",
          "skewed_right"
        ],
        "space_complexity_requirement": [
          "O(h)",
          "O(n)",
          "O(1) if Morris traversal allowed"
        ],
        "time_complexity_mode": [
          "amortized_O1_next",
          "worst_case_Oh_next"
        ],
        "data_streaming": "offline_initialization_online_query",
        "operation_set": [
          "next",
          "hasNext",
          "prev",
          "peek"
        ],
        "iterator_type": [
          "inorder",
          "preorder",
          "postorder",
          "reverse_inorder"
        ],
        "modification_support": [
          "read_only",
          "support_delete_current"
        ],
        "multi_instance": false,
        "online_node_insertion": false
      }
    }
  },
  {
    "title": "把二叉搜索树转换为累加树",
    "slug": "w6cpku",
    "schema": {
      "Input Structure": "二叉搜索树 root，其中每个节点包含整数值；节点数 n ∈ [0, 1e4]；节点值 ∈ [-1e4, 1e4]；所有值互不相同；左右子树均为二叉搜索树",
      "Core Constraint": "二叉搜索树的中序遍历具有严格单调递增性；大于等于某节点值的所有节点在树中分布于其自身、右子树以及父路径上的某些祖先及其右子树中；累加和可通过反向中序遍历（右→根→左）一次性确定",
      "Objective Function": "将每个节点的值替换为树中所有大于或等于该节点原值的节点值之和",
      "Algorithmic Invariant": "维护一个全局累加器 sum，按反向中序遍历顺序（右-根-左）访问节点：每访问一个节点，将其值加入 sum，然后将该节点的值更新为当前 sum；由于 BST 的结构性质，该遍历顺序保证了所有已访问节点值均 ≥ 当前节点原值，且未访问节点值均 < 当前节点原值，因此局部更新可保持全局正确性",
      "Transformable Parameters": [
        "是否允许重复值（若允许，则需定义‘大于等于’的处理方式）",
        "目标函数变化：改为小于等于该节点的所有节点值之和",
        "数据流化：支持动态插入/删除节点后在线更新（转化为可持久化或伸展树结构）",
        "输出形式变化：仅返回某个特定节点的转换后值，而非整棵树",
        "多组输入：批量处理多个 BST",
        "遍历方式约束：要求非递归实现（如使用显式栈）或 Morris 遍历以满足空间复杂度 O(1）",
        "值域扩展：节点值范围扩大至 long 类型，防止累加溢出"
      ]
    }
  },
  {
    "title": "序列重建",
    "slug": "ur2n8P",
    "schema": {
      "Input Structure": [
        "长度为 n 的整数数组 nums，其中 nums 是 [1, n] 范围内整数的排列",
        "二维整数数组 sequences，每个 sequences[i] 是 nums 的一个子序列",
        "1 <= n <= 10^4, 1 <= sum(sequences[i].length) <= 10^5"
      ],
      "Core Constraint": [
        "超序列必须包含所有 sequences[i] 作为子序列",
        "最短超序列的长度等于原排列 nums 的长度（即不能插入冗余元素）",
        "唯一性要求：任意两个不同的最短超序列不能同时满足所有 sequences 的子序列约束",
        "sequences 提供的是局部顺序约束，整体顺序由这些约束的传递闭包决定"
      ],
      "Objective Function": "判定 nums 是否是给定 sequences 的唯一最短超序列（布尔判定问题）",
      "Algorithmic Invariant": [
        "若 nums 是唯一最短超序列，则其相邻元素对 (nums[i], nums[i+1]) 必须在至少一个 sequence 中连续出现（即构成直接依赖）",
        "构造图模型：将 sequences 中每对连续元素视为有向边 u → v，形成 DAG",
        "唯一拓扑序的存在性等价于：该 DAG 存在唯一的拓扑排序，且与 nums 一致",
        "唯一拓扑序的充要条件是：任意相邻节点在拓扑序中的先后关系被某条边显式约束，且图中不存在分支选择（即每个入度>0的节点仅有唯一前驱可扩展）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": "1e4 可扩展至 1e5（限制算法复杂度在 O(n + m)）",
          "sequences 总长度": "sum(|sequences[i]|) <= 1e5，可改为离线批处理或在线流式输入"
        },
        "输入形式": {
          "是否保证 nums 是排列": "可变为任意数组，需先判断合法性",
          "sequences 是否提供重复边": "当前无重复，可放开为多重边（需去重处理）"
        },
        "约束条件": {
          "是否要求最短": "可变形为‘是否存在超序列’或‘求最长公共超序列’",
          "是否要求唯一": "可改为计数问题：有多少个最短超序列（模意义下）"
        },
        "图结构属性": {
          "是否有环": "当前隐含无环，可加入检测 cycle 的要求",
          "是否强连通": "可扩展为循环依赖场景"
        },
        "输出形式": {
          "返回值类型": "当前为 bool，可改为返回所有可能的最短超序列（构造题）或字典序最小的一个"
        },
        "动态性": {
          "是否在线": "sequences 可逐个到达，要求增量维护唯一性判定"
        }
      }
    }
  },
  {
    "title": "二叉搜索树中的中序后继",
    "slug": "P5rCT8",
    "schema": {
      "Input Structure": {
        "type": "Binary Tree",
        "specific_type": "Binary Search Tree (BST)",
        "node_structure": "TreeNode with val, left, right",
        "p_node": "Given node p in the tree",
        "constraints": {
          "n_nodes": "[1, 10^4]",
          "val_range": "[-10^5, 10^5]",
          "unique_values": true,
          "p_exists_in_tree": true
        }
      },
      "Core Constraint": {
        "inorder_successor_definition": "The inorder successor of node p is the node with the smallest value greater than p.val.",
        "BST_property": "For any node, all nodes in left subtree have smaller values, and all nodes in right subtree have larger values.",
        "structural_implication": "In-order traversal order can be determined using BST property without explicit traversal."
      },
      "Objective Function": {
        "goal": "Find the in-order successor of given node p",
        "output_type": "TreeNode or null",
        "function_type": "Search / Query"
      },
      "Algorithmic Invariant": {
        "search_strategy": "Navigate from root to target using BST ordering",
        "candidate_tracking": "Maintain a candidate successor (initially null), updating it whenever a node with value > p.val is encountered during descent.",
        "monotonicity": "As we traverse from root toward leaves, decisions are irreversible due to BST structure: if p.val < current.val, successor may be current or in left subtree; else go to right subtree.",
        "correctness_preservation": "At each step, either the current node is a potential successor, or the successor lies entirely within one subtree — no backtracking needed."
      },
      "Transformable Parameters": {
        "tree_structure": [
          "BST",
          "balanced/unbalanced",
          "degenerate_chain"
        ],
        "input_form": [
          "pointer_to_root_and_p",
          "serialized_array_like_leetcode"
        ],
        "query_type": [
          "single_query",
          "multiple_queries_on_same_tree"
        ],
        "data_flow": [
          "offline",
          "online_insertions_deletions"
        ],
        "relax_constraints": [
          "non-unique_values",
          "allow_duplicates_in_BST",
          "find_predecessor_instead"
        ],
        "objective_variants": [
          "find_kth_successor",
          "count_nodes_between_p_and_successor",
          "return_depth_of_successor"
        ],
        "extension_dimensions": [
          "support_parent_pointers",
          "without_using_parent_pointer",
          "iterative_only_requirement"
        ]
      }
    }
  },
  {
    "title": "火星词典",
    "slug": "Jf1JuT",
    "schema": {
      "Input Structure": [
        "给定一个字符串列表 words，长度为 n",
        "每个字符串 words[i] 由小写英文字母组成",
        "words 中的字符串按外星语言字典序升序排列",
        "1 <= words.length <= 100",
        "1 <= words[i].length <= 100"
      ],
      "Core Constraint": [
        "字符串之间的字典序关系隐含字符间的偏序关系",
        "若两个字符串 s 和 t 满足 s < t，则在第一个不同字符位置 c1 (来自 s) 和 c2 (来自 t)，有 c1 < c2",
        "若一个字符串是另一个的前缀且长度更短，则合法（如 'ab' < 'abc'）；反之若长串在前则矛盾（如 'abc' < 'ab' 不成立）",
        "所有字符的顺序必须形成有向无环图（DAG），否则无解"
      ],
      "Objective Function": [
        "还原一组满足所有字符串排序约束的字母递增顺序",
        "返回任意一种合法拓扑序",
        "若不存在合法顺序，返回空字符串 \"\""
      ],
      "Algorithmic Invariant": [
        "字符间的大小关系可建模为有向边：c1 → c2 表示 c1 在字母表中位于 c2 前",
        "通过遍历相邻单词对提取唯一有效的字符比较关系",
        "使用入度数组与队列维护当前可确定顺序的字符（入度为 0）",
        "拓扑排序过程中每步只选择一个可用节点，保证构造过程不破坏全局一致性",
        "若最终输出字符数少于实际出现字符数，则存在环，无解"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "words.length": "可变范围：1 ~ 10^4（扩展场景）",
          "words[i].length": "可变范围：1 ~ 1000（长字符串场景）"
        },
        "字符集": [
          "仅小写字母 → 可扩展至大写字母、数字或自定义符号集",
          "是否包含未出现在 words 中的额外字母（需补全？）"
        ],
        "输入形式": [
          "一次性离线输入 → 可改为在线流式添加单词并动态更新顺序",
          "是否多组独立测试数据"
        ],
        "约束条件": [
          "允许相同字符串？当前题目不允许（会破坏严格序）",
          "是否要求返回所有可能的合法顺序（计数 / 枚举）",
          "是否要求字典序最小的结果（优化目标变化）"
        ],
        "图结构变形": [
          "标准 DAG 拓扑排序 → 可加入权重变为带权排序",
          "是否允许循环依赖检测后修复（如删除最少边）"
        ],
        "输出形式": [
          "返回字符串形式的顺序 → 可改为返回邻接表 / 偏序关系集合"
        ]
      }
    }
  },
  {
    "title": "递增顺序搜索树",
    "slug": "NYBBNL",
    "schema": {
      "Input Structure": "一棵二叉搜索树，节点数 n ∈ [1, 100]，每个节点值为整数且满足 0 <= Node.val <= 1000",
      "Core Constraint": "二叉搜索树的中序遍历具有严格单调递增性；目标结构要求所有节点仅保留右子树，形成链状结构",
      "Objective Function": "构造一棵新的递增顺序搜索树，使得中序遍历顺序不变，且最左边的节点为根，每个节点只有右子节点",
      "Algorithmic Invariant": "在中序遍历过程中，当前访问节点应接在前一个遍历节点的右侧；维护一个伪头节点和尾指针，确保链式结构的正确构建；遍历顺序与构造顺序一致，保证局部构造不影响全局有序性",
      "Transformable Parameters": {
        "数据规模": "n 的范围可调整（如扩展至 1e5，在线处理）",
        "输入形式": "是否直接给出中序序列而非树结构（结构化输入变化）",
        "输出形式": "是否要求原地修改树结构或返回新树",
        "是否多组数据": "支持批量转换多个 BST",
        "树类型变体": "是否推广至平衡 BST、AVL 或允许重复值的 BST",
        "遍历方式": "是否改为前序/后序重构（目标函数变化导致结构不同）"
      }
    }
  },
  {
    "title": "课程表 II",
    "slug": "QA2IGt",
    "schema": {
      "Input Structure": [
        "整数 numCourses，表示课程总数，记为 n（n ≥ 1）",
        "二维数组 prerequisites，每个元素为 [a_i, b_i]，表示课程 a_i 必须在课程 b_i 之后学习",
        "该结构构成一个有向图：节点为课程 0 到 n-1，边 b_i → a_i 表示先修关系",
        "输入隐含一个有向无环图（DAG）或可能含环的图"
      ],
      "Core Constraint": [
        "课程顺序必须满足所有给定的先修依赖关系",
        "若存在循环依赖（如 a→b 且 b→a），则无法完成所有课程",
        "每个课程只能在其所有前驱课程完成后才能开始",
        "问题本质是判断图是否为有向无环图（DAG），并在是的情况下求其拓扑排序"
      ],
      "Objective Function": [
        "构造一个长度为 numCourses 的数组，表示合法的修课顺序",
        "若存在多个合法顺序，返回任意一种即可",
        "若不存在合法顺序（即图中存在环），返回空数组",
        "目标函数类型：构造方案 + 判定是否存在"
      ],
      "Algorithmic Invariant": [
        "拓扑排序过程中，始终维护入度为 0 的节点集合（可立即修读的课程）",
        "每次从入度为 0 的节点中选择一个加入结果序列，并将其所有后继节点的入度减 1",
        "该过程不会破坏未处理部分的依赖结构正确性",
        "使用 Kahn 算法或 DFS 栈序（逆后序）均可保证：当节点出栈/入队时，其所有前驱已被处理",
        "最终序列长度等于 numCourses 当且仅当图中无环"
      ],
      "Transformable Parameters": [
        "numCourses 的数量级：当前 ≤ 2000，可变更为更大规模以限制算法复杂度（如要求 O(n + m)）",
        "prerequisites 是否允许重复边或自环（当前不允许）",
        "是否多组测试数据",
        "是否在线添加先修关系（动态拓扑排序）",
        "是否要求输出所有可能的修课顺序（计数或枚举）",
        "是否要求字典序最小的修课顺序（改变选择策略）",
        "图的存储形式：边列表 vs 邻接表 vs 邻接矩阵",
        "是否将问题转化为最小化并行修课轮数（分层拓扑排序）"
      ]
    }
  },
  {
    "title": "二叉树中的最大路径和",
    "slug": "jC7MId",
    "schema": {
      "Input Structure": "二叉树的根节点 root；每个节点具有整数值 val；节点数 n ∈ [1, 3×10⁴]；-1000 ≤ Node.val ≤ 1000",
      "Core Constraint": "路径定义为树中任意节点出发，沿父-子连接到达任意节点的序列，同一节点至多出现一次；路径不必经过根；路径和由路径上所有节点值累加得到；路径结构受树形拓扑约束，分支不可重复访问",
      "Objective Function": "求所有可能路径中的最大路径和（最大化）",
      "Algorithmic Invariant": "对每个节点，递归计算其左右子树能提供的最大单向路径和（非环形延伸）；以该节点为转折点的完整路径和 = 左子树贡献 + 右子树贡献 + 当前节点值；维护全局最优解的同时，向上返回仅含当前节点及其一侧子树的最大路径（保证路径连续且可延伸）",
      "Transformable Parameters": [
        "节点值域范围：如扩展至负数密集或全正情况",
        "树的形态约束：是否为平衡树、完全二叉树、链状退化等",
        "路径限制条件：是否必须包含叶节点 / 根节点",
        "路径长度限制：如最多 k 个节点",
        "输出形式变化：返回路径方案而非仅和值",
        "目标函数变换：最小路径和 / 最接近零的路径和 / 路径和等于目标值的存在性判定",
        "结构维度扩展：从二叉树推广至多叉树",
        "动态更新支持：支持插入/删除节点后的在线查询"
      ]
    }
  },
  {
    "title": "矩阵中的最长递增路径",
    "slug": "fpTFWP",
    "schema": {
      "Input Structure": [
        "二维整数矩阵 matrix[1..m][1..n]",
        "元素值为非负整数（实际可为任意整数，但无重复单调性限制）",
        "每个位置可向上下左右四个方向移动",
        "不允许对角线移动或越界"
      ],
      "Core Constraint": [
        "路径必须严格递增：从 matrix[i][j] 移动到相邻格子时，目标值必须大于当前值",
        "图结构隐式由矩阵和递增边构成，形成有向无环图（DAG）——因严格递增保证无环",
        "局部最优依赖全局拓扑顺序：长路径必然包含短路径的延伸"
      ],
      "Objective Function": "计算矩阵中所有可能路径中的最长递增路径的长度（最大步数）",
      "Algorithmic Invariant": [
        "记忆化搜索状态：dp[i][j] 表示从 (i,j) 出发的最长递增路径长度，一旦确定不会改变",
        "拓扑性质：若存在边 (i,j) → (ni,nj)，则 dp[i][j] > dp[ni][nj] 不成立；反向更新满足 DAG 动态规划顺序",
        "状态转移不变量：dp[i][j] = 1 + max(dp[ni][nj]) 对所有满足 matrix[ni][nj] > matrix[i][j] 的邻居成立",
        "搜索过程中已计算节点不再重复计算，保证复杂度可控"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": [
            "1 <= m, n <= 200",
            "可扩展至 1000 或在线场景"
          ],
          "值域范围": [
            "0 <= matrix[i][j] <= 2^31 - 1",
            "可限制为小整数域或加入负数"
          ]
        },
        "图结构变形": [
          "允许对角线移动",
          "允许环绕（环形矩阵）",
          "三维立方体网格扩展"
        ],
        "路径约束变化": [
          "非严格递增 → 严格递减 / 非递减 / 峰值路径",
          "加入最多k次下降机会（带权回退）"
        ],
        "目标函数变换": [
          "计数最长路径的数量",
          "构造字典序最小的最长路径",
          "是否存在长度 ≥ K 的递增路径（判定问题）"
        ],
        "输入形式": [
          "静态一次性输入",
          "动态修改单点值后查询（支持更新操作）",
          "多组测试用例",
          "在线流式生成矩阵块"
        ],
        "算法优化空间": [
          "是否允许 O(mn log(mn)) 解法（排序+DP）",
          "是否要求纯 DFS+memo 或拓扑排序实现"
        ]
      }
    }
  },
  {
    "title": "路径总和 III",
    "slug": "6eUYwP",
    "schema": {
      "Input Structure": [
        "二叉树的根节点 root，类型为 TreeNode",
        "每个节点包含整数值 val",
        "节点数量范围 [0, 1000]",
        "节点值域：-10^9 <= Node.val <= 10^9",
        "目标和 targetSum ∈ [-1000, 1000]"
      ],
      "Core Constraint": [
        "路径方向必须是向下的（从父节点到子节点）",
        "路径不需要从根开始，也不需要在叶子结束",
        "同一路径上不能向上或横向移动",
        "不同路径可以重叠"
      ],
      "Objective Function": "计数：求所有节点值之和等于 targetSum 的向下路径的数目",
      "Algorithmic Invariant": [
        "前缀和性质：从根到当前节点路径上的前缀和 S，若存在祖先节点处前缀和为 S - targetSum，则该段路径和为 targetSum",
        "哈希表记录从根到当前节点路径上各前缀和的出现次数",
        "递归遍历中维护当前路径前缀和，进入子树前更新哈希表，退出时恢复（回溯）",
        "局部状态一致性：每层递归调用保持前缀和与哈希表的一致性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "[0, 1000]",
            "可扩展至 1e5（需优化）"
          ],
          "值域": [
            "Node.val: [-1e9, 1e9]",
            "targetSum: [-1000, 1000]"
          ]
        },
        "输入形式": [
          "单组输入 / 多组测试数据",
          "树以数组形式给出（如层序遍历）或指针结构"
        ],
        "是否在线": false,
        "路径约束变化": [
          "必须从根开始",
          "必须终止于叶子",
          "允许非向下路径（如任意两点间简单路径）"
        ],
        "目标函数变换": [
          "判定是否存在一条路径",
          "求最长/最短满足条件的路径长度",
          "求路径的最大和（给定 targetSum 下界）"
        ],
        "操作类型扩展": [
          "支持动态插入/删除子树",
          "支持修改节点值后重新查询"
        ],
        "空间限制": [
          "不允许使用哈希表（强制 O(1) 空间解法不存在，但可限制为 O(h)）"
        ]
      }
    }
  },
  {
    "title": "求根节点到叶节点数字之和",
    "slug": "3Etpl5",
    "schema": {
      "Input Structure": "二叉树的根节点 root；每个节点包含一个整数值 val ∈ [0, 9]；树中节点数 n ∈ [1, 1000]，树深度 ≤ 10",
      "Core Constraint": "每条从根到叶的路径唯一对应一个数字，该数字由路径上节点值按顺序构成；路径之间相互独立，且所有叶子必须被遍历以保证完整性",
      "Objective Function": "计算所有根到叶路径所表示数字的总和（求和）",
      "Algorithmic Invariant": "在深度优先搜索过程中，当前路径对应的数值可通过父节点传递并线性更新：cur_sum = cur_sum * 10 + node.val；到达叶节点时，该路径贡献值确定且可累加至全局结果",
      "Transformable Parameters": {
        "值域范围": "Node.val 是否扩展为 [0, k] 或支持负数",
        "树结构变化": "是否推广至多叉树、N 叉树或 DAG",
        "目标函数变换": "改为求最大路径数字、最小路径数字、路径数字计数、或是否存在某特定数字",
        "输入形式": "是否在线构建树（流式节点插入）、是否多组测试数据",
        "约束条件": "是否限制路径长度、是否允许中间节点剪枝（如遇到 0 不继续）",
        "输出形式": "是否要求输出每条路径对应的数字列表",
        "数据规模": "树深度是否扩大（突破 10），节点数是否达到 1e5 量级（影响递归可行性）"
      }
    }
  },
  {
    "title": "除法求值",
    "slug": "vlzXQL",
    "schema": {
      "Input Structure": [
        "图结构 G = (V, E)，其中 V 是变量字符串集合，E 是有向带权边集",
        "每条边 e_i: u → v 对应 equations[i] = [A_i, B_i]，权重 w(e_i) = values[i] 表示 A_i / B_i = values[i]",
        "查询数组 queries，每个 query_j = [C_j, D_j] 要求计算 C_j / D_j",
        "所有变量名是由小写字母和数字组成的非空字符串"
      ],
      "Core Constraint": [
        "等式关系具有传递性：若 a/b = x, b/c = y，则 a/c = x*y",
        "逆向关系成立：若 a/b = x，则 b/a = 1/x",
        "图中任意两节点间的路径权重乘积唯一（无矛盾）",
        "若两个变量不在同一连通分量内，则无法确定其比值"
      ],
      "Objective Function": [
        "对每个查询 [C_j, D_j]，输出 C_j / D_j 的实数值",
        "若 C_j 或 D_j 未在已知变量中出现，或二者不连通，则输出 -1.0",
        "目标函数为多组判定 + 数值推导的混合类型：存在性判断 + 值构造"
      ],
      "Algorithmic Invariant": [
        "使用带权并查集时：每个节点维护到根节点的相对权重 ratio[root]，合并与查询时保持路径压缩中的权值一致性",
        "使用 BFS/DFS 时：从起点出发搜索终点，路径上边权累积乘积不变且与路径无关（因无矛盾）",
        "图的连通性与权值可分解性构成解法正确性的基础：只要连通，就存在唯一解"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "equations.length": "1 <= n <= 20（原题较小，可扩展至 1e4+ 以要求高效算法）",
          "queries.length": "1 <= q <= 20（可改为在线查询或批量离线）"
        },
        "图结构形式": [
          "是否允许环形依赖（当前允许，但无矛盾）",
          "是否为 DAG / 树 / 森林",
          "是否加入删除操作（动态图）"
        ],
        "输入输出形式": [
          "是否要求返回所有可能路径的结果列表（而非单一值）",
          "是否支持模糊匹配变量名（如正则）",
          "是否输出推导路径"
        ],
        "值域特性": [
          "values[i] 是否可为负数（引入符号不确定性）",
          "是否包含零值（导致除零风险，需特殊处理）"
        ],
        "查询模式": [
          "离线批量查询 → 在线实时查询",
          "单点查询 → 区间比值聚合查询（如 a1/a2 * a2/a3 * ...）"
        ],
        "是否多组数据": false,
        "是否循环": false,
        "是否有序": false
      }
    }
  },
  {
    "title": "二叉树的序列化与反序列化",
    "slug": "h54YBf",
    "schema": {
      "Input Structure": [
        "二叉树的根节点 root",
        "树中节点数 n ∈ [0, 10^4]",
        "每个节点的值 val ∈ [-1000, 1000]",
        "输入形式为指针结构的二叉树（非数组表示）",
        "输出要求为字符串（序列化）或重建后的树结构（反序列化）"
      ],
      "Core Constraint": [
        "序列化过程必须将树结构完整编码为可传输的线性字符串",
        "反序列化过程必须能唯一重构原始树结构",
        "编码方式无需与 LeetCode 格式一致，但需自洽可逆",
        "树的拓扑结构信息（如空节点位置）必须被显式或隐式保留"
      ],
      "Objective Function": [
        "设计两个函数：serialize 和 deserialize",
        "目标是实现可逆映射：Tree → String → Tree'",
        "保证对于任意合法输入树 T，有 deserialize(serialize(T)) == T",
        "不追求压缩率或最优长度，只要求正确性和可行性"
      ],
      "Algorithmic Invariant": [
        "遍历顺序的一致性：序列化与反序列化使用相同的遍历策略（如前序、层序等）",
        "空节点标记的完整性：空子树通过特殊符号（如 'null'）标记以终止递归",
        "构造顺序的同步性：反序列化时按序列化产生的顺序逐个恢复节点并连接",
        "状态指针或队列的推进与树结构展开保持同步"
      ],
      "Transformable Parameters": {
        "数据规模": "n ∈ [0, 10^4]",
        "值域范围": "val ∈ [-1000, 1000]",
        "是否有序": false,
        "是否完全二叉树": false,
        "是否平衡": false,
        "输入形式": "原始树指针 / 字符串",
        "输出形式": "字符串 / 重建树",
        "是否多组数据": false,
        "是否在线": false,
        "序列化格式约束": [
          "无强制格式（可自由设计）",
          "可变体包括：前序+null标记、层序BFS、括号编码、后缀表达式等"
        ],
        "是否支持修改操作": false,
        "是否循环结构": false
      }
    }
  },
  {
    "title": "所有可能的路径",
    "slug": "bP4bmD",
    "schema": {
      "Input Structure": [
        "有向无环图 (DAG) 表示为二维数组 graph[0..n-1]",
        "graph[i] 是节点 i 的出边邻居列表",
        "n 个节点编号从 0 到 n-1",
        "2 <= n <= 15",
        "图结构隐式给出，无需建图"
      ],
      "Core Constraint": [
        "图是有向无环的（DAG），保证无环意味着搜索不会陷入无限递归",
        "路径必须从节点 0 开始，到节点 n-1 结束",
        "只能沿有向边前进，不能反向",
        "所有路径均为简单路径（无重复节点）"
      ],
      "Objective Function": [
        "枚举所有从节点 0 到节点 n-1 的路径",
        "目标是构造并输出所有完整路径方案",
        "不要求路径顺序"
      ],
      "Algorithmic Invariant": [
        "深度优先搜索（DFS）过程中，当前路径 path 的前缀始终是从 0 出发的有效路径",
        "回溯时维护路径状态的一致性：进入节点时加入 path，退出时弹出",
        "由于是 DAG，无需 visited 数组判环，拓扑序天然保证安全性",
        "每个节点的邻接表遍历完成后，其作为中间节点的所有路径分支已被完全探索"
      ],
      "Transformable Parameters": [
        "n 的数量级：可扩展至更大规模（如 n <= 1e5）以要求记忆化或动态规划优化",
        "是否允许环：若取消 DAG 约束，则需引入 visited 控制或剪枝策略",
        "是否要求字典序输出：增加排序约束",
        "是否仅计数路径总数：将构造问题变为计数问题（DP 可解）",
        "是否多源多汇：改为从多个起点到多个终点",
        "是否在线查询：支持动态加边后重新查询路径",
        "输入形式：改为边列表或邻接矩阵输入",
        "是否限制路径长度：加入最长/最短路径约束"
      ]
    }
  },
  {
    "title": "打开转盘锁",
    "slug": "zlDJc7",
    "schema": {
      "Input Structure": [
        "四维环形数组（每个维度长度为10，对应数字 '0'-'9'）",
        "初始状态为 '0000'",
        "目标状态为字符串 target（长度为4）",
        "死亡状态集合 deadends：字符串列表，每个字符串表示一个禁用状态"
      ],
      "Core Constraint": [
        "状态空间是离散的、有限的（共 10^4 = 10000 种状态）",
        "每次操作只能改变一个拨轮的一位数字（±1 mod 10）",
        "禁止进入 deadends 中的任意状态",
        "问题具有无权图上的最短路径结构：从起点到终点避开障碍的最少步数"
      ],
      "Objective Function": "求从初始状态 '0000' 到目标状态 target 的最小旋转次数；若不可达，返回 -1",
      "Algorithmic Invariant": [
        "BFS 层序扩展保证首次到达目标时路径最短",
        "已访问状态（包括 deadends）永久标记，避免重复访问",
        "每个状态最多有 8 个邻居（每位 ±1，共 4 位 × 2 = 8）",
        "状态转移对称且可逆，但存在单向阻塞（deadends 导致不可回退）"
      ],
      "Transformable Parameters": {
        "n_dimensions": 4,
        "per_dimension_size": 10,
        "initial_state": "'0000'",
        "target_form": "固定字符串 / 正则模式 / 多目标集合",
        "deadends": {
          "cardinality": "1 <= |deadends| <= 500",
          "structure": "显式列表 / 隐式规则生成（如正则排除）",
          "includes_initial": "是否包含 '0000' 影响可行性"
        },
        "operation_model": [
          "单步旋转一位",
          "是否允许批量旋转",
          "代价是否统一（可变为加权）"
        ],
        "input_mode": "一次性输入 / 在线查询多个 target",
        "output_type": "最小步数 / 路径构造 / 方案计数",
        "state_space_topology": "环形（mod 10）/ 线性边界（不可绕）",
        "multi_source_target": "多源多汇 / 单源多目标",
        "dynamic_obstacles": "deadends 是否随时间变化"
      }
    }
  },
  {
    "title": "二叉树剪枝",
    "slug": "pOCWxh",
    "schema": {
      "Input Structure": "二叉树 root，其中每个节点的值为 0 或 1；节点数 n ∈ [1, 200]",
      "Core Constraint": "一个子树可被剪除当且仅当其所有节点（包括自身和后代）的值均为 0；剪枝操作具有自底向上依赖性：父节点是否保留依赖于子树是否已被完全剪除",
      "Objective Function": "返回经过剪除所有不包含 1 的子树后的新二叉树根节点",
      "Algorithmic Invariant": "采用后序遍历（左右根）递归处理：当前节点的保留决策基于其左右子树是否均被剪除且自身值为 0；若子树返回 null，则表示该子树已被完全剪除；递归结构保持局部最优解合并为全局最优解",
      "Transformable Parameters": {
        "值域扩展": "节点值是否可为任意整数，判定条件改为非正 / 非负子树",
        "剪枝条件变化": "改为剪除全为 1 的子树，或满足其他谓词的子树",
        "目标函数变形": "统计被剪除的节点数量，而非返回树结构",
        "输入形式变化": "多叉树替代二叉树",
        "在线处理": "支持动态插入/删除节点后的实时剪枝",
        "数据规模": "节点数从 [1,200] 扩展至 1e5，要求非递归实现",
        "是否多组数据": "批量处理多个独立二叉树"
      }
    }
  },
  {
    "title": "单词接龙",
    "slug": "om3reC",
    "schema": "{\n  \"Input Structure\": [\n    \"字符串 beginWord（长度为 L，1 ≤ L ≤ 10）\",\n    \"字符串 endWord（长度等于 beginWord）\",\n    \"字符串列表 wordList，其中每个字符串长度均为 L\",\n    \"所有字符串由小写英文字母组成\",\n    \"beginWord != endWord\",\n    \"wordList 中所有字符串互不相同\"\n  ],\n  \"Core Constraint\": [\n    \"每次转换只能改变一个字符\",\n    \"转换序列中的中间单词必须存在于 wordList 中\",\n    \"序列的第一个单词是 beginWord（不一定在 wordList 中）\",\n    \"序列的最后一个单词是 endWord（必须在 wordList 中才能构成有效路径）\",\n    \"图结构隐式构建：每个单词是一个节点，若两单词仅有一个字符不同，则存在无向边\"\n  ],\n  \"Objective Function\": \"计算从 beginWord 到 endWord 的最短转换序列中包含的单词数目（即路径长度，按节点数计）。若不存在这样的序列，返回 0。\",\n  \"Algorithmic Invariant\": [\n    \"使用 BFS 按层扩展可保证首次到达 endWord 时路径最短\",\n    \"每一层代表从起点出发经过 k 步可达的所有单词集合\",\n    \"已访问过的单词无需再次处理（避免环路与重复计算）\",\n    \"状态转移通过枚举当前单词的每一位并替换为 a-z 来生成邻居节点\",\n    \"无需显式建图，可通过哈希集合快速判断邻居是否在字典中\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n = |wordList| ≤ 5000\",\n      \"L = |word| ≤ 10\",\n      \"字母表大小：26（小写英文）\"\n    },\n    \"输入形式\": \"离线一次性输入，单组数据\",\n    \"是否有序\": \"wordList 无序，但可用哈希集合存储以支持 O(1) 查询\",\n    \"是否循环\": false,\n    \"是否在线\": false,\n    \"是否允许多次修改\": false,\n    \"目标函数变体\": [\n      \"改为输出具体路径（构造方案）\",\n      \"求所有最短路径的数量（计数型）\",\n      \"允许改变最多 K 个字符（约束放宽）\",\n      \"转换需满足额外语义约束（如必须是合法英文单词链）\"\n    ],\n    \"图结构变形\": [\n      \"二维网格上的词梯问题\",\n      \"单词间编辑距离为 2 的也可连接（邻接规则变化）\",\n      \"有向转换：某些变换不可逆\"\n    ],\n    \"优化方向\": [\n      \"双向 BFS 加速搜索\",\n      \"A* 启发式搜索（若定义与 endWord 的差异作为启发函数）\"\n    ]\n  }\n}"
  },
  {
    "title": "二叉树的右视图",
    "slug": "WNC0Lk",
    "schema": {
      "Input Structure": "二叉树的根节点 root，其中每个节点包含整数值和左右子树指针；节点数范围 [0, 100]，节点值域 [-100, 100]",
      "Core Constraint": "同一层中，右侧优先可见；若某层存在多个节点，则最右侧的节点遮挡其左侧所有节点",
      "Objective Function": "返回从右侧观察时，每一层最后被看到的节点值列表（按从顶到底顺序）",
      "Algorithmic Invariant": "使用层序遍历（BFS），每层仅保留最后一个非空节点的值；或使用 DFS 按根-右-左顺序首次进入新深度时记录该节点值（保证最右优先访问）",
      "Transformable Parameters": [
        "树是否为空（边界情况）",
        "节点值域范围：[-100, 100] → 可扩展至任意整数",
        "数据规模：n ≤ 100 → 可放大至 1e5（影响解法选择）",
        "是否多组测试数据",
        "是否在线构建树并实时查询右视图",
        "目标函数变化：改为左视图 / 顶部视图 / 锯齿形视图",
        "输入形式：层序数组输入 → 前序+中序构造 → 边列表建树",
        "是否允许重复值",
        "是否为 N 叉树扩展"
      ]
    }
  },
  {
    "title": "找树左下角的值",
    "slug": "LwUNpT",
    "schema": {
      "Input Structure": "二叉树的根节点 root；树中每个节点具有左子节点、右子节点和整数值 val；节点数 n ∈ [1, 10^4]；-2^31 <= Node.val <= 2^31 - 1",
      "Core Constraint": "最底层指深度最大；若多层存在相同最大深度，则取最左侧节点；遍历顺序需保证在达到最大深度时优先访问左子树",
      "Objective Function": "找出并返回二叉树中最底层最左边节点的值",
      "Algorithmic Invariant": "使用层级优先或深度优先搜索，维护当前已知最大深度与对应最左值；当进入新深度时，首次到达该深度的节点即为该层最左节点；后续同深度节点不更新答案，确保‘最左’性质不变",
      "Transformable Parameters": [
        "是否要求返回节点而非值",
        "是否多解需输出所有最底层最左候选",
        "输入形式：层序数组表示 / 指针结构 / 在线建树",
        "是否允许空树（增加边界判断）",
        "目标变换：最底层最右边 / 最顶层最左 / 第K层最左",
        "数据规模：n 是否扩展至 10^5 或更高（影响递归可行性）",
        "是否在线查询动态插入后的最底层最左值"
      ]
    }
  },
  {
    "title": "在每个树行中找最大值",
    "slug": "hPov7L",
    "schema": {
      "Input Structure": "二叉树的根节点 root，节点数范围 [0, 10^4]，每个节点值 ∈ [-2^31, 2^31 - 1]",
      "Core Constraint": "每一层的节点构成一个横向层级结构，同层节点之间无直接连接，但可通过广度优先遍历一次性获取；每层最大值仅依赖于该层所有节点的值，不依赖父层或子层",
      "Objective Function": "找出二叉树中每一层的最大值，并按层序返回一个整数列表",
      "Algorithmic Invariant": "使用队列进行层序遍历（BFS），每层遍历开始时记录当前层节点数量，确保该层所有节点被处理且仅被处理一次；维护每层局部最大值，在进入下一层前更新结果列表",
      "Transformable Parameters": [
        "树是否为空（边界情况）",
        "节点值域范围（是否有负数、极大值）",
        "是否多组测试数据",
        "是否要求返回最大值对应节点而非数值",
        "是否改为求每层最小值 / 平均值 / 众数（目标函数变换）",
        "是否改为树中每条路径上的最大值（结构变换）",
        "输入形式：先序序列+空标记（如数组表示） vs 指针结构",
        "是否支持在线插入/删除后动态查询每层最大值（数据流化）",
        "树的类型变化：N叉树 / 完全二叉树 / 二叉搜索树"
      ]
    }
  },
  {
    "title": "01 矩阵",
    "slug": "2bCMpM",
    "schema": {
      "Input Structure": [
        "二维矩阵 mat[1..m][1..n]",
        "每个元素 mat[i][j] ∈ {0, 1}",
        "m >= 1, n >= 1",
        "1 <= m * n <= 10^4",
        "至少存在一个 0"
      ],
      "Core Constraint": [
        "距离定义在四连通相邻格子之间（上下左右），每步距离为 1",
        "每个位置的答案取决于其到最近的 0 的最短路径长度",
        "局部最小无法确定全局最优，需传播已知信息",
        "从所有 0 同时开始扩散可保证首次到达即最短"
      ],
      "Objective Function": "对每个位置 (i, j)，计算其到最近的 0 的曼哈顿级最短距离，构造相同大小的距离矩阵",
      "Algorithmic Invariant": [
        "多源 BFS：将所有值为 0 的位置作为初始队列，距离为 0",
        "一旦某个 1 被访问，则其距离被确定（第一次到达即最短）",
        "状态按层扩展，每轮处理同一距离的所有节点，保持单调递增性",
        "未访问的位置初始距离设为无穷大，逐步被更新"
      ],
      "Transformable Parameters": {
        "n 的数量级": "m * n <= 10^4（当前离线小规模）；可扩展至 10^6 并要求优化空间",
        "值域变化": "mat[i][j] 可推广为任意整数，求到最近目标值的距离",
        "目标值设定": "从固定 0 变为动态查询某数值 x 的最近距离",
        "邻接方式": "四连通 → 八连通",
        "是否在线": "静态输入 → 支持单点修改后重新查询整个矩阵",
        "输出形式": "仅输出最大距离 / 输出特定位置距离 / 构造方案路径",
        "维度扩展": "2D 矩阵 → 3D 立方体或更高维网格",
        "权重图变形": "边权非均匀（不同方向代价不同）"
      }
    }
  },
  {
    "title": "完全二叉树插入器",
    "slug": "NaqhDT",
    "schema": {
      "Input Structure": [
        "完全二叉树的根节点 root，初始时为包含 1 到 1000 个节点的完全二叉树",
        "每个节点类型为 TreeNode，具有 val、left、right 字段",
        "后续插入值 v ∈ [0, 5000]"
      ],
      "Core Constraint": [
        "树始终保持完全二叉树结构：即除最后一层外，所有层完全填充；最后一层节点尽可能靠左",
        "新节点必须插入到第一个缺失左子或右子的位置，按层序顺序（从上到下、从左到右）"
      ],
      "Objective Function": [
        "初始化数据结构 CBTInserter(root)",
        "insert(v)：插入值为 v 的新节点，保持完全二叉树性质，返回新节点父节点的值",
        "get_root()：返回当前树的根节点"
      ],
      "Algorithmic Invariant": [
        "使用队列维护所有「尚未填满两个子节点」的节点，按层序排列",
        "队首节点为下一个可插入父节点：若其左子为空则插左；否则插右并将其从候选队列移除",
        "每次插入后，新节点若存在空位（即成为非满节点），则加入队列尾部",
        "该队列维护了层序遍历中所有待填充节点，保证插入位置正确且 O(1) 可得"
      ],
      "Transformable Parameters": [
        "初始树节点数范围：[1, 1000]",
        "insert 操作调用次数上限：10000",
        "节点值域：[0, 5000]",
        "是否允许多组测试数据",
        "是否支持删除或修改操作（当前不支持）",
        "是否在线构造（是，逐次插入）",
        "输入形式：序列化数组表示初始树（如 [1,2,3,4,5,6]）",
        "输出形式：插入返回父节点值，get_root 返回树结构"
      ]
    }
  },
  {
    "title": "判断二分图",
    "slug": "vEAB3K",
    "schema": {
      "Input Structure": {
        "type": "undirected graph",
        "representation": "adjacency list",
        "node_count": "n",
        "node_ids": "0 to n-1",
        "constraints": [
          "no self-loops",
          "no parallel edges",
          "symmetric adjacency: if v in graph[u], then u in graph[v]",
          "graph may be disconnected"
        ]
      },
      "Core Constraint": {
        "description": "The graph must allow a partition of nodes into two disjoint sets A and B such that every edge connects a node in A to a node in B. This is equivalent to the absence of odd-length cycles.",
        "implication": "Each connected component must be bipartite independently, and coloring consistency must be maintained across BFS/DFS traversal."
      },
      "Objective Function": {
        "type": "decision problem",
        "goal": "determine whether the given undirected graph is bipartite"
      },
      "Algorithmic Invariant": {
        "method": "BFS/DFS with two-coloring",
        "invariants": [
          "Each node is assigned one of two colors (e.g., 0 or 1).",
          "During traversal, adjacent nodes must have opposite colors.",
          "If a neighbor is already colored and has the same color as the current node, the graph is not bipartite.",
          "Color assignment is consistent within each connected component.",
          "Unvisited components are processed independently without affecting global validity."
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n_size",
            "description": "number of nodes",
            "range": "1 <= n <= 100",
            "can_scale": true,
            "possible_values": "small (<=100), medium (<=1e4), large (<=1e5)"
          },
          {
            "name": "connectivity",
            "description": "whether the graph is connected or disconnected",
            "options": [
              "connected",
              "disconnected"
            ],
            "default": "disconnected"
          },
          {
            "name": "input_format",
            "description": "graph representation",
            "options": [
              "adjacency list",
              "edge list",
              "adjacency matrix"
            ]
          },
          {
            "name": "query_type",
            "description": "single instance vs. multiple test cases",
            "options": [
              "single",
              "multiple"
            ]
          },
          {
            "name": "online_offline",
            "description": "processing mode",
            "options": [
              "offline",
              "online (dynamic edge addition)"
            ]
          },
          {
            "name": "output_detail",
            "description": "what to return",
            "options": [
              "boolean (is bipartite)",
              "partition sets A and B",
              "first violating edge"
            ]
          },
          {
            "name": "variation",
            "description": "related constraints",
            "options": [
              "check for k-partiteness (k > 2)",
              "allow self-loops / multi-edges",
              "directed bipartite matching condition"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "最近的请求次数",
    "slug": "H8086Q",
    "schema": {
      "Input Structure": "一维时间序列 T[1..n]，其中每个元素 t_i 表示一个请求发生的时间戳（单位：毫秒），t_i ∈ [1, 10^9]；输入为在线流式数据，每次调用 ping(t) 添加一个新时间戳，且保证 t 严格递增。",
      "Core Constraint": "需要统计在当前时间 t 的滑动窗口 [t - 3000, t] 内的有效请求数；由于时间戳严格递增，已离开窗口的历史请求不会再次进入，因此可被永久丢弃。",
      "Objective Function": "返回在过去 3000 毫秒内（含当前请求）发生的请求数量，即满足 t_i ≥ t - 3000 的请求数。",
      "Algorithmic Invariant": "使用队列维护滑动窗口内的有效请求时间戳；左端指针（队首）可单调出队，因后续查询的时间窗口只会右移，队首若小于当前下界 t - 3000 则永远无效；新元素从队尾入队，队列长度即为答案。",
      "Transformable Parameters": [
        "滑动窗口大小 W（原题为 3000），可变参数如 W=1000 或 W=6000",
        "时间戳是否仍保持单调递增（若取消该约束，则需离线处理或使用树状数组）",
        "是否允许多个请求共享同一时间戳",
        "值域范围：t 的上限（影响是否可用数组索引优化）",
        "是否支持删除操作（如 cancel(t)）",
        "是否要求返回具体请求列表而非仅计数",
        "是否多组独立测试实例",
        "是否在线输入（本题是典型在线模型）"
      ]
    }
  },
  {
    "title": "数据流中的移动平均值",
    "slug": "qIsx9U",
    "schema": {
      "Input Structure": [
        "数据流序列 val_stream = [val_1, val_2, ..., val_n]",
        "窗口大小 size ∈ ℤ⁺, 1 <= size <= 1000",
        "每个元素 val ∈ ℤ, -1e5 <= val <= 1e5",
        "输入形式为在线调用 next(val)，每次添加一个整数"
      ],
      "Core Constraint": [
        "滑动窗口仅保留最近的 size 个元素",
        "当元素数量不足 size 时，计算前缀平均值",
        "超出 size 的旧元素必须被移除（先进先出）",
        "需要在 O(1) 时间内完成每次平均值计算"
      ],
      "Objective Function": [
        "返回当前滑动窗口内所有数字的平均值",
        "目标函数类型：构造性数值输出（浮点数）",
        "每步操作均需实时响应"
      ],
      "Algorithmic Invariant": [
        "使用队列维护窗口内的元素顺序，保证 FIFO 正确性",
        "维护窗口内元素的累计和 sum，每次更新时动态调整：sum = sum + new_val - old_val（若满）",
        "指针或索引推进不破坏历史状态一致性",
        "平均值计算仅依赖当前 sum 和有效长度 min(size, 当前元素数)"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "size 范围": [
            1,
            1000
          ],
          "next 调用次数上限": 10000,
          "值域范围": [
            -100000,
            100000
          ]
        },
        "输入形式": "在线流式输入（逐个调用 next）",
        "是否多组数据": false,
        "是否循环": false,
        "是否允许负值": true,
        "是否有序": false,
        "窗口类型": "固定大小滑动窗口",
        "输出精度要求": "默认 double 精度，可调整",
        "扩展可能性": [
          "改为加权移动平均",
          "支持删除操作（双向滑动）",
          "支持动态调整窗口大小",
          "改为指数衰减平均（EMA）",
          "离线批量处理版本"
        ]
      }
    }
  },
  {
    "title": "岛屿的最大面积",
    "slug": "ZL6zAn",
    "schema": {
      "Input Structure": {
        "type": "2D grid",
        "dimensions": "m x n",
        "element_type": "binary (0 or 1)",
        "spatial_property": "grid edges are surrounded by water (0)",
        "connectivity_rule": "4-directional adjacency (up/down/left/right)",
        "constraints": [
          "m == grid.length",
          "n == grid[i].length",
          "1 <= m, n <= 50",
          "grid[i][j] ∈ {0, 1}"
        ]
      },
      "Core Constraint": {
        "island_definition": "A maximal connected component of 1s under 4-directional adjacency",
        "component_separation": "Different islands are separated by 0s and cannot be diagonally connected",
        "locality": "Each cell contributes at most 1 to the area, and only if it is part of a contiguous land region"
      },
      "Objective Function": {
        "goal": "maximize",
        "output_type": "integer",
        "target": "maximum area among all islands",
        "edge_case": "return 0 if no island exists"
      },
      "Algorithmic Invariant": {
        "exploration_method": "DFS/BFS traversal from unvisited land cell (1)",
        "state_tracking": "visited cells are marked to avoid revisiting and overcounting",
        "component_aggregation": "during traversal, the size of current connected component is accumulated recursively",
        "optimality_preservation": "once an island is fully explored, its area is globally optimal for that component; global maximum is maintained across components"
      },
      "Transformable Parameters": {
        "grid_dimension": [
          "1 <= m, n <= 50",
          "can scale to larger sizes or become sparse"
        ],
        "connectivity_mode": [
          "4-directional (current)",
          "8-directional (diagonal allowed)"
        ],
        "value_domain": [
          "binary {0,1} (current)",
          "multi-class labels (e.g., different terrain types)"
        ],
        "input_form": [
          "static offline grid (current)",
          "online updates (dynamic insertion/deletion of land)"
        ],
        "output_variation": [
          "maximum area (current)",
          "number of islands",
          "minimum island area",
          "total land area",
          "largest perimeter",
          "k-th largest island"
        ],
        "structural_modification": [
          "planar grid (current)",
          "toroidal/cylindrical wrapping (edges connected)"
        ],
        "additional_constraints": [
          "no constraints on shape (current)",
          "only convex-shaped islands count",
          "exclude islands with holes"
        ]
      }
    }
  },
  {
    "title": "组合总和 Ⅳ",
    "slug": "D0F0SV",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums 中元素为互不相同的正整数",
        "目标整数 target",
        "1 <= n <= 200",
        "1 <= nums[i] <= 1000",
        "1 <= target <= 1000"
      ],
      "Core Constraint": [
        "每个组合的元素和必须恰好等于 target",
        "允许重复使用 nums 中的元素",
        "顺序不同的序列视为不同组合（即考虑排列顺序）",
        "问题具有最优子结构：达到某个和 s 的方案数可由更小的和转移而来"
      ],
      "Objective Function": "计数 —— 求总和恰好为 target 的元素排列（有序组合）的个数",
      "Algorithmic Invariant": [
        "动态规划状态定义：dp[s] 表示组成和为 s 的排列数",
        "状态转移方程：dp[s] = Σ dp[s - num] （对所有满足 num <= s 的 num ∈ nums）",
        "初始条件：dp[0] = 1（空排列构成和为0）",
        "状态更新顺序：从小到大枚举 s，确保子问题已求解",
        "每一步转移保持已计算状态的正确性和完整性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "<= 200",
            "可扩展至 1e3 或在线场景"
          ],
          "target 的范围": [
            "<= 1000",
            "可扩大至 1e5 或更高"
          ]
        },
        "值域变化": [
          "nums 是否包含负数（进阶问题）",
          "若允许负数，则需限制最大递归深度或路径长度以避免无限循环"
        ],
        "输入形式": [
          "是否多组测试数据",
          "是否在线查询多个 target"
        ],
        "组合规则": [
          "是否允许重复使用元素（当前为允许）",
          "是否将顺序不同的序列视为相同（切换为组合而非排列）"
        ],
        "输出要求": [
          "仅返回总数",
          "是否要求输出所有具体组合方案"
        ],
        "约束条件": [
          "是否有使用次数限制（如每个元素最多用 k 次）",
          "是否加入模数取余（如结果 mod 1e9+7）"
        ]
      }
    }
  },
  {
    "title": "零钱兑换",
    "slug": "gaM7Ch",
    "schema": {
      "Input Structure": [
        "一维数组 coins[1..m]，表示 m 种不同面额的硬币",
        "每个硬币面额为正整数，且可重复使用（无限供应）",
        "一个非负整数 amount，表示目标总金额",
        "约束：1 <= m <= 12, 1 <= coins[i] <= 2^31 - 1, 0 <= amount <= 10^4"
      ],
      "Core Constraint": [
        "状态转移依赖于子问题：凑出金额 k 的最少硬币数由凑出 k - coin 的最优解递推而来",
        "无后效性：当前金额的最优解仅依赖更小金额的解，不依赖路径细节",
        "局部最优可扩展为全局最优（满足动态规划最优子结构）"
      ],
      "Objective Function": [
        "求最小化硬币个数",
        "若无法恰好凑出 amount，返回 -1",
        "特别地，当 amount = 0 时，返回 0"
      ],
      "Algorithmic Invariant": [
        "定义 dp[i] 表示凑出金额 i 所需的最少硬币数",
        "dp[0] = 0，其余初始化为 +∞",
        "对每个金额 i 从 1 到 amount，遍历所有硬币面额 c，执行状态转移：",
        "dp[i] = min(dp[i], dp[i - c] + 1)，其中 i >= c",
        "状态转移过程中保持 dp 数组的最优性不变"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "amount 的数量级": [
            "0 ~ 10^4",
            "可扩展至 10^6（需优化）"
          ],
          "coins 长度": [
            "1 ~ 12",
            "可变为任意长度"
          ]
        },
        "值域特性": {
          "硬币面额是否有序": [
            false,
            "可要求输入有序或无序"
          ],
          "是否存在单位1硬币": [
            false,
            "影响是否有解"
          ]
        },
        "输入形式": {
          "是否多组测试数据": [
            false,
            "可改为多组输入"
          ],
          "是否在线查询": [
            false,
            "可设计为多次查询不同 amount"
          ]
        },
        "约束变化": {
          "每种硬币是否有限数量": [
            false,
            "可改为有限背包形式"
          ],
          "是否允许超额支付并找零": [
            false,
            "变形为双向交易问题"
          ]
        },
        "目标函数变换": {
          "目标类型": [
            "最小化个数",
            "可改为最大化种类数",
            "计数方案总数",
            "判定是否存在"
          ],
          "输出形式": [
            "返回最小个数",
            "可改为输出具体组合方案"
          ]
        },
        "结构扩展": {
          "输入维度": [
            "1D 硬币列表",
            "可扩展为二维限制（如行列选择）"
          ],
          "是否环形/图结构": [
            false,
            "暂无直接映射"
          ]
        }
      }
    }
  },
  {
    "title": "目标和",
    "slug": "YaVDxD",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "positive_integer",
        "size": "n",
        "range": {
          "n": "1 <= n <= 20",
          "value_per_element": "0 <= nums[i] <= 1000",
          "total_sum": "0 <= sum(nums) <= 1000"
        },
        "sorted": false,
        "distinct": false
      },
      "Core Constraint": {
        "description": "每个元素必须被赋予 '+' 或 '-' 符号，形成带符号的和表达式",
        "mathematical_form": "求满足 Σ(signed nums[i]) = target 的符号分配方案数",
        "partition_interpretation": "等价于将数组划分为两个子集：正子集 P 和负子集 N，使得 sum(P) - sum(N) = target，且 sum(P) + sum(N) = total_sum",
        "derived_condition": "sum(P) = (target + total_sum) / 2，因此问题转化为是否存在子集和为 (target + total_sum)/2"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "计算使表达式结果等于 target 的不同符号分配方案的数量"
      },
      "Algorithmic Invariant": {
        "invariant_type": "subset-sum state preservation",
        "description": "在动态规划过程中，dp[j] 表示和为 j 的子集数目；加入新数字 num 后，更新所有可能达到的和状态，且不重复计数已处理的组合",
        "monotonicity": "状态空间随物品逐个加入单调扩展",
        "optimality_preservation": "每一步的状态转移基于前缀最优性，无后效性"
      },
      "Transformable Parameters": {
        "data_scale": {
          "n_range": [
            "small: 1~20",
            "medium: ~30",
            "large: >40 (需折半搜索或优化)"
          ],
          "value_range": [
            "non-negative integers",
            "allow_negative_values?"
          ]
        },
        "input_form": {
          "single_array": true,
          "multi_group_input": false,
          "online_queries": false
        },
        "constraints_variation": {
          "target_range": "-1000 <= target <= 1000",
          "sum_constraint": "total_sum <= 1000 allows DP on sum"
        },
        "problem_transforms": [
          "change objective: existence only → counting",
          "change operation: ± → other operations (e.g., * or /)",
          "add constraint: limited number of '-' allowed",
          "extend dimension: 2D array with grid path choice determining sign",
          "make online: incremental number arrival, query current ways",
          "hidden monotonicity: reorder array to enable pruning"
        ],
        "structural_variation": {
          "circular_array": false,
          "ordered_required": false
        }
      }
    }
  },
  {
    "title": "分割等和子集",
    "slug": "NUPfPr",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中 n >= 1；nums[i] ∈ 正整数；1 <= n <= 200，1 <= nums[i] <= 100",
      "Core Constraint": "总和必须为偶数才能分割；问题转化为是否存在一个子集，其元素和等于总和的一半（子集和问题）",
      "Objective Function": "判定是否存在一种划分方式，使得数组能被分成两个非空子集，且两子集元素和相等",
      "Algorithmic Invariant": "使用动态规划维护可达状态集合：dp[i] 表示是否存在子集和为 i；状态转移满足背包更新规则（倒序遍历避免重复使用）；贪心不可行，但子问题最优性可通过 DP 递推保持",
      "Transformable Parameters": {
        "数据规模": "n 的范围可调整（如 n <= 20 → n <= 1000）",
        "值域范围": "nums[i] 是否允许更大（如到 1e9）或包含负数",
        "目标函数变换": "从判定 → 计数（有多少种分法）→ 构造方案（输出具体划分）",
        "约束条件扩展": "是否要求两部分长度也相等；是否允许多于两部分的等和划分（如 K 分割）",
        "输入形式变化": "是否多组测试数据；是否在线流式输入（需支持增量处理）",
        "结构变形": "从一维数组 → 树上节点权值能否二分"
      }
    }
  },
  {
    "title": "三角形最小路径和",
    "slug": "IlPe0q",
    "schema": {
      "Input Structure": [
        "二维三角形数组 triangle[1..n][1..i+1], 其中第 i 行有 i+1 个元素 (i 从 0 开始)",
        "triangle[i][j] ∈ ℤ, 即整数（可负）",
        "结构固定：每行长度递增，triangle[0].length = 1, triangle[i].length = triangle[i-1].length + 1"
      ],
      "Core Constraint": [
        "路径必须从顶点 triangle[0][0] 出发，逐层向下移动",
        "每步只能转移到下一行的相同下标或下标+1位置：即从 triangle[i][j] → triangle[i+1][j] 或 triangle[i+1][j+1]",
        "路径构成一条从顶到底的连通序列，共 n 层，每层一个节点"
      ],
      "Objective Function": "求所有从顶到底路径中的最小路径和（数值最小化）",
      "Algorithmic Invariant": [
        "动态规划状态定义：dp[i][j] 表示到达 triangle[i][j] 的最小路径和",
        "状态转移满足：dp[i][j] = triangle[i][j] + min(dp[i-1][j-1], dp[i-1][j])，边界需处理",
        "最优子结构：全局最优路径的子路径也是对应子问题的最优解",
        "可原地更新：当前行状态仅依赖上一行，可用滚动数组压缩至 O(n) 空间"
      ],
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 200] → 可扩展至 1e5（需线性解）或缩小至 10（暴力可行）",
        "值域范围": "triangle[i][j] ∈ [-1e4, 1e4] → 可设为非负、正整数、或加入浮点数",
        "目标函数变形": [
          "最小路径和 → 最大路径和",
          "是否存在路径和等于 target",
          "路径和的方案数"
        ],
        "输入形式": [
          "静态一次性输入 → 在线逐行输入（流式处理）",
          "是否允许修改某一行后重新查询"
        ],
        "约束变化": [
          "移动规则变化：如允许多方向跳转（非相邻列）",
          "起点/终点不限定：可从底边任一点出发，或到达顶点"
        ],
        "空间限制": "是否要求 O(n) 或 O(1) 额外空间 → 触发滚动数组优化技巧",
        "多组数据": "是否包含 T 组独立三角形输入"
      }
    }
  },
  {
    "title": "最小路径和",
    "slug": "0i0mDW",
    "schema": {
      "Input Structure": [
        "二维非负整数网格 grid[1..m][1..n]",
        "m >= 1, n >= 1",
        "grid[i][j] ∈ [0, 100]"
      ],
      "Core Constraint": [
        "只能向下或向右移动，路径具有方向单调性",
        "每个位置的状态仅依赖于上方和左方的最优解",
        "无后效性：到达某点的最小路径和不依赖后续决策"
      ],
      "Objective Function": "求从左上角 (0,0) 到右下角 (m-1,n-1) 的所有路径中，数字总和最小值（最小化）",
      "Algorithmic Invariant": [
        "动态规划状态定义：dp[i][j] = 到达 (i,j) 的最小路径和",
        "状态转移方程：dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])",
        "边界条件可初始化，递推过程保持最优子结构",
        "遍历顺序从左到右、从上到下保证状态已计算"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": [
            "1~200",
            "可扩展至 1e3 或更高（需优化空间）"
          ]
        },
        "移动规则": [
          "仅右/下 → 可改为四方向 → 算法变为 Dijkstra",
          "加入障碍物 → 转换为带约束的路径问题"
        ],
        "目标函数变化": [
          "最小化 → 最大化（最大路径和）",
          "计数：最小路径和的方案数"
        ],
        "输入形式": [
          "静态网格 → 在线逐行输入",
          "是否允许多组查询（不同起点/终点）"
        ],
        "数值属性": [
          "非负整数 → 允许负数 → 仍可用 DP，但贪心失效",
          "值域范围变化影响是否可用滚动数组"
        ],
        "是否循环网格": false,
        "是否多组数据": false
      }
    }
  },
  {
    "title": "最大矩形",
    "slug": "PLYXKQ",
    "schema": {
      "Input Structure": [
        "二维字符矩阵 matrix[0..m-1][0..n-1]，由 '0' 和 '1' 组成",
        "输入形式为一维字符串数组，每个字符串表示一行二进制字符",
        "0 <= m, n <= 200",
        "matrix[i][j] ∈ {'0', '1'}"
      ],
      "Core Constraint": [
        "矩形区域内的所有元素必须全为 '1'",
        "最大矩形必须是连续的、轴对齐的子矩阵",
        "每一行的高度可转化为柱状图问题：若当前行为 '1'，则高度累加；否则重置为 0",
        "问题本质是将二维最大全1矩形转化为多轮一维最大矩形面积问题"
      ],
      "Objective Function": [
        "最大化矩形面积（宽 × 高）",
        "返回满足条件的最大矩形的面积值",
        "若无有效矩形（全0或空矩阵），返回0"
      ],
      "Algorithmic Invariant": [
        "维护每行对应的柱状图高度数组 heights[j]：表示从当前行向上延伸的连续 '1' 的个数",
        "对每一行构建的 heights 数组，使用「单调栈」求解最大矩形面积",
        "在单调栈中，当遇到 height[i] < height[stack.top()] 时，弹出栈顶并计算以该柱为中心的最大扩展矩形",
        "栈内保持索引对应的高度单调递增，确保左边界可确定，右边界由首次破坏单调性的位置决定",
        "每次更新全局最大面积 ans = max(ans, h * (r - l - 1))，其中 h 是柱高，l 和 r 是左右边界"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的范围": [
            "0 ≤ m, n ≤ 200",
            "可扩展至 2000 以测试 O(mn) 算法效率"
          ],
          "是否稀疏": "可引入稀疏矩阵设定"
        },
        "输入形式": [
          "字符串数组（每行一个二进制串）",
          "可变体：二维整数数组 int[][] matrix",
          "可变体：压缩存储格式（如 RLE）"
        ],
        "值域变化": [
          "仅限 '0'/'1' → 可推广为字符矩阵中找特定字符构成的最大矩形",
          "允许负值？否（本题不适用）"
        ],
        "目标函数变换": [
          "最大面积 → 最小正面积",
          "计数：有多少个面积等于最大值的矩形",
          "构造：输出矩形的具体坐标范围"
        ],
        "约束变化": [
          "全1矩形 → 允许最多 k 个 '0' 的近似矩形",
          "要求矩形为正方形 → 转化为 LeetCode 221 题",
          "要求矩形边界全为 '1'（空心矩形）"
        ],
        "动态性": [
          "静态输入 → 支持单点修改操作（在线更新）",
          "是否支持行列插入删除"
        ],
        "多组数据": "是否处理多个独立测试用例",
        "输出形式": [
          "仅面积 → 返回 [row1, col1, row2, col2]",
          "是否需要方案数"
        ]
      }
    }
  },
  {
    "title": "柱状图中最大的矩形",
    "slug": "0ynMMM",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "一维数组 heights[1..n]，表示柱状图中每个柱子的高度，每个柱子宽度为1",
        "constraints": {
          "length_range": [
            1,
            100000
          ],
          "value_range": [
            0,
            10000
          ]
        }
      },
      "Core Constraint": {
        "description": "矩形的面积由区间内最小高度与区间长度共同决定；最大矩形必然以某个柱子的高度为其高，且向左右尽可能扩展直到遇到更矮的柱子",
        "key_insight": "局部最优解可通过枚举每个位置作为矩形高度的最大可扩展区间获得",
        "structure_property": "区间极小值约束下的连续子数组长度最大化"
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "maximum area of rectangle that can be formed within the histogram",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "primary_paradigm": "monotonic stack",
        "invariant_description": "维护一个单调递增栈，保存索引；当遇到更小高度时，弹出栈顶元素并计算以其高度为高的最大矩形面积；此时左边界为新栈顶+1，右边界为当前索引-1，保证每次计算时该高度在对应区间内是最小值",
        "correctness_guarantee": "栈中元素始终保持高度单调递增，确保每个柱子被处理时，其左右第一个更小值的位置可被准确确定",
        "time_complexity_invariant": "每个元素最多入栈出栈一次，O(n)时间复杂度"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "input_dimension",
            "type": "structural",
            "options": [
              "1D",
              "2D (largest rectangle in binary matrix)"
            ],
            "default": "1D"
          },
          {
            "name": "value_domain",
            "type": "numerical",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "default": "non-negative"
          },
          {
            "name": "data_streaming",
            "type": "temporal",
            "options": [
              "offline",
              "online_query"
            ],
            "default": "offline"
          },
          {
            "name": "query_mode",
            "type": "interaction",
            "options": [
              "single_instance",
              "multiple_queries_on_dynamic_array"
            ],
            "default": "single_instance"
          },
          {
            "name": "output_detail",
            "type": "output_form",
            "options": [
              "max_area_only",
              "also_return_indices_or_subregion"
            ],
            "default": "max_area_only"
          },
          {
            "name": "constraint_modification",
            "type": "logical",
            "options": [
              "exact_rectangle",
              "at_most_k_units_wider",
              "with_holes_allowed"
            ],
            "default": "exact_rectangle"
          }
        ]
      }
    }
  },
  {
    "title": "每日温度",
    "slug": "iIQa4I",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length_range": [
          1,
          100000
        ],
        "value_range": [
          30,
          100
        ],
        "description": "一维数组 temperatures[1..n]，表示每日气温，元素为非负整数且在 [30,100] 范围内"
      },
      "Core Constraint": {
        "constraint": "每个位置的结果由其右侧第一个更大元素的位置决定",
        "dependency": "局部信息不足，需通过单调性维护候选索引",
        "structure_property": "右侧更大值的查找具有后向依赖性，但可通过栈结构消除重复搜索"
      },
      "Objective Function": {
        "type": "array",
        "goal": "构造一个输出数组",
        "element_meaning": "每个位置 i 的值为 j - i，其中 j 是最小索引满足 j > i 且 temperatures[j] > temperatures[i]；若不存在则为 0",
        "objective": "求每个元素到其下一个更大元素的距离（天数）"
      },
      "Algorithmic Invariant": {
        "invariant": "使用单调栈维护未找到答案的下标，栈中温度严格单调递减",
        "stack_property": "当遍历到温度 T[i] 时，所有栈顶对应温度 < T[i] 的下标均可确定答案",
        "correctness_guarantee": "每个元素入栈一次、出栈一次，指针推进与栈状态共同保证已处理区域的最优性",
        "monotonicity": "栈中索引对应的温度值单调递减，确保贪心弹出的安全性"
      },
      "Transformable Parameters": {
        "n_scale": "1e5 可调整为 1e6 或更低以适应不同复杂度要求",
        "value_domain": "温度范围可扩展至负数或更高（如 [-100,100]）",
        "input_form": "可变为在线输入流（数据逐个到达）",
        "output_form": "可改为输出下一个更高温的具体日期/索引，而非等待天数",
        "data_variation": "是否允许多组测试数据",
        "structural_transformation": "可推广至二维温度网格，求最近更高点的曼哈顿距离",
        "constraint_modification": "将‘更高’改为‘更高或相等’以改变单调性条件",
        "operation_support": "加入修改操作，支持动态更新温度（带修版本）"
      }
    }
  },
  {
    "title": "行星碰撞",
    "slug": "XagZNi",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element": "integer",
        "size": "n",
        "constraints": [
          "2 <= n <= 10000",
          "-1000 <= asteroids[i] <= 1000",
          "asteroids[i] != 0"
        ],
        "meaning": {
          "absolute_value": "planet size",
          "sign": "direction: positive for right, negative for left"
        }
      },
      "Core Constraint": {
        "collision_condition": "only when a right-moving (positive) planet is followed by a left-moving (negative) planet",
        "no_collision_cases": [
          "same direction planets never collide",
          "left-moving planet followed by right-moving planet will not collide due to diverging directions"
        ],
        "interaction_scope": "collisions occur sequentially from left to right, but resolution may propagate backward due to chain reactions"
      },
      "Objective Function": {
        "goal": "compute the final state of planets after all possible collisions",
        "output_type": "array",
        "semantics": "remaining planets in their final order after all collisions resolved"
      },
      "Algorithmic Invariant": {
        "data_structure": "stack",
        "invariant_description": "the stack maintains the current surviving planets with correct relative order and no pending collisions within itself",
        "monotonicity": "planets in stack are effectively non-colliding; only top element can interact with next incoming planet",
        "update_rule": "if current planet is negative and larger than top positive planet, pop stack (top explodes); if equal, both explode; if smaller, current planet explodes; otherwise push current planet",
        "correctness_guarantee": "after processing each element, the stack contains the correct surviving sequence up to that point under collision rules"
      },
      "Transformable Parameters": {
        "n_range": [
          2,
          10000
        ],
        "value_domain": [
          -1000,
          1000
        ],
        "allow_zero": false,
        "input_form": "offline, one-dimensional array",
        "output_form": "list of remaining planets in original traversal order",
        "multi_query": false,
        "online_processing": false,
        "dimension_extension": "can be generalized to 2D movement or network paths (not applicable here)",
        "velocity_heterogeneity": "current assumption: uniform speed; variant could introduce variable speeds",
        "collision_rule_variants": [
          "non-symmetric destruction (e.g., only smaller explodes, same size survives)",
          "partial damage models",
          "direction change instead of explosion"
        ],
        "order_of_evaluation": "left-to-right sequential scan is canonical; alternate evaluation orders would break semantics"
      }
    }
  },
  {
    "title": "不同的子序列",
    "slug": "21dk04",
    "schema": {
      "Input Structure": [
        "一维字符串 s[1..n]，长度 n ≥ 0",
        "一维字符串 t[1..m]，长度 m ≥ 0",
        "字符集：英文字母（大小写敏感）",
        "s 和 t 均为静态输入，无修改操作"
      ],
      "Core Constraint": [
        "子序列保持原字符串中字符的相对顺序",
        "t 的匹配必须在 s 中按序出现，但不要求连续",
        "不同路径对应不同的删除方式，即使结果相同也视为不同方案（如位置选择不同）",
        "局部决策依赖前缀匹配状态"
      ],
      "Objective Function": "计数 —— 统计 s 的所有子序列中与 t 完全相等的个数",
      "Algorithmic Invariant": [
        "动态规划状态 dp[i][j] 表示 s[1..i] 中匹配 t[1..j] 的子序列个数",
        "状态转移满足：若 s[i] == t[j]，则 dp[i][j] = dp[i-1][j-1] + dp[i-1][j]；否则 dp[i][j] = dp[i-1][j]",
        "初始边界条件稳定：dp[i][0] = 1（空串总可被匹配），dp[0][j>0] = 0",
        "状态转移具有前缀依赖性和无后效性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 的数量级": [
            "≤ 1000",
            "可扩展至 ≤ 1e5（需优化）"
          ],
          "是否允许超大输入（如 1e5+）": false
        },
        "字符串性质": {
          "是否有序": false,
          "是否循环": false,
          "是否允许通配符或正则扩展": false,
          "字符集类型": "有限字母表（A-Za-z）"
        },
        "输入形式": {
          "是否多组测试数据": false,
          "是否在线查询（增量添加字符）": false,
          "是否支持更新操作（如插入/删除 s 中字符）": false
        },
        "目标函数变体": [
          "判定是否存在至少一个子序列（存在性判断）",
          "求最长公共子序列长度（结构相似但目标不同）",
          "输出所有方案路径（构造型）",
          "模意义下计数（防止溢出）"
        ],
        "约束变化": [
          "要求子序列连续（退化为子串匹配）",
          "允许多次使用同一字符（重用限制解除）",
          "加入间隔约束（如相邻字符在原串中距离 ≤ K）"
        ]
      }
    }
  },
  {
    "title": "逆波兰表达式求值",
    "slug": "8Zf90G",
    "schema": {
      "Input Structure": [
        "一维字符串数组 tokens[1..n]",
        "tokens[i] ∈ {\"+\", \"-\", \"*\", \"/\"} ∪ 整数集合",
        "整数范围：[-200, 200]",
        "1 <= n <= 10^4"
      ],
      "Core Constraint": [
        "表达式为有效的逆波兰表达式（后缀表达式）",
        "运算顺序严格依赖于栈结构：遇到操作符时，必须有至少两个操作数在栈中",
        "除法为整数除法，向零截断",
        "无除零情况，输入总能得出有效数值"
      ],
      "Objective Function": "计算逆波兰表达式的最终数值结果",
      "Algorithmic Invariant": [
        "使用栈维护待合并的操作数：所有未参与运算的数字按顺序入栈",
        "每次遇到操作符时，弹出栈顶两个元素进行二元运算（先弹出的是右操作数）",
        "将运算结果重新压入栈中，保持后续运算的结构性不变",
        "遍历结束后，栈中仅剩一个元素，即为整个表达式的值",
        "栈的状态始终代表当前已解析前缀子表达式的中间结果集合"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^4（可调整为更大规模或支持流式输入）",
        "值域": "整数范围 [-200, 200]（可扩展至 long 或支持浮点）",
        "操作符集合": [
          "+",
          "-",
          "*",
          "/"
        ],
        "是否支持自定义函数": false,
        "是否在线输入": false,
        "是否多组数据": false,
        "错误处理要求": "当前假设输入总是有效；可变形为需要验证语法合法性",
        "输出形式": "返回单一整数值；可变体包括输出每一步栈状态或构造中缀表达式"
      }
    }
  },
  {
    "title": "最小时间差",
    "slug": "569nqc",
    "schema": {
      "Input Structure": [
        "数组 timePoints[1..n]，其中每个元素为字符串格式的 'HH:MM'",
        "表示 24 小时制下的时间点",
        "n ∈ [2, 2×10⁴]",
        "每个时间可转换为 [0, 1439] 范围内的整数（单位：分钟）"
      ],
      "Core Constraint": [
        "时间是环形结构：最小差可能跨越 00:00（即 23:59 到 00:00 的差为 1 分钟）",
        "任意两个时间点的时间差定义为顺时针与逆时针方向中较小者",
        "重复时间点导致最小差为 0"
      ],
      "Objective Function": "计算所有无序时间点对之间的最小时间差（以分钟为单位）",
      "Algorithmic Invariant": [
        "排序后，最小时间差一定出现在相邻时间点之间或首尾跨越 00:00 的位置",
        "将时间映射为线性数组上的点，并考虑环形首尾连接的一种展开方式",
        "若存在重复时间，则提前可判定最优解为 0",
        "维护当前最小差值，遍历相邻对更新答案"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的范围：从几十到 2×10⁴（允许 O(n log n) 排序）",
        "输入形式": [
          "字符串列表 ['HH:MM'] 或直接给出分钟数组",
          "是否保证合法性（如无效时间是否需要校验）"
        ],
        "时间制式": [
          "24 小时制（固定）或可扩展为通用周期 T",
          "是否支持秒级精度"
        ],
        "是否环形": [
          "是（本题默认）或否（线性时间轴）"
        ],
        "输出目标": [
          "最小差值（本题）",
          "最大差值",
          "第 k 小差值",
          "所有差值的计数分布"
        ],
        "是否多组数据": "单组输入；可扩展为多测例批量处理",
        "是否在线查询": "离线处理全部时间点；可改造为动态插入/查询最小差"
      }
    }
  },
  {
    "title": "交错字符串",
    "slug": "IY6buf",
    "schema": {
      "Input Structure": [
        "字符串 s1，长度为 m，由小写英文字母组成，可为空",
        "字符串 s2，长度为 n，由小写英文字母组成，可为空",
        "字符串 s3，长度为 p = m + n，由小写英文字母组成，可为空"
      ],
      "Core Constraint": [
        "s3 必须是由 s1 和 s2 的非空子串按交错顺序拼接而成",
        "交错方式有两种起始模式：s1 开头 或 s2 开头",
        "|n - m| <= 1 不适用于子串数量（原题中此条件为误导性描述，实际无此全局限制），但每次选择必须来自 s1 或 s2 的当前剩余前缀",
        "每个子串非空，且整体必须完整使用 s1 和 s2"
      ],
      "Objective Function": "判定是否存在一种合法的交错方式，使得 s3 可由 s1 和 s2 交织构成（布尔判定问题）",
      "Algorithmic Invariant": [
        "状态 dp[i][j] 表示 s1 的前 i 个字符和 s2 的前 j 个字符是否能交织成 s3 的前 i+j 个字符",
        "状态转移满足：dp[i][j] = (dp[i-1][j] && s1[i-1] == s3[i+j-1]) || (dp[i][j-1] && s2[j-1] == s3[i+j-1])",
        "初始状态 dp[0][0] = true，边界状态可递推",
        "状态转移具有方向单调性：只能从左或上转移而来，形成 DAG 结构"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n <= 100, p <= 200": "支持 O(mn) DP 解法",
          "扩展可能": "若 m,n 达到 1e5，则需考虑贪心或双指针启发式（但本题不适用）"
        },
        "字符集": [
          "当前为小写英文字母",
          "可变体：大写字母、数字、区分大小写与否"
        ],
        "是否允许空子串": [
          "当前约束：非空子串",
          "变形：允许空分割 → 等价于任意顺序合并 → 更简单"
        ],
        "交错模式": [
          "当前：两种起始方式（s1 先或 s2 先），自动隐含在 DP 中",
          "变形：强制指定起始字符串",
          "变形：限定交替次数 ≤ K"
        ],
        "目标函数变化": [
          "计数型：有多少种交织方式",
          "构造型：输出任意一种合法分割方案",
          "最小化分割段数：优化交织段数"
        ],
        "输入形式": [
          "当前：一次性离线输入三字符串",
          "在线变形：逐步输入 s3 字符，实时判断是否仍可能交织（流式判定）"
        ],
        "多组数据": "是否处理多组测试用例（竞赛常见）"
      }
    }
  },
  {
    "title": "验证外星语词典",
    "slug": "lwyVBB",
    "schema": {
      "Input Structure": {
        "words": "字符串数组 words[1..n]，其中每个 words[i] 是由小写字母组成的非空字符串",
        "order": "长度为 26 的字符串 order，表示外星文字母表的顺序，是 'a'-'z' 的一个排列"
      },
      "Core Constraint": {
        "字母序定义": "字符之间的大小关系由 order 中的位置决定：靠前的字符小于靠后的字符",
        "字典序规则": "两个单词按从左到右逐字符比较，第一个不同字符决定顺序；若一个单词是另一个的前缀，则较短者更小（即空字符 '∅' < 任意字符）"
      },
      "Objective Function": "判定函数：判断字符串数组 words 是否按照给定外星文字典序单调非递减排列",
      "Algorithmic Invariant": {
        "局部可判定性": "相邻单词的相对顺序决定了整体是否有序（即：若 ∀i, words[i] ≤ words[i+1]，则整体有序）",
        "比较不变性": "一旦建立字符映射（char → index），任意两字符比较可在 O(1) 时间完成",
        "前缀剪枝性质": "在比较两个单词时，遇到第一个不同字符即可得出结果，无需遍历完整个字符串"
      },
      "Transformable Parameters": {
        "数据规模": "n = words.length ∈ [1, 100]，单个单词长度 ∈ [1, 20]",
        "字母表维度": "可扩展至 k 字符系统（如 order.length = k），不限于 26",
        "输入形式": [
          "是否在线：单词流式输入，需动态判断是否仍保持有序",
          "是否多组数据：多个 words 数组共享同一个 order"
        ],
        "排序目标变化": [
          "改为构造合法排序序列（构造题）",
          "计数满足字典序的子序列数量（计数题）",
          "最小修改次数使序列有序（优化题）"
        ],
        "约束变形": [
          "允许大写字母或特殊符号",
          "order 不完整（仅部分字符有序）",
          "多维词典序（如先按长度再按字典序）"
        ]
      }
    }
  },
  {
    "title": "字母异位词分组",
    "slug": "sfvd7V",
    "schema": {
      "Input Structure": [
        "字符串数组 strs[1..n]",
        "每个字符串 strs[i] 是由小写字母组成的字符串",
        "1 <= n <= 10^4",
        "0 <= |strs[i]| <= 100"
      ],
      "Core Constraint": [
        "两个字符串互为变位词，当且仅当它们的字符频次分布完全相同",
        "变位词关系具有自反性、对称性和传递性，构成等价类划分",
        "分组必须覆盖所有输入字符串且不重复"
      ],
      "Objective Function": [
        "将所有互为变位词的字符串归入同一组",
        "构造一个列表，包含若干子列表，每个子列表是一个变位词组",
        "输出形式为 List<List<String>>，组内顺序任意，组间顺序任意"
      ],
      "Algorithmic Invariant": [
        "使用规范化表示（如排序后的字符串或字符计数向量）作为哈希键，保证同一变位词类映射到相同键",
        "哈希表中每个键对应的值列表动态累加属于该类的原始字符串",
        "遍历过程中保持：已处理字符串全部归类，未处理字符串不影响已有分类正确性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": "1e4 可扩展至 1e5 或更高",
          "字符串长度": "0~100 可改为固定长 / 超长串"
        },
        "字符集": [
          "仅小写字母 → 扩展至大写、数字、Unicode"
        ],
        "输入形式": [
          "一次性输入 → 流式添加字符串（在线模式）",
          "是否支持删除操作"
        ],
        "输出要求": [
          "仅分组 → 同时输出每组的代表元",
          "是否要求组内字典序",
          "是否去重"
        ],
        "变位词定义变形": [
          "严格频次相等 → 允许最多 k 个字符差异（模糊匹配）",
          "忽略特定字符（如空格、标点）"
        ],
        "多组数据": "是否处理多个独立测试用例"
      }
    }
  },
  {
    "title": "最长公共子序列",
    "slug": "qJnOS7",
    "schema": {
      "Input Structure": [
        "两个字符串 text1[1..m] 和 text2[1..n]",
        "字符集为有限字母表（如小写英文字母）",
        "m, n ≥ 1，且 m, n ≤ 1000"
      ],
      "Core Constraint": [
        "子序列保持原字符的相对顺序",
        "公共子序列需同时在两个字符串中以相同顺序出现",
        "字符匹配具有传递性和可组合性：若 text1[i] == text2[j]，则该字符可作为 LCS 的一部分；否则需分别跳过 i 或 j"
      ],
      "Objective Function": "求最长公共子序列的长度（最大化）",
      "Algorithmic Invariant": [
        "DP 状态定义：dp[i][j] 表示 text1[1..i] 与 text2[1..j] 的最长公共子序列长度",
        "状态转移满足最优子结构：",
        "  - 若 text1[i] == text2[j]，则 dp[i][j] = dp[i-1][j-1] + 1",
        "  - 否则 dp[i][j] = max(dp[i-1][j], dp[i][j-1])",
        "状态转移过程中，已计算的 dp 值不会被推翻，具有单调非减性",
        "每步决策仅依赖于已确定的前缀信息"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "字符串长度范围": "1 <= m, n <= 1000（可扩展至 5000 或支持大数）"
        },
        "字符集类型": [
          "仅小写字母（可变为大写、数字、Unicode 等）"
        ],
        "目标函数变化": [
          "返回长度 → 返回任意一个LCS串",
          "返回所有不同LCS的数量（计数型变形）",
          "返回字典序最小的LCS（构造+优化）"
        ],
        "输入形式": [
          "静态双串输入（可变为多组测试用例、在线流式添加字符）"
        ],
        "约束条件变化": [
          "允许k次字符修改后的最长公共子序列（编辑距离融合）",
          "要求子序列是回文的（复合约束）",
          "子序列必须连续（退化为最长公共子串）"
        ],
        "是否循环": false,
        "是否在线": false,
        "是否多组数据": false
      }
    }
  },
  {
    "title": "有效的字母异位词",
    "slug": "dKk3P7",
    "schema": {
      "Input Structure": [
        "两个字符串 s 和 t",
        "s.length, t.length ∈ [1, 5 * 10^4]",
        "字符集：初始为小写字母 a-z，可扩展至 Unicode"
      ],
      "Core Constraint": [
        "变位词的定义：两字符串中每个字符的出现频次完全相同，且字符顺序不完全相同",
        "字符频次是核心匹配条件",
        "顺序不同是必要判定条件（即不能是同一字符串）"
      ],
      "Objective Function": "判定 s 和 t 是否互为变位词（返回布尔值）",
      "Algorithmic Invariant": [
        "字符频次统计具有可交换性：频次直方图相等 ⇔ 字符多集合相等",
        "若频次分布相同且 s ≠ t，则满足变位词条件",
        "频次比较与字符排列顺序无关，具备置换不变性"
      ],
      "Transformable Parameters": {
        "数据规模": "字符串长度范围 [1, 5 * 10^4]",
        "字符集": [
          "基础版：仅小写字母 a-z",
          "进阶版：支持 Unicode 字符（需哈希表而非数组计数）"
        ],
        "输入形式": "一次性输入两个字符串",
        "是否多组数据": false,
        "是否在线": false,
        "变位词定义参数化": [
          "是否允许 s == t（即顺序完全相同）",
          "是否要求至少一个字符位置不同",
          "是否放宽为多重集合相等即算变位词（忽略顺序差异显式判断）"
        ],
        "输出要求": [
          "基础：返回布尔值",
          "扩展：返回最小交换次数使成为变位词",
          "扩展：返回所有不同位置索引"
        ]
      }
    }
  },
  {
    "title": "分割回文串 II",
    "slug": "omKAoA",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n（1 ≤ n ≤ 2000）",
        "s 由小写英文字母组成",
        "输入为一维字符序列"
      ],
      "Core Constraint": [
        "每个子串必须是回文串",
        "分割位置可变，但必须覆盖整个字符串",
        "前缀的最优分割依赖于其内部回文结构的可分性"
      ],
      "Objective Function": "求将字符串分割为若干回文子串所需的最少分割次数",
      "Algorithmic Invariant": [
        "动态规划状态 dp[i] 表示子串 s[0:i+1] 的最小分割次数",
        "若 s[j:i+1] 是回文串，则 dp[i] = min(dp[i], dp[j-1] + 1) 对所有 j ≤ i 成立",
        "回文判断可通过预处理的二维布尔表 isPalin[j][i] 快速查询，满足区间可扩展性：isPalin[j][i] = (s[j] == s[i]) && (j+1 > i-1 || isPalin[j+1][i-1])",
        "状态转移具有前向依赖性和无后效性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 2000（可调整为更大规模以区分解法）",
        "字符类型": "仅小写字母（可推广至大写、数字、Unicode）",
        "是否要求构造方案": false,
        "目标函数形式": "最少分割次数（可变为：最多回文子串数 / 所有合法分割方案计数）",
        "是否在线输入": false,
        "是否多组数据": false,
        "回文定义是否允许空串或单字符": "允许（单字符默认为回文）",
        "是否加入额外约束": [
          "如每个回文子串长度 ≥ K",
          "或每个子串类型唯一",
          "或限定分割段数"
        ]
      }
    }
  },
  {
    "title": "最长的斐波那契子序列的长度",
    "slug": "Q91FMA",
    "schema": {
      "Input Structure": [
        "一维数组 arr[1..n]",
        "严格递增的正整数序列",
        "3 <= n <= 1000",
        "1 <= arr[i] < arr[i+1] <= 10^9"
      ],
      "Core Constraint": [
        "斐波那契式子序列要求：n >= 3 且对所有 i + 2 <= n，满足 X_i + X_{i+1} = X_{i+2}",
        "子序列保持原顺序，但不要求连续",
        "数组严格递增，保证元素唯一且有序，可用于快速查找"
      ],
      "Objective Function": [
        "最大化子序列长度",
        "若不存在长度 >= 3 的斐波那契式子序列，返回 0"
      ],
      "Algorithmic Invariant": [
        "固定前两项 arr[i] 和 arr[j] (i < j)，可唯一确定后续项：next = arr[i] + arr[j]",
        "利用哈希表存储元素到索引的映射，实现 O(1) 后续项存在性检查",
        "动态规划状态：dp[i][j] 表示以 arr[i] 和 arr[j] 为最后两项的斐波那契式子序列的最大长度",
        "状态转移：若存在 k < i 使得 arr[k] + arr[i] = arr[j]，则 dp[i][j] = dp[k][i] + 1；否则 dp[i][j] = 2（初始化）"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的范围：3 ~ 1000（当前），可扩展至 1e5（需优化）",
        "值域范围": "arr[i] 最大达 1e9，影响哈希表可行性",
        "是否有序": "当前为严格递增，可变形为无序数组（增加难度）",
        "输入形式": "单组离线输入，可改为多组测试用例或在线查询",
        "子序列类型": "当前为经典子序列（保序不连续），可改为子数组（连续）",
        "目标函数变体": [
          "计数：有多少个最长斐波那契子序列",
          "判定：是否存在长度 ≥ K 的斐波那契子序列",
          "构造：输出一个最长子序列的具体方案"
        ],
        "约束条件变形": [
          "允许非严格递增",
          "允许负整数",
          "要求三项不同起点（如必须包含首元素）"
        ],
        "算法路径依赖": "当前依赖哈希 + DP，若取消哈希则退化为暴力搜索"
      }
    }
  },
  {
    "title": "LRU 缓存",
    "slug": "OrIXps",
    "schema": {
      "Input Structure": [
        "双向链表（用于维护访问顺序，头尾指针）",
        "哈希表（用于键到节点的 O(1) 映射）",
        "正整数 capacity 表示缓存最大容量",
        "操作序列：包含 'get(key)' 和 'put(key, value)' 操作",
        "key ∈ [0, 10000], value ∈ [0, 10^5]",
        "最多执行 2 × 10^5 次操作"
      ],
      "Core Constraint": [
        "缓存容量有限，插入新项时若满则必须淘汰最久未使用的项",
        "每次 get 或 put 操作都会使对应 key 变为最新使用（需更新顺序）",
        "所有操作需在常数时间内完成（进阶要求）",
        "键值对的唯一性：每个 key 最多存在一个实例"
      ],
      "Objective Function": [
        "设计一个支持 get 和 put 操作的数据结构",
        "get 操作：查询指定 key 的值，若不存在返回 -1",
        "put 操作：插入或更新键值对，并在超出容量时驱逐最久未使用项",
        "目标是实现 LRU 缓存机制的功能正确性和高效性"
      ],
      "Algorithmic Invariant": [
        "最近使用的节点始终被移动到链表头部（或尾部，依实现而定）",
        "链表中的节点按从新到旧（或从旧到新）有序排列",
        "哈希表始终与链表同步：任何链表节点的增删改都反映在哈希表中",
        "每次操作后，缓存大小不超过 capacity，且淘汰策略满足 LRU 规则",
        "双数据结构协同不变量：哈希表提供 O(1) 访问，双向链表支持 O(1) 插入删除"
      ],
      "Transformable Parameters": {
        "capacity 数量级": "1 <= capacity <= 3000（可扩展至更大规模）",
        "key 值域": "0 <= key <= 10000（可改为负数或字符串键）",
        "value 值域": "0 <= value <= 1e5（可变类型如对象、复杂结构）",
        "操作次数上限": "最多 2e5 次调用（可调整为更高并发场景）",
        "是否多组数据": false,
        "是否在线": true,
        "是否允许重复 key": false,
        "淘汰策略可替换": [
          "LRU → LFU（最不经常使用）",
          "LRU → FIFO（先进先出）",
          "LRU → MRU（最近使用优先淘汰）"
        ],
        "数据结构可变形式": [
          "双向链表 + 哈希表 → 使用 STL list + unordered_map（C++）",
          "模拟链表使用数组索引（离线静态分配）",
          "仅用哈希表维护时间戳（牺牲 O(1) 复杂度）"
        ],
        "功能扩展位": [
          "支持 delete(key)",
          "支持 getOlder() / getNewest() 等元信息查询",
          "支持持久化快照或版本控制"
        ]
      }
    }
  },
  {
    "title": "将字符串翻转到单调递增",
    "slug": "cyJERH",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n",
        "s[i] ∈ {'0', '1'}",
        "1 <= n <= 20000"
      ],
      "Core Constraint": [
        "单调递增字符串定义为：若干 '0'（可无）后接若干 '1'（可无）",
        "翻转操作允许将任意 '0'→'1' 或 '1'→'0'",
        "最终字符串必须满足全局非降序结构（即存在一个分割点 k，使得前缀全为 '0'，后缀全为 '1'）"
      ],
      "Objective Function": "求使字符串单调递增的最小翻转次数（最小化）",
      "Algorithmic Invariant": [
        "枚举所有可能的分割位置 k（从 0 到 n），其中 [0:k) 为 '0'，[k:n] 为 '1'",
        "对于每个 k，翻转代价 = 前缀中 '1' 的个数 + 后缀中 '0' 的个数",
        "利用前缀和预处理 '1' 的数量，可在 O(1) 时间内计算每个 k 对应的代价",
        "最优解一定对应某个 k 的分割方案，状态空间被压缩至线性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e4 ~ 1e5（当前为 2e4）",
        "字符集扩展": "是否扩展为多进制串（如 '0','1','2'）的单调非降序调整",
        "目标模式变化": [
          "'0' 和 '1' 交替",
          "以 '1' 开头后接 '0'",
          "回文结构约束"
        ],
        "翻转代价不对称": "例如 '0'→'1' 代价为 a，'1'→'0' 代价为 b",
        "允许多段单调块": "如最多两个递增段，或限定 '010' 模式禁止",
        "输入形式": "是否支持在线输入流或动态修改",
        "输出要求": [
          "仅返回最小次数",
          "返回具体翻转位置",
          "返回所有最优方案数（计数型变形）"
        ],
        "是否多组数据": false,
        "是否循环字符串": false
      }
    }
  },
  {
    "title": "粉刷房子",
    "slug": "JEj789",
    "schema": {
      "Input Structure": "二维数组 costs[1..n][1..3]，其中 n 表示房子数量，每行三个正整数表示将该房子粉刷成红、蓝、绿三种颜色的花费成本；costs[i][j] ≥ 1，且 n ≥ 1",
      "Core Constraint": "相邻两个房子不能粉刷成相同颜色；每个房子必须选择且仅选择一种颜色；当前房子的颜色选择依赖于前一个房子的颜色选择（状态转移）",
      "Objective Function": "求粉刷完所有房子的最小总花费成本",
      "Algorithmic Invariant": "动态规划状态可定义为 dp[i][0], dp[i][1], dp[i][2]，分别表示前 i 个房子且第 i 个房子涂成红/蓝/绿时的最小累计成本；状态转移中，每一步只保留最优子结构，且满足无后效性：dp[i][j] = min(dp[i-1][k]) + costs[i][j] （k ≠ j）",
      "Transformable Parameters": [
        "n 的数量级：1 <= n <= 100（可扩展至 1e5，推动优化）",
        "颜色种类数：从 3 种变为 k 种（k ≥ 2），即 costs 变为 n×k 矩阵",
        "是否允许相邻颜色相同：约束反转为可相同或限制更多模式",
        "是否加入周期性约束：首尾房子颜色也不能相同",
        "是否在线输入：逐个输入房子的成本，要求实时更新最小成本",
        "costs 值域变化：从正整数扩展到非负整数或含负数（特殊语义）",
        "是否多组数据：连续处理多个测试用例",
        "目标函数变换：从最小化总成本变为计数合法方案数或判定是否存在可行解"
      ]
    }
  },
  {
    "title": "O(1) 时间插入、删除和获取随机元素",
    "slug": "FortPu",
    "schema": {
      "Input Structure": [
        "设计一个支持三种操作的数据结构：insert(val), remove(val), getRandom()",
        "val 是整数，范围为 [-2^31, 2^31 - 1]",
        "最多执行 2 * 10^5 次操作",
        "调用 getRandom 时集合非空"
      ],
      "Core Constraint": [
        "需要在平均时间复杂度 O(1) 下完成所有三个操作",
        "哈希表可实现 insert 和 remove 的 O(1) 查找，但无法直接实现等概率随机访问",
        "数组支持 O(1) 随机访问（通过索引），但插入删除通常为 O(n)",
        "因此必须结合动态数组与哈希表：用数组存储元素以支持随机访问，用哈希表记录值到索引的映射",
        "为了在删除时保持数组紧凑且不破坏其他元素的索引映射，采用‘与末尾交换后弹出’策略"
      ],
      "Objective Function": [
        "构造满足上述约束的数据结构并正确实现三个函数的行为",
        "返回布尔值表示 insert/remove 是否成功",
        "getRandom 需保证每个现存元素被返回的概率相等"
      ],
      "Algorithmic Invariant": [
        "数组 nums 存储当前集合中所有元素，无重复",
        "哈希表 map: val → index 维护每个值在 nums 中的当前下标",
        "在 insert 时，若 val 不存在，则追加至 nums 尾部，并更新 map",
        "在 remove 时，先查 map 找到 val 的索引 i，将 nums[i] 与 nums[last] 交换，更新 map 中对应项的索引，然后从 nums 弹出末尾并删除 map[val]",
        "此交换-弹出机制确保其余元素索引不变性或可维护性，从而维持 O(1) 复杂度",
        "getRandom 通过对 nums 长度取随机索引实现均匀采样"
      ],
      "Transformable Parameters": [
        "数据规模：操作次数从 10^3 到 2*10^5 可变，影响是否允许非均摊解法",
        "值域是否受限（如正整数、小范围）——影响哈希策略",
        "是否允许重复元素（→ 支持多重集）",
        "是否要求严格 O(1) 而非均摊 O(1)",
        "是否在线：所有操作均为实时调用，不能预处理",
        "是否多组测试数据",
        "随机性要求：是否真随机 / 伪随机 / 只需形式上等概率",
        "输出形式：返回值序列 vs 状态打印",
        "扩展操作：如 getMinimum(), getMedian() 等附加查询"
      ]
    }
  },
  {
    "title": "打家劫舍 II",
    "slug": "PzWKhm",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "constraints": [
          "1 <= n <= 100",
          "0 <= nums[i] <= 1000"
        ],
        "structure": "circular array (first and last elements are adjacent)"
      },
      "Core Constraint": {
        "description": "相邻房屋不能同时被偷，否则触发报警；首尾房屋也视为相邻，形成环形约束",
        "implication": "选择子集时需避免任何两个相邻下标（包括0和n-1）同时被选中",
        "dependency": "局部决策影响全局可行性，最优解必须满足环状非邻接条件"
      },
      "Objective Function": {
        "type": "optimization",
        "goal": "maximization",
        "target": "maximum sum of non-adjacent elements in a circular array"
      },
      "Algorithmic Invariant": {
        "principle": "动态规划状态可分解为线性段上的无相邻选取问题，通过拆环为链处理环形约束",
        "invariants": [
          "将环形结构拆分为两个线性子问题：包含首部不包含尾部、包含尾部不包含首部",
          "每个子问题中，dp[i] 表示前 i 个房屋能获得的最大金额，且满足不偷相邻房屋",
          "状态转移：dp[i] = max(dp[i-1], dp[i-2] + nums[i])",
          "最终结果为两个子问题的最大值"
        ],
        "monotonicity": "dp 序列具有单调非减性质，基于贪心选择的可延展性",
        "optimal_substructure": true,
        "overlapping_subproblems": true
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 100",
        "value_domain": "0 <= nums[i] <= 1000",
        "circularity": {
          "base": true,
          "variants": [
            "linear street (no connection between first and last)",
            "multi-ring or hierarchical rings"
          ]
        },
        "input_form": {
          "single_array": true,
          "multiple_queries": false,
          "online_updates": false,
          "mutable_values": false
        },
        "output_form": {
          "return_max_sum": true,
          "construct_solution_path": false,
          "count_number_of_optimal_solutions": false
        },
        "constraint_variants": [
          "k-separated houses (at least k houses between two robbed ones)",
          "house weights with dependencies (e.g., tree-structured neighborhoods)",
          "probabilistic alarm triggering"
        ]
      }
    }
  },
  {
    "title": "循环有序列表的插入",
    "slug": "4ueAj6",
    "schema": {
      "Input Structure": [
        "循环双向链表的任意节点指针 head",
        "链表节点数 n 满足 0 <= n <= 5 * 10^4",
        "每个节点值 val 满足 -10^6 <= Node.val <= 10^6",
        "insertVal 满足 -10^6 <= insertVal <= 10^6",
        "链表为单调非递减且循环（即最后一个节点的 next 指向头节点）"
      ],
      "Core Constraint": [
        "链表是循环有序的，但起始点不一定是全局最小值",
        "插入后必须保持整个链表仍为循环单调非递减",
        "若链表为空，需创建单节点循环链表并返回该节点",
        "允许多个合法插入位置，任选其一即可"
      ],
      "Objective Function": "在循环有序链表中插入一个新值 insertVal，使得插入后的链表仍然保持循环单调非递减，并返回原始 head 节点（若原 head 非空）",
      "Algorithmic Invariant": [
        "双指针遍历：使用 prev 和 curr 指针遍历环，检测满足 insertVal 可插入的位置",
        "插入条件不变量：当 (prev.val <= insertVal <= curr.val) 时，可在 prev 和 curr 之间插入",
        "跨边界不变量：若 curr.val < prev.val，则说明跨越了循环断点（最大→最小），此时只要 insertVal >= prev.val 或 insertVal <= curr.val 即可插入",
        "若遍历一圈未找到插入点（如所有值相等），则可在任意位置插入（例如回到起点时插入）"
      ],
      "Transformable Parameters": [
        "n 的数量级：0 到 5e4（可调整为更小或支持动态增长）",
        "是否允许重复值：当前允许（非严格递增）",
        "是否严格递增：可改为不允许重复值作为变体",
        "数据类型：Node.val 是否扩展为浮点数或字符串",
        "输入形式：是否提供头节点 vs. 提供最小节点 vs. 提供随机节点",
        "是否在线：连续插入多个值，要求每次插入后仍有序",
        "是否多组数据：批量插入测试",
        "链表结构变化：从循环链表变为普通有序链表或双向循环链表（增强操作灵活性）",
        "目标函数变化：改为求所有可能插入位置的数量（计数型）或返回最优插入位置（如最左）"
      ]
    }
  },
  {
    "title": "扁平化多级双向链表",
    "slug": "Qv1Da2",
    "schema": {
      "Input Structure": "多级双向链表的头节点，每个节点包含三个指针：next、prev 和 child；节点值为正整数（1 <= Node.val <= 10^5）；总节点数 ≤ 1000",
      "Core Constraint": "child 指针指向一个独立的双向子链表，该子链表应被扁平化插入到当前节点与下一个节点之间；prev 和 next 指针在展平后需保持正确双向连接",
      "Objective Function": "将多级双向链表展平为单层双向链表，使得所有节点按深度优先顺序排列，并返回新链表的头节点",
      "Algorithmic Invariant": "使用 DFS 遍历或栈维护待处理的 next 节点；当存在 child 时，先处理 child 子链表，再接回原 next 链；遍历过程中 prev 指针可重建，结构无环且层次关系唯一确定展平顺序",
      "Transformable Parameters": {
        "数据规模": "节点总数 n 的范围：0 ≤ n ≤ 1000",
        "值域约束": "Node.val ∈ [1, 10^5]",
        "是否有序": "原始链表按输入顺序组织，无显式排序要求",
        "是否循环": "链表不循环，以 null 终止",
        "是否多组数据": "单组输入，一次展平操作",
        "是否在线": "离线处理，一次性输入整个链表结构",
        "child 结构形态": "可变换为左孩子右兄弟树结构进行遍历；允许 child 链表为空或嵌套任意深度"
      }
    }
  },
  {
    "title": "回文链表",
    "slug": "aMhZSa",
    "schema": "{\n  \"Input Structure\": \"单向链表 head，节点数 n ∈ [1, 10^5]，每个节点值 node.val ∈ [0, 9]，链表结构为 ListNode* 或等价指针形式\",\n  \"Core Constraint\": \"回文性质要求序列正向与反向完全一致；由于是单向链表，无法直接逆向遍历，需通过结构变换或指针技巧获取逆序信息\",\n  \"Objective Function\": \"判定链表是否为回文（布尔值：true / false）\",\n  \"Algorithmic Invariant\": \"使用快慢指针定位中点，反转后半段链表后与前半段逐节点比较；比较过程中若所有对应节点相等，则维持回文不变性；反转恢复可保证原链表结构可选地被保留\",\n  \"Transformable Parameters\": {\n    \"n 的数量级\": \"1e5（允许线性算法）\",\n    \"值域范围\": \"[0, 9]（可扩展为字符或其他可比类型）\",\n    \"链表类型\": \"单向无环链表（可变体：循环链表、双向链表）\",\n    \"是否允许修改链表\": \"是（O(1) 空间解法依赖此操作），也可要求不修改（需额外空间）\",\n    \"是否多组数据\": \"否（可扩展为多测）\",\n    \"是否在线处理\": \"否（离线输入）\",\n    \"目标函数变体\": [\"计数回文子链表个数\", \"最长回文前缀\", \"构造回文链表\"]\",\n    \"输入形式\": \"头指针（可变为数组表示、流式输入等）\"\n  }\n}"
  },
  {
    "title": "重排链表",
    "slug": "LGjMqU",
    "schema": {
      "Input Structure": [
        "单链表 head，长度为 n，节点形式为 L₀ → L₁ → … → Lₙ₋₁ → Lₙ",
        "每个节点包含整数值 val（1 <= val <= 1000）",
        "链表长度范围：[1, 5 * 10⁴]"
      ],
      "Core Constraint": [
        "重排规则为交替连接前段与后段节点：L₀ → Lₙ → L₁ → Lₙ₋₁ → ...",
        "必须实际交换节点指针，不能仅修改节点值",
        "只能遍历链表常数次（隐式约束：需高效实现）",
        "后半段节点需要逆序访问，而链表不支持随机访问"
      ],
      "Objective Function": "将链表重排为前后交错的顺序结构并返回头节点",
      "Algorithmic Invariant": [
        "链表可被分割为前半段和后半段两个独立部分",
        "后半段反转后，其顺序变为 Lₙ → Lₙ₋₁ → … → Lₙ/₂₊₁，便于交替合并",
        "使用快慢指针可在线性时间内定位中点",
        "交替合并过程中，双指针分别遍历前半段（正序）与反转后的后半段（逆序），每步插入一个后段节点到前段中"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 5 * 10⁴",
        "值域": "节点值 ∈ [1, 1000]",
        "是否有序": "输入链表无序性不影响结构，但位置索引决定重排逻辑",
        "是否循环": "可变体：环形链表下的类似重排",
        "是否多组输入": "可扩展为多组链表批量处理",
        "是否在线": "可设计为动态插入后触发重排的在线版本",
        "操作类型扩展": [
          "允许删除或修改节点后再重排",
          "输出第 k 步后的中间状态",
          "限制额外空间使用（如不允许转数组）"
        ]
      }
    }
  },
  {
    "title": "两数相加 II",
    "slug": "lMSNwu",
    "schema": {
      "Input Structure": [
        "两个非空链表 l1 和 l2，每个节点存储一位数字",
        "链表长度 n ∈ [1, 100]",
        "节点值 node.val ∈ [0, 9]",
        "数字最高位位于链表头（即：从左到右为高位到低位）",
        "无前导零（除了单个节点 0）"
      ],
      "Core Constraint": [
        "加法运算需按位进行，考虑进位传播",
        "链表顺序为高位在前，无法直接对齐个位进行逐位相加",
        "若不允许修改原链表，则不能通过反转链表来调整访问顺序"
      ],
      "Objective Function": "构造一个新的链表表示两个数的和，结果链表也应为高位在前",
      "Algorithmic Invariant": [
        "使用栈结构可逆序访问链表元素，从而实现从低位到高位的加法模拟",
        "维护一个进位变量 carry，每轮计算 (val1 + val2 + carry) 并生成新节点",
        "新链表节点按计算顺序反向构建（头插法），或通过递归/栈回溯正向构造结果",
        "不依赖修改原链表的前提下，仍能保证每一位正确对齐与进位传递"
      ],
      "Transformable Parameters": {
        "是否允许修改原链表": true,
        "输入形式": "链表（高位在前）",
        "数据规模": "链表长度 ≤ 100",
        "值域限制": "每位数字 ∈ [0,9]",
        "是否多组数据": false,
        "是否在线处理": false,
        "进阶约束": [
          "不能翻转链表 → 强制使用辅助栈或递归",
          "可扩展为支持负数、小数部分、任意进制"
        ],
        "输出要求": "返回新链表，结构同输入（高位在前）"
      }
    }
  },
  {
    "title": "反转链表",
    "slug": "UHnkqh",
    "schema": {
      "Input Structure": "单链表 head，节点数 n ∈ [0, 5000]，每个节点值 val ∈ [-5000, 5000]",
      "Core Constraint": "链表结构为单向顺序结构，只能从头到尾遍历；反转操作需通过指针重连实现，不能使用额外数组存储值",
      "Objective Function": "返回反转后链表的头节点（构造方案）",
      "Algorithmic Invariant": "维护三个指针：prev（已反转部分的头）、curr（当前待反转节点）、nextTemp（暂存 curr.next）；每次将 curr 指向 prev，并推进指针，保持链不断裂且状态正确迁移",
      "Transformable Parameters": [
        "是否允许使用递归（栈空间）",
        "链表长度范围（n 的数量级）",
        "节点值域范围",
        "是否循环链表（变形题）",
        "是否双向链表",
        "是否要求原地反转",
        "是否在线构建反转（边插入边反转）",
        "是否多组测试数据"
      ]
    }
  },
  {
    "title": "相交链表",
    "slug": "3u1WK4",
    "schema": {
      "Input Structure": [
        "两个单链表 headA 和 headB",
        "链表节点数分别为 m 和 n，0 <= m, n <= 3 * 10^4",
        "每个节点具有唯一内存地址（无环）",
        "链表结构不可修改（保持原始结构）",
        "节点值范围：1 <= Node.val <= 10^5"
      ],
      "Core Constraint": [
        "若两链表相交，则从某节点开始到末尾完全重合（共享节点）",
        "相交结构呈 'Y' 形而非 'X' 形（最多一个交点）",
        "不存在环，保证链式结构为简单路径",
        "判断依据是节点内存地址相同，而非值相同"
      ],
      "Objective Function": [
        "判定两个链表是否存在交点",
        "若存在，返回首个相交节点的引用",
        "若不存在，返回 null"
      ],
      "Algorithmic Invariant": [
        "双指针遍历 A+B 与 B+A 的长度相同，若有交点则会在第二轮相遇",
        "指针 pA 遍历完 A 后转向 headB，pB 遍历完 B 后转向 headA",
        "当 pA == pB 时，该位置即为交点或共同结束（null）",
        "移动过程中不破坏链表结构，仅用 O(1) 额外空间"
      ],
      "Transformable Parameters": {
        "数据规模": "m, n ∈ [0, 3*10^4]",
        "值域限制": "Node.val ∈ [1, 10^5]",
        "是否允许环": "原题禁止；可变形为‘带环链表求交点’",
        "输入形式": "headA 和 headB 头节点；可改为数组描述 + skip 值构造",
        "输出要求": "返回节点引用；可改为返回布尔 / 交点值 / 下标",
        "是否多组数据": "单次查询；可扩展为多次询问的离线版本",
        "是否在线": "静态输入；可设计动态插入链表段后查询",
        "内存约束": "要求 O(1) 空间；可放宽至哈希表解法（O(n)）",
        "结构变更": "不可修改链表；可放开为允许临时修改 next 指针"
      }
    }
  },
  {
    "title": "环形链表 II",
    "slug": "c32eOV",
    "schema": {
      "Input Structure": "单向链表 ListNode *head，节点数 n ∈ [0, 10^4]，每个节点值域为 [-10^5, 10^5]，链表可能存在环（尾部连接到某一前驱节点），无外部索引输入（pos 仅用于题面描述）",
      "Core Constraint": "若链表有环，则从头节点出发沿 next 指针最终会进入一个循环；环的入口节点是唯一满足：存在两个不同路径长度从头到达该节点的节点；问题结构具有状态演化中的周期性与相遇性质",
      "Objective Function": "定位并返回链表中环的入口节点；若无环，返回 null",
      "Algorithmic Invariant": "使用快慢双指针（Floyd 判圈算法）：\n- 快指针每次走两步，慢指针每次走一步，若存在环则二者必在环内相遇\n- 相遇后，将一指针重置至头节点，两指针均以单步前进，再次相遇点即为环入口\n- 此不变量成立基于：设头到入口距离为 a，入口到相遇点为 b，环剩余为 c，则有 a = c (mod 环长)，故重置后同步移动可对齐入口",
      "Transformable Parameters": [
        "链表是否允许修改（当前约束：不允许修改）",
        "空间复杂度要求：O(1) 或允许哈希表存储访问记录",
        "是否提供 pos 参数作为输入（当前：不提供，仅用于描述）",
        "是否多组测试数据",
        "是否在线构建链表（动态插入/删除导致环变化）",
        "链表是否为双向链表（可逆向追踪）",
        "是否要求返回环的长度或整个环的节点集合（而非仅入口）",
        "是否存在多个独立环（当前假设至多一个环）",
        "节点值是否唯一或可重复（影响基于值的查找策略）"
      ]
    }
  },
  {
    "title": "删除链表的倒数第 N 个结点",
    "slug": "SLwz0R",
    "schema": {
      "Input Structure": [
        "链表 L = [Node_1, Node_2, ..., Node_sz], 其中每个节点包含整数值和指向下一个节点的指针",
        "Node.val ∈ [0, 100]",
        "链表长度 sz 满足 1 <= sz <= 30",
        "给定整数 n，表示要删除从末尾数第 n 个节点，且 1 <= n <= sz"
      ],
      "Core Constraint": [
        "链表为单向结构，无法直接访问前驱节点",
        "目标节点的位置由其与链表末尾的距离决定（倒数第 n 个）",
        "仅允许一次遍历完成操作（进阶要求隐含约束）",
        "删除操作需维护链表连接完整性"
      ],
      "Objective Function": "删除链表中倒数第 n 个节点，并返回修改后链表的头结点",
      "Algorithmic Invariant": [
        "使用双指针技术：快指针先走 n 步，慢指针再开始移动",
        "当快指针到达末尾时，慢指针恰好位于待删除节点的前驱位置",
        "快慢指针之间的距离始终保持 n，保证定位准确性",
        "头结点可能被删除，因此需引入虚拟头节点（dummy）以统一处理"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题较小（sz ≤ 30），可扩展至大规模链表（如 1e5）以强调一趟扫描必要性",
        "是否多组数据": false,
        "是否在线": false,
        "输入形式": "原始为静态链表构造数组 + n；可变形为流式节点输入或支持动态删除查询",
        "链表类型": [
          "单链表 → 双链表（降低难度，可反向遍历）",
          "普通链表 → 循环链表（增加边界复杂度）"
        ],
        "删除策略": [
          "删除倒数第 n 个 → 删除所有满足某种位置模式的节点（如每隔 k 个删一个）",
          "删除 → 替换/标记"
        ],
        "是否要求常数空间": true,
        "是否允许两趟扫描": [
          "基础版本允许；进阶版本强制限制为一趟扫描，形成算法分层"
        ]
      }
    }
  },
  {
    "title": "回文子串",
    "slug": "a7VOhD",
    "schema": {
      "Input Structure": "字符串 s[1..n]，其中 n = |s|，s 由小写英文字母组成，1 <= n <= 1000",
      "Core Constraint": "回文子串的判定依赖于中心对称性：一个子串是回文当且仅当其首尾字符相等且内部子串也是回文；所有子串由起始和结束位置唯一确定",
      "Objective Function": "计数 —— 统计所有回文子字符串的总数（按不同起止位置视为不同子串）",
      "Algorithmic Invariant": "以每个位置为中心向外扩展时，若 s[i-k] == s[i+k]，则当前区间 [i-k, i+k] 是回文；对于偶数长度回文，使用双中心 (i, i+1) 扩展；每次扩展保持已验证区域的回文性质不变",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1000（可改为更大规模并要求 O(n) 解法）",
        "字符类型": "是否仅限小写字母（可推广至大写、数字、Unicode）",
        "是否区分重复子串": "可变：是否将相同内容但不同位置的子串视为同一项",
        "目标函数形式": "可变换为：最长回文子串、是否存在长度≥K的回文子串、回文子序列计数等",
        "输入结构维度": "可扩展至二维：在字符矩阵中统计回文子矩形或回文路径",
        "是否在线处理": "是否支持动态添加字符并实时更新回文子串数量",
        "是否要求去重": "输出无重复内容的回文子串数量"
      }
    }
  },
  {
    "title": "验证回文串 II",
    "slug": "RQku0D",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length_range": [
          1,
          100000
        ],
        "properties": [
          "non-empty",
          "1D sequence"
        ]
      },
      "Core Constraint": {
        "description": "回文结构具有对称性约束；若首尾字符不匹配，最多允许一次删除操作来尝试恢复对称性",
        "key_insight": "局部不匹配时，可通过跳过左或右字符之一试探剩余子串是否为回文",
        "constraint_type": "single-edit tolerance under symmetry"
      },
      "Objective Function": {
        "type": "decision problem",
        "goal": "determine whether the string can become a palindrome by deleting at most one character"
      },
      "Algorithmic Invariant": {
        "invariant_description": "双指针从两端向内收敛，首次遇到不匹配时，进入唯一一次决策点：尝试跳过左侧或右侧字符，并验证剩余子串是否全局回文",
        "preserved_properties": [
          "在不匹配前，外部已匹配部分不影响内部判断",
          "一旦使用删除机会，后续必须严格回文",
          "决策具有贪心最优性：首次冲突即决定所有可能路径"
        ],
        "main_algorithm": "greedy two-pointer",
        "supporting_method": "substring palindrome check"
      },
      "Transformable Parameters": {
        "edit_limit": {
          "default": 1,
          "possible_values": [
            0,
            1,
            2,
            "k"
          ],
          "transformation": "≤K deletions → 转化为编辑距离类问题"
        },
        "operation_type": {
          "options": [
            "delete",
            "insert",
            "replace"
          ],
          "current": "delete"
        },
        "input_dimension": {
          "current": "1D string",
          "extendable_to": [
            "2D grid",
            "circular string"
          ]
        },
        "query_mode": {
          "mode": "offline single query",
          "can_be_transformed_to": [
            "online queries",
            "multiple strings"
          ]
        },
        "output_detail": {
          "current": "boolean decision",
          "possible": [
            "return index to delete",
            "count valid deletion positions",
            "list all solutions"
          ]
        },
        "string_properties": {
          "sorted": false,
          "unique_chars": false,
          "case_sensitive": true,
          "allow_uppercase": false
        },
        "data_scale": {
          "n": "1e5",
          "adjustable": true,
          "impacts": "rules out O(n^2) naive methods; requires early termination or linear scan"
        }
      }
    }
  },
  {
    "title": "验证回文串",
    "slug": "XltzEq",
    "schema": {
      "Input Structure": [
        "字符串 s[1..n]",
        "s 由 ASCII 字符组成",
        "1 <= n <= 2 * 10^5"
      ],
      "Core Constraint": [
        "回文判定仅基于字母和数字字符",
        "忽略字母大小写差异",
        "非字母数字字符在比较中被跳过",
        "有效字符序列需满足对称性约束"
      ],
      "Objective Function": "判定处理后的字符序列是否为回文串（布尔值：是/否）",
      "Algorithmic Invariant": [
        "双指针从两端向内推进",
        "左指针始终指向下一个待比较的有效字符，右指针同理",
        "每次比较前跳过无效字符，不破坏对称性检查的完整性",
        "指针相遇前若出现不匹配，则非回文；否则为回文"
      ],
      "Transformable Parameters": {
        "字符集类型": "ASCII → Unicode / 扩展字母（如带重音符号）",
        "有效字符定义": "仅字母数字 → 可配置字符类别（如允许特定符号）",
        "大小写敏感性": "忽略大小写 → 区分大小写",
        "目标函数变换": "判定回文 → 计数最长回文前缀 / 构造最短回文串",
        "输入形式": "单次字符串 → 多组测试数据 / 在线流式字符输入",
        "数据规模": "n <= 2e5 → 更大规模或实时处理要求",
        "预处理要求": "显式提取有效字符 → 原地双指针跳过"
      }
    }
  },
  {
    "title": "最小覆盖子串",
    "slug": "M1oyTv",
    "schema": {
      "Input Structure": [
        "一维字符串 s[1..n], 其中 n = |s|",
        "一维字符串 t[1..m], 其中 m = |t|",
        "字符集：大小写英文字母",
        "s 和 t 的长度满足 1 <= n, m <= 10^5"
      ],
      "Core Constraint": [
        "目标子串必须覆盖 t 中所有字符的频次（多重集包含）",
        "即：对于每个字符 c，子串中 c 的出现次数 >= t 中 c 的出现次数",
        "子串在 s 中必须是连续的"
      ],
      "Objective Function": "求 s 中满足字符覆盖条件的最短连续子串；若不存在则返回空字符串",
      "Algorithmic Invariant": [
        "使用滑动窗口维护当前区间 [l, r] 内的字符频次计数",
        "右指针扩展以寻找可行解，左指针收缩以优化窗口长度",
        "当窗口内字符频次满足 t 的需求时，状态为‘覆盖完成’",
        "通过哈希表或数组记录目标频次与当前盈余/缺口，保持移动的单调有效性",
        "每次移动均保持‘最小左端点已尝试’的贪心性质"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 的数量级": [
            "<= 10^3",
            "<= 10^5",
            "可扩展至 10^6"
          ],
          "字符集大小": [
            "仅小写字母",
            "大小写混合",
            "含数字或特殊字符"
          ]
        },
        "输入形式": [
          "单组 s 和 t",
          "多组查询（固定 t，多组 s）",
          "在线流式输入 s（逐字符输入）"
        ],
        "约束条件": [
          "是否要求严格最短（唯一答案）",
          "是否允许近似解（如长度不超过最优 k 倍）",
          "是否加入额外约束（如子串位置限制、禁止某些字符相邻）"
        ],
        "目标函数变形": [
          "改为求最长子串（仍满足覆盖）",
          "改为计数满足条件的子串数量",
          "改为判定是否存在长度 ≤ K 的解"
        ],
        "结构变形": [
          "从线性字符串 → 环形字符串",
          "从一维 → 二维网格中的路径覆盖",
          "从字符频次覆盖 → 子序列覆盖（非连续）"
        ],
        "操作支持": [
          "静态输入",
          "支持修改 s 或 t 后重新查询（动态版本）",
          "支持删除/插入字符后维护答案"
        ]
      }
    }
  },
  {
    "title": "无重复字符的最长子串",
    "slug": "wtcaE1",
    "schema": {
      "Input Structure": [
        "一维字符串 s[1..n]",
        "字符集：英文字母、数字、符号、空格",
        "n ∈ [0, 5×10⁴]"
      ],
      "Core Constraint": [
        "子串必须是连续的",
        "任意字符在子串中至多出现一次",
        "重复性由字符频次决定，局部窗口内可维护唯一性"
      ],
      "Objective Function": "求满足无重复字符条件的最长连续子串的长度（最大化）",
      "Algorithmic Invariant": [
        "使用滑动窗口双指针 L 和 R，维护区间 [L, R] 内字符的频次哈希表",
        "右指针 R 每次扩展一位，若新字符未在当前窗口中出现，则更新最大长度",
        "若新字符已存在，则左指针 L 不断右移直至冲突消除，保持窗口合法性",
        "窗口扩展与收缩过程中，始终维持内部无重复字符的状态不变量"
      ],
      "Transformable Parameters": {
        "n 的数量级": [
          "n ≤ 5e4",
          "可调整为 n ≤ 1e6（要求 O(n) 解法）"
        ],
        "字符集类型": [
          "ASCII 字符",
          "仅小写字母（可降维用数组代替哈希表）",
          "Unicode 字符串（测试数据结构适应性）"
        ],
        "是否允许重复": [
          "最多 k 次重复（变形为最多k个重复字符的最长子串）",
          "每个字符恰好出现两次等约束"
        ],
        "目标函数变化": [
          "输出方案数（计数类）",
          "返回字典序最小的最长子串（构造类）",
          "判定是否存在长度 ≥ K 的无重复子串（判定类）"
        ],
        "输入形式": [
          "单组字符串",
          "多组查询（离线批处理）",
          "流式字符输入（在线模式，支持 append 操作）"
        ],
        "结构维度变换": [
          "二维字符网格中的最长无重复路径",
          "环形字符串（首尾相连）",
          "允许跳过最多 m 个字符的子序列版本"
        ]
      }
    }
  },
  {
    "title": "找到字符串中所有字母异位词",
    "slug": "VabMRr",
    "schema": "{\n  \"Input Structure\": [\n    \"一维字符串 s[1..n], 其中 n = |s|\",\n    \"一维字符串 p[1..m], 其中 m = |p|\",\n    \"字符集限定为小写字母 a-z\",\n    \"m <= n\",\n    \"所有字符均为非负ASCII码（具体值域：'a' 到 'z'）\"\n  ],\n  \"Core Constraint\": [\n    \"变位词定义：两字符串字符频次完全相同\",\n    \"目标子串长度固定为 m = |p|\",\n    \"滑动窗口内字符频率分布必须与 p 的字符频率分布一致\",\n    \"局部信息可通过频次统计压缩，支持 O(1) 扩展/收缩\"\n  ],\n  \"Objective Function\": \"计数并构造所有满足条件的子串起始索引列表（即：判定 + 构造方案）\",\n  \"Algorithmic Invariant\": [\n    \"使用滑动窗口维护当前区间 [l, r] 内字符频次\",\n    \"通过双指针实现窗口平移：每次移动 l 或 r 时，仅更新进出字符的计数\",\n    \"利用频次匹配状态变量（如：match_count）判断当前窗口是否构成变位词\",\n    \"窗口大小恒等于 m，因此每次移动左端点前检查是否匹配\",\n    \"频次数组差分比较具有可加性与可撤销性，支持增量更新\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n 和 m 的数量级\": \"1 <= n, m <= 3 * 10^4\",\n      \"可扩展至 10^5~10^6（要求线性解法）\"\n    },\n    \"字符集\": [\n      \"仅小写字母（当前设定）\",\n      \"可变换为大写字母、数字、Unicode 字符等\"\n    ],\n    \"输入形式\": [\n      \"静态一次性输入（当前）\",\n      \"可改为在线流式输入 s，要求实时返回可能的起始位置\"\n    ],\n    \"约束条件\": [\n      \"子串长度严格等于 |p|（当前）\",\n      \"可变形为：长度 ≥ |p| 且包含 p 的变位词作为子序列\",\n      \"或允许最多 k 个字符不同（模糊匹配）\"\n    ],\n    \"输出形式\": [\n      \"返回所有起始索引（当前）\",\n      \"可改为返回子串集合、去重后的结果、最长连续段等\"\n    ],\n    \"多组数据\": [\n      \"单组 s 和 p（当前）\",\n      \"可扩展为多组 p 查询同一 s（离线 / 在线）→ 转化为模式匹配预处理问题\"\n    ],\n    \"是否有序\": \"s 和 p 均无序，但 s 按顺序扫描（顺序结构关键）\"\n  }\n}"
  },
  {
    "title": "字符串的排列",
    "slug": "MPnaiL",
    "schema": {
      "Input Structure": {
        "s1": "string of length m, containing only lowercase English letters",
        "s2": "string of length n (n >= m), containing only lowercase English letters",
        "constraints": [
          "1 <= m, n <= 10^4",
          "characters are from 'a' to 'z'"
        ]
      },
      "Core Constraint": {
        "description": "A permutation of s1 exists as a contiguous substring in s2 if and only if there is a window in s2 of length m with exactly the same character frequency as s1.",
        "key_insight": "Character frequency distribution is invariant under permutation; thus matching multiset in a sliding window implies existence of permutation."
      },
      "Objective Function": "Determine whether any contiguous substring of s2 of length |s1| has the same character frequency distribution as s1 (i.e.,判定是否存在).",
      "Algorithmic Invariant": {
        "technique": "Sliding Window with Fixed Length",
        "invariants": [
          "The window size remains constant at |s1| during traversal.",
          "Character frequency count of current window in s2 is maintained incrementally: add rightmost character, remove leftmost character.",
          "Equality of frequency vectors (or hash maps) between s1 and current window implies valid anagram/sub-permutation.",
          "All operations preserve O(1) amortized update per step due to fixed alphabet size (26 letters)."
        ],
        "optimality_condition": "Since comparison can be reduced to tracking mismatched character counts, we can maintain a single integer diff counter for efficiency — this preserves monotonic progress toward feasibility."
      },
      "Transformable Parameters": {
        "data_size": {
          "m_n_range": "Can scale from 1e3 → 1e5 → streaming",
          "alphabet_size": "Extend from 26 to arbitrary Unicode or case-sensitive sets"
        },
        "input_form": [
          "Case sensitivity: toggle between case-sensitive and insensitive",
          "Allow non-letter characters: digits, symbols"
        ],
        "temporal_behavior": [
          "Offline batch processing → Online stream querying (real-time anagram detection)",
          "Support dynamic updates: insert/delete in s2"
        ],
        "structural_variation": [
          "Change from 'exact permutation' to 'at most k differing characters'",
          "Generalize to 's1's permutation appears as subsequence' (harder variant)"
        ],
        "output_requirement": [
          "Return boolean (existence) → return all starting indices → return closest match index",
          "Return minimal edit distance to form a permutation"
        ],
        "constraint_modification": [
          "Relax exact frequency match to bounded divergence (e.g., chi-square test threshold)",
          "Impose additional ordering constraints within the window"
        ]
      }
    }
  },
  {
    "title": "二维区域和检索 - 矩阵不可变",
    "slug": "O4NDxx",
    "schema": {
      "Input Structure": {
        "type": "2D matrix",
        "dimensions": "m x n",
        "element_type": "integer",
        "constraints": [
          "m == matrix.length",
          "n == matrix[i].length",
          "1 <= m, n <= 200",
          "-10^5 <= matrix[i][j] <= 10^5"
        ],
        "initialization": "NumMatrix(int[][] matrix) initializes with given 2D integer matrix"
      },
      "Core Constraint": {
        "description": "Submatrix sum queries are static and multiple; precomputation is beneficial to achieve efficient query response.",
        "key_idea": "Each query asks for the sum over a contiguous rectangular region defined by two corners (row1, col1) and (row2, col2).",
        "structure_dependency": "The 2D prefix sum can be constructed because addition is associative and commutative, and regions can be decomposed using inclusion-exclusion."
      },
      "Objective Function": {
        "goal": "Compute the sum of elements in a specified submatrix",
        "function_type": "Range Query - Summation",
        "output_type": "integer",
        "query_count": "Up to 10^4 calls to sumRegion"
      },
      "Algorithmic Invariant": {
        "primary_method": "2D Prefix Sum",
        "invariants": [
          "Prefix[i][j] = sum of all elements in submatrix from (0,0) to (i-1,j-1)",
          "Any submatrix sum can be computed in O(1) time using inclusion-exclusion on precomputed prefix sums",
          "Precomputation preserves correctness under decomposition: S(row1,col1,row2,col2) = Prefix[row2+1][col2+1] - Prefix[row1][col2+1] - Prefix[row2+1][col1] + Prefix[row1][col1]"
        ],
        "complexity_tradeoff": "O(mn) preprocessing enables O(1) per query, optimal when query count >> number of updates"
      },
      "Transformable Parameters": {
        "data_size": {
          "m_n_range": "1 <= m, n <= 200",
          "can_scale": true,
          "scaled_version_hint": "If m,n up to 1e3 or more, space optimization or sparse methods may be needed"
        },
        "value_domain": {
          "range": [
            -100000,
            100000
          ],
          "allows_negative": true
        },
        "input_form": {
          "static_matrix": true,
          "mutable": false,
          "variant_slot": "Can be transformed into mutable version (with update operations) → leads to 2D Fenwick Tree / Segment Tree"
        },
        "query_mode": {
          "offline_vs_online": "Online queries (each depends on previous initialization)",
          "batch_possible": false,
          "streaming_adaptation": "Support incremental queries without re-initialization"
        },
        "multiple_instances": {
          "multi_test_cases": false,
          "can_extend": true,
          "extension_hint": "Multiple independent matrices → add reset() or reuse initialization"
        },
        "dimensionality": {
          "current": "2D",
          "transformable_to": [
            "1D (LeetCode 303)",
            "3D (cube sum queries)",
            "higher-dimensional hyperrectangle queries"
          ]
        },
        "operation_type": {
          "current": "sum",
          "can_change_to": [
            "min",
            "max",
            "xor",
            "product"
          ],
          "constraint_on_change": "Only sum allows full O(1) 2D decomposition via inclusion-exclusion; others require different data structures"
        },
        "update_support": {
          "current": "immutable",
          "possible_transformation": "Add update(i, j, delta) → requires BIT / Segment Tree",
          "complexity_impact": "Changes from O(mn) init + O(1) query to O(log m log n) per operation"
        }
      }
    }
  },
  {
    "title": "寻找数组的中心下标",
    "slug": "tvdfij",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n ≥ 1，元素值域为 [-1000, 1000]",
      "Core Constraint": "中心下标 i 满足：左侧元素和（nums[0] 到 nums[i-1]）等于右侧元素和（nums[i+1] 到 nums[n-1]）；左右区间为空时和为 0",
      "Objective Function": "寻找满足条件的最靠左的中心下标；若不存在则返回 -1",
      "Algorithmic Invariant": "总和 S 固定，遍历过程中维护当前前缀和 prefixSum，则位置 i 为中心下标当且仅当 prefixSum == S - prefixSum - nums[i]；即 2 * prefixSum + nums[i] == S；该条件可在 O(1) 时间内验证",
      "Transformable Parameters": {
        "数据规模": "n 的数量级可变（如 1e4 → 1e5 或支持动态扩展）",
        "值域范围": "nums[i] 是否包含负数、是否非负、是否为正整数",
        "数组性质": "是否有序、是否循环数组",
        "目标函数变化": [
          "改为返回所有中心下标（计数/枚举）",
          "求最大/最小的中心下标",
          "是否存在中心下标（判定问题）"
        ],
        "输入形式": "是否多组测试数据、是否在线输入（流式数组）",
        "约束变形": "允许误差容忍（如左右和之差 ≤ K）、加权左右和平衡"
      }
    }
  },
  {
    "title": "连续数组",
    "slug": "A1NYOS",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中每个元素为 0 或 1",
      "Core Constraint": "连续子数组中 0 和 1 的数量相等，等价于将 0 视为 -1 后，子数组和为 0",
      "Objective Function": "求满足条件的最长连续子数组的长度（最大化）",
      "Algorithmic Invariant": "前缀和 + 哈希表记录首次出现位置：若两个位置的前缀和相同，则其间子数组和为 0；最早出现的位置能保证长度最大",
      "Transformable Parameters": [
        "n 的数量级：1e5（可改为 1e6 要求在线处理）",
        "值域：是否扩展为多类元素（如 0,1,2）并要求各类数量相等",
        "输入形式：是否允许负数或非二进制输入",
        "是否多组数据",
        "是否在线输入（数据流形式）",
        "目标变换：从最长长度 → 计数满足条件的子数组个数",
        "约束变化：从相等数量 → 0 比 1 多 k 个"
      ]
    }
  },
  {
    "title": "和为 K 的子数组",
    "slug": "QTMn0o",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 1 <= n <= 2 * 10^4，-1000 <= nums[i] <= 1000；给定目标整数 k，-10^7 <= k <= 10^7",
      "Core Constraint": "连续子数组的和等于 k；前缀和之差决定子数组和：若 pre[j] - pre[i] = k，则子数组 nums[i+1..j] 的和为 k",
      "Objective Function": "计数：统计和为 k 的连续子数组的个数",
      "Algorithmic Invariant": "使用哈希表维护前缀和出现次数；遍历过程中，对于当前前缀和 s，查询 s - k 是否存在；每一步更新不影响之前计算的正确性，且满足可加性与无后效性",
      "Transformable Parameters": {
        "数据规模": "n 的范围可调整（如 1e5 → 1e6），是否允许超大规模（需考虑哈希性能）",
        "值域约束": "nums[i] 是否非负（影响滑动窗口可行性）、k 是否为正",
        "输入形式": "是否多组数据、是否在线输入（动态添加元素）",
        "目标函数变化": "由计数变为判定是否存在、或求最长/最短满足条件的子数组长度",
        "结构变形": "从 1D 数组扩展到 2D 矩阵（子矩阵和为 k）、环形数组",
        "操作类型": "支持修改操作（动态版本）、区间查询（多个 k 查询）"
      }
    }
  },
  {
    "title": "打家劫舍",
    "slug": "Gu0c2T",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "一维数组 nums[1..n]，表示沿街房屋中存放的现金金额",
        "constraints": {
          "length_range": [
            1,
            100
          ],
          "value_range": [
            0,
            400
          ]
        }
      },
      "Core Constraint": {
        "description": "相邻房屋不能同时被偷窃，否则会触发报警；即选择的子序列中任意两个元素在原数组中不能相邻",
        "key_property": "局部选择影响全局可行性，存在前后依赖关系",
        "dependency": "当前决策仅依赖前两个位置的最优解"
      },
      "Objective Function": {
        "type": "maximization",
        "goal": "计算在不触发警报的前提下，能够获得的最大金钱总额",
        "output_type": "single integer"
      },
      "Algorithmic Invariant": {
        "paradigm": "dynamic programming",
        "invariants": [
          "dp[i] = max(dp[i-1], dp[i-2] + nums[i]) 表示前 i 个房屋能偷到的最大金额",
          "每一步的状态只依赖于前两个状态，具有无后效性",
          "状态转移过程中保持最优子结构：局部最优可合并为全局最优",
          "可通过滚动变量压缩空间，仅维护前两个状态"
        ],
        "monotonicity": false,
        "optimal_substructure": true,
        "overlapping_subproblems": true
      },
      "Transformable Parameters": {
        "n_scale": "small (≤ 100)",
        "value_domain": "bounded non-negative integers",
        "array_ordering": "unordered (but index order matters due to adjacency constraint)",
        "circular_layout": false,
        "online_input": false,
        "multiple_queries": false,
        "modifications_allowed": false,
        "additional_constraints": [],
        "possible_transforms": [
          "输入变为环形（首尾相邻）→ House Robber II",
          "目标函数变为计数：满足条件的方案数",
          "加入负权值（惩罚项）",
          "二维扩展：网格状房屋布局",
          "允许跳过最多 k 间连续房屋",
          "在线查询：动态添加房屋并实时返回最大收益"
        ]
      }
    }
  },
  {
    "title": "乘积小于 K 的子数组",
    "slug": "ZVAVXX",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "positive integers",
        "length_range": "1 <= n <= 3 * 10^4",
        "value_range": "1 <= nums[i] <= 1000",
        "ordered": true,
        "continuous_subarray_required": true
      },
      "Core Constraint": {
        "product_constraint": "subarray product < k",
        "multiplicative_accumulation": true,
        "monotonicity_under_expansion": "expanding subarray increases product (since all numbers > 1)",
        "local_decision_possible": "if a window [l, r] has product >= k, then all windows extending to the right will also violate if left fixed"
      },
      "Objective Function": {
        "type": "counting",
        "target": "number of contiguous subarrays where product of elements is strictly less than k"
      },
      "Algorithmic Invariant": {
        "two_pointers": {
          "left_pointer_l": "marks the earliest start index for which [l, r] is valid",
          "right_pointer_r": "current end of window being extended",
          "invariant": "for each r, we maintain the smallest l such that the product of nums[l..r] < k; all starting positions from current l to r yield valid subarrays ending at r",
          "shrink_on_violation": "when product >= k, move l forward and divide out nums[l]",
          "expand_r_monotonically": "r increases from 0 to n-1"
        },
        "count_update_rule": "at each r, the number of new valid subarrays ending at r is (r - l + 1)"
      },
      "Transformable Parameters": {
        "k_value": {
          "range": "0 <= k <= 10^6",
          "special_cases": [
            "k == 0 → output always 0 (since all nums[i] >= 1)",
            "k == 1 → only empty or single-element with value <1 possible → none exist"
          ]
        },
        "array_properties": {
          "allows_zeros": false,
          "allows_fractions": false,
          "can_be_negative": false,
          "sorted": false
        },
        "input_variations": [
          "allow negative integers → product sign alternates → requires different state tracking",
          "allow floating point values → precision issues, non-monotonic growth",
          "2D version: count submatrices with product < k",
          "circular array: allow wrapping around"
        ],
        "query_mode": {
          "offline": true,
          "online_queries": false,
          "support_updates": false
        },
        "output_requirements": {
          "only_count": true,
          "list_all_subarrays": false,
          "longest_or_shortest_valid": false
        },
        "data_scale": {
          "n_upper_bound": "3e4",
          "algorithm_complexity_requirement": "O(n) expected due to size"
        }
      }
    }
  },
  {
    "title": "使用最小花费爬楼梯",
    "slug": "GzCJIP",
    "schema": {
      "Input Structure": "一维数组 cost[0..n-1]，其中 n >= 2；每个元素为非负整数，表示在对应阶梯上攀爬所需支付的体力花费；下标从 0 开始；最终目标是到达索引为 n 的位置（即楼层顶部，超出数组末尾）",
      "Core Constraint": "每次可选择爬 1 或 2 个阶梯，支付当前所在阶梯的 cost 后才能移动；起始时可选择从索引 0 或 1 出发；状态转移仅依赖前两个位置的最优解",
      "Objective Function": "求达到楼层顶部（索引 n）所需的最小体力总花费",
      "Algorithmic Invariant": "动态规划状态单调递推：dp[i] = min(dp[i-1], dp[i-2]) + cost[i]，其中 dp[i] 表示到达第 i 阶的最小花费；初始状态分离且局部最优可合并；每一步决策不影响更早状态的最优性",
      "Transformable Parameters": {
        "数据规模": "n 的范围：2 <= n <= 1000（可扩展至 1e5 要求线性解法）",
        "值域": "cost[i] ∈ [0, 999]（可改为负数或更大范围）",
        "是否有序": "cost 数组无序（可设计为单调序列以引入贪心变形）",
        "输入维度": "1D → 可拓展为环形结构（如最后一阶连回第一阶）",
        "目标函数变换": "最小化总花费 → 计数达到顶部的路径数（满足最小花费）→ 判定是否存在花费不超过 K 的路径",
        "是否多组数据": "单次输入 → 多组测试用例",
        "是否在线": "离线一次性输入 → 支持动态修改 cost 值的在线查询（需结合线段树或DP维护）",
        "动作规则变化": "每次走 1 或 2 步 → 可走 1~k 步（滑动窗口优化DP）"
      }
    }
  },
  {
    "title": "长度最小的子数组",
    "slug": "2VG8Kg",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中每个元素为正整数；给定一个正整数 target",
      "Core Constraint": "连续子数组的和 ≥ target；由于数组元素均为正，前缀和具有严格单调性，因此任意扩展子数组长度会增加其和，缩短则减少其和",
      "Objective Function": "求满足和 ≥ target 的连续子数组的最小长度；若不存在则返回 0",
      "Algorithmic Invariant": "使用双指针（滑动窗口）维护当前窗口 [l, r] 内的子数组和：当窗口和 ≥ target 时，尝试收缩左边界以寻找更短的有效子数组；当窗口和 < target 时，扩展右边界。每次移动均保持窗口和的正确性且不遗漏最优解",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1e5",
        "值域": "nums[i] ∈ [1, 1e5], target ∈ [1, 1e9]",
        "是否有序": "数组无序，但元素为正保证了前缀和单调性",
        "是否循环": "否；可变形为环形数组版本",
        "是否多组输入": "单组输入；可扩展为多组测试用例",
        "是否在线": "离线处理；可设计为数据流中动态查询最小长度子数组",
        "目标函数变化": "可改为求最大长度、计数满足条件的子数组个数",
        "约束反转": "可改为和 ≤ target 的最长子数组（需负数支持）",
        "输入维度变换": "可推广至二维矩阵中求最小面积子矩阵和 ≥ target",
        "进阶要求": "存在 O(n) 双指针解法；O(n log n) 解法可通过前缀和 + 二分查找实现"
      }
    }
  },
  {
    "title": "复原 IP 地址",
    "slug": "0on3uN",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n（0 ≤ n ≤ 3000）",
        "s 仅由数字字符 '0'-'9' 组成"
      ],
      "Core Constraint": [
        "有效 IP 地址必须恰好由四个整数段组成，用 '.' 分隔",
        "每个整数段对应一个子串，表示的整数值在 [0, 255] 范围内",
        "每个整数段不能有前导零（即长度大于1时首字符不能为'0'）",
        "所有字符必须被使用且只能使用一次"
      ],
      "Objective Function": "构造并返回所有可能的有效 IP 地址方案（枚举 / 构造类问题）",
      "Algorithmic Invariant": [
        "搜索空间可通过分段位置（插入三个 '.' 的位置）进行剪枝枚举",
        "每一段的合法性（值域、前导零）可在 O(1) 时间验证",
        "深度优先搜索中，已确定的前 k 段不会影响后续段的合法生成条件（局部独立性）",
        "回溯过程中维护当前路径与剩余字符，状态转移具有明确边界"
      ],
      "Transformable Parameters": [
        "字符串长度上限：n ∈ [0, 3000]，可调整为更小或更大规模",
        "是否允许前导零：可设为可选参数（如变形题中允许）",
        "每段数值范围：可改为 [0, 99] 或 [0, 999] 等（改变约束）",
        "IP 段数：可推广为 K 段（如泛化为 '恢复 K 进制地址'）",
        "输入形式：是否多组字符串输入 / 在线查询模式",
        "输出要求：仅计数 / 输出所有方案 / 输出字典序最小方案",
        "字符集扩展：是否包含非数字字符（引入过滤逻辑）"
      ]
    }
  },
  {
    "title": "分割回文串",
    "slug": "M99OJA",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，其中 1 <= n <= 16",
        "字符集：仅小写英文字母",
        "输入形式：单个静态字符串（离线）"
      ],
      "Core Constraint": [
        "每个子串必须是回文串",
        "分割必须覆盖整个字符串且不重叠",
        "所有可能的分割方案需穷尽所有合法组合"
      ],
      "Objective Function": "构造并返回字符串 s 的所有可能的回文分割方案（构造方案类问题）",
      "Algorithmic Invariant": [
        "前缀子串若为回文，则剩余后缀可递归求解其所有回文分割",
        "状态可分解：f(i) 表示从位置 i 到末尾的所有回文分割方案",
        "可通过回溯维护当前路径，并在到达末尾时记录有效方案",
        "预处理回文性（如 DP 预计算所有区间是否为回文）可加速判定"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 16（当前），可扩展至 n <= 20（指数剪枝）或更小用于简化",
        "字符集类型": [
          "仅小写字母（当前）",
          "可推广至大写字母、数字、Unicode 字符",
          "可加入字符频率约束（如最多出现 k 次）"
        ],
        "是否有序": "字符串顺序固定，不可重排",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "回文定义变化": [
          "标准回文（当前）",
          "允许忽略大小写",
          "允许忽略非字母字符",
          "k-近似回文（最多 k 个错配）"
        ],
        "输出要求变化": [
          "返回所有方案（当前）",
          "仅返回方案数",
          "返回最短/最长分割长度",
          "返回字典序最小方案"
        ],
        "附加约束": [
          "无（当前）",
          "每个回文子串长度 >= k",
          "分割段数恰好为 k",
          "不允许单字符回文"
        ],
        "操作类型扩展": [
          "静态查询（当前）",
          "支持字符修改后的重新查询（动态版本）"
        ]
      }
    }
  },
  {
    "title": "三数之和",
    "slug": "1fGaJU",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          -100000,
          100000
        ],
        "duplicates_allowed": true,
        "sorted": false
      },
      "Core Constraint": {
        "triplet_sum_constraint": "a + b + c = 0",
        "uniqueness_constraint": "no duplicate triplets (order-insensitive)",
        "index_distinctness": "three distinct indices i, j, k",
        "global_dependency": "solution set depends on global value distribution and pairwise complement existence"
      },
      "Objective Function": {
        "type": "construction",
        "goal": "find all unique triplets that sum to zero",
        "output_form": "list of lists, each inner list is a triplet [a, b, c] with a <= b <= c"
      },
      "Algorithmic Invariant": {
        "main_algorithm": "two pointers with outer loop",
        "invariants": [
          "array is sorted to enable duplicate skipping and two-pointer movement",
          "for fixed first element nums[i], problem reduces to 2Sum II on subarray nums[i+1:]",
          "left and right pointers move based on current sum vs target (0 - nums[i])",
          "duplicate triplets avoided by skipping same values in outer and inner loops"
        ],
        "state_monotonicity": "as left pointer increases or right decreases, the sum changes monotonically",
        "correctness_preservation": "each move maintains the invariant that no valid solution is skipped due to ordering and exhaustive scan"
      },
      "Transformable Parameters": {
        "n_value": "0 <= n <= 3000",
        "value_domain": "integers in [-1e5, 1e5]",
        "input_sorted": {
          "default": false,
          "can_be_transformed_to_sorted": true
        },
        "target_sum": {
          "default": 0,
          "transformable": true,
          "examples": [
            "K-sum",
            "3Sum Closest",
            "4Sum"
          ]
        },
        "uniqueness_requirement": {
          "default": "no duplicate triplets",
          "can_be_relaxed": true,
          "variants": [
            "count only",
            "allow repeated elements",
            "distinct indices only"
          ]
        },
        "output_type": {
          "default": "all solutions",
          "alternatives": [
            "existence check",
            "number of triplets",
            "one solution only"
          ]
        },
        "online_processing": false,
        "multi_query_support": false,
        "data_update_support": false,
        "dimension_extension": {
          "possible": true,
          "directions": [
            "2D array",
            "higher k-tuples",
            "tree-based nodes"
          ]
        }
      }
    }
  },
  {
    "title": "括号生成",
    "slug": "IDBivT",
    "schema": {
      "Input Structure": {
        "type": "Integer",
        "value_range": "1 <= n <= 8",
        "description": "正整数 n，表示括号的对数"
      },
      "Core Constraint": {
        "constraints": [
          "生成的字符串由恰好 n 个 '(' 和 n 个 ')' 组成",
          "任意前缀中 '(' 的数量不少于 ')' 的数量",
          "最终字符串中 '(' 和 ')' 数量相等"
        ],
        "structure": "深度优先搜索状态空间中的合法路径约束",
        "dependency": "当前状态是否可扩展仅取决于已使用的左右括号数量及平衡性"
      },
      "Objective Function": {
        "type": "Construct All Valid Solutions",
        "goal": "生成所有可能的有效括号组合",
        "output_form": "返回字符串列表，包含所有长度为 2n 的有效括号序列"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "在递归构造过程中，左括号数量始终 >= 右括号数量（即未闭合的左括号数 >= 0）",
          "当且仅当 left_count == right_count == n 时，得到一个完整有效的解",
          "剪枝条件：若 left_used > n 或 right_used > left_used，则该分支非法不可继续"
        ],
        "monotonicity": "left_used 和 right_used 随构造过程单调递增",
        "state_progression": "每一步选择添加 '(' 或 ')' 均基于当前计数和约束进行决策"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n_value_range",
            "description": "括号对数的范围",
            "default": "1 <= n <= 8",
            "possible_extensions": [
              "扩大至 n <= 12（需考虑输出规模爆炸）",
              "支持多组 n 同时输入"
            ]
          },
          {
            "name": "bracket_types",
            "description": "括号种类",
            "options": [
              "单类型 '()'（原题）",
              "多类型如 '()', '[]', '{}'（变形题：生成多类有效括号组合）"
            ]
          },
          {
            "name": "validity_definition",
            "description": "有效性定义方式",
            "options": [
              "标准前缀约束（当前左括号不少于右括号）",
              "隐式约束：通过栈模拟判断合法性（可用于 DP 或回文变体）"
            ]
          },
          {
            "name": "output_requirement",
            "description": "输出形式",
            "options": [
              "输出所有方案（原题）",
              "仅计数（卡塔兰数直接公式求解）",
              "输出字典序第 k 个方案（在线查询）",
              "输出最长/最短有效子串（子问题提取）"
            ]
          },
          {
            "name": "input_structure_variation",
            "description": "输入结构变化",
            "options": [
              "固定 n → 给定模式串要求填充（如 '_(_)_(' → 补全为有效串）",
              "在线生成：逐字符输入，实时输出可能完成的有效组合"
            ]
          },
          {
            "name": "additional_constraints",
            "description": "附加限制",
            "options": [
              "禁止连续三个相同符号",
              "要求结果按特定顺序排列（如反转序）",
              "加入嵌套深度限制（如最大深度 <= d）"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "两数之和 II - 输入有序数组",
    "slug": "kLl5u1",
    "schema": {
      "Input Structure": "一维数组 numbers[0..n-1]，其中 n ≥ 2；numbers 按非递减顺序排列；元素为整数，值域 [-1000, 1000]；给定目标整数 target ∈ [-1000, 1000]",
      "Core Constraint": "数组有序（非递减），且仅存在唯一一对不同下标的元素满足两数之和等于 target；同一元素不可使用两次",
      "Objective Function": "找出两个下标 i 和 j，满足 0 <= i < j < n 且 numbers[i] + numbers[j] == target，并返回 [i, j]",
      "Algorithmic Invariant": "利用数组有序性，通过双指针从两端向中间逼近：左指针 L 初始指向最小值（首部），右指针 R 初始指向最大值（尾部）；若 numbers[L] + numbers[R] < target，则所有 L 右侧的指针与当前 R 的组合均过小，故 L 必须右移；若和 > target，则所有 R 左侧的指针与当前 L 的组合均过大，故 R 必须左移；每次移动保证不跳过可能解，且最终收敛到唯一解",
      "Transformable Parameters": {
        "数据规模": "n ∈ [2, 3×10^4]",
        "值域范围": "numbers[i] ∈ [-1000, 1000], target ∈ [-1000, 1000]",
        "数组有序性": "必须非递减；可变形为非递增或无序（退化为 Two Sum 原题）",
        "唯一解假设": "可改为多组解并要求返回所有对、或返回任意一组",
        "输入形式": "单组输入；可扩展为多组测试用例",
        "在线性": "当前为离线一次性输入；可设计为在线流式输入并查询是否存在两数之和等于 target",
        "输出形式": "返回下标对；可改为返回数值对、或判断存在性",
        "指针起点": "本题下标从 0 开始；可调整为从 1 开始（如 LeetCode 167）"
      }
    }
  },
  {
    "title": "最大单词长度乘积",
    "slug": "aseY1I",
    "schema": {
      "Input Structure": [
        "字符串数组 words[1..n]",
        "每个字符串 words[i] 由小写英文字母组成",
        "1 <= n <= 1000",
        "1 <= |words[i]| <= 1000"
      ],
      "Core Constraint": [
        "两个字符串无相同字符 ⇔ 它们字符集合的交集为空",
        "字符种类有限（仅26个小写字母），可用位掩码（bitmask）表示字符存在性",
        "字符串间字符冲突可通过位运算快速判断：mask[i] & mask[j] == 0"
      ],
      "Objective Function": "最大化满足条件的一对字符串的长度乘积，即求 max(|words[i]| × |words[j]|)，其中 words[i] 与 words[j] 不含公共字符；若不存在则返回 0",
      "Algorithmic Invariant": [
        "使用位掩码预处理每个字符串的字符集，实现 O(1) 冲突检测",
        "对于每对字符串 (i, j)，通过位与运算判断是否可配对",
        "最优解一定出现在某两个字符串之间，枚举所有可能配对即可覆盖解空间",
        "可优化：对相同掩码的字符串只保留最长者（贪心剪枝）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "10^3",
            "可扩展至 10^4（需优化枚举方式）"
          ],
          "字符串长度": [
            "<= 1000",
            "可设为动态或流式"
          ]
        },
        "字符集": [
          "仅小写字母（26位）",
          "可扩展至大写、数字（增加位宽）",
          "可改为任意字符（需哈希集合判断交集）"
        ],
        "输入形式": [
          "一次性离线输入",
          "可改为在线查询：动态添加字符串并维护最大乘积"
        ],
        "输出目标": [
          "最大长度乘积",
          "可变换为：计数满足条件的字符串对数目",
          "构造取得最大值的具体字符串对"
        ],
        "约束条件": [
          "不包含相同字符",
          "可变形为：至少包含 k 个相同字符",
          "共享字符数不超过 t"
        ],
        "是否多组数据": false,
        "是否允许重复字符串": true,
        "是否排序": "无需排序，但可按位掩码分组优化"
      }
    }
  },
  {
    "title": "全排列 II ",
    "slug": "7p8L0Z",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中 n ∈ [1, 8]，元素为整数且允许重复，值域为 [-10, 10]",
      "Core Constraint": "由于存在重复元素，直接全排列会产生重复方案；需通过排序 + 相邻去重剪枝或频次统计来避免生成重复排列",
      "Objective Function": "构造并返回所有不重复的全排列（即去重后的所有可能排列）",
      "Algorithmic Invariant": "在回溯过程中，同一层递归中相同值的元素只能被选择一次（即：已选则跳过后续相同值）；或使用频次计数确保每个元素使用不超过其出现次数",
      "Transformable Parameters": {
        "数据规模": "n 的范围可调整（当前为 ≤8，适合暴力枚举）",
        "值域": "nums[i] 的取值范围可扩大或缩小",
        "是否有序输入": "输入是否预先排序（影响去重实现方式）",
        "是否允许重复": "切换为无重复版本即变为标准全排列问题",
        "输出形式": "可要求仅返回数量、特定序号的排列、字典序第k个排列等",
        "是否在线": "可改为动态插入/删除元素后重新生成排列（扩展题型）",
        "多组数据": "是否处理多个独立测试用例"
      }
    }
  },
  {
    "title": "全排列",
    "slug": "VvJkup",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums 中的元素为整数",
        "所有元素互不相同",
        "1 <= n <= 6",
        "-10 <= nums[i] <= 10"
      ],
      "Core Constraint": [
        "排列由所有原始元素构成，每个元素恰好出现一次",
        "无重复数字 ⇒ 无需去重剪枝（基于值）",
        "排列顺序不同即视为不同方案",
        "解空间为对称群 S_n 的全部元素"
      ],
      "Objective Function": [
        "构造并返回所有可能的全排列",
        "目标函数类型：构造方案",
        "输出形式：二维列表，每个子列表是一个排列"
      ],
      "Algorithmic Invariant": [
        "递归过程中维护已选路径 path 和剩余可选元素集合",
        "每一步选择一个未使用的元素，保证不会重复选取",
        "回溯时恢复状态，保持搜索完整性",
        "深度优先搜索遍历排列树的所有叶节点"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的上限（当前为 6，可扩展至支持更大 n 或剪枝优化需求）",
        "元素性质": [
          "是否允许重复元素（→ 则需去重逻辑）",
          "是否有序输入影响输出顺序"
        ],
        "输出要求": [
          "是否按字典序输出",
          "是否只返回数量而非具体方案（→ 变为计数问题）",
          "是否限制前缀或后缀结构"
        ],
        "输入形式": [
          "是否多组测试数据",
          "是否在线生成下一个排列（→ 类似 next_permutation 迭代器）"
        ],
        "约束变化": [
          "加入局部顺序约束（如某元素必须在另一元素前）",
          "加入分组排列或带权重排列"
        ]
      }
    }
  },
  {
    "title": "只出现一次的数字 II",
    "slug": "WGki4K",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length": "n",
        "value_range": [
          -2147483648,
          2147483647
        ],
        "constraints": [
          "数组长度满足 1 <= n <= 3 * 10^4",
          "除一个元素出现一次外，其余所有元素均恰好出现三次"
        ]
      },
      "Core Constraint": {
        "description": "每个非目标元素出现次数为3，目标元素仅出现1次，利用位运算中三进制模意义下的抵消性质可分离出唯一元素",
        "key_idea": "在二进制每一位上统计所有数该位的1的总和，若对3取模结果为1，则说明目标元素在该位为1"
      },
      "Objective Function": {
        "type": "find_unique_element",
        "goal": "返回那个只出现一次的整数",
        "output_type": "single_integer"
      },
      "Algorithmic Invariant": {
        "primary": "位计数不变性",
        "invariants": [
          "对于任意二进制位，所有出现三次的数字在该位上的贡献之和必为0（mod 3）",
          "因此最终每位上sum % 3的结果即为目标元素对应位的值",
          "通过遍历维护每一位的计数状态，可以在线性时间内重构目标数"
        ],
        "alternative_invariant": "有限状态机转移：用两个变量模拟三进制计数器（如ones, twos），实现O(1)空间"
      },
      "Transformable Parameters": {
        "appearance_count": {
          "common_value": 3,
          "can_be_changed_to": [
            "k",
            2
          ],
          "effect": "当变为2时退化为 'Single Number' 原题；推广至k次可用哈希或通用位模法"
        },
        "target_frequency": {
          "current": 1,
          "can_be_generalized_to": [
            "r (r < k)",
            "odd_count"
          ]
        },
        "data_streaming": {
          "form": "offline_batch",
          "can_transform_to": "online_query"
        },
        "space_constraint": {
          "requirement": "O(1) extra space",
          "challenge": "需设计位操作或状态机避免哈希表"
        },
        "input_properties": {
          "sorted": false,
          "distinct_values": false,
          "negative_allowed": true
        },
        "output_form": {
          "form": "single_value",
          "can_extend_to": [
            "return_index",
            "count_solutions",
            "list_all_once_elements_if_relaxed"
          ]
        },
        "complexity_requirements": {
          "time": "O(n)",
          "space": "O(1)"
        }
      }
    }
  },
  {
    "title": "组合总和 II",
    "slug": "4sjJUc",
    "schema": {
      "Input Structure": [
        "一维数组 candidates[1..n]",
        "candidates 中元素为正整数，范围 [1, 50]",
        "数组长度 n ∈ [1, 100]",
        "数组可能包含重复元素",
        "目标值 target ∈ [1, 30]"
      ],
      "Core Constraint": [
        "每个数字在单个组合中只能使用一次",
        "解集不能包含重复的组合（即不同排列但相同元素构成的组合视为重复）",
        "组合的元素之和必须等于 target",
        "输入无序，需通过排序与跳过策略避免重复枚举"
      ],
      "Objective Function": "找出所有满足和为 target 的唯一组合（计数 + 构造方案）",
      "Algorithmic Invariant": [
        "在递归搜索中，若当前元素与前一元素相同，且前一元素未被选入当前分支，则跳过当前元素（去重剪枝）",
        "搜索过程中维护剩余目标值 remain，当 remain == 0 时记录方案，remain < 0 时剪枝",
        "通过升序排序保证组合非递减，从而避免顺序不同但内容相同的重复组合",
        "每层递归从当前位置之后（或允许重复选择题型中可包含当前位置）选择下一元素，确保不回头选造成重复"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "n ≤ 10",
            "n ≤ 20",
            "n ≤ 100"
          ],
          "target 值域": [
            "target ≤ 30",
            "target ≤ 100",
            "target 可变"
          ]
        },
        "输入特性": {
          "是否允许重复元素": [
            true,
            false
          ],
          "是否已排序": [
            false,
            true
          ],
          "元素值域": [
            "正整数",
            "非负整数",
            "含负数"
          ]
        },
        "使用规则": {
          "每个数字使用次数限制": [
            "仅一次",
            "最多 k 次",
            "无限次（变为 Combination Sum I 类型）"
          ]
        },
        "输出要求": {
          "是否需要去重": [
            true,
            false
          ],
          "输出形式": [
            "返回所有组合",
            "仅返回组合数",
            "返回是否存在解"
          ],
          "是否要求字典序输出": [
            true,
            false
          ]
        },
        "查询模式": {
          "是否多组数据": [
            false,
            true
          ],
          "是否在线查询": [
            false,
            true
          ]
        }
      }
    }
  },
  {
    "title": "二进制求和",
    "slug": "JFETK5",
    "schema": {
      "Input Structure": [
        "两个非空字符串 a 和 b",
        "每个字符 ∈ {'0', '1'}",
        "1 <= |a|, |b| <= 10^4",
        "字符串若不为 \"0\"，则不含前导零"
      ],
      "Core Constraint": [
        "二进制加法需逐位进行，考虑进位",
        "每一位的和由当前位 a[i], b[j] 和进位 carry 共同决定",
        "结果字符串应满足二进制表示规范（无前导零，除非值为 0）"
      ],
      "Objective Function": "计算 a 和 b 的二进制和，并以标准二进制字符串形式输出",
      "Algorithmic Invariant": [
        "从最低位到最高位依次处理，进位状态 carry 在每一步中被正确维护",
        "任意时刻，已处理部分的和是最终结果后缀的精确表示",
        "未处理部分不影响已确定的低位结果（前向不可逆依赖）"
      ],
      "Transformable Parameters": {
        "数据规模": "字符串长度上限可调整（如从 10^4 改为 10^6 或更小）",
        "输入形式": [
          "是否允许前导零输入",
          "是否支持多进制（如三进制、k 进制扩展）",
          "是否支持多个字符串相加（从两个变为多个）"
        ],
        "输出要求": [
          "是否要求去除前导零",
          "是否需要返回中间进位状态序列"
        ],
        "在线性": "是否支持流式输入（逐字符输入，实时输出部分结果）",
        "异常处理": "是否允许非法字符输入（如非 '0'/'1'），并定义相应行为"
      }
    }
  },
  {
    "title": "比特位计数",
    "slug": "w3tCBm",
    "schema": {
      "Input Structure": "非负整数 n，表示范围 [0, n] 的整数集合；需计算每个整数 i ∈ [0, n] 的二进制表示中 1 的个数",
      "Core Constraint": "整数的二进制表示具有递推结构：i 的二进制中 1 的个数等于 i >> 1（即 i//2）的 1 的个数加上 i 的最低位（i & 1）；该性质源于二进制位移与奇偶性分离",
      "Objective Function": "构造长度为 n+1 的数组 ans，其中 ans[i] 表示整数 i 的二进制表示中 1 的个数；目标函数为计数型（counting）",
      "Algorithmic Invariant": "利用动态规划思想：dp[i] = dp[i >> 1] + (i & 1)；每一步依赖已计算的小规模子问题结果，且状态转移不破坏前序正确性；扫描顺序从 0 到 n 单调递增，保证子问题先求解",
      "Transformable Parameters": {
        "n 的数量级": "1e5（题目给定），可扩展至 1e7 以测试线性算法性能",
        "值域": "输入为非负整数，可变形为有符号整数或负数补码计数",
        "是否有序": "输入范围天然有序（0 到 n），可改为无序集合要求离线处理",
        "是否多组输入": "原题单组，可扩展为多组 n 的查询（需预处理全局表）",
        "是否在线": "原始为离线一次性输出，可改造为在线查询模式：每次询问一个 i，返回 popcount(i)，支持多次调用",
        "是否使用内置函数": "禁止使用 __builtin_popcount 等，强调手动实现位运算逻辑",
        "数据结构限制": "空间复杂度限定 O(n)，不允许使用哈希表等额外结构存储中间结果"
      }
    }
  },
  {
    "title": "组合总和",
    "slug": "Ygoe9J",
    "schema": {
      "Input Structure": [
        "一维数组 candidates[1..n]",
        "candidates 中元素为无重复的正整数",
        "target 为正整数",
        "1 <= n <= 30",
        "1 <= candidates[i] <= 200",
        "1 <= target <= 500"
      ],
      "Core Constraint": [
        "组合中数字可重复选取，但组合本身必须唯一（基于多重集意义）",
        "组合顺序无关，即 [2,2,3] 与 [2,3,2] 视为相同，仅保留一种形式",
        "搜索空间受 target 上界限制，且合法解数量保证少于 150 个",
        "不可跳过候选集中的可用数字而强行构造子集"
      ],
      "Objective Function": "找出所有使得数字和等于 target 的唯一组合（多重集），并返回所有满足条件的组合列表",
      "Algorithmic Invariant": [
        "采用深度优先搜索（DFS）回溯框架，按非降序扩展路径以避免重复组合",
        "每层递归从当前索引开始枚举，防止重复选择前面已跳过的数导致等价组合",
        "路径和 path_sum ≤ target 始终成立，剪枝掉超出 target 的分支",
        "状态转移具有前缀可累积性：若当前路径无法扩展出解，则其所有延伸均可剪枝"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": "1 <= n <= 30 → 可改为更大或更小",
          "target 范围": "1 <= target <= 500 → 可调整至更高或引入负数"
        },
        "输入性质": [
          "candidates 是否允许重复元素",
          "candidates 是否有序（已排序 / 需自行排序）",
          "是否允许负数或零"
        ],
        "目标函数变换": [
          "求存在性（判定是否有至少一个组合）",
          "求最短/最长组合长度",
          "求组合个数（而非具体方案）",
          "求字典序第 k 小的组合"
        ],
        "约束变化": [
          "每个数字最多使用一次（变为子集和问题）",
          "每个数字有使用次数上限",
          "组合长度需在 [L,R] 范围内"
        ],
        "输出形式": [
          "仅返回组合个数",
          "返回去重后的组合集合",
          "要求输出所有排列形式（考虑顺序）"
        ],
        "多组数据": "是否处理多组 (candidates, target) 查询",
        "在线性": "是否支持动态添加 candidate 或修改 target 并实时查询"
      }
    }
  },
  {
    "title": "两数相除",
    "slug": "xoh6Oh",
    "schema": {
      "Input Structure": [
        "两个整数 a 和 b",
        "a ∈ [-2^31, 2^31 - 1]",
        "b ∈ [-2^31, 2^31 - 1] 且 b ≠ 0",
        "环境为 32 位有符号整数系统"
      ],
      "Core Constraint": [
        "不能使用乘法、除法和取模运算符",
        "结果需截断小数部分（向零取整）",
        "若结果溢出（> 2^31 - 1），则返回 2^31 - 1",
        "除法本质是求 a 中最多包含多少个 b（带符号）"
      ],
      "Objective Function": "计算并返回整数除法的商 truncate(a / b)",
      "Algorithmic Invariant": [
        "通过倍增减法（指数级逼近）模拟除法：每次用被除数减去最大的 b 的 2^k 倍而不越界",
        "符号独立处理，绝对值域上进行非负数除法",
        "利用位移替代乘法：b << k 等价于 b * 2^k",
        "每轮确定一个 2^k 位的贡献，保证不重复也不遗漏"
      ],
      "Transformable Parameters": {
        "数据规模": "32 位有符号整数范围，可扩展至 64 位或任意精度",
        "是否允许特定操作": [
          "禁止 '*' '/' '%' → 可改为仅禁止 '/'",
          "是否允许位运算（如左移）→ 控制是否可用加速手段"
        ],
        "溢出处理方式": [
          "溢出返回 INT_MAX → 可改为报错、返回 NULL 或 modulo 处理"
        ],
        "取整方向": [
          "向零截断（truncate）→ 可改为 floor、ceil 等",
          "影响负数结果，例如 -2.7335 截断为 -2 而非 -3"
        ],
        "输入形式": [
          "单组 a, b → 可改为多组查询",
          "静态输入 → 可设计为在线输入流中连续除法任务"
        ],
        "是否隐藏约束": [
          "显式给出 b ≠ 0 → 可改为隐式保证或需判零处理"
        ]
      }
    }
  },
  {
    "title": "主题空间",
    "slug": "YesdPw",
    "schema": {
      "Input Structure": [
        "二维字符网格 grid[1..m][1..n]",
        "每个元素 grid[i][j] ∈ {'0','1','2','3','4','5'}",
        "字符 '0' 表示走廊，'1'~'5' 表示不同主题空间",
        "连通性定义为四连通（上下左右）",
        "整个区域外侧视为走廊"
      ],
      "Core Constraint": [
        "同一主题空间由相同字符的四连通区域构成",
        "一个主题空间若与任意一个 '0'（走廊）在四连通意义下相邻，则被视为与走廊相邻",
        "边界外侧默认为走廊，因此贴边的主题空间可能因外侧为走廊而被判定为相邻"
      ],
      "Objective Function": "计算所有不与走廊直接相邻的主题空间中的最大面积；若不存在则返回 0",
      "Algorithmic Invariant": [
        "使用 Flood Fill（DFS/BFS）可完整标记每个连通块及其面积",
        "在遍历连通块时，若其任意位置与 '0' 相邻或位于边界（隐式外侧走廊），则该块被标记为与走廊相邻",
        "一旦确定某连通块的所有节点均不与 '0' 相邻且不接触外边界，则其满足‘内部隔离’条件",
        "连通块的访问状态具有不可逆性：每个格子仅属于一个主题空间，访问后无需重复处理"
      ],
      "Transformable Parameters": {
        "Grid Size": "m, n ∈ [1, 500] → 可扩展至 1e3 或缩小至 50",
        "Character Set": "当前为 '0'~'5'，可推广到更大字符集或泛化为类别标签",
        "Connectivity": "四连通 → 八连通（变形题）",
        "Boundary Treatment": "外侧是否总是走廊 → 可改为开放边界或需显式输入",
        "Adjacency Definition": "与 '0' 相邻 → 可改为与其他特定类型相邻",
        "Objective Variation": [
          "最大面积 → 最小面积 / 计数满足条件的空间数量 / 所有非相邻空间的总面积"
        ],
        "Output Requirement": "仅最大面积 → 可要求输出具体位置或连通块标识",
        "Online Query": "静态地图 → 支持动态修改 grid 值并实时查询",
        "Multiple Test Cases": "单组数据 → 多组测试用例批量处理",
        "Value Constraints": "字符限定为数字 → 可改为任意字符或引入权重值"
      }
    }
  },
  {
    "title": "完成一半题目",
    "slug": "WqXACV",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "name": "questions",
        "length": "2 * N",
        "element_type": "integer",
        "value_range": [
          1,
          1000
        ],
        "constraints": [
          "questions.length == 2 * N",
          "N >= 1",
          "2 <= questions.length <= 10^5"
        ]
      },
      "Core Constraint": {
        "description": "每道题对应一个知识点类型；每位扣友选一题且题目互不相同；目标是使选出的 N 道题覆盖的知识点种类数最少。",
        "key_insight": "同一知识点类型题目越多，越有可能被多人选择，从而减少总类型数。",
        "constraint_logic": "若某知识点出现频次为 f，则最多可被 min(f, N) 位扣友选择（但实际受总人数限制），需通过贪心策略优先利用高频知识点以压缩种类数。"
      },
      "Objective Function": {
        "type": "minimization",
        "target": "minimum number of distinct topic types among the selected N questions",
        "form": "integer output: minimum k such that N questions can be chosen with exactly k distinct types"
      },
      "Algorithmic Invariant": {
        "invariant_description": "在按频次降序排列的知识点中，尽可能多地使用每个知识点的题目来满足 N 个选择需求，使得使用的不同知识点数量最小。",
        "greedy_condition": "优先选用出现次数多的知识点可最小化所需种类数，该贪心选择具有最优子结构。",
        "monotonicity": "随着我们从高频到低频遍历知识点，累计可覆盖的选择数单调递增，所需知识点种类单调非减。"
      },
      "Transformable Parameters": {
        "n_magnitude": "1 <= N <= 5e4",
        "value_domain": "1 <= questions[i] <= 1000",
        "array_order": "unordered input; frequency-based processing required",
        "duplicates_allowed": true,
        "multi_test_cases": false,
        "online_input": false,
        "modifications": [
          "allow deletion or update operations on questions (dynamic version)",
          "change objective to maximization (max distinct types under constraints)",
          "add dependency between topics (e.g., prerequisite knowledge)",
          "extend to 2D grid of questions (spatial arrangement)",
          "make selection constrained by adjacency or index range"
        ],
        "input_structure_variants": [
          "questions as stream (online model)",
          "questions distributed across groups or rounds"
        ]
      }
    }
  },
  {
    "title": "下载插件",
    "slug": "Ju9Xwi",
    "schema": {
      "Input Structure": "整数 n（表示需要下载的插件数量），1 <= n <= 10^5",
      "Core Constraint": "每分钟只能选择以下两种操作之一：(1) 使用当前带宽下载插件；(2) 将带宽加倍（下载速度翻倍）。初始带宽为每分钟 1 个插件。下载总量可以超过 n。",
      "Objective Function": "求完成至少 n 个插件下载所需的最少分钟数（最小化时间）",
      "Algorithmic Invariant": "存在一个最优策略：先进行若干次‘加倍’操作，然后连续进行‘下载’操作直到满足 n。因为一旦开始下载，后续再加倍不如提前加倍更优（贪心性质）。即：最优解中所有‘加倍’操作位于所有‘下载’操作之前。",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^5（可扩展至更大规模以要求 O(log n) 解法）",
        "初始带宽": "可变（如从 b 开始，而非 1）",
        "加倍倍数": "改为 k 倍（而非固定 2 倍）",
        "操作类型": "增加更多操作类型（如减速、临时提速、消耗时间升级等）",
        "是否在线": "输入 n 是否逐个给出，需在线回答",
        "多组数据": "是否有多组测试用例需批量处理",
        "目标函数变化": "从最小化时间 → 最小化能耗 / 操作代价总和（若每次加倍或下载有代价）"
      }
    }
  },
  {
    "title": "魔塔游戏",
    "slug": "p0NxJO",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "nums[0..n-1]",
        "element_type": "integer",
        "constraints": [
          "1 <= n <= 10^5",
          "-10^5 <= nums[i] <= 10^5"
        ],
        "initial_health": 1,
        "health_unbounded": true,
        "access_order_adjustable": true
      },
      "Core Constraint": {
        "health_must_remain_positive": true,
        "adjustment_rule": "only negative-valued rooms (monsters) can be moved",
        "move_operation": "move one monster room to the end of the sequence",
        "sequential_visit": "rooms are visited in order, but with allowed reordering via move-to-end operations",
        "global_feasibility_condition": "total sum of health changes + initial health must allow survival; if prefix sum drops to <=0 and cannot be fixed by moving monsters, return -1"
      },
      "Objective Function": {
        "goal": "minimize number of adjustments (moves)",
        "output_type": "integer",
        "failure_case": -1,
        "condition_for_failure": "even after all possible valid moves, there is no way to maintain positive health throughout"
      },
      "Algorithmic Invariant": {
        "greedy_invariant": "process rooms in order while maintaining current health; whenever health would drop to <=0, it is optimal to retroactively 'remove' (i.e., postpone) the largest damage (most negative) monster so far",
        "postponement_optimality": "postponing a monster does not affect future decisions on earlier segments; once postponed, it will be handled at the end only if safe",
        "two-phase_simulation": "simulate main pass assuming we can delay monsters; use priority queue to track monsters encountered and greedily remove the worst one when needed",
        "monotonicity_of_correction": "each time a health violation occurs, correcting it by removing the worst monster so far maintains feasibility with minimal moves"
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          100000
        ],
        "value_range": [
          -100000,
          100000
        ],
        "initial_health_variable": false,
        "health_upper_bound": "unbounded",
        "adjustment_operations": [
          "only move-to-end allowed",
          "can only move negative elements"
        ],
        "number_of_moves_cost_model": "each move counts as 1 regardless of value",
        "input_stream_type": "offline batch input",
        "multiple_test_cases": false,
        "online_version_possible": true,
        "allow_move_positive_rooms": false,
        "alternative_objectives": [
          "count total number of valid sequences",
          "minimize maximum blood loss at any point",
          "find lexicographically smallest adjustment sequence"
        ],
        "structural_variants": [
          "2D grid traversal with same rules",
          "circular room layout",
          "limited number of moves allowed"
        ]
      }
    }
  },
  {
    "title": "守卫城堡",
    "slug": "7rLGCR",
    "schema": {
      "Input Structure": [
        "二维字符网格 grid[2][n]，其中 n = grid[0].length",
        "每个格子为以下之一：'.'（平地）、'#'（障碍物）、'S'（恶魔出生点）、'P'（瞬移点）、'C'（城堡）",
        "grid.length == 2，即地图高度固定为2行",
        "2 <= n <= 10^4"
      ],
      "Core Constraint": [
        "恶魔从任意 'S' 出发，可上下左右移动，但不能越界或进入 '#'",
        "所有 'P' 点之间相互连通（瞬移）——一旦到达任一 'P'，即可传送到其他任意 'P'",
        "玩家只能将 '.' 改为 '#'（建障），目标是阻断所有从 'S' 到 'C' 的路径",
        "若存在一条从某个 'S' 到 'C' 的路径（考虑瞬移能力），且无法通过建障阻断，则返回 -1",
        "问题本质是：在有限操作下破坏所有源（S）到汇（C）的连通性，瞬移点形成等价类节点"
      ],
      "Objective Function": "最小化所需建造的障碍物数量，使得没有任何恶魔能从任意出生点 'S' 到达城堡 'C'；若不可能则返回 -1",
      "Algorithmic Invariant": [
        "瞬移点 'P' 构成一个强连通组件，可视为图中的超级节点",
        "整个地图可建模为图，其中每个非 '#' 格子是一个节点，相邻 '.' 或 'S' 或 'C' 与 'P' 间有边",
        "使用 BFS/DFS 求解从所有 'S' 可达区域时，必须将所有 'P' 视为已联通",
        "最小割思想：在关键通路上设置障碍相当于删除节点（点割集），目标是最小点割集分离 {S} 与 {C}",
        "由于图宽仅为2，每一列的状态可以压缩（状态压缩DP或分段处理）",
        "最优策略中，障碍物只需设在连接 S 和 C 的必经点上，特别是狭窄通道或 P 连接的关键 '.' 上"
      ],
      "Transformable Parameters": {
        "地图维度": {
          "行数是否扩展": "可由 2 行扩展至 M 行（M ≥ 2）",
          "列数规模": "n ∈ [2, 10^4]，可调整为更小或支持动态增长"
        },
        "瞬移机制": [
          "是否允许多组独立瞬移点（颜色标记）",
          "是否限制瞬移次数",
          "是否改为单向传送"
        ],
        "障碍建造规则": [
          "是否允许在 'S' 或 'P' 上建障（原题不允许）",
          "建造是否有成本差异（如某些地形更贵）"
        ],
        "恶魔行为": [
          "是否允许多阶段移动（先走再传）",
          "是否多个恶魔并发移动并共享路径信息"
        ],
        "输入形式": [
          "是否多组测试数据",
          "是否在线更新地图后查询最小障碍数"
        ],
        "输出目标": [
          "最小障碍数（当前）",
          "是否存在方案（判定型）",
          "构造一种最优布防方案（构造型）"
        ],
        "约束变化": [
          "是否允许负权重地形（非均匀代价）",
          "是否加入时间维度（动态封锁）"
        ]
      }
    }
  },
  {
    "title": "最多牌组数",
    "slug": "Up5XYM",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "integers",
        "description": "一维数组 tiles[1..n]，表示麻将牌的数值",
        "constraints": [
          "tiles.length ∈ [1, 1e5]",
          "tiles[i] ∈ [1, 1e9]"
        ]
      },
      "Core Constraint": {
        "description": "每张牌只能使用一次；一组牌为三张，必须是顺子（连续三个数字）或刻子（三个相同数字）；决策相互影响，因同一数字可能参与不同形式组合（如既可作刻子也可参与多个顺子）",
        "key_insight": "较小数值优先用于顺子能提升整体利用率（贪心合理性），但需考虑后续数字是否存在"
      },
      "Objective Function": {
        "type": "maximization",
        "target": "最大可组成的牌组数量",
        "output_single_value": true
      },
      "Algorithmic Invariant": {
        "invariants": [
          "遍历过程中维护每个数字的可用张数（频次计数）",
          "从小到大枚举数字时，优先尝试以当前数字 i 开头构成顺子 [i, i+1, i+2]（若可行），否则再考虑刻子 [i,i,i]",
          "贪心选择的正确性依赖于：若存在最优解中未在 i 处构造顺子，则可通过调整使之成立而不损失总数（可证明的贪心交换论证）",
          "已处理过的数字不再回溯，状态单调推进"
        ],
        "algorithm_paradigm": "greedy + frequency counting",
        "supporting_data_structure": "hash map or array for count tracking"
      },
      "Transformable Parameters": {
        "n_range": "[1, 1e5]",
        "value_domain": "[1, 1e9]",
        "ordering": "unsorted input, but processed in sorted order",
        "duplicates_allowed": true,
        "tile_usage_limit": 1,
        "group_types": [
          "triplet (same number)",
          "sequence (consecutive numbers)"
        ],
        "variations": [
          "是否允许四张为一组（如杠子）",
          "目标变为判定能否全部用完",
          "输出具体方案而非仅数量",
          "改为在线添加牌并实时查询最大组合数",
          "限制顺子长度为 k（非常规3）",
          "tiles[i] 可为负数（扩展值域）",
          "二维麻将坐标系统下的连通组判断（结构变换）"
        ],
        "multi_query": false,
        "online_mode": false,
        "data_modification": false
      }
    }
  },
  {
    "title": "蓄水",
    "slug": "o8SXZn",
    "schema": {
      "Input Structure": [
        "数组 bucket[1..n]，表示每个水缸对应水桶的初始容量",
        "数组 vat[1..n]，表示每个水缸所需的最低蓄水量",
        "n ∈ [1, 100]",
        "bucket[i], vat[i] ∈ [0, 10^4]"
      ],
      "Core Constraint": [
        "每次‘蓄水’操作会将所有水桶加满并倒入对应水缸，增加量为当前 bucket[i]",
        "‘升级水桶’只能逐次对单个水桶 +1 容量",
        "总操作次数 = 升级次数 + 蓄水次数",
        "最终每个水缸的实际蓄水量 ≥ vat[i]"
      ],
      "Objective Function": "最小化总操作次数（升级次数 + 蓄水次数）",
      "Algorithmic Invariant": [
        "蓄水次数 k 决定了每个 bucket[i] 至少需要达到 ⌈vat[i]/k⌉ 才能在 k 次内满足要求",
        "对于固定的蓄水次数 k（≥1），可反推出每个位置需升级至的目标容量，并计算所需升级次数",
        "最优解必然出现在某个合理的整数 k（蓄水次数）上，且 k 的上界有限（如 max(vat[i])）",
        "枚举蓄水次数作为主变量，转化为贪心决策：对每个 k，计算 total_upgrade = Σ max(0, ⌈vat[i]/k⌉ - bucket[i])，总代价为 k + total_upgrade"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可扩展至 10^3 或更高，推动使用更优复杂度算法",
        "值域范围": "vat[i] 可扩大至 10^6，要求优化枚举策略",
        "是否有序": "输入无序，但可通过排序辅助剪枝（如按 vat[i] 排序）",
        "是否循环": "否，可改为动态增删水缸（在线版本）",
        "是否多组输入": "当前单组，可扩展为多测",
        "是否在线": "离线处理，可设计成支持修改 bucket 或 vat 的在线查询",
        "操作类型变化": [
          "升级变为批量加权升级（不同成本）",
          "允许减少水桶容量以换取其他资源",
          "蓄水操作可选择子集执行"
        ],
        "目标函数变换": [
          "从最小化总操作次数 → 最小化最大单个水桶升级次数",
          "计数满足条件的方案数",
          "判定是否存在不超过 T 次操作的方案"
        ],
        "约束反转": "从 '≥ vat[i]' 改为 '≤ vat[i]' 并最大化蓄水量"
      }
    }
  },
  {
    "title": "电动车游城市",
    "slug": "DFPeFJ",
    "schema": {
      "Input Structure": {
        "graph": "undirected weighted graph represented as an edge list paths[i] = [u, v, dist], where u and v are nodes (cities), and dist is the distance (positive integer ≤ cnt)",
        "n": "number of cities, 2 <= n <= 100, indexed from 0 to n-1",
        "cnt": "maximum battery capacity of the e-bike, 1 <= cnt <= 100",
        "charge": "array of length n, charge[i] ∈ [1,100], representing time cost per unit electricity charged at city i",
        "start": "source city index",
        "end": "destination city index"
      },
      "Core Constraint": {
        "battery_constraint": "the bike can travel at most 'cnt' units on a full charge; each unit of distance consumes 1 unit of battery and 1 unit of time",
        "recharge_any_city": "every city has a charging station; charging is instantaneous in modeling but costs time proportional to amount charged × charge[i]",
        "state_dependency": "feasibility of traversing an edge depends on current battery level; recharging decisions affect both time cost and reachability",
        "time_additive": "total time = sum of travel time (edge weights) + sum of charging time (amount × charge[i])"
      },
      "Objective Function": "minimize total time (charging time + travel time) to go from start to end, starting with 0 battery",
      "Algorithmic Invariant": {
        "state_space_partition": "state defined as (city, battery_level), where battery_level ∈ [0, cnt]",
        "optimal_substructure": "shortest path in state space obeys dynamic programming principle: if minimal time to reach (u, b) is known, it can be used to relax neighbors",
        "monotonicity_in_time": "time only increases with transitions; no negative cycles possible",
        "dijkstra_applicability": "since all edge costs (time) are non-negative, Dijkstra's algorithm over state space (node, battery) guarantees optimality",
        "battery_transition_rules": [
          "from state (u, b), one may either:",
          "  - recharge 1 unit: (u, b+1) with cost charge[u], if b < cnt",
          "  - traverse edge (u,v,dist): (v, b - dist) with cost dist, if b >= dist"
        ]
      },
      "Transformable Parameters": {
        "battery_capacity": "cnt ∈ [1, 100]; can be scaled or made variable (e.g., per-city capacity)",
        "charge_rates": "charge[i] values; can be zero, negative (invalid), or unbounded; can be made time-dependent",
        "graph_type": "current: static undirected graph; can become directed, dynamic, or include time-windows",
        "initial_battery": "currently fixed at 0; could be parameterized",
        "multiple_queries": "single (start,end) pair now; can extend to multiple queries or all-pairs",
        "online_updates": "static input now; can allow edge additions/deletions or changing charge rates",
        "action_constraints": "can restrict number of charges, or add cooldown between charges",
        "objective_variants": [
          "minimize total energy consumed",
          "minimize number of charging stops",
          "constrained optimization: minimize time subject to max k charges"
        ],
        "determinism": "fully deterministic now; could introduce probabilistic travel times or charging failures"
      }
    }
  },
  {
    "title": "批量处理任务",
    "slug": "t3fKg1",
    "schema": {
      "Input Structure": {
        "type": "2D array",
        "elements": [
          "triplet [start, end, period]"
        ],
        "description": "Array of tasks where each task is represented as [start, end, period]; start and end define the inclusive time interval available for the task, and period is the total processing time required (can be non-contiguous).",
        "constraints_on_values": {
          "start": "integer >= 0",
          "end": "integer <= 1e9, >= start",
          "period": "integer >= 1, <= (end - start + 1)"
        },
        "size": "1 <= tasks.length <= 1e5"
      },
      "Core Constraint": {
        "description": "Each task must be scheduled within its [start, end] window for exactly 'period' units of time. Time slots can be shared across multiple tasks (no concurrency limit), but each unit of machine runtime (on-time) can contribute to multiple tasks simultaneously. The challenge is to maximize overlap of on-time across tasks to minimize total machine runtime.",
        "key_insight": "The problem reduces to selecting a minimal set of time points such that every task has sufficient coverage within its window, with reuse of common time points encouraged."
      },
      "Objective Function": {
        "goal": "minimize total machine on-time",
        "type": "minimization",
        "output_semantics": "smallest number of distinct time units during which the computer must be on to satisfy all tasks' period requirements within their respective intervals"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "Greedy scheduling by sorting tasks based on end time ensures optimal substructure: earlier deadlines should be satisfied first to avoid fragmentation.",
          "Time points selected toward the end of a task's interval are more likely to benefit subsequent overlapping tasks (backward placement within window maximizes reusability).",
          "Using a sweep-line approach with an active set of tasks and greedy assignment from right to left in time maintains feasibility while minimizing new开机 events.",
          "Once a time point is chosen, it can be greedily assigned to all pending tasks that cover that time, reducing their remaining period."
        ],
        "primary_paradigm": "greedy + event sweeping",
        "supporting_techniques": [
          "sorting by end time",
          "time-point sweeping",
          "interval coverage"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n",
            "range": "1e1 to 1e5",
            "comment": "number of tasks; affects choice between O(n log n) vs O(n) algorithms"
          },
          {
            "name": "time_domain",
            "values": [
              "discrete",
              "continuous (real line)"
            ],
            "default": "discrete integers",
            "impact": "changes from combinatorial selection to measure-theoretic covering"
          },
          {
            "name": "period_continuity",
            "values": [
              "non-continuous allowed",
              "must be continuous"
            ],
            "default": "non-continuous",
            "transformation": "if continuous → becomes a dynamic programming or sliding window problem"
          },
          {
            "name": "input_form",
            "values": [
              "offline batch",
              "online stream"
            ],
            "default": "offline",
            "impact": "determines whether greedy sort is possible"
          },
          {
            "name": "concurrency_limit",
            "values": [
              "unlimited",
              "bounded C simultaneous tasks"
            ],
            "default": "unlimited",
            "impact": "introduces resource contention; shifts solution toward simulation or flow models"
          },
          {
            "name": "output_type",
            "values": [
              "total on-time",
              "exact schedule",
              "each task’s assigned times"
            ],
            "default": "total on-time"
          },
          {
            "name": "modifications",
            "values": [
              "static input",
              "supports insert/delete/update queries"
            ],
            "default": "static",
            "impact": "would require data structures like segment trees or balanced BSTs"
          }
        ]
      }
    }
  },
  {
    "title": "变换的迷宫",
    "slug": "Db3wC1",
    "schema": {
      "Input Structure": [
        "三维字符数组 maze[0..T-1][0..n-1][0..m-1], 表示 T 个时间步的 n×m 迷宫地形",
        "maze[t][i][j] ∈ {'.', '#'}, 其中 '.' 表示可通行，'#' 表示陷阱",
        "起点为 (0, 0)，终点为 (n-1, m-1)",
        "初始时刻 t=0，小力位于起点",
        "时间范围 T = len(maze), 满足 1 <= T <= 100, 1 <= n, m <= 50"
      ],
      "Core Constraint": [
        "迷宫随时间演化，每个位置在不同时刻可能为陷阱或空地",
        "小力每时刻可选择上下左右移动一步或原地停留",
        "两个魔法卷轴：临时消除术（下一时刻指定位置变为空地）、永久消除术（之后所有时刻该位置均为空地）",
        "卷轴使用立即生效于下一个时间步，且使用后消失",
        "起点和终点在所有时刻始终为空地（约束保证）",
        "路径必须全程避开陷阱（除非被卷轴修改）"
      ],
      "Objective Function": "判定是否存在一条从 (0,0) 到 (n-1,m-1) 的合法路径，使得在时间 [0, T-1] 内能到达终点，且不经过任何未被消除的陷阱",
      "Algorithmic Invariant": [
        "状态可建模为 (t, x, y, used_temp, used_perm)，表示在时刻 t 位于 (x,y)，并记录两个卷轴的使用状态",
        "BFS 状态扩展时，考虑五种动作：不动、四方向移动、以及在合适时机使用卷轴改变未来地形",
        "卷轴作用可预计算影响区域：临时消除仅作用于 t+1 时刻某位置；永久消除从 t+1 起持续生效",
        "状态转移满足时间单调推进（t 只增不减），空间位置合法转移，卷轴使用不可逆",
        "剪枝条件：同一 (t,x,y,used_temp,used_perm) 状态只需访问一次"
      ],
      "Transformable Parameters": {
        "时间维度规模": "T ∈ [1, 100]",
        "空间维度规模": "n, m ∈ [1, 50]",
        "是否多组输入": false,
        "是否在线处理": false,
        "卷轴数量与类型": [
          "可推广至 k1 个临时卷轴，k2 个永久卷轴",
          "或加入冷却时间、作用范围（如3×3区域）等变体"
        ],
        "地形变化模式": [
          "固定序列（当前设定）",
          "循环变化",
          "由函数生成（如周期性）"
        ],
        "动作集合扩展": [
          "是否允许瞬移（需额外约束）",
          "是否引入体力消耗限制移动次数"
        ],
        "目标函数变换": [
          "最小化到达时间",
          "最大化存活概率（随机陷阱下）",
          "计数可行方案数"
        ],
        "信息可见性": [
          "完全观测（当前设定）",
          "部分观测（仅知当前视野内地形）→ 在线决策"
        ],
        "卷轴使用时机": "必须在使用时刻提前声明作用位置，不能回溯修改"
      }
    }
  },
  {
    "title": "乐团站位",
    "slug": "SNJvJP",
    "schema": {
      "Input Structure": [
        "二维矩阵 grid，大小为 num × num（num ∈ [1, 10^9]）",
        "左上角坐标为 (0, 0)，每个位置按顺时针螺旋方式填充乐器编号 1~9 的循环序列",
        "给定查询坐标 (Xpos, Ypos)，满足 0 <= Xpos, Ypos < num"
      ],
      "Core Constraint": [
        "填充顺序为从外层到内层的顺时针螺旋遍历：右 → 下 → 左 → 上",
        "每一圈构成一个闭合环带（ring），环带宽度为1，逐层向内收缩",
        "总元素按螺旋序连续编号，起始值为1，依次递增并以9为模循环（即编号 = ((序号 - 1) mod 9) + 1）",
        "任意位置的乐器编号仅由其在螺旋序列中的全局序号决定"
      ],
      "Objective Function": "计算位于坐标 (Xpos, Ypos) 的成员所持乐器编号（构造类单点查询）",
      "Algorithmic Invariant": [
        "螺旋结构具有分层不变性：每个位置属于唯一的环带层级 k = min(Xpos, num-1-Xpos, Ypos, num-1-Ypos)",
        "每层环带可独立计算其起始序号和偏移量",
        "同一层内四个边的坐标映射到局部偏移具有方向一致性",
        "无需实际构造矩阵，可通过数学公式直接定位全局序号"
      ],
      "Transformable Parameters": {
        "num": "矩阵边长，取值范围 [1, 10^9]，影响层数与每层周长",
        "Xpos_Ypos": "查询坐标，可扩展为多组查询或在线输入",
        "spiral_direction": "旋转方向（顺时针/逆时针），当前为顺时针",
        "start_value_or_cycle": "起始编号或循环周期（如改为1~k循环），当前为1~9",
        "output_type": "输出内容可变：乐器编号 / 所在层数 / 螺旋序号 / 多点批量输出",
        "dimension": "可推广至三维螺旋或更高维数组（暂未启用）",
        "query_mode": "单次查询 → 多次查询离线处理 → 动态修改螺旋规则的在线系统"
      }
    }
  },
  {
    "title": "采购方案",
    "slug": "4xy4Wx",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "nums is a 1D array of length n (2 <= n <= 1e5)",
          "nums[i] >= 1",
          "target is a positive integer (1 <= target <= 1e5)"
        ],
        "sorted": false,
        "duplicates_allowed": true
      },
      "Core Constraint": {
        "description": "The sum of any two distinct elements must not exceed target; selection is unordered and indices must be different.",
        "key_condition": "i < j and nums[i] + nums[j] <= target",
        "combinatorial_nature": true,
        "pairwise_dependency": true
      },
      "Objective Function": {
        "type": "counting",
        "goal": "Count the number of unordered pairs (i, j) with i < j such that nums[i] + nums[j] <= target",
        "output_modulo": 1000000007
      },
      "Algorithmic Invariant": {
        "invariant_type": "two-pointer monotonicity",
        "description": "After sorting, for a fixed left pointer i, all valid right pointers j satisfy j > i and nums[i] + nums[j] <= target. As i increases, the maximal valid j is non-increasing.",
        "movement_rule": "If nums[i] + nums[j] <= target, then all indices from i+1 to j form valid pairs with i; move i forward. Otherwise, move j backward.",
        "state_preservation": "The count of valid pairs in the processed prefix/suffix remains invariant during pointer movement."
      },
      "Transformable Parameters": {
        "n_range": [
          2,
          100000
        ],
        "value_domain": [
          1,
          100000
        ],
        "is_sorted_input": false,
        "circular_array": false,
        "online_queries": false,
        "batch_processing": false,
        "modification_operations": false,
        "output_form": "count modulo 1e9+7",
        "allow_same_index": false,
        "objective_variation": [
          "maximize_sum_under_constraint",
          "minimize_sum_above_target",
          "existence_of_pair"
        ],
        "dimension_extension": "2D_point_pairs",
        "additional_constraints": []
      }
    }
  },
  {
    "title": "黑盒光线反射",
    "slug": "IQvJ9i",
    "schema": {
      "Input Structure": [
        "二维矩形边界上的环形小孔结构，总共有 2*(m+n) 个小孔，按顺时针编号（0 到 2*(m+n)-1）",
        "每个小孔位于 n×m 矩形的四条边上：上边（m 个）、右边（n 个）、下边（m 个）、左边（n 个）",
        "每个小孔具有位置坐标和方向属性，可打开或关闭",
        "光线沿 y = x 或 y = -x 方向传播（即对角线方向，±45°）",
        "初始状态：所有小孔关闭"
      ],
      "Core Constraint": [
        "光线在闭合小孔之间反射，遵循镜面反射规则（入射角等于反射角）",
        "当光线到达开启的小孔时立即射出，返回该小孔编号",
        "若光线射向未打开的顶点（拐角），则原路反射",
        "光线从小孔进入的方向必须与几何位置兼容（如角落小孔只允许特定方向入射）",
        "小孔的开闭状态动态变化，影响光线路径终点"
      ],
      "Objective Function": [
        "对于每次 `open(index, direction)` 操作，模拟光线从指定小孔以指定方向射入后的传播路径",
        "确定光线最终从哪一个已打开的小孔射出",
        "返回射出小孔的序号"
      ],
      "Algorithmic Invariant": [
        "光线路径在封闭系统中是确定性的：给定起始位置、方向和当前开闭状态，路径唯一",
        "反射过程满足空间对称性与方向守恒：可通过坐标变换建模为平面上的直线运动",
        "利用展开法（Unfolding the Grid）将反射路径转化为直线轨迹：每遇到边界则镜像扩展平面",
        "路径中首次遇到的“已开启”小孔即为出口，搜索过程中跳过关闭的小孔",
        "使用哈希表维护当前开启的小孔集合，实现 O(1) 查询"
      ],
      "Transformable Parameters": [
        "n 和 m 的数量级：[1, 10000] → 可调整至更高（离线批量处理）或更低（静态预处理）",
        "操作次数上限：1e4 → 可扩展为在线流式查询或支持撤销操作",
        "是否允许多次连续 open 同一小孔（幂等性处理）",
        "是否支持动态修改已有光线路径（如插入障碍）",
        "direction 是否扩展为更多角度（如八方向）",
        "输入形式：单组初始化 + 多次操作 → 可变为多组测试用例",
        "是否要求输出完整路径而非仅出口编号",
        "是否加入延迟关闭、定时开关等时间维度控制"
      ]
    }
  },
  {
    "title": "早餐组合",
    "slug": "2vYnGI",
    "schema": "{\n  \"Input Structure\": [\n    \"一维整型数组 staple[1..n], 其中 n = length(staple)\",\n    \"一维整型数组 drinks[1..m], 其中 m = length(drinks)\",\n    \"整数 x 表示最大预算\",\n    \"staple[i] ≥ 1, drinks[i] ≥ 1\",\n    \"数据规模：n, m ≤ 1e5，值域 ≤ 1e5，x ≤ 2e5\"\n  ],\n  \"Core Constraint\": [\n    \"每种购买方案由一份主食和一款饮料构成\",\n    \"总花费必须满足：staple[i] + drinks[j] ≤ x\",\n    \"主食与饮料选择独立，但组合受联合约束\",\n    \"问题本质是两数组间满足和约束的配对计数\"\n  ],\n  \"Objective Function\": \"计数所有满足 staple[i] + drinks[j] ≤ x 的 (i,j) 配对数量，并对 1e9+7 取模\",\n  \"Algorithmic Invariant\": [\n    \"若将 drinks 数组排序，则对于固定的 staple[i]，合法的 drinks[j] 构成前缀区间\",\n    \"利用二分查找或双指针可快速统计每个 staple[i] 对应的合法 drinks 数量\",\n    \"排序 drinks 后，整体单调性保证：staple 值越小，可匹配的 drinks 范围越大\",\n    \"可使用双指针技巧：staple 升序排列，drinks 升序排列，用右指针从大到小滑动维护 drinks 中满足条件的最大索引\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n, m 是否扩大至 1e6（要求 O(n+m) 解）\",\n      \"值域是否增大至 1e9（要求离散化或二分）\"\n    },\n    \"输入形式\": [\n      \"是否在线输入饮品价格流（要求预处理 staple 后支持查询）\",\n      \"是否多组查询不同 x 值（要求离线批量处理或前缀和预计算）\"\n    ],\n    \"数组性质\": [\n      \"staple 或 drinks 是否已排序\",\n      \"是否允许负价格（改变单调性假设）\"\n    ],\n    \"目标函数变换\": [\n      \"改为求最大/最小花费的合法组合\",\n      \"改为判定是否存在恰好花费 x 的方案\",\n      \"改为构造字典序最小的方案对\"\n    ],\n    \"约束类型变换\": [\n      \"≤ x → ≥ x 或 = x\",\n      \"加入第三类商品形成三元组约束\"\n    ],\n    \"输出要求\": [\n      \"是否需要去重（相同价格组合视为一种）\",\n      \"是否要求输出具体方案列表\"\n    ],\n    \"模数设置\": [\n      \"是否取消取模要求\",\n      \"是否更换模数或改为不取模\"\n    ]\n  }\n}"
  },
  {
    "title": "黑白方格画",
    "slug": "ccw6C7",
    "schema": {
      "Input Structure": [
        "二维网格，大小为 n × n（n ∈ [1, 6]）",
        "初始所有格子为白色",
        "操作对象：可选择任意多行和任意多列整体染黑"
      ],
      "Core Constraint": [
        "每选一行会将该行全部 n 个格子染黑",
        "每选一列会将该列全部 n 个格子染黑",
        "行与列的交点会被重复染色但只计一次",
        "最终黑色格子总数 = |行集|×n + |列集|×n - |行集|×|列集|",
        "即：k = r*n + c*n - r*c，其中 r 是选中的行数，c 是选中的列数"
      ],
      "Objective Function": "计数 —— 满足最终恰好有 k 个黑色格子的不同涂色方案数量（不同行列组合视为不同方案）",
      "Algorithmic Invariant": [
        "黑色格子总数仅依赖于所选行数 r 和列数 c，而非具体哪几行哪几列",
        "对于固定的 (r, c)，若满足 r*n + c*n - r*c == k，则对应 C(n,r) × C(n,c) 种方案",
        "枚举 r ∈ [0,n], c ∈ [0,n] 即可覆盖所有可能状态",
        "组合数可预处理或直接计算（因 n ≤ 6）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题 n ≤ 6，可扩展至 n ≤ 20（需优化组合数计算）或 n ≤ 1e5（需数学推导）",
        "k 的约束": [
          "可变为 ≥k、≤k 的计数问题",
          "或判定是否存在解",
          "或求最小/最大可达到的黑格数"
        ],
        "是否允许重叠优化": "引入权重或代价函数（如每行/列有成本，总成本受限）",
        "输入形式": [
          "单组数据 → 多组测试数据",
          "静态输入 → 在线查询（固定 n，多次询问 k）"
        ],
        "操作类型扩展": [
          "加入不可用行列限制",
          "允许对角线或其他形状操作",
          "禁止全涂或空涂"
        ],
        "颜色规则变化": "改为三次染色（黑白灰）、或异或染色（偶次变白）等"
      }
    }
  },
  {
    "title": "速算机器人",
    "slug": "nGK0Fy",
    "schema": "{\n  \"Input Structure\": [\n    \"初始状态变量 x 和 y，其中 x = 1, y = 0\",\n    \"给定一个由大写字母 'A' 和 'B' 组成的字符串 s\",\n    \"s.length <= 10，字符表示操作序列\"\n  ],\n  \"Core Constraint\": [\n    \"'A' 运算定义为：x = 2 * x + y\",\n    \"'B' 运算定义为：y = 2 * y + x\",\n    \"操作按字符串 s 的顺序依次执行，每步依赖当前 x 和 y 的值\",\n    \"运算具有前向状态依赖性：后续状态完全由前一状态通过确定性规则演化而来\"\n  ],\n  \"Objective Function\": [\n    \"计算经过所有操作后，最终的 x + y 值\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"状态 (x, y) 在每一步变换中保持整数性\",\n    \"每一步操作是确定性的且不可逆\",\n    \"状态演化路径唯一，不依赖未来或过去的操作顺序以外的信息\",\n    \"无需回溯或分支选择，仅需顺序模拟即可得到结果\"\n  ],\n  \"Transformable Parameters\": {\n    \"初始值\": {\n      \"x_initial\": \"可变（如从 (1,0) 改为任意整数对）\",\n      \"y_initial\": \"可变\"\n    },\n    \"操作集\": {\n      \"是否扩展新指令（如 C: x = x + 3*y）\": true,\n      \"操作是否可交换（改变 A/B 顺序的影响）\": true\n    },\n    \"字符串约束\": {\n      \"长度范围\": \"0 <= |s| <= n, n 可调整（如扩大至 1e5 并要求矩阵快速幂优化）\",\n      \"字符集合\": [\"A\", \"B\"] // 可增加更多操作符\n    },\n    \"数据流模式\": {\n      \"是否在线输入操作字符\": false,\n      \"是否支持撤销操作\": false\n    },\n    \"输出形式\": {\n      \"返回值类型\": \"最终 x+y（可改为返回 (x,y) 对、最大值、模意义下结果等）\"\n    },\n    \"数值属性\": {\n      \"是否允许负数\": true,\n      \"是否取模\": false\n    }\n  }\n}"
  },
  {
    "title": "古董键盘",
    "slug": "Uh984O",
    "schema": {
      "Input Structure": [
        "一个整数 k，表示每个字母 a~z 最多可被按下 k 次",
        "一个整数 n，表示总共按键次数",
        "字符集固定为 26 个小写英文字母（a~z）",
        "n 的取值范围为 [1, 26*k]"
      ],
      "Core Constraint": [
        "每个字符最多使用 k 次",
        "总长度恰好为 n",
        "不同字符的使用次数相互独立但受全局上限 k 约束",
        "字符串顺序重要（即排列问题）"
      ],
      "Objective Function": "计数：求所有可能按出的不同字符串的数量（考虑顺序），结果对 1e9+7 取模",
      "Algorithmic Invariant": [
        "状态可由当前已使用的字符频次分布压缩表示（如用多重集合或计数向量）",
        "使用动态规划时，状态转移满足：新增一个字符 c 当且仅当 c 的使用次数 < k",
        "利用组合数学中的多重排列公式：若各字符使用次数为 c1, c2, ..., c26，则方案数为 n! / (c1! * c2! * ... * c26!)",
        "可通过 DP + 枚举使用频次的方式进行状态推进，状态维度可优化为剩余长度和当前字符位置"
      ],
      "Transformable Parameters": {
        "k的取值范围": "1 <= k <= 5（当前约束），可扩展至更大值以测试复杂度边界",
        "n的取值范围": "1 <= n <= 26*k（当前离散上限），可变为连续输入或多组数据",
        "字符集大小": "固定为 26，可泛化为 C 个字符的一般情况",
        "是否允许空串": "当前不允许（n>=1），可作为变形参数",
        "目标函数形式": "当前为计数；可变体包括：判定是否存在、构造字典序第K个串、输出最长回文子序列长度等",
        "数据规模": "n 最大为 130（26*5），适合 O(n^2 * 26) 或类似复杂度算法；可设置在线查询多个 (n,k) 对",
        "是否多组输入": "原题单组输入，可扩展为 T 组测试数据",
        "是否加入额外约束": "例如某些字符必须使用、相邻字符不能相同、必须形成回文等"
      }
    }
  },
  {
    "title": "追逐游戏",
    "slug": "Za25hA",
    "schema": {
      "Input Structure": {
        "type": "graph",
        "formal": "Undirected connected graph G = (V, E), where |V| = n, |E| = n, represented by edge list edges; each edge [a, b] connects two distinct vertices. Two starting nodes: startA ∈ V, startB ∈ V, with startA ≠ startB.",
        "node_count": "n = |V| = |edges|",
        "properties": [
          "connected",
          "no multiple edges",
          "undirected",
          "n vertices and n edges → exactly one cycle (pseudotree)"
        ]
      },
      "Core Constraint": {
        "structural": "The graph is a pseudotree — a connected undirected graph with exactly one cycle. This implies the graph consists of a single cycle with trees (chains) attached to it.",
        "gameplay": "Turn-based pursuit game with asymmetric information:小力 moves first, then 小扣 observes and responds. Both players move optimally. Movement allowed to adjacent node or stay in place.",
        "termination": "Game ends when both players are at the same node at the end of a round."
      },
      "Objective Function": {
        "type": "minimization with fallback",
        "goal": "Minimum number of rounds required for 小力 to catch 小扣, assuming both play optimally.",
        "output": "Return -1 if 小扣 can evade forever; otherwise return the minimal positive integer number of rounds."
      },
      "Algorithmic Invariant": {
        "invariants": [
          "If the distance from 小力 to 小扣 is 0 at any round, game ends.",
          "小扣 can only be caught if he cannot keep increasing or maintaining his safety margin under optimal play.",
          "On any tree (acyclic) component, 小力 always wins eventually if the graph has no cycle or if 小扣 is forced into a branch without escape.",
          "Key invariant on cycle: If 小扣 reaches the cycle and can maintain a distance > 1 from 小力 along the cycle, and if the cycle length ≥ 4, then evasion is possible due to parity advantage (since 小扣 moves second).",
          "Distance propagation via BFS from both agents’ starting positions is essential to evaluate reachability and timing."
        ],
        "strategy_monotonicity": "Once 小力 reduces the shortest-path distance to 小扣 below a critical threshold (e.g., ≤1), capture is inevitable in finite steps.",
        "parity_invariant": "Due to turn order (小力 first), 小扣 gains an effective half-move advantage on cycles — this enables infinite evasion when cycle length ≥ 4 and 小扣 enters it before being trapped."
      },
      "Transformable Parameters": {
        "graph_structure": [
          "pseudotree (default)",
          "tree (n-1 edges) → 小力 always wins",
          "general graph with multiple cycles → harder analysis, possibly NP-hard"
        ],
        "cycle_properties": {
          "cycle_length_threshold": "≥4 allows evasion, ≤3 does not (due to insufficient space and parity)"
        },
        "movement_rules": [
          "both move simultaneously (changes information structure)",
          "allow teleportation / limited jumps",
          "restrict staying in place"
        ],
        "information_access": [
          "full observability (current setting)",
          "partial visibility (e.g., line-of-sight only)"
        ],
        "data_scale": {
          "n_range": [
            3,
            100000.0
          ],
          "time_complexity_constraint": "Expected O(n) or O(n log n) solution"
        },
        "input_form": [
          "static offline input (default)",
          "dynamic edge updates (not suitable here)",
          "multiple queries with fixed graph"
        ],
        "output_form": [
          "single integer: min rounds or -1",
          "extended: path reconstruction, strategy trace"
        ],
        "player_initiative": [
          "小力 moves first (default)",
          "simultaneous moves",
          "小扣 moves first (unfair but analyzable)"
        ]
      }
    }
  },
  {
    "title": "快速公交",
    "slug": "meChtZ",
    "schema": {
      "Input Structure": [
        "整数 target (目标站点，1 <= target <= 1e9)",
        "正整数 inc (从 x 走到 x+1 的时间成本)",
        "正整数 dec (从 x 走到 x-1 的时间成本)",
        "数组 jump[0..m-1]，其中 m <= 10，jump[i] >= 2",
        "数组 cost[0..m-1]，表示搭乘第 i 辆公交车的耗时"
      ],
      "Core Constraint": [
        "移动方式包括：步行（+1 或 -1）和搭乘公交车（x -> jump[i] * x）",
        "搭乘公交车可任意使用、不限次数，且可在任意站点触发",
        "允许经过编号大于 target 的站点",
        "问题本质是带权图上的最短路径，但状态空间极大（target 可达 1e9），不能显式建图",
        "最优解具有子结构重叠性与最优子结构性质"
      ],
      "Objective Function": "求从站点 0 到站点 target 的最小时间花费（对 1e9+7 取模）",
      "Algorithmic Invariant": [
        "反向思维：从 target 出发倒推回 0 比正向更优，因为 jump 是乘法操作，正向分支爆炸",
        "对于当前站点 x，所有可能前驱为：x-1（步行来）、x+1（走回来）、以及满足 jump[i] * p == x 的 p（即 x % jump[i] == 0 时，p = x / jump[i]）",
        "采用记忆化搜索 + BFS / Dijkstra 风格松弛：每个状态的最短距离一旦确定，不再更新",
        "状态转移中，仅当新路径更短时才扩展，保证贪心正确性",
        "由于 dec 和 inc 不同，往复行走有代价差异，必须考虑双向移动"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "target": "1 <= target <= 1e9（大值域，禁止线性DP）",
          "m": "1 <= m <= 10（公交车种类少，可枚举）",
          "jump[i]": "2 <= jump[i] <= 1e6",
          "cost[i], inc, dec": "1 <= ... <= 1e6"
        },
        "输入形式": "单组输入，离线处理",
        "是否取模": true,
        "是否允许负站点": false,
        "是否在线查询": false,
        "公交规则变体": [
          "jump 规则可改为加法或幂运算",
          "cost 可依赖当前站点（如 cost[i] * x）",
          "引入搭乘次数限制"
        ],
        "移动规则变体": [
          "inc/dec 是否随位置变化",
          "是否允许跳跃到 jump[i] * x + offset",
          "是否加入传送门等其他操作"
        ],
        "目标函数变体": [
          "最小步数（而非时间）",
          "是否存在可行解",
          "构造最优路径方案"
        ]
      }
    }
  },
  {
    "title": "导航装置",
    "slug": "hSRGyL",
    "schema": {
      "Input Structure": "一棵二叉树 root，节点数为 N，节点值为 1~N 的排列；树通过指针结构给出，非空节点构成连通无环图；输入规模：2 <= N <= 50000",
      "Core Constraint": "任意两个不同景点到所有导航装置的距离向量必须不同；即对于任意两个节点 u ≠ v，存在至少一个装置 d，使得 dist(u, d) ≠ dist(v, d)；导航装置集合需满足全局可区分性约束",
      "Objective Function": "最小化导航装置的数量 M",
      "Algorithmic Invariant": "1. 若某子树已被足够多的外部装置覆盖（提供区分能力），则其内部无需额外装置；\n2. 在树形 DP 中维护每个节点子树的‘未被区分状态’或‘是否已被锚定’；\n3. 贪心选择原则：优先在度数较高或处于对称结构中的节点设置装置以打破对称性；\n4. 对称子树必须至少有一个节点被装置打破对称，否则无法区分对应位置",
      "Transformable Parameters": {
        "数据规模": "N ∈ [2, 50000]，可扩展至 1e5 或改为多组测试数据",
        "树结构类型": "从普通二叉树 → 完全二叉树 / 链状树 / 星形树 / 多叉树",
        "装置编号顺序": "是否要求按节点编号升序输出装置位置（影响构造方案）",
        "输出形式": "仅输出最小数量 / 输出具体装置位置 / 输出所有可行解数量",
        "距离定义方式": "边权是否为 1（默认）→ 可变为带权图上的距离",
        "在线查询": "是否支持动态增删装置并实时判断是否仍满足区分性",
        "隐藏条件": "是否存在对称结构（如镜像子树）作为关键难点"
      }
    }
  },
  {
    "title": "数字游戏",
    "slug": "5TxKeK",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "nums[0..n-1]",
        "constraints": [
          "n = len(nums), 1 <= n <= 1e5",
          "nums[i] 是整数, 1 <= nums[i] <= 1000",
          "数组按计数器编号升序给出"
        ]
      },
      "Core Constraint": {
        "description": "对于每个前缀 [0:i]，需将子数组 nums[0..i] 变为严格递增序列，满足 nums[a] + 1 == nums[a+1] 对所有 0 <= a < i 成立",
        "implication": "目标序列必须是公差为1的等差数列，即形如 [x, x+1, x+2, ..., x+i] 的形式，其中起始值 x 可自由选择以最小化操作次数"
      },
      "Objective Function": {
        "type": "prefix array of minimization",
        "goal": "对每个 i（0 <= i < N），求将前缀 nums[0..i] 修改为某个公差为1的等差数列所需的最小操作总数（每次 ±1 计 1 次操作）",
        "output": "长度为 N 的数组，第 i 个元素为最小操作数模 1000000007"
      },
      "Algorithmic Invariant": {
        "invariant_1": "最优目标序列的起始值 x 应使变换后的序列 [x, x+1, ..., x+i] 尽可能接近原始 nums[0..i]，即最小化 sum(|nums[j] - (x+j)|) over j=0..i",
        "invariant_2": "令 b[j] = nums[j] - j，则原问题转化为：选择一个常数 x，使得 sum(|b[j] - x|) 最小 —— 此为经典中位数贪心问题",
        "invariant_3": "当 x 取数组 b[0..i] 的中位数时，绝对偏差和最小",
        "invariant_4": "可用对顶堆或排序+滑动中位数维护前缀 b[0..i] 的中位数及绝对偏差和，支持增量更新"
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 1e5 (可扩展至 1e6 要求在线算法)",
        "value_domain": "nums[i] ∈ [1, 1000] (可改为 [-1e5, 1e5])",
        "arithmetic_step": "公差固定为1 → 可推广为 k (给定步长)",
        "operation_cost": "每次±1代价为1 → 可变为平方代价、非线性代价",
        "modular_output": "是否取模 1e9+7 (可取消或换模数)",
        "input_form": "单组输入 → 多组测试数据",
        "query_mode": "离线前缀输出 → 在线询问某个 i 的答案",
        "constraint_type": "严格递增 a+1 → 非严格 a+k 或其他模式如斐波那契模式",
        "additional_operations": "仅允许±1 → 允许批量修改或跳变"
      }
    }
  },
  {
    "title": "秋叶收藏集",
    "slug": "UlBDOe",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "leaves[1..n]",
        "characters": [
          "r",
          "y"
        ],
        "length_constraint": "3 <= n <= 10^5",
        "description": "表示红叶('r')和黄叶('y')的序列，长度至少为3"
      },
      "Core Constraint": {
        "target_pattern": "red-yellow-red",
        "partition_structure": "三段式划分：第一段全为'r'，第二段全为'y'，第三段全为'r'",
        "segment_nonempty": "每一段长度 >= 1",
        "transformation_rule": "每次操作可将'r'→'y'或'y'→'r'，目标是最小化替换次数以满足模式"
      },
      "Objective Function": {
        "goal": "minimization",
        "objective": "最小化将原字符串变为形如 'rr...yy...rr...'（红-黄-红）所需的字符替换次数"
      },
      "Algorithmic Invariant": {
        "invariant_description": "枚举中间黄色段的起始与结束位置（即两个分割点i,j），则总代价 = 左段非'r'数 + 中段非'y'数 + 右段非'r'数",
        "optimization_insight": "通过预处理前缀中'r'和'y'的数量，可在O(1)时间内计算任意区间的转换成本",
        "state_monotonicity": "利用动态规划状态机思想：维护当前处于第一段（红）、第二段（黄）、第三段（红）的最小代价，状态只能按序转移",
        "dp_invariant": "状态转移保证：只有在已进入第k段的前提下才能进入第k+1段，且最终必须到达第3段"
      },
      "Transformable Parameters": {
        "n_range": [
          3,
          100000.0
        ],
        "alphabet_size": 2,
        "character_set": [
          "r",
          "y"
        ],
        "pattern_length": 3,
        "target_segments": "fixed to 3 (R-Y-R)",
        "segment_length_constraint": "all segments must be non-empty",
        "input_form": "offline, static string",
        "output_form": "single integer (minimum operations)",
        "multi_query": false,
        "online_input": false,
        "edit_operations": "only color replacement allowed",
        "allowed_transformations": [
          "change target pattern: e.g., Y-R-Y, R-R-Y, etc.",
          "allow empty segments",
          "generalize to k-segment pattern",
          "add cost weights for r→y and y→r",
          "extend to cyclic string",
          "introduce insertion/deletion operations",
          "require reconstruction of final string"
        ]
      }
    }
  },
  {
    "title": "寻宝",
    "slug": "xun-bao",
    "schema": {
      "Input Structure": [
        "二维字符矩阵 maze[1..n][1..m]",
        "每个位置为以下之一：'S'（起点）、'T'（终点/宝藏点）、'M'（机关点，数量 ≤ 16）",
        "'O'（石堆点，可无限取石，数量 ≤ 40）",
        "'#'（墙，不可通行）",
        "'.'（空地，可自由通行）",
        "所有非墙格子均可多次经过",
        "人物一次只能携带一个石头"
      ],
      "Core Constraint": [
        "机关 'M' 必须被重石覆盖才能触发，且一旦触发需保持至最终到达 'T'",
        "只有所有 'M' 都被触发后，才可进入 'T' 拿取宝藏",
        "搬起和放下石头不计入步数，但移动一格算一步",
        "从 'O' 取石或向 'M' 放石必须位于该格上",
        "路径中可重复访问任意非墙节点，包括 'O' 多次取石"
      ],
      "Objective Function": [
        "最小化总移动步数",
        "使得从 'S' 出发，通过若干次往返搬运石头，将所有 'M' 触发，并最终到达 'T'",
        "若无法完成任务，返回 -1"
      ],
      "Algorithmic Invariant": [
        "状态空间可建模为 (当前坐标, 已触发机关集合) 的状态图",
        "使用预处理 BFS 计算任意两个关键点（S, T, O, M）之间的最短距离",
        "在状态转移中，每次携带石头从 O 到未触发的 M 是有效推进",
        "已触发机关集合单调增加（不可逆），构成 DP 状态的无后效性",
        "最优子结构：从一个机关子集到另一个的扩展可通过枚举下一个目标 M 实现"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "maze dimensions": "1 <= n, m <= 100",
          "number of M": "0 <= |M| <= 16 → 支持状态压缩DP",
          "number of O": "0 <= |O| <= 40"
        },
        "输入形式": "字符串数组表示迷宫，固定字符编码",
        "是否多组数据": false,
        "是否在线": false,
        "机关触发机制": "显式要求全部触发才可开启终点",
        "携带限制": "仅能携带一块石头",
        "石堆容量": "无限供应",
        "墙壁属性": "静态不可通行",
        "可变扩展方向": [
          "改为部分触发即解锁区域",
          "引入动态机关重置机制",
          "允许多块石头携带（k-stone constraint）",
          "加入时间限制或移动障碍物",
          "变为在线查询：新增机关或石堆后的再规划"
        ]
      }
    }
  },
  {
    "title": "最小矩形面积",
    "slug": "zui-xiao-ju-xing-mian-ji",
    "schema": {
      "Input Structure": [
        "二维数组 lines[1..n]，每个元素为 [k, b]",
        "每条直线形式为 y = kx + b，其中 k > 0 且为整数，b 为整数",
        "n = len(lines) 满足 1 <= n <= 1e5",
        "不存在重合直线（即任意两条 (k1, b1) ≠ (k2, b2)）"
      ],
      "Core Constraint": [
        "所有直线斜率 k > 0，因此两两之间必有唯一交点（除非平行，但此处 k 不同则不平行）",
        "交点坐标可通过解析公式计算：对于直线 y = k1*x + b1 和 y = k2*x + b2，交点 x = (b2 - b1)/(k1 - k2), y = k1*x + b1",
        "由于 k > 0 且互不相同，分母非零，所有对都有定义的交点",
        "目标是覆盖所有 C(n,2) 个交点的最小轴对齐矩形"
      ],
      "Objective Function": "计算包含所有直线两两交点的最小轴对齐矩形面积；若交点数 ≤ 1 或所有交点共线且平行于坐标轴，则返回 0",
      "Algorithmic Invariant": [
        "交点的 x 坐标仅由 (b2 - b1)/(k1 - k2) 决定，可通过对 (k, b) 对的代数分析进行极值推导",
        "最小包围矩形的边界由交点中 min_x, max_x, min_y, max_y 确定",
        "可以不显式计算所有 O(n^2) 个交点，而是通过数学变换将极值问题转化为关于 (k, b) 的函数优化",
        "利用斜率单调性与截距关系，可在 O(n log n) 时间内求出 x 和 y 坐标的极值",
        "关键观察：固定 k 排序后，x 坐标极值出现在相邻或极端参数组合中（凸包思想或排序扫描）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1e5（当前），可扩展至支持更大规模或在线输入",
        "斜率符号约束": "当前 k > 0，可变形为 k ∈ Z\\{0} 或允许 k=0（水平线）",
        "是否允许平行线": "当前无重合，但可引入平行线（相同 k 不同 b）导致无交点",
        "输入形式": "当前为离线静态数组，可改为动态添加/删除直线",
        "输出精度要求": "当前误差容忍 1e-4，可调整为更高精度或整数化条件",
        "维度扩展": "可推广到三维平面或多维超平面交点包围盒问题",
        "目标函数变化": "从面积 → 周长 / 是否存在面积小于 K 的子集 / 计数满足在矩形内的交点数",
        "约束反转": "求最大空矩形 / 覆盖至少 K 个交点的最小矩形"
      }
    }
  },
  {
    "title": "最小跳跃次数",
    "slug": "zui-xiao-tiao-yue-ci-shu",
    "schema": {
      "Input Structure": "一维数组 jump[0..n-1]，其中 n = length(jump)，jump[i] ≥ 1，表示在位置 i 向右可跳跃的固定距离；小球起始于位置 0，目标是向右跳出区间 [0, n-1]（即到达位置 ≥ n）",
      "Core Constraint": "在任意位置 i，可选择：(1) 向右跳至 i + jump[i]；(2) 向左跳至任意位置 j（0 ≤ j < i）。但无法从位置 0 向左跳。跳跃行为构成有向图转移关系，且向左跳提供强连通性优化路径",
      "Objective Function": "求将小球从位置 0 出发，通过最少次数的按动弹簧操作，使其向右跳出机器（位置 ≥ n）的最小步数",
      "Algorithmic Invariant": "使用 BFS 按层扩展状态时，一旦访问某个位置 i，则其最短到达步数已确定；利用‘向左跳可达所有左侧未访问节点’的性质，在首次到达某位置时，可一次性将所有左侧未访问位置加入下一层或当前层（取决于实现），从而保证单调推进与最优性不变量",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^6（可调整为更小规模用于教学题）",
        "jump[i] 值域": "1 <= jump[i] <= 10000（可设为更大或动态变化）",
        "是否允许负跳跃值": false,
        "是否双向弹射均可": "原题中仅位置 0 不能左跳，其余均可 —— 可改为限制某些位置不可左跳",
        "是否在线输入": false,
        "是否多组数据": false,
        "是否支持修改操作": "当前为静态数组，可扩展为支持单点更新 jump[i]",
        "目标方向": "当前为向右跳出（≥n），可变换为向左跳出（<0）或任一方向均可",
        "移动规则变形": "例如：向左只能跳到特定模式的位置（如偶数索引）、或需代价"
      }
    }
  },
  {
    "title": "二叉树染色",
    "slug": "er-cha-shu-ran-se-UGC",
    "schema": {
      "Input Structure": [
        "二叉树 root，每个节点具有整数值 val",
        "结点数量 n ∈ [1, 10000]",
        "每个节点 val ∈ [1, 10000]",
        "k ∈ [1, 10]"
      ],
      "Core Constraint": [
        "染色的蓝色结点形成的连通块（在树中）中，每个连通块的结点数不得超过 k",
        "连通性基于树结构：父子边连接的蓝色结点视为相连",
        "不能有超过 k 个蓝色结点在同一个连通分量中"
      ],
      "Objective Function": "最大化所有被染成蓝色的结点的价值总和",
      "Algorithmic Invariant": [
        "树形 DP 状态设计：对每个子树，维护以该节点为根的连通段长度为 j（0 ≤ j ≤ k）时的最大收益",
        "若当前节点不染色，则子树之间相互独立，可分别取最优解",
        "若当前节点染色，则至多只能从两个子树中继承一个非零长度的连通路径，且总长度不超过 k",
        "状态转移时保持连通性与长度约束的单调可组合性"
      ],
      "Transformable Parameters": {
        "k 的取值范围": "可扩展至更大（如 k ≤ 100），或作为变量输入",
        "树的形态约束": [
          "是否为满二叉树 / 完全二叉树 / 链状",
          "是否平衡"
        ],
        "染色约束形式": [
          "改为 ≥k 个才允许染色（激活条件）",
          "每个连通块恰好为 k 个",
          "全局最多存在 m 个连通块"
        ],
        "目标函数变化": [
          "求最小化代价",
          "计数满足条件的方案数",
          "构造最优染色方案"
        ],
        "颜色数量扩展": [
          "允许多种颜色，每种颜色内部连通块大小受限"
        ],
        "操作模式": [
          "支持动态修改节点价值",
          "在线查询不同 k 下的答案"
        ],
        "连通定义变换": [
          "仅考虑叶节点之间的连通性",
          "忽略父-子方向，使用无向连通"
        ]
      }
    }
  },
  {
    "title": "游乐园的迷宫",
    "slug": "you-le-yuan-de-mi-gong",
    "schema": {
      "Input Structure": [
        "二维平面上的点集 points[0..n-1]，其中 n = |points|",
        "每个点为坐标对 (x, y)，且所有点互不重合",
        "不存在三点共线",
        "输入包含一个长度为 n-2 的字符串 direction，仅含 'L' 和 'R'"
      ],
      "Core Constraint": [
        "路径必须访问所有 n 个点恰好一次，形成一条简单哈密顿路径（起点 → 经过中间点 → 回到终点）",
        "路径中每三个连续点构成的转向必须与 direction 字符串对应位置的要求一致：'L' 表示左转，'R' 表示右转",
        "转向判断基于向量叉积符号：对于三点 A→B→C，若向量 AB × 向量 BC > 0 则为左转，< 0 则为右转",
        "由于无三点共线，叉积永不为零，方向唯一确定"
      ],
      "Objective Function": [
        "构造任意一条满足给定转向序列的遍历路径",
        "输出路径上点的索引序列，即一个 [0, n-1] 的排列，表示访问顺序"
      ],
      "Algorithmic Invariant": [
        "贪心构造不变性：可以固定起点和次点后，逐个选择下一个满足转向约束的点",
        "在剩余未访问点中，只要存在某个点使得当前三元组满足所需转向（L/R），即可安全选取该点而不会导致后续无解",
        "可证明：在任意时刻，满足当前转向要求的候选点至少存在一个，并且选择其一仍保留全局可完成性（基于平面几何性质与归纳法）",
        "状态演化单调：已访问序列逐步扩展，未访问集合缩小，无需回溯"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前 3 <= n <= 1000，可变至更小或更大规模（如 n ≤ 1e5，在线构造）",
        "是否允许三点共线：当前禁止，可改为允许并定义共线时的行为（如视为无效/默认方向）",
        "输入形式：direction 可变为在线流式输入（逐字符给出，需实时响应下一点）",
        "输出要求：由输出任意解 → 输出字典序最小解 / 所有解计数",
        "图结构变化：由完全图上的路径 → 加入边权限制或连通性约束",
        "目标函数变换：由构造方案 → 判定是否存在解（当允许共线或加入额外约束时可能不可行）",
        "维度扩展：由 2D 平面 → 高维空间中的‘转向’定义（需重新建模）"
      ]
    }
  },
  {
    "title": "小张刷题计划",
    "slug": "xiao-zhang-shua-ti-ji-hua",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "time[i]: non-negative integer representing time to complete task i",
        "constraints": [
          "length n: 1 <= n <= 10^5",
          "value range: 1 <= time[i] <= 10000",
          "sequence order must be preserved (tasks processed from 0 to n-1)",
          "input is a one-dimensional ordered array of non-negative integers"
        ]
      },
      "Core Constraint": {
        "description": "Tasks must be completed in sequential order without skipping; each day can include at most one求助 (help request), which removes the time cost of one task per day. The workload of a day is the sum of the time of all tasks completed on that day, minus the maximum single task time (since one help can remove the longest task).",
        "key_conditions": [
          "Daily workload = total time of tasks assigned to the day - max(task_time) [due to one free help]",
          "Cannot reorder tasks",
          "Each day at most one task can be fully skipped (via help)"
        ]
      },
      "Objective Function": "Minimize T, where T is the maximum daily workload across m days (after applying one help per day to remove the largest task time in that day)",
      "Algorithmic Invariant": {
        "invariant_type": "Binary search monotonicity + greedy feasibility",
        "properties": [
          "If a maximum daily workload T is feasible, then any T' > T is also feasible (monotonicity for binary search)",
          "For a fixed T, we can greedily assign tasks to days: accumulate tasks until adding another would exceed T even with help (i.e., current_sum - max_so_far > T)",
          "The decision problem (can we finish in m days with max workload ≤ T?) has optimal substructure and greedy choice property",
          "Help usage is optimally applied to the longest task in each day"
        ]
      },
      "Transformable Parameters": {
        "n_value_range": "1 <= n <= 10^5",
        "m_value_range": "1 <= m <= 1000",
        "time_value_range": "1 <= time[i] <= 10000",
        "ordering": "sequential processing required",
        "help_limit_per_day": "1 (can be generalized to k)",
        "input_form": "offline, static array",
        "multiple_test_cases": false,
        "online_updates": false,
        "data_structure_extension": "could generalize to support modifications or deletions",
        "dimension_extension": "could extend to 2D task grid with row/column constraints",
        "objective_variation": [
          "Change from minimize max → minimize sum of squares",
          "Change from min-max to counting number of valid schemes"
        ],
        "constraint_reversal": "Change 'at most one help per day' → 'at least one help per day'",
        "hidden_monotonicity": "Monotonicity in binary search on answer is implicit but provable"
      }
    }
  },
  {
    "title": "期望个数统计",
    "slug": "qi-wang-ge-shu-tong-ji",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          0,
          1000000
        ],
        "duplicates_allowed": true,
        "order_property": "unordered input, but processed in descending order by value"
      },
      "Core Constraint": {
        "description": "能力值相同的简历在排序中的相对顺序是随机的，等可能地取自其全排列；不同能力值之间排序固定（从大到小）；相同位置匹配的期望具有线性可加性。",
        "key_idea": "X 可分解为每个位置是否匹配的指示变量之和，且期望可线性分解为每个面试者在相同位置被选中的概率之和。",
        "independence": "不同能力值组间排序独立，组内随机；同一组内的任意两个元素在两个序列中同位置的概率仅依赖于组大小。"
      },
      "Objective Function": {
        "goal": "compute expectation",
        "target_variable": "X",
        "definition": "X = number of resumes appearing at the same position in both A's and B's browsing orders",
        "math_form": "E[X] = sum_{i=1}^{n} P(position i matches)"
      },
      "Algorithmic Invariant": {
        "linearity_of_expectation": true,
        "group_contribution_invariance": "对于每个能力值相同的组 g（大小为 k），该组对总期望的贡献恒为 1，无论 k 如何分布。",
        "proof_sketch": "在大小为 k 的组中，任意一个特定元素在两个独立随机排列中出现在同一位置的概率是 1/k，k 个元素总期望贡献为 k * (1/k) = 1。",
        "additive_decomposition": "整体期望等于各能力值分组的期望贡献之和，每组贡献为 1"
      },
      "Transformable Parameters": {
        "n_value_range": [
          1,
          100000
        ],
        "score_value_range": [
          0,
          1000000
        ],
        "duplicate_distribution": "可调节重复元素的频次与分组结构",
        "input_order": "原始输入无序，但处理基于排序后的分组",
        "output_type": "single float or integer (expectation)",
        "multiple_test_cases": false,
        "online_processing": false,
        "randomness_model": "uniform random permutation within groups of equal scores",
        "extension_slots": [
          "改为求方差 Var(X)",
          "加入偏序约束（如某些人必须排在前面）",
          "变为在线随机生成顺序并查询部分期望",
          "能力值有噪声，变为概率排序（Plackett-Luce 模型）",
          "输出每个位置的匹配概率分布"
        ]
      }
    }
  },
  {
    "title": "游乐园的游览计划",
    "slug": "you-le-yuan-de-you-lan-ji-hua",
    "schema": {
      "Input Structure": [
        "无向图 G = (V, E)，其中 V 是节点集合，|V| = N，节点编号从 0 到 N-1",
        "每个节点 i 有一个非负喜爱值 value[i] ≥ 0",
        "边集 E 包含 M 条无向边，表示双向路径，E = {edges[i] = [u, v]}，无重边",
        "3 <= N <= 10000, 1 <= M <= 10000"
      ],
      "Core Constraint": [
        "选择一个重点节点 A，上午和下午分别构造一条形如 A-B-C-A 的三角形回路（即三元环）",
        "B ≠ C，且边 (A,B), (B,C), (C,A) 均存在",
        "同一天内重复游玩的项目不重复计分：总得分是所有**去重后访问的节点**的喜爱值之和",
        "上午与下午可共享部分或全部相邻项目，但必须各自构成合法三元环"
      ],
      "Objective Function": "最大化所选两个三元环（均包含重点节点 A）并集节点的喜爱值总和，即 max(Σ value[v], v ∈ (T1 ∪ T2))，若不存在合法方案则返回 0",
      "Algorithmic Invariant": [
        "对于固定的重点项目 A，其可行的三元环由其邻居之间的连边决定：若 u, v ∈ neighbor(A)，且 (u,v) ∈ E，则 A-u-v-A 构成一个合法路径",
        "两个三元环的贡献为它们所覆盖节点的并集，因此最优策略是在 A 的邻域中寻找两对互连节点 (u1,v1), (u2,v2)，使得 value[A] + value[u1] + value[v1] + value[u2] + value[v2] - 重复项 最大化",
        "由于重点节点 A 固定时，问题退化为在其邻居子图中找最多两条边（对应两个三角形），使得涉及节点的价值和最大（去重）",
        "枚举中心点 A，再枚举其邻居中所有能构成三角形的边对，并贪心选取价值和最大的两个（允许重叠）是正确性保证的关键"
      ],
      "Transformable Parameters": {
        "图结构类型": [
          "一般无向图",
          "稀疏图",
          "稠密图",
          "树（无环）",
          "平面图"
        ],
        "是否允许自环或重边": false,
        "value 值域": "[0, 10000]",
        "数据规模 n/m": [
          "N=1e4,M=1e4（当前）",
          "N=500,M=O(N²)（暴力可行）",
          "N=1e5,M=1e5（需优化枚举）"
        ],
        "是否多组数据": false,
        "是否在线": false,
        "目标函数变体": [
          "改为计数：有多少个中心点 A 可以选出两个合法三元环",
          "改为判定：是否存在某个 A 能使总喜爱值 ≥ K",
          "改为最小化最大单次路径花费"
        ],
        "约束变化": [
          "要求上午与下午路径完全不相交（除 A 外）",
          "最多只能玩 k 次（k>2）这样的路径",
          "B 和 C 不需要相连（变为星型结构）→ 则退化为简单度数问题"
        ],
        "输入形式变化": [
          "边以流式方式给出",
          "value 动态更新",
          "图是动态增删边"
        ]
      }
    }
  },
  {
    "title": "传递信息",
    "slug": "chuan-di-xin-xi",
    "schema": {
      "Input Structure": [
        "有向图 G = (V, E)，其中 V = {0, 1, ..., n-1}，表示 n 名玩家",
        "边集 relation ⊆ V × V，每条边 [u, v] 表示信息可从玩家 u 单向传递给玩家 v",
        "给定整数 k ≥ 1，表示传递轮数",
        "起点为节点 0，终点为节点 n-1",
        "n ≤ 10, k ≤ 5, |E| ≤ 90"
      ],
      "Core Constraint": [
        "信息每轮必须传递一次，且只能沿有向边进行",
        "允许重复经过同一节点或同一条边",
        "路径长度严格等于 k（即恰好 k 轮）",
        "路径必须从节点 0 出发，在第 k 轮结束时恰好到达节点 n-1"
      ],
      "Objective Function": "计数：求从节点 0 到节点 n-1 的、长度恰好为 k 的有向路径数量",
      "Algorithmic Invariant": [
        "状态 dp[r][v] 表示经过 r 轮后到达节点 v 的方案数",
        "状态转移满足：dp[r+1][v] = Σ dp[r][u]，其中所有 (u,v) ∈ E",
        "初始状态 dp[0][0] = 1，其余为 0",
        "由于 k 较小且图规模极小，状态空间有限，可通过动态规划逐层推进而不丢失最优性",
        "每一轮的状态仅依赖前一轮，具有时间维度上的单向递推不变性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可扩展至 1e3 或更高（需矩阵快速幂优化）",
        "k 的范围": "当前小（≤5），可变为大值（如 1e9）以触发矩阵快速幂解法",
        "图的存储形式": "当前为边列表，可改为邻接表或邻接矩阵",
        "是否允许多组查询": "可设计为多组 (k) 查询，推动预处理或矩阵幂优化",
        "是否在线": "可改为动态增删边，在线查询方案数",
        "路径约束": "可增加‘不可重复访问节点’等限制",
        "目标函数变形": "从计数 → 是否存在路径 / 最短到达轮数 / 方案数模大质数",
        "起点终点固定性": "可变为任意起点/终点对",
        "边权引入": "可加入边权，转化为‘总权值为特定值’的路径计数"
      }
    }
  },
  {
    "title": "二叉树任务调度",
    "slug": "er-cha-shu-ren-wu-diao-du",
    "schema": {
      "Input Structure": [
        "二叉树结构 T，其中每个节点表示一个任务",
        "T.root 表示根任务",
        "每个节点具有左子节点 T.left 和右子节点 T.right（可能为空），代表其前导任务",
        "每个节点的 val 属性为正实数，表示该任务的执行时间",
        "任务依赖关系构成一棵有向树（从叶子到根）",
        "所有任务可中断、可恢复（非抢占开销为0）"
      ],
      "Core Constraint": [
        "任务必须在其所有子任务（前导任务）完成后才能开始",
        "系统有两个 CPU 核，可并行执行两个不同任务",
        "同一任务不能同时在两个核上运行",
        "任务可任意暂停与恢复，暂停时间连续（支持非整数时间点）",
        "总执行时间由调度路径中的关键路径与并行利用率共同决定"
      ],
      "Objective Function": "最小化所有任务完成的总体时间（即调度长度 / makespan）",
      "Algorithmic Invariant": [
        "对于任意子树，其最优调度时间取决于左右子树的执行时间和可并行度",
        "设 left_time 和 right_time 分别为左右子树的总执行时间，subtree_makespan 为该子树的最小完成时间，则：",
        "若 left_time <= right_time，可通过在第二个核上重叠部分 left_time 来减少等待",
        "存在贪心策略：优先安排耗时长的子树先执行或并行填充短子树空隙",
        "递归结构中，当前任务只能在左右子任务都完成后才可执行，且其执行不可分割",
        "最优解满足：T.makespan = max(left.makespan, right.makespan, (left.total + right.total + self.val) / 2)，其中 total 是子树总执行时间之和"
      ],
      "Transformable Parameters": {
        "CPU核数量": "2（可扩展至 k 核）",
        "是否可中断": true,
        "任务执行时间类型": "正整数（可变为浮点数或负值变形）",
        "树结构限制": "二叉树（可推广至多叉树或 DAG）",
        "依赖方向": "子节点为前导任务（可反转为父节点为前驱）",
        "输入形式": "树的层序遍历数组（如 [47,74,31]），null 表示空节点",
        "输出精度要求": "支持小数输出（如 7.5），可限定为整数",
        "是否多组数据": false,
        "在线性": "离线处理整棵树",
        "节点数量级": "n <= 1000",
        "单节点时间值域": "[1, 1000]"
      }
    }
  },
  {
    "title": "切分数组",
    "slug": "qie-fen-shu-zu",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "每个元素为整数，满足 2 <= nums[i] <= 10^6",
        "数组长度 n 满足 1 <= n <= 10^5"
      ],
      "Core Constraint": [
        "每个子数组的划分必须满足：其最左端与最右端元素的最大公约数 > 1",
        "子数组非空且覆盖原数组全部元素",
        "划分位置只能在相邻元素之间进行"
      ],
      "Objective Function": "最小化子数组的数量（即最少划分数）",
      "Algorithmic Invariant": [
        "动态规划状态 dp[i] 表示前 i 个元素的最小划分数",
        "若存在 j < i 使得 gcd(nums[j], nums[i]) > 1，则可从 dp[j] 转移到 dp[i]",
        "利用因子传播：枚举 nums[i] 的所有质因数，并记录该质因数最近一次出现的位置以优化转移",
        "状态转移具有单调性：dp[i] 不会随 i 增加而减少"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1e5",
            "可扩展至 1e6（在线处理）"
          ],
          "nums[i] 值域": [
            "[2, 1e6]",
            "可调整为 [1, 1e7] 或含 1 的情况"
          ]
        },
        "输入形式": {
          "是否有序": "否（可变：改为有序数组影响贪心可行性）",
          "是否循环数组": "否（可变为环形数组，首尾相连）"
        },
        "约束条件": {
          "gcd 条件": "大于 1（可改为 >= k、等于 k、或小于 k）",
          "头尾定义": "最左和最右元素（可改为任意两端、或指定索引）"
        },
        "目标函数变化": [
          "求最小划分数（当前）",
          "改为求最大划分数（即最多段数仍满足条件）",
          "改为判定是否存在一种划分使得段数 <= K",
          "改为计数合法划分方案总数"
        ],
        "操作类型扩展": [
          "静态一次性输入（当前）",
          "支持单点修改 → 在线查询最小划分数（带更新的数据结构题）"
        ],
        "多组数据": "否（可扩展为 T 组测试用例，T <= 1e4）"
      }
    }
  },
  {
    "title": "魔术排列",
    "slug": "er94lq",
    "schema": {
      "Input Structure": {
        "type": "array",
        "description": "长度为 N 的排列 target，其中 target 是数字 1~N 的一个排列",
        "size": "N",
        "element_range": "1 <= target[i] <= N",
        "constraints": [
          "target 是 1~N 的全排列",
          "1 <= N <= 5000"
        ]
      },
      "Core Constraint": {
        "description": "魔术师的洗牌过程具有确定性结构：每轮将当前序列中下标为偶数位置（从1开始）的元素按原顺序前置到奇数位置元素之前，形成新序列；然后取走前 k 张（或全部若数量 ≤ k），剩余部分递归执行相同操作。",
        "key_properties": [
          "洗牌操作是固定的、可模拟的函数：f(arr) = [arr[1], arr[3], ..., arr[2m-1]] + [arr[0], arr[2], ..., arr[2n-2]] （索引从0转为1-based描述）",
          "取卡行为依赖于全局参数 k，且 k 在整个过程中保持不变",
          "最终输出序列由多轮洗牌+截断拼接而成"
        ]
      },
      "Objective Function": {
        "type": "decision",
        "goal": "判定是否存在某个整数 k >= 1，使得从初始排列 [1,2,...,N] 出发，按照指定洗牌规则和固定 k 取卡，最终得到的「魔术取数排列」恰好等于 target"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "对于给定的 k，整个「魔术取数排列」的生成过程是完全确定的，可以正向模拟",
          "洗牌操作具有结构性质：它等价于对数组下标的重排映射，该映射可预计算",
          "一旦 k 确定，每一轮取出的元素个数最多为 k，且仅取决于剩余长度与 k 的关系",
          "若某轮洗牌后前 min(k, len) 个元素不匹配 target 中对应段，则此 k 可剪枝"
        ],
        "optimization_insight": "由于 N <= 5000，而 k 的可能取值范围为 1 到 N，可通过枚举 k 并模拟全过程验证合法性；关键优化在于快速模拟洗牌过程（利用下标变换规律）"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "k_type",
            "description": "k 是否固定 / 是否允许变化",
            "options": [
              "fixed",
              "variable_per_round",
              "adaptive"
            ],
            "default": "fixed"
          },
          {
            "name": "shuffle_rule",
            "description": "洗牌方式是否改变",
            "options": [
              "even_before_odd (current)",
              "odd_before_even",
              "reverse_second_half",
              "interleave_even_odd"
            ]
          },
          {
            "name": "input_initialization",
            "description": "初始排列是否一定是 [1,2,...,N]",
            "options": [
              "sorted",
              "arbitrary_permutation",
              "given_initial"
            ]
          },
          {
            "name": "output_form",
            "description": "目标输出形式",
            "options": [
              "decision",
              "find_min_k",
              "count_valid_k",
              "construct_process"
            ]
          },
          {
            "name": "data_flow",
            "description": "是否支持在线查询多个 target",
            "options": [
              "offline",
              "online_batch"
            ]
          },
          {
            "name": "constraint_on_N",
            "description": "数据规模",
            "range": "N <= 5000 (original), upgradable to 1e5 with optimized simulation"
          },
          {
            "name": "additional_operations",
            "description": "是否加入插入/删除/修改操作",
            "options": [
              "static",
              "dynamic_update"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "剧情触发时间",
    "slug": "ju-qing-hong-fa-shi-jian",
    "schema": {
      "Input Structure": [
        "二维数组 increase[1..n], 其中每个元素为长度为3的一维数组 [ΔC, ΔR, ΔH]",
        "二维数组 requirements[1..m], 其中每个元素为长度为3的一维数组 [c_i, r_i, h_i]",
        "n = 天数，表示属性每日增量；m = 剧情数量",
        "所有值均为非负整数"
      ],
      "Core Constraint": [
        "三种属性 C, R, H 随时间单调递增（每天累加）",
        "每个剧情触发条件是三维独立下界约束：C ≥ c_i, R ≥ r_i, H ≥ h_i",
        "属性增长由固定序列决定，不可跳过或重排天数",
        "一旦某天满足某个剧情的所有条件，则该剧情在最早这一天被触发"
      ],
      "Objective Function": [
        "对每个剧情 i，求最小的天数 t（从0开始），使得前 t 天的属性总和满足 C_t ≥ c_i, R_t ≥ r_i, H_t ≥ h_i",
        "若不存在这样的 t（即最终属性仍不满足），返回 -1",
        "输出为长度为 m 的整数数组，对应每个剧情的触发时间"
      ],
      "Algorithmic Invariant": [
        "前缀和数组 P[t] = (C_t, R_t, H_t) 表示第 t 天结束时的累计属性值，具有单调性",
        "对于每个剧情 i，其触发时间可通过在前缀和序列上进行三分维度独立二分查找后取最大值得到",
        "由于属性单调不减，可在预处理前缀和后，对每个 requirement 独立计算答案，互不影响",
        "可将多维判断转化为：t 是触发时间当且仅当 P[t] ≥ requirement_i（按维比较）且 P[t-1] < requirement_i"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^4",
        "m 的数量级": "1 <= m <= 10^5",
        "值域范围": {
          "increase[i][j]": "0 <= x <= 10",
          "requirements[i][j]": "0 <= x <= 100000"
        },
        "是否有序": "increase 按时间顺序给出，不可重排；requirements 无序，需逐个处理",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "可变扩展点": [
          "改为在线查询：动态添加新的 requirement",
          "支持修改某一天的 increase 值（需要树状数组/线段树维护）",
          "限制只能使用部分连续天数（如滑动窗口式势力发展）",
          "目标函数变为：求能触发至少 k 个剧情的最短时间区间",
          "增加资源衰减机制，破坏单调性 → 转为状态搜索问题",
          "要求输出所有剧情首次触发的全序序列（去重、排序）"
        ]
      }
    }
  },
  {
    "title": "拿硬币",
    "slug": "na-ying-bi",
    "schema": {
      "Input Structure": "一维数组 coins[1..n]，其中每个元素 coins[i] 表示第 i 堆力扣币的数量；1 <= n <= 4，1 <= coins[i] <= 10，非负整数",
      "Core Constraint": "每次操作只能从任意一堆中拿走 1 枚或 2 枚硬币；每堆的操作独立，且最优策略仅依赖于该堆的硬币数",
      "Objective Function": "求拿完所有堆硬币所需的最少操作次数（最小化总次数）",
      "Algorithmic Invariant": "对于每堆数量为 c 的硬币，其最少操作次数为 ⌈c / 2⌉；整体最优解等于各堆局部最优解之和，具有可加性与无后效性",
      "Transformable Parameters": [
        "n 的数量级：原题较小（≤4），可扩展至 1e5 形成贪心/批处理场景",
        "coins[i] 的值域：当前 ≤10，可扩大至 1e9 观察公式直接计算能力",
        "是否允许一次拿 k 枚（k=1,2,...,K）：推广为参数化操作集",
        "是否限制每堆最多操作次数：加入额外约束形成背包类变形",
        "是否在线输入堆的信息：如流式添加新堆",
        "目标函数变换：从‘最小次数’变为‘是否存在恰好 K 次的方案’进行判定问题改编"
      ]
    }
  },
  {
    "title": "Sparse Similarity LCCI",
    "slug": "sparse-similarity-lcci",
    "schema": {
      "Input Structure": [
        "二维数组 docs[0..n-1]，其中 docs[i] 表示 id 为 i 的文档",
        "每个 docs[i] 是一个一维整数数组，元素互不相同",
        "n = docs.length ≤ 500",
        "每个文档长度 ≤ 500",
        "文档由非空、无重复的整数集合表示"
      ],
      "Core Constraint": [
        "文档间相似度定义为交集大小除以并集大小（Jaccard 相似度）",
        "相似度非常稀疏：绝大多数文档对的交集为空",
        "只需考虑相似度 > 0 的文档对",
        "每对文档的相似度仅依赖于其元素集合的交集与并集"
      ],
      "Objective Function": [
        "枚举所有相似度大于 0 的文档对 (i, j)，其中 i < j",
        "计算每对文档的 Jaccard 相似度",
        "输出格式为字符串 '{i},{j}: {similarity}'，相似度保留小数点后4位"
      ],
      "Algorithmic Invariant": [
        "若两个文档有共同元素，则它们的相似度 > 0",
        "交集大小可通过哈希表或倒排索引高效统计公共元素",
        "利用稀疏性跳过无交集的文档对，避免 O(n²m) 的暴力枚举",
        "通过元素到文档ID的倒排映射，只处理共享至少一个元素的文档对"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "docs.length": "可变，当前 ≤ 500",
          "单个文档长度": "可变，当前 ≤ 500",
          "值域范围": "整数范围可扩展，当前未限定"
        },
        "输入形式": {
          "是否有序": "文档内元素顺序无关（集合语义）",
          "是否去重": "已保证元素各不相同"
        },
        "输出要求": {
          "输出精度": "可调整小数位数（如 2 位或 6 位）",
          "输出格式": "可改为返回浮点数组或结构体",
          "是否排序": "当前任意顺序，可改为按 id 或相似度排序"
        },
        "稀疏性假设": {
          "是否稀疏": "可切换为稠密场景，影响算法设计选择"
        },
        "功能扩展": {
          "是否在线": "可改为流式添加文档并动态更新相似对",
          "是否增量计算": "支持插入/删除文档元素",
          "阈值条件": "当前 >0，可改为 ≥θ（如 0.1）"
        },
        "结构变形": {
          "维度扩展": "可推广至高维集合相似度（如 minhash 应用）",
          "相似度指标": "可替换为余弦相似度、欧氏距离等"
        }
      }
    }
  },
  {
    "title": "Langtons Ant LCCI",
    "slug": "langtons-ant-lcci",
    "schema": {
      "Input Structure": [
        "无限二维网格，初始全为白色方格",
        "蚂蚁起始位置在原点 (0, 0)，初始朝向为右（R）",
        "给定整数 K，表示蚂蚁执行的动作步数",
        "K ∈ [0, 100000]"
      ],
      "Core Constraint": [
        "每一步的行为由当前所在格子的颜色决定：",
        " - 白色 ('_')：翻转颜色为黑色，向右转90度（顺时针），前进一步",
        " - 黑色 ('X')：翻转颜色为白色，向左转90度（逆时针），前进一步",
        "状态转移完全确定且无分支",
        "网格变化与蚂蚁路径强耦合，历史操作影响后续行为"
      ],
      "Objective Function": [
        "模拟蚂蚁前 K 步的完整行为过程",
        "返回能够包含所有走过方格的最小矩形区域的网格表示",
        "输出形式为字符串数组，每个字符串代表一行",
        "需标记蚂蚁最终位置及其朝向（'L', 'U', 'R', 'D'）"
      ],
      "Algorithmic Invariant": [
        "蚂蚁的状态由 (x, y, dir) 唯一确定，其中 dir ∈ {0: 右, 1: 下, 2: 左, 3: 上}",
        "网格颜色变化具有可逆性但路径不可逆，整体系统呈现复杂动态演化",
        "每步操作是确定性的有限状态转移：颜色判断 → 转向 → 移动 → 更新位置和网格",
        "使用哈希表记录已访问坐标及其颜色，实现稀疏网格高效模拟",
        "边界可通过 min/max x/y 动态维护，用于构造最终输出矩形"
      ],
      "Transformable Parameters": [
        "K 的数量级：[0, 1e5]（当前限制），可扩展至更大规模或在线流式处理",
        "初始网格颜色配置：全白 / 全黑 / 自定义图案",
        "蚂蚁初始位置与朝向：可变参数",
        "转向规则：可改为其他角度系统（如60度）或随机化",
        "颜色翻转逻辑：可替换为多色循环（如 Langton's Ant 变种）",
        "是否多只蚂蚁并发运行",
        "是否要求输出中间状态轨迹",
        "输出形式：是否仅返回坐标序列 / 网格快照 / 差分更新",
        "是否离线批处理或多组测试用例输入"
      ]
    }
  },
  {
    "title": "Word Rectangle LCCI",
    "slug": "word-rectangle-lcci",
    "schema": {
      "Input Structure": [
        "给定一个字符串数组 words[1..n]",
        "每个字符串 words[i] 表示一个由小写字母组成的单词",
        "1 ≤ n ≤ 1000, 1 ≤ len(words[i]) ≤ 100",
        "所有单词可重复使用，不要求连续选取"
      ],
      "Core Constraint": [
        "构造的矩形必须满足：每一行（从左到右）是一个单词",
        "每一列（从上到下）也是一个单词",
        "所有行长度相等，所有列高度相等 → 矩形结构隐含 m × k 维度一致性",
        "行与列的交叉字符必须一致（即 grid[i][j] 同时属于第 i 行和第 j 列的单词）",
        "单词来源仅限于给定清单（允许重复使用）"
      ],
      "Objective Function": [
        "最大化矩形面积 = 行数 × 列数",
        "若有多个最大面积解，输出任意一个合法方案即可",
        "目标是构造性求解（constructive output），而非仅计数或判定"
      ],
      "Algorithmic Invariant": [
        "按列逐步构建候选矩形时，每添加一列，所有已有前缀在对应行方向上必须是某个单词的前缀（可用 Trie 维护）",
        "利用 DFS + 剪枝：当前已构建前 k 列形成的每行前缀，均存在于单词集合的前缀集中",
        "当某一行的前缀无法扩展为完整单词时，提前回溯",
        "维护列方向上的潜在单词匹配：若当前列构成的字符串在单词集中，则可能作为有效列",
        "最优性剪枝：优先尝试长宽积大的尺寸组合（如从 max_len * max_len 向下枚举）"
      ],
      "Transformable Parameters": [
        "单词数量级：|words| ∈ [1, 1000], 可变至更大规模（如 1e4）引入 Trie 性能考量",
        "单词长度范围：L ∈ [1, 100]，可调整为固定长度或更长",
        "是否要求输出所有最大面积矩形（→ 计数 / 枚举）",
        "是否禁止单词重复使用（→ 约束反转）",
        "是否允许对角线也成词（→ 多维约束扩展）",
        "是否在线添加单词（→ 动态输入）",
        "是否限定矩形为正方形（→ 目标函数变形）",
        "是否改为最小面积但覆盖最多不同单词（→ 目标函数变换）",
        "输入是否变为二维字符网格初值，要求修复成合法行列成词结构（→ 逆向问题）"
      ]
    }
  },
  {
    "title": "Sum Swap LCCI",
    "slug": "sum-swap-lcci",
    "schema": {
      "Input Structure": [
        "一维数组 array1[1..n], 元素为整数",
        "一维数组 array2[1..m], 元素为整数",
        "n, m ≥ 1，值域为整数（无显式符号限制）"
      ],
      "Core Constraint": [
        "交换一对元素 (a ∈ array1, b ∈ array2) 后，两个数组的元素和相等",
        "即：sum(array1) - a + b = sum(array2) - b + a",
        "化简得：a - b = (sum(array1) - sum(array2)) / 2",
        "因此目标差值固定且可预先计算"
      ],
      "Objective Function": [
        "构造性求解：返回任意一对满足条件的 (a, b)",
        "若不存在，返回空数组"
      ],
      "Algorithmic Invariant": [
        "设 diff = (sum1 - sum2) / 2，则需在 array1 中找 a，在 array2 中找 b，使得 a = b + diff",
        "若 diff 非整数，则无解",
        "利用哈希集合加速查找，保证每个候选 a 的匹配 b 可 O(1) 验证",
        "解的存在性仅依赖于数值差与集合包含关系，不依赖顺序"
      ],
      "Transformable Parameters": {
        "数据规模": "n, m ≤ 10^5 → 可扩展至支持更大规模或流式输入",
        "值域范围": "整数 → 可限定为正整数、非负整数或引入负数",
        "是否有序": "数组无序 → 可设定为有序以优化搜索方式",
        "是否多组数据": "单组输入 → 可改为多组查询",
        "是否在线": "离线处理 → 可设计为动态修改数组后查询",
        "输出要求": "返回任意一组解 → 可改为返回所有解、字典序最小解或判断解数量",
        "操作类型": "仅交换一对 → 可扩展为交换多对或带代价的交换"
      }
    }
  },
  {
    "title": "T9 LCCI",
    "slug": "t9-lcci",
    "schema": {
      "Input Structure": [
        "字符串 num，长度为 n（n ≤ 1000），由数字字符组成，不含 '0' 和 '1'",
        "字符串数组 words，长度 m ≤ 500，每个 words[i] 长度等于 num.length",
        "每个数字字符映射到一组字母（如：'2'→['a','b','c']，'3'→['d','e','f'] 等）"
      ],
      "Core Constraint": [
        "单词匹配规则：words[i][j] 必须属于 num[j] 所映射的字母集合",
        "所有候选词等长且与输入数字串等长",
        "匹配是逐位独立、字符对齐的（即第 j 个字母必须对应第 j 个数字）"
      ],
      "Objective Function": "筛选出所有满足数字映射关系的单词，构造匹配列表（存在性判定 + 构造方案）",
      "Algorithmic Invariant": [
        "每一位上的字符合法性可独立验证，无需回溯或全局依赖",
        "一旦某单词在任意位置不匹配，则可提前剪枝",
        "映射关系固定且预定义，查询时间为 O(1)"
      ],
      "Transformable Parameters": {
        "n 的数量级": "num.length 可变，当前 ≤ 1000；可扩展至支持更长序列或流式输入",
        "值域": "当前数字不含 0,1；可放开此限制并定义其映射",
        "是否有序": "words 数组无序；可要求输出保持原序或字典序",
        "是否循环": "否；可设计环形匹配问题（如首尾相连）",
        "是否多组输入": "单次输入；可改为多组测试用例批量处理",
        "是否在线": "离线处理；可改造为在线查询系统：给定数字串实时返回匹配词",
        "映射可变性": "当前使用标准 T9 映射；可允许自定义键盘映射",
        "输出形式": "当前返回完整列表；可改为仅返回数量、最长匹配词、或 top-k 相关词"
      }
    }
  },
  {
    "title": "Max Submatrix LCCI",
    "slug": "max-submatrix-lcci",
    "schema": {
      "Input Structure": "二维整数矩阵 matrix[1..N][1..M]，元素可为正、负或零；N, M ≥ 1，值域为整数范围",
      "Core Constraint": "子矩阵由其左上角 (r1, c1) 和右下角 (r2, c2) 唯一确定；总和最大的子矩阵的最优解必然出现在某个连续行区间与列区间的组合中",
      "Objective Function": "找出元素总和最大的子矩阵，并返回其左上角和右下角坐标 [r1, c1, r2, c2]",
      "Algorithmic Invariant": "枚举行区间 [i, j] 后，将二维问题压缩为一维最大子数组问题（Kadane算法）；在每一列上累加行区间内的值形成临时数组，该数组的最大子数组对应最优列区间；此变换保持最优性不变",
      "Transformable Parameters": {
        "数据规模": "N, M 的数量级：当前为 ≤ 200，可扩展至支持更大规模或稀疏矩阵",
        "元素类型": "是否允许浮点数、是否全为非负/非正",
        "矩阵形状": "是否方阵、是否退化为一维（N=1 或 M=1）",
        "输入形式": "是否在线输入矩阵行 / 块，是否支持动态更新",
        "输出要求": "返回最大和（而非坐标）、返回所有最优解、要求字典序最小的解",
        "约束条件": "子矩阵面积必须 ≥ K，或行列连续性可被打破（如选择任意元素集合）"
      }
    }
  },
  {
    "title": "Max Black Square LCCI",
    "slug": "max-black-square-lcci",
    "schema": {
      "Input Structure": [
        "二维方阵 matrix[1..n][1..n]",
        "每个元素为 0 或 1",
        "0 表示黑色像素，1 表示白色像素",
        "n ≤ 200"
      ],
      "Core Constraint": [
        "目标子方阵的四条边上的所有像素必须全为 0（黑色）",
        "内部像素颜色不限",
        "子方阵需为正方形且边与矩阵对齐",
        "存在多个合法最大子方阵时，按左上角 (r, c) 字典序最小返回"
      ],
      "Objective Function": [
        "构造一个四边全黑的最大子方阵",
        "最大化边长 size",
        "若 size 相同，最小化 r；若 r 相同，最小化 c",
        "返回 [r, c, size]"
      ],
      "Algorithmic Invariant": [
        "预处理每个位置向右和向下连续黑色像素的长度（含自身）",
        "对于每个可能的左上角 (i, j)，枚举可能的边长 k，检查是否能形成四边全黑的 k×k 子方阵",
        "利用预处理信息快速验证：上边、下边、左边、右边是否均为全黑",
        "一旦找到某个 k 可行，则该 (i, j) 处最大可行边长即为 k，无需更大尝试",
        "遍历顺序保证第一个找到的最大解即为字典序最小"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的范围：1 ≤ n ≤ 200；可扩展至更大但需优化",
        "值域表示": "可变换为字符矩阵（如 'B'/'W'），或使用其他数值编码",
        "颜色定义": "可反转：1 为黑，0 为白",
        "形状约束": "可改为矩形（最大子矩形四边全黑）",
        "边界要求": "可改为三边黑、或内部也需全黑、或仅外框指定模式",
        "输出形式": "可改为返回所有最大子方阵 / 仅返回 size / 返回面积",
        "多组数据": "支持批量处理多个测试用例",
        "在线查询": "支持动态修改像素后查询当前最大子方阵（增加更新操作）",
        "结构维度": "可推广至 3D 立方体表面全黑问题"
      }
    }
  },
  {
    "title": "Missing Two LCCI",
    "slug": "missing-two-lcci",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，包含 [1, N] 范围内的部分整数，其中 N = n + 2；数组无重复元素，无序；所有值 ∈ [1, N]",
      "Core Constraint": "缺失恰好两个数字，其余每个数字出现一次；输入范围紧凑（1 到 N），支持基于索引或数值的数学映射",
      "Objective Function": "找出缺失的两个数字，并以任意顺序返回它们",
      "Algorithmic Invariant": "利用求和不变性与平方和不变性：总和 S = N*(N+1)/2，平方和 Q = N*(N+1)*(2N+1)/6；通过实际和与理论和之差建立方程组，可唯一解出两个缺失数；或利用原地哈希（将数值映射到索引位置）标记已存在数字，未被标记的位置对应缺失值",
      "Transformable Parameters": {
        "n 的数量级": "nums.length <= 30000 → N <= 30002，适合 O(N) 时间、O(1) 空间算法",
        "值域": "[1, N]，连续正整数，可构造数学关系",
        "是否有序": "否，输入无序，但可通过数学方法或原地重排解决",
        "缺失个数": "固定为2，可推广为k个缺失（如k=1为简单求和题，k>2则需额外空间或不同策略）",
        "是否多组输入": "单组数据",
        "是否在线": "否，离线一次性输入",
        "输出形式": "返回两个缺失数字的列表，顺序无关",
        "空间约束": "要求 O(1) 额外空间，允许修改原数组（若不允许，则需数学法）"
      }
    }
  },
  {
    "title": "Shortest Supersequence LCCI",
    "slug": "shortest-supersequence-lcci",
    "schema": {
      "Input Structure": [
        "一维数组 big[1..n]，表示长数组，元素为整数",
        "一维数组 small[1..m]，表示短数组，元素互不相同",
        "n <= 100000, m <= 100000",
        "big 和 small 中的元素均为整数（无符号性约束）"
      ],
      "Core Constraint": [
        "目标是在 big 中找到一个子数组，使其包含 small 中所有元素（顺序无关）",
        "small 中元素互不相同，因此每个元素只需出现至少一次",
        "子数组的合法性仅依赖于元素覆盖完整性，不依赖顺序或连续性之外的结构"
      ],
      "Objective Function": [
        "最小化子数组长度（即右端点 - 左端点 + 1）",
        "若存在多个最短子数组，返回左端点最小的一个",
        "若不存在满足条件的子数组，返回空数组"
      ],
      "Algorithmic Invariant": [
        "使用滑动窗口双指针：左指针 L 和右指针 R",
        "维护当前窗口 [L, R] 内对 small 中元素的覆盖计数（哈希表或数组记录频次）",
        "右指针扩展以增加覆盖，左指针收缩以尝试缩短合法窗口",
        "当窗口恰好覆盖所有 small 元素时，尝试移动左指针以寻找更优解",
        "一旦窗口不再覆盖全部，则必须由右指针继续扩展",
        "状态单调性：随着 R 增加，首次达到全覆盖后，L 可逐步推进；整体满足‘可扩展、可收缩’的滑动窗口不变性"
      ],
      "Transformable Parameters": [
        "small 是否允许重复元素（当前不允许，可变形为允许多重集匹配）",
        "是否要求严格最小长度，或改为最大长度 / 计数类问题",
        "输入是否有序或具有某种分布特性（如随机、局部聚集）",
        "是否多组 small 查询（离线 / 在线）",
        "数据规模：n 和 m 的数量级（当前为 1e5，适合 O(n) 或 O(n log n)）",
        "是否支持动态更新 big（加入/删除元素）",
        "是否环形数组（将 big 视为循环）",
        "输出形式：返回区间端点 / 返回子数组本身 / 仅判断存在性",
        "是否允许近似解或需精确最优"
      ]
    }
  },
  {
    "title": "Pairs With Sum LCCI",
    "slug": "pairs-with-sum-lcci",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          -100000,
          100000
        ],
        "sorted": false,
        "duplicates_allowed": true,
        "description": "一维整数数组 nums，长度不超过 100000，元素和 target 均在 [-10^5, 10^5] 范围内"
      },
      "Core Constraint": {
        "constraint": "每个数只能属于一个数对",
        "implication": "一旦某个元素被匹配，就不能再次参与其他配对",
        "structure_impact": "需要按频次或访问状态管理元素使用情况，避免重复使用"
      },
      "Objective Function": {
        "type": "construction",
        "goal": "找出所有两数之和等于 target 的整数对",
        "output_form": "二维数组，每个子数组为 [a, b] 满足 a + b == target",
        "uniqueness": "不同索引的相同数值可视为不同元素，但输出不强制去重值对"
      },
      "Algorithmic Invariant": {
        "invariant": "哈希表记录未匹配元素的频次，遍历过程中维护可配对状态",
        "rules": [
          "对于当前元素 x，若 target - x 存在于哈希表中，则形成一对，并将两者频次各减一",
          "每轮决策仅依赖已处理元素的状态，不影响后续最优性",
          "配对顺序不影响最终最大匹配数（贪心可证明）"
        ],
        "optimality_guarantee": "在元素不可复用约束下，贪心匹配策略可得到最大匹配数"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_scale",
            "values": [
              "n <= 1000",
              "n <= 10000",
              "n <= 100000",
              "n up to 1e6"
            ],
            "impact": "决定是否可用 O(n) 哈希或需考虑排序双指针"
          },
          {
            "name": "array_sorted",
            "values": [
              false,
              true
            ],
            "impact": "若有序，可切换为双指针解法"
          },
          {
            "name": "online_queries",
            "values": [
              false,
              true
            ],
            "impact": "是否支持动态添加数字并查询可配对数"
          },
          {
            "name": "output_requirement",
            "values": [
              "all_pairs",
              "count_only",
              "distinct_value_pairs",
              "index_pairs"
            ],
            "impact": "改变输出形式影响去重逻辑与存储方式"
          },
          {
            "name": "pair_uniqueness_rule",
            "values": [
              "no_index_reuse",
              "no_value_pair_duplicate"
            ],
            "impact": "约束是基于索引还是值对的唯一性"
          },
          {
            "name": "multi_target",
            "values": [
              false,
              true
            ],
            "impact": "单 target vs 多组 target 查询"
          },
          {
            "name": "circular_or_structured_input",
            "values": [
              "linear_array",
              "2D_matrix",
              "circular_buffer"
            ],
            "impact": "输入结构变化引发变体"
          }
        ]
      }
    }
  },
  {
    "title": "Rank from Stream LCCI",
    "slug": "rank-from-stream-lcci",
    "schema": {
      "Input Structure": [
        "数据流形式的一维整数序列，逐个输入（在线模式）",
        "每个数字 x 满足：x ≤ 50000",
        "track 和 getRankOfNumber 操作总数 ≤ 4000（各不超过 2000 次）"
      ],
      "Core Constraint": [
        "需要动态维护已读入数字的累积分布信息",
        "查询操作要求快速回答前缀计数（≤ x 的元素个数）",
        "插入与查询交替进行，无法预知全部数据（在线处理约束）"
      ],
      "Objective Function": [
        "支持两个操作：",
        "1. track(int x)：将整数 x 插入数据结构（无返回值）",
        "2. getRankOfNumber(int x)：返回当前已插入中小于或等于 x 的元素个数",
        "目标函数为在线前缀计数"
      ],
      "Algorithmic Invariant": [
        "使用频次数组或树状数组（Fenwick Tree）维护值域上的累积频率",
        "值域较小（x ≤ 50000），允许以空间换时间",
        "插入操作更新频次，查询操作利用前缀和性质快速计算 rank",
        "树状数组/线段树保证单次操作 O(log V)，V 为值域上限"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "最大操作次数": 4000,
          "值域范围": [
            0,
            50000
          ]
        },
        "输入形式": "在线流式输入，支持插入与查询交错",
        "是否多组数据": false,
        "是否有序": "输入序列本身无序，但数据结构内部按值域组织",
        "值域特性": "非负整数，有明确上界（适合桶/树状数组）",
        "可变约束": [
          "若值域扩大至 1e9，则需改为离散化 + 线段树 或 平衡 BST",
          "若操作次数增至 1e5，则需更高效结构如分块或动态开点线段树",
          "若支持删除操作，则需可减频次的数据结构",
          "若改为求第 k 小（逆问题），则转为顺序统计树"
        ]
      }
    }
  },
  {
    "title": "Group Anagrams LCCI",
    "slug": "group-anagrams-lcci",
    "schema": {
      "Input Structure": [
        "Array of strings S[1..n]",
        "Each string consists of lowercase English letters",
        "Length of each string is at least 1, but variable across elements"
      ],
      "Core Constraint": [
        "Two strings are anagrams if and only if they have identical character frequency distributions",
        "Anagram equivalence is transitive and symmetric → forms equivalence classes",
        "Grouping must be complete: all anagrams in the input belong to exactly one group"
      ],
      "Objective Function": "Group all strings that are anagrams of each other into separate sublists",
      "Algorithmic Invariant": [
        "Strings with the same sorted character sequence are guaranteed to be anagrams",
        "Hashing the sorted version of a string provides a canonical key for its anagram class",
        "Insertion into hash map preserves grouping without duplication or omission",
        "Order within groups and order of groups do not matter (as per problem constraints)"
      ],
      "Transformable Parameters": {
        "n": "1 ≤ n ≤ 10^4",
        "string_length": "1 ≤ len(S[i]) ≤ 100",
        "character_set": "Only lowercase English letters (can be generalized to Unicode or case-sensitive)",
        "input_form": "Batch input as array; can be transformed to stream / online insertion",
        "output_form": [
          "List of grouped anagrams",
          "Optional: output only sizes of groups",
          "Optional: output largest group only"
        ],
        "anagram_definition": [
          "Classic anagram (rearrangement)",
          "Can be modified: k-anagrams, anagrams with at most d edits, etc."
        ],
        "space_constraint": "Whether to optimize for space (in-place grouping if possible)",
        "multi_grouping_criteria": "Support multiple grouping rules simultaneously (e.g., by length AND anagram)"
      }
    }
  },
  {
    "title": "Find Closest LCCI",
    "slug": "find-closest-lcci",
    "schema": {
      "Input Structure": [
        "一维字符串数组 words[1..n]",
        "words[i] 为非空字符串",
        "给定两个不同的目标单词 word1 和 word2",
        "n <= 100000"
      ],
      "Core Constraint": [
        "最短距离定义为两单词下标之差的绝对值 |i - j|",
        "word1 和 word2 必须在数组中出现至少一次",
        "每次查询仅涉及两个不同单词",
        "单词出现位置具有局部性：只需遍历一次即可收集所有候选位置"
      ],
      "Objective Function": "求 word1 的某个出现位置与 word2 的某个出现位置之间的最小绝对下标差（即最短距离）",
      "Algorithmic Invariant": [
        "双指针推进：维护指向 word1 和 word2 出现位置列表的两个指针",
        "当 pos1 < pos2 时，移动 word1 的指针可尝试缩小距离",
        "当 pos1 > pos2 时，移动 word2 的指针可尝试缩小距离",
        "状态单调性：位置列表有序，因此双指针无需回溯",
        "局部最优选择不会错过全局最优解：贪心移动较小索引者"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的数量级可变（如 1e3 → 1e6）",
        "是否多组输入": true,
        "是否在线查询": true,
        "预处理允许": "可预先建立单词到位置列表的哈希映射以支持多轮查询",
        "输入形式": "一次性数组输入 或 流式文本输入",
        "单词重复性": "允许重复单词",
        "是否区分大小写": "可设定为区分或不区分",
        "目标函数变形": [
          "改为最长距离",
          "改为存在性判定（是否存在距离 ≤ K）",
          "计数满足距离条件的配对数量"
        ],
        "约束变换": "从 '不同单词' 放宽至 '可相同单词'（需保证下标不同）",
        "维度扩展": "从一维文本扩展至二维网格文本"
      }
    }
  },
  {
    "title": "Find Majority Element LCCI",
    "slug": "find-majority-element-lcci",
    "schema": {
      "Input Structure": [
        "一维整数数组 A[1..n]",
        "元素为任意整数（可正可负）",
        "数组长度 n ≥ 1"
      ],
      "Core Constraint": [
        "主要元素定义为出现次数 > n/2 的元素",
        "至多存在一个主要元素（由计数约束决定）",
        "无序输入，不保证任何单调性或局部聚集性"
      ],
      "Objective Function": [
        "判定是否存在主要元素",
        "若存在，返回该元素值",
        "若不存在，返回 -1",
        "目标函数类型：判定 + 构造（唯一可行解）"
      ],
      "Algorithmic Invariant": [
        "使用摩尔投票法（Boyer-Moore Voting Algorithm）的不变量：",
        "维护一个候选主元素 candidate 和计数器 count",
        "当 count == 0 时，将当前元素设为 candidate",
        "若当前元素等于 candidate，则 count++，否则 count--",
        "最终 candidate 是唯一可能的主要元素（需二次验证）",
        "算法过程中，非主要元素无法抵消主要元素的净优势（在 > n/2 条件下）"
      ],
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 1e5] → 可扩展至流式场景",
        "值域范围": "int 范围 → 可推广至对象或字符串流",
        "是否有序": "否 → 若有序可触发其他解法（如中位数法）",
        "是否允许多个主要元素": "否 → 变形题可改为 > n/k 的众数计数",
        "是否在线输入": "否 → 可改造为数据流模型下的 Majority Finding",
        "是否多组数据": "单组 → 可支持批量查询",
        "空间限制": "O(1) → 放宽后可用哈希表计数",
        "时间复杂度要求": "O(N) → 更高复杂度允许则可用排序"
      }
    }
  },
  {
    "title": "Get Kth Magic Number LCCI",
    "slug": "get-kth-magic-number-lcci",
    "schema": {
      "Input Structure": [
        "整数 k（表示要找第 k 个满足条件的数）",
        "数值范围：k ≥ 1，输出为正整数",
        "生成序列中的每个数的素因子只能是 3, 5, 7（可重复），即形如 3^a × 5^b × 7^c，其中 a,b,c ≥ 0"
      ],
      "Core Constraint": [
        "所有符合条件的数可以按递增顺序唯一排列",
        "下一个最小数必然是已有结果中的某个数乘以 3、5 或 7 得到",
        "必须避免重复加入同一个数值（例如 3×5 和 5×3 可能产生相同结果）"
      ],
      "Objective Function": "求第 k 个素因子仅包含 3, 5, 7 的正整数（即丑数变种，基数为 {3,5,7}）",
      "Algorithmic Invariant": [
        "使用多路归并思想：维护三个指针（或队列），分别指向下一个待乘 3、5、7 的已生成数的位置",
        "每次从 candidates = {res[i3]*3, res[i5]*5, res[i7]*7} 中选择最小值加入结果序列",
        "对应指针只在该候选值等于最小值时前移，确保单调性和无遗漏",
        "已生成的序列保持有序，新元素由旧元素扩展而来，保证完整性与不重不漏"
      ],
      "Transformable Parameters": [
        "素因子集合可变：如改为 {2,3,5}（标准丑数）或任意给定质数集合 P",
        "目标序号 k 的规模：k ≤ 1e3（暴力可解） vs k ≤ 1e6（需线性算法）",
        "是否要求输出整个序列而非仅第 k 项",
        "是否允许因子外的其他素因子存在（判定类变形）",
        "是否在线查询多个 k 值（多组数据）",
        "是否限制空间复杂度（如不允许保存全部前缀结果）",
        "是否加入删除操作（动态集合维护）"
      ]
    }
  },
  {
    "title": "Circus Tower LCCI",
    "slug": "circus-tower-lcci",
    "schema": {
      "Input Structure": [
        "数组 height[1..n] 表示每个人的身高，其中 n ≤ 10000",
        "数组 weight[1..n] 表示每个人的体重",
        "height 和 weight 对应同一人",
        "height[i], weight[i] 为正整数"
      ],
      "Core Constraint": [
        "叠罗汉序列中，每个人必须严格比下方的人矮且轻",
        "即若 (h_i, w_i) 在 (h_j, w_j) 上方，则 h_i < h_j 且 w_i < w_j",
        "问题等价于在二维偏序下求最长严格递增子序列"
      ],
      "Objective Function": "求最多能叠多少人（最长合法链的长度）",
      "Algorithmic Invariant": [
        "对身高排序后，转化为关于体重的最长严格递增子序列问题",
        "当身高相同时，按体重降序排列，防止同一高度多人被选入序列",
        "使用贪心 + 二分插入维护 LIS 的最小尾部值数组，保证状态最优性",
        "LIS 构造过程中的单调性：tail[k] 表示长度为 k+1 的递增子序列的最小末尾重量"
      ],
      "Transformable Parameters": {
        "n 的数量级": "n <= 10000（可改为 1e5 或更高以要求更优解法）",
        "是否允许相等": "可变为 ≤ 而非 <，改变偏序类型",
        "维度扩展": "可扩展到三维（身高、体重、力量）",
        "输入形式": "可由两个数组变为一个结构体数组",
        "是否多组数据": "可设计为多组测试用例",
        "在线处理": "人员逐个加入，要求动态维护最大叠层",
        "输出要求": "可要求输出具体方案路径，而非仅长度",
        "约束组合方式": "可改为‘至少一项更小’或加权综合判断"
      }
    }
  },
  {
    "title": "Baby Names LCCI",
    "slug": "baby-names-lcci",
    "schema": {
      "Input Structure": [
        "names: List of strings in format 'Name(Frequency)', length ≤ 100000",
        "synonyms: List of strings in format '(Name1,Name2)', representing equivalent name pairs"
      ],
      "Core Constraint": [
        "Name equivalence is transitive, symmetric, and reflexive — forms an equivalence relation",
        "Each equivalence class should be merged into a single canonical (true) name",
        "Frequencies of all names in the same equivalence class must be summed"
      ],
      "Objective Function": [
        "Merge frequencies of synonymous names",
        "For each equivalence class, output the lexicographically smallest name as the representative"
      ],
      "Algorithmic Invariant": [
        "Union-Find (Disjoint Set Union, DSU) structure maintains connected components of equivalent names",
        "During union, always choose the lexicographically smaller name as the root/representative",
        "Path compression and union by rank ensure efficiency while preserving correct representative"
      ],
      "Transformable Parameters": {
        "n_names": "≤ 100000",
        "n_synonyms": "Can vary; sparse or dense synonym pairs",
        "name_string_case": "Case-sensitive or case-insensitive matching",
        "output_criteria": [
          "Lexicographically smallest name (current)",
          "Original most frequent name",
          "Shortest name",
          "First occurring name in input"
        ],
        "synonym_directionality": [
          "Undirected (current)",
          "Directed synonym rules (e.g., only map A → B)"
        ],
        "input_format": [
          "String parsing required (current)",
          "Pre-parsed (name, freq) tuples and synonym pairs"
        ],
        "online_updates": [
          "Offline batch processing (current)",
          "Online: incremental synonym or name-frequency updates"
        ],
        "equivalence_semantics": [
          "Transitive closure applied (current)",
          "Only direct synonyms considered (no transitivity)"
        ]
      }
    }
  },
  {
    "title": "Number Of 2s In Range LCCI",
    "slug": "number-of-2s-in-range-lcci",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "value_range": "1 <= n <= 10^9",
        "description": "一个非负整数 n，表示数字范围 [0, n] 内的所有整数"
      },
      "Core Constraint": {
        "constraint": "数字 2 的出现次数需按位独立统计，每一位的贡献可分离计算",
        "reasoning": "高位变化不影响低位已统计的结果；每位上 '2' 的出现具有周期性和结构性规律，可通过数学归纳法分解为若干完整周期与残余部分"
      },
      "Objective Function": {
        "goal": "计数",
        "target": "统计从 0 到 n（含）中所有整数里，十进制表示下数字 '2' 出现的总次数"
      },
      "Algorithmic Invariant": {
        "invariant": "逐位处理时，当前位的 '2' 出现次数仅依赖于其高位、低位和当前位数值，且可通过分类讨论确定：\n- 若当前位 < 2：高位决定完整周期数\n- 若当前位 == 2：高位 × 当前权重 + 低位 + 1\n- 若当前位 > 2：(高位 + 1) × 当前权重",
        "property": "数位 DP 中的状态不变性：已处理高位状态对低位无后效性，且每轮迭代保持总数累计正确"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "parameter": "目标数字",
            "variation": "将 '2' 改为任意 digit ∈ [0,9]"
          },
          {
            "parameter": "输入形式",
            "variation": "多组测试数据输入 / 单次查询"
          },
          {
            "parameter": "数据规模",
            "variation": "n 的数量级：10^9 → 10^18（需要使用 long 或字符串输入）"
          },
          {
            "parameter": "进制系统",
            "variation": "从十进制扩展至 b 进制（如二进制中统计 1 的个数）"
          },
          {
            "parameter": "输出类型",
            "variation": "改为构造首次出现位置 / 输出包含 '2' 的数字列表"
          },
          {
            "parameter": "在线性",
            "variation": "支持动态修改 n 并快速回答（结合预处理表）"
          }
        ]
      }
    }
  },
  {
    "title": "Find Longest Subarray LCCI",
    "slug": "find-longest-subarray-lcci",
    "schema": {
      "Input Structure": "一维数组 A[1..n]，每个元素为字母（A-Z, a-z）或数字字符（0-9）；n ≤ 100000",
      "Core Constraint": "子数组中字母与数字的个数必须相等；问题可转化为前缀和差值相等的最远下标对",
      "Objective Function": "寻找最长子数组使得字母和数字个数相同；若多个解，返回左端点最小者；不存在则返回空数组",
      "Algorithmic Invariant": "将字母视为+1，数字视为-1（或反之），前缀和相等的两个位置之间的区间和为0，对应字母数字数量相等；首次出现的前缀和位置应保留以最大化区间长度",
      "Transformable Parameters": {
        "n 的数量级": "1e5",
        "值域": "仅包含字母和数字字符",
        "是否有序": "输入顺序固定，不可重排",
        "是否循环": "否，线性数组",
        "是否多组输入": "否，单次输入",
        "是否在线": "否，离线处理",
        "平衡条件变化": "可改为字母比数字多k个，或任意两类元素的数量差为k",
        "目标函数变化": "可改为计数满足条件的子数组个数，或判定是否存在",
        "输出形式变化": "可要求返回长度、下标范围，或所有最优解"
      }
    }
  },
  {
    "title": "Missing Number LCCI",
    "slug": "missing-number-lcci",
    "schema": {
      "Input Structure": "一维数组 nums[1..n], 包含从 0 到 n 的 n 个整数中的 n 个（缺失一个），值域为 [0, n]，无重复元素",
      "Core Constraint": "输入数组包含从 0 到 n 的完整集合中恰好缺失一个整数，其余元素唯一且不越界",
      "Objective Function": "找出缺失的那一个整数",
      "Algorithmic Invariant": "利用求和不变性：前 n+1 个非负整数之和为 S = n*(n+1)/2；实际数组和与 S 的差即为缺失值；或利用异或性质：0 到 n 所有数的异或结果与数组所有元素异或结果的差异即为缺失值",
      "Transformable Parameters": {
        "数据规模 n": "1 <= n <= 10^5 或支持更大规模（如 10^7，强调 O(n) 性能）",
        "是否有序": "可以是乱序或有序输入",
        "是否多组数据": "单组输入 / 多组测试用例",
        "是否在线": "离线处理 / 支持流式输入（数据逐个到达）",
        "输入形式变化": "可改为链表结构、只允许遍历一次、空间限制 O(1)",
        "扩展变形": "缺失两个数（需输出两个解）、存在一个重复数代替缺失（找重复+缺失）"
      }
    }
  },
  {
    "title": "Boolean Evaluation LCCI",
    "slug": "boolean-evaluation-lcci",
    "schema": {
      "Input Structure": [
        "字符串 s，表示一个由 '0', '1', '&', '|', '^' 构成的布尔表达式",
        "每个字符交替为操作数（'0'/'1'）和运算符（'&','|','^'）",
        "操作数个数 = 运算符个数 + 1",
        "运算符数量 ≤ 19"
      ],
      "Core Constraint": [
        "括号可以任意插入以改变求值顺序，但不能改变原字符顺序",
        "所有运算符均为二元、左结合可重括号化",
        "不同括号划分对应不同的语法树结构",
        "子表达式的计算结果只有 0 或 1 两种状态"
      ],
      "Objective Function": "计数：有多少种加括号方式，使得整个表达式的求值结果等于给定的 result（0 或 1）",
      "Algorithmic Invariant": [
        "区间动态规划（Interval DP）：定义 dp[i][j][v] 表示子串 s[i:j+1] 能否通过某种括号方式得到结果 v（v ∈ {0,1}）",
        "状态转移时枚举区间内的每一个运算符作为根节点进行分割",
        "左右子区间的结果组合通过当前运算符决定父区间的可能结果",
        "子问题独立且满足最优子结构：整体方案数 = 所有合法分割下左右方案数的乘积之和"
      ],
      "Transformable Parameters": {
        "运算符种类": {
          "可变范围": [
            "仅 &",
            "& 和 |",
            "& | ^",
            "加入 ! 或 -> 等"
          ],
          "当前值": [
            "&",
            "|",
            "^"
          ]
        },
        "目标结果 result": {
          "可变范围": [
            0,
            1
          ],
          "当前值": "参数化输入"
        },
        "表达式长度 n": {
          "数量级": "运算符数 ≤ 19 → 总长 ≤ 39",
          "扩展可能": "支持更大规模时需优化或使用记忆化搜索"
        },
        "是否要求构造所有方案": {
          "可选": [
            false,
            true
          ],
          "当前": false
        },
        "是否允许多重否定或一元操作符": {
          "可变性": true,
          "当前": false
        },
        "输入形式": {
          "可变类型": [
            "单个字符串",
            "抽象语法树前序遍历",
            "分词列表"
          ],
          "当前": "单一字符串"
        },
        "数据流模式": {
          "可变选项": [
            "离线处理",
            "在线查询不同 result",
            "动态修改表达式"
          ],
          "当前": "离线一次性输入"
        }
      }
    }
  },
  {
    "title": "Word Transformer LCCI",
    "slug": "word-transformer-lcci",
    "schema": {
      "Input Structure": [
        "字符串 beginWord，长度为 L",
        "字符串 endWord，长度为 L",
        "字典 wordList: 字符串列表，每个字符串长度均为 L",
        "所有字符均来自小写英文字母 a-z"
      ],
      "Core Constraint": [
        "每次变换只能更改一个字符",
        "每一步生成的新词必须存在于 wordList 中（包括 endWord）",
        "转换路径必须是连续的、合法的单词序列",
        "不允许重复使用同一个单词（除特殊变体外）"
      ],
      "Objective Function": "构造一条从 beginWord 到 endWord 的最短转换路径；若不存在则返回空列表",
      "Algorithmic Invariant": [
        "BFS 能保证首次到达 endWord 时路径最短",
        "每一层扩展对应一次字符变换，状态转移仅依赖当前单词和字典",
        "通过 visited 集合避免环路，保持搜索无环性",
        "邻接状态可通过枚举单字符替换并在哈希集中快速查找"
      ],
      "Transformable Parameters": {
        "n": "wordList 长度，可设为 1e2 / 1e3 / 1e5 级别",
        "L": "单词长度，可为固定值或可变参数",
        "character_set": "字符集大小（如 a-z 扩展至数字或大写）",
        "allow_cycle": "是否允许路径中重复访问同一单词",
        "output_type": [
          "返回任意一条路径",
          "返回最短路径条数",
          "返回所有最短路径",
          "仅判断是否存在"
        ],
        "query_mode": [
          "单次查询",
          "多组 begin/endWord 在同一字典下批量查询",
          "在线动态添加/删除 wordList 中的词"
        ],
        "transition_constraint": [
          "仅限单字符变化",
          "可扩展为编辑距离 ≤K 的跳跃",
          "加入语义相似度约束等隐式条件"
        ],
        "dictionary_coverage": "endWord 是否一定在 wordList 中（决定是否存在解）"
      }
    }
  },
  {
    "title": "Volume of Histogram LCCI",
    "slug": "volume-of-histogram-lcci",
    "schema": {
      "Input Structure": "一维非负整数数组 H[1..n]，表示直方图各柱子的高度，每个柱子宽度为1",
      "Core Constraint": "每个位置能存储的水量由其左右两侧最大高度的较小值与当前高度之差决定；左右边界约束可分离且具有全局依赖性",
      "Objective Function": "计算整个直方图中能够接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护左侧最大值 maxLeft 和右侧最大值 maxRight；若 maxLeft ≤ maxRight，则左指针当前位置的蓄水量可确定，且移动左指针不破坏已确定区域的最优性；反之移动右指针",
      "Transformable Parameters": {
        "n 的数量级": "1 ≤ n ≤ 10^5（可调整为更小或支持在线流式输入）",
        "值域": "H[i] ≥ 0（可变形为允许负值，需重新定义语义）",
        "是否有序": "无序（可构造单调序列变体）",
        "是否循环": "否（可扩展为环形直方图）",
        "是否多组输入": "单组输入（可改为多组测试用例）",
        "是否在线": "离线处理（可设计为动态添加柱子的在线版本）",
        "输出形式": "仅总量（可改为输出每列存水量或可视化方案）",
        "操作类型": "静态只读（可加入更新、删除、插入操作形成数据结构题）"
      }
    }
  },
  {
    "title": "Continuous Median LCCI",
    "slug": "continuous-median-lcci",
    "schema": {
      "Input Structure": [
        "数据流形式的一维整数序列（动态输入）",
        "每个元素为 int 类型，可正可负",
        "输入是在线的（online），即逐个添加，不可随机访问历史全集"
      ],
      "Core Constraint": [
        "中位数依赖于全局有序性，但无法在每次插入后完全排序（效率过低）",
        "必须通过维护部分有序结构来快速获取中间排名的值",
        "插入操作与查询操作交替进行，要求均摊高效"
      ],
      "Objective Function": [
        "支持两个操作：addNum 添加一个数字；findMedian 查询当前中位数",
        "目标函数为构造一个能动态维护中位数的数据结构",
        "返回类型为 double，需处理偶数长度下的平均值"
      ],
      "Algorithmic Invariant": [
        "使用两个堆（最大堆 + 最小堆）维护数据分布：左侧最大堆存较小一半，右侧最小堆存较大一半",
        "两堆大小差不超过 1，保证堆顶对应中位数位置",
        "每次插入通过比较决定进入左堆或右堆，并适时平衡堆大小",
        "堆顶元素的组合（单个或平均）始终代表当前中位数"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的数量级（如 1e4, 1e5, 1e6），影响是否允许 O(n log n) 或需严格 O(log n) 插入）",
        "值域范围": "int 范围是否受限（如仅正整数、小范围整数）",
        "输入形式": "是否离线（已知全部数据） vs 在线（逐个 addNum）",
        "输出精度": "是否要求精确 double，或可接受近似中位数",
        "多组数据": "是否需要支持多个独立实例并行运行",
        "操作扩展": "是否增加 deleteNum、modifyNum 等操作",
        "中位数定义变形": "是否改为第 k 小、加权中位数、滑动窗口中位数等"
      }
    }
  },
  {
    "title": "Calculator LCCI",
    "slug": "calculator-lcci",
    "schema": {
      "Input Structure": [
        "字符串 S 表示一个算术表达式",
        "S 包含非负整数、空格字符 ' '、以及运算符 '+'、'-'、'*'、'/'",
        "表达式中不含括号",
        "整数除法向零取整（仅保留整数部分）",
        "输入保证语法有效"
      ],
      "Core Constraint": [
        "运算符优先级：'*' 和 '/' 优先于 '+' 和 '-'",
        "表达式从左到右结合（相同优先级左结合）",
        "不能使用内置求值函数（如 eval），需手动解析并计算",
        "需要在线性或准线性时间内完成解析与计算"
      ],
      "Objective Function": "计算并返回该算术表达式的最终数值结果",
      "Algorithmic Invariant": [
        "维护一个栈用于存储待合并的项（通常是中间结果中的加减项）",
        "遍历过程中，当前数字和前一个运算符共同决定如何更新状态",
        "遇到 '+'：将当前数字压入栈；遇到 '-'：将负数压入栈",
        "遇到 '*' 或 '/'：立即与栈顶元素进行运算，并将结果重新压入栈",
        "最终结果为栈中所有元素之和",
        "状态机驱动的词法解析：逐字符读取，跳过空格，合并连续数字"
      ],
      "Transformable Parameters": {
        "是否包含括号": false,
        "是否支持浮点数": false,
        "值域范围": "非负整数，假设在 int32 范围内",
        "运算符集合": [
          "+",
          "-",
          "*",
          "/"
        ],
        "是否允许一元运算符（如 -5）": false,
        "输入形式": "单个字符串，离线处理",
        "是否多组数据": false,
        "是否在线输入（流式字符）": false,
        "除法规则": "向零取整（C++/Java 风格整数除法）",
        "空间复杂度约束": "可优化至 O(1) 辅助空间（通过变量替代栈）"
      }
    }
  },
  {
    "title": "LRU Cache LCCI",
    "slug": "lru-cache-lcci",
    "schema": {
      "Input Structure": [
        "双向链表（用于维护访问顺序，头尾指针）",
        "哈希表（用于键值映射，支持 O(1) 查找）",
        "固定整数容量 capacity（正整数）",
        "操作序列：包含 get(key) 和 put(key, value)，其中 key、value 均为整数"
      ],
      "Core Constraint": [
        "缓存容量有限，达到上限后插入新键值对必须淘汰最近最少使用（LRU）的元素",
        "get 和 put 操作均为有效访问，需更新对应元素为最新使用",
        "所有操作需在平均 O(1) 时间内完成",
        "数据局部性：最近访问的元素短期内可能再次被访问"
      ],
      "Objective Function": [
        "支持高效的数据获取与写入",
        "在容量满时自动驱逐最久未使用的条目",
        "保证语义正确性：存在则返回值，否则返回 -1；put 正确更新或插入并维护 LRU 顺序"
      ],
      "Algorithmic Invariant": [
        "哈希表始终指向双向链表中的有效节点",
        "双向链表按访问时间降序排列：头节点为最新访问，尾节点为最久未访问",
        "每次 get 或 put 存在的 key，对应节点被移动到链表头部",
        "put 新 key 且容量满时，删除尾部节点，并从哈希表中移除对应键",
        "插入和删除操作不破坏链表结构与哈希一致性"
      ],
      "Transformable Parameters": [
        "capacity 的数量级（如 1e3 / 1e5 / 动态可调）",
        "是否允许多线程并发访问（线程安全变体）",
        "是否支持 key 的权重不同（带权 LRU）",
        "是否支持 TTL（过期机制）扩展",
        "是否记录访问频率（LFU 变种）",
        "是否仅离线批处理操作序列（非在线）",
        "输入形式：单组实例 / 多组测试用例",
        "值域范围：key 是否为正整数 / 字符串 key",
        "是否要求输出淘汰顺序或历史状态"
      ]
    }
  },
  {
    "title": "Add Without Plus LCCI",
    "slug": "add-without-plus-lcci",
    "schema": {
      "Input Structure": [
        "两个32位整数 a 和 b",
        "a, b ∈ [-2^31, 2^31 - 1]",
        "输入为单组数据，无额外结构（如数组、图等）"
      ],
      "Core Constraint": [
        "不能使用加法运算符（+）或其他算术运算符（如 -, *, /）",
        "必须通过位运算模拟整数加法的底层逻辑",
        "负数以补码形式表示，需兼容负数与正数的混合运算"
      ],
      "Objective Function": "计算 a + b 的精确值并返回",
      "Algorithmic Invariant": [
        "加法可分解为：无进位加法（a ^ b）与进位项（(a & b) << 1）的迭代和",
        "每轮迭代中，进位项逐步向高位传播，直到进位为0",
        "异或操作（^）保持无进位和的正确性，与操作加左移（& + <<）正确生成进位",
        "状态收敛性：进位项每次左移，最终会超出32位范围或变为0，保证算法终止"
      ],
      "Transformable Parameters": {
        "数据类型范围": "32位有符号整数（可扩展至64位或无溢出限制）",
        "是否支持负数": true,
        "是否多组输入": false,
        "是否在线处理": false,
        "是否允许使用部分算术运算符": "禁止使用+及其他四则运算符，仅允许位运算",
        "输出形式": "返回整型结果，不打印过程",
        "扩展变形": [
          "实现减法（通过加法与取反）",
          "实现乘法/除法（作为中间层母题）",
          "支持大整数（非固定位）",
          "要求不使用循环（递归或有限步展开）"
        ]
      }
    }
  },
  {
    "title": "Multi Search LCCI",
    "slug": "multi-search-lcci",
    "schema": {
      "Input Structure": [
        "字符串 big[1..n], 其中 n = len(big), 0 <= n <= 1000",
        "字符串数组 smalls[1..m], 每个 smalls[i] 是长度不超过 1000 的非空或空字符串",
        "smalls 中无重复字符串",
        "所有字符均为英文小写字母",
        "smalls 的总字符数 <= 10^6"
      ],
      "Core Constraint": [
        "每个 smalls[i] 在 big 中的匹配是独立的子串匹配问题",
        "多个模式串共享同一主串，适合预处理主串或构建统一索引结构",
        "暴力匹配的时间复杂度不可接受（因 smalls 总字符数大），需优化匹配过程",
        "允许离线处理所有 smalls 查询"
      ],
      "Objective Function": [
        "对每个 smalls[i]，求其在 big 中所有起始匹配位置的升序列表",
        "构造二维整数列表 positions，其中 positions[i] = [p1, p2, ...]"
      ],
      "Algorithmic Invariant": [
        "使用字典树（Trie）组织 smalls 可实现前缀共享，降低总匹配开销",
        "或对 big 构建后缀数组 / 自动机（如 Aho-Corasick）以支持多模式匹配",
        "遍历 big 时，每一步可同时推进多个潜在匹配（状态机迁移）",
        "匹配成功时记录当前位置且不中断后续可能匹配"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "len(big)": [
            "<= 1000",
            "<= 1e5",
            "<= 1e6"
          ],
          "len(smalls)": [
            "<= 100",
            "<= 1e4",
            "<= 1e5"
          ],
          "smalls 总字符数": [
            "<= 10^3",
            "<= 10^6",
            "可超过 10^6"
          ]
        },
        "输入形式": [
          "一次性输入全部 smalls（离线）",
          "逐个查询 smalls（在线）",
          "smalls 动态增删"
        ],
        "字符串特性": [
          "是否保证无重复 smalls 字符串",
          "是否含空字符串",
          "字符集：仅小写 / 大小写混合 / ASCII / Unicode"
        ],
        "输出要求": [
          "仅起始位置",
          "返回 (start, end) 区间",
          "返回匹配次数而非位置",
          "仅判断是否存在匹配"
        ],
        "扩展方向": [
          "支持通配符匹配",
          "允许模糊匹配（编辑距离 ≤ k）",
          "big 为循环字符串",
          "要求去重重叠匹配"
        ]
      }
    }
  },
  {
    "title": "The Masseuse LCCI",
    "slug": "the-masseuse-lcci",
    "schema": {
      "Input Structure": [
        "一维数组 A[1..n]",
        "A[i] 表示第 i 个预约的时长",
        "A[i] 为非负整数",
        "数组长度 n ≥ 1"
      ],
      "Core Constraint": [
        "不能选择相邻的元素（即若选择了 A[i]，则 A[i-1] 和 A[i+1] 均不可选）",
        "决策具有局部依赖性：当前是否选择只影响前后位置",
        "最优子结构成立：全局最优解包含子区间的最优解"
      ],
      "Objective Function": [
        "最大化所选预约的总时长",
        "返回最大总分钟数（不要求输出具体方案）"
      ],
      "Algorithmic Invariant": [
        "定义 dp[i][0] 表示前 i 个预约中不选第 i 个的最大总时长，dp[i][1] 表示选择第 i 个的最大总时长",
        "状态转移满足：",
        "  dp[i][0] = max(dp[i-1][0], dp[i-1][1])",
        "  dp[i][1] = dp[i-1][0] + A[i]",
        "状态可逐项递推，且无后效性",
        "空间可优化至 O(1)：只需维护前一个状态的两个值"
      ],
      "Transformable Parameters": {
        "n 的数量级": [
          "n ≤ 10^4（原题规模）",
          "可扩展至 n ≤ 10^6（要求线性解法）"
        ],
        "值域": [
          "A[i] ≥ 0（当前设定）",
          "变形：允许 A[i] 为负数（需重新考虑贪心可行性）"
        ],
        "是否有序": "无需排序，顺序结构本身重要",
        "是否循环": [
          "否（线性序列）",
          "可变形为环形数组（首尾也不能同时选）"
        ],
        "是否多组输入": [
          "单组数据（原题）",
          "可改为多组测试用例"
        ],
        "是否在线": [
          "离线输入",
          "可设计为在线流式输入（动态更新最大收益）"
        ],
        "输出形式": [
          "仅返回最大总时长",
          "可改为输出选择的预约下标序列",
          "或输出方案数（计数型变体）"
        ],
        "约束变化": [
          "不能接连续两个 → 可改为不能接连续 k 个",
          "休息时间从 1 单位变为 d 单位"
        ]
      }
    }
  },
  {
    "title": "Longest Word LCCI",
    "slug": "longest-word-lcci",
    "schema": {
      "Input Structure": [
        "数组 words[1..n]",
        "每个元素为非空字符串 words[i]",
        "1 <= n <= 200",
        "1 <= |words[i]| <= 100",
        "字符串由小写英文字母组成"
      ],
      "Core Constraint": [
        "目标单词必须能被完全分解为数组中其他一个或多个单词的拼接",
        "构成目标单词的组件单词必须全部来自原数组（允许重复使用，但不能使用其自身）",
        "分解具有前缀可扩展性：若某前缀可由集合中单词组成，则后续只需验证剩余后缀"
      ],
      "Objective Function": [
        "最大化目标单词长度",
        "在长度相同时最小化字典序",
        "若无符合条件的单词，返回空字符串"
      ],
      "Algorithmic Invariant": [
        "使用动态规划或记忆化搜索判断一个字符串是否可拆分为集合中的单词",
        "较长单词的可组合性依赖于其前缀的可拆分性与剩余后缀的存在性",
        "集合按长度排序后逆序遍历，可尽早找到最长解；结合字典序剪枝保证最优性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "≤ 200",
            "可扩展至 1e4 或在线流式输入"
          ],
          "字符串长度": [
            "≤ 100",
            "可增至 1e5 形成 Trie 优化需求"
          ]
        },
        "词典属性": [
          "是否允许单词重复",
          "是否区分大小写",
          "是否包含空串"
        ],
        "组合规则": [
          "是否允许使用自身",
          "是否限制使用次数（如最多两次）",
          "是否要求最少拼接次数"
        ],
        "目标函数变体": [
          "返回所有最长可组合单词",
          "求最短可组合单词",
          "计数可组合单词总数"
        ],
        "输入形式": [
          "单组数据 → 多组测试用例",
          "静态输入 → 支持插入/删除单词的动态集合"
        ],
        "算法需求": [
          "是否要求构造具体方案（路径输出）",
          "是否需要避免重复组件"
        ]
      }
    }
  },
  {
    "title": "Smallest K LCCI",
    "slug": "smallest-k-lcci",
    "schema": {
      "Input Structure": "一维数组 arr[1..n]，其中 n = len(arr)；元素为整数；0 <= n <= 100000；k 满足 0 <= k <= min(100000, n)",
      "Core Constraint": "最小的 k 个元素由全局排序后的前缀决定；局部最小值集合可通过部分排序或优先队列维护",
      "Objective Function": "找出数组中数值最小的 k 个数；不要求顺序",
      "Algorithmic Invariant": "使用最大堆维护当前候选的 k 个最小元素：当堆大小超过 k 时弹出最大值；任意时刻堆中保存的是遍历过的元素中最小的 k 个；或通过快速选择算法实现线性期望时间下的划分不变性：每次分区后 pivot 位置确定其在最终排序中的相对位置",
      "Transformable Parameters": {
        "数据规模": "n 的数量级可变（如 1e3 → 1e5 → 1e7），影响解法选择（堆 vs 快速选择 vs 排序）",
        "是否有序": "arr 是否已排序或近似有序（可优化为双指针或直接截取）",
        "是否允许重复元素": "影响计数逻辑和去重处理",
        "输出要求": "是否要求去重、是否需按序输出、是否返回索引而非值",
        "是否多组数据": "是否批量处理多个数组与不同的 k",
        "是否在线": "数据流形式输入，需支持动态插入与查询最小 k 个数",
        "k 的特性": "k 是否极小（适合堆）、极大（接近 n，可转为删最大 n-k 个）、或固定"
      }
    }
  },
  {
    "title": "Re-Space LCCI",
    "slug": "re-space-lcci",
    "schema": {
      "Input Structure": {
        "sentence": "string of length n (1D array of characters), where 0 <= n <= 1000",
        "dictionary": "list of strings, total character count <= 150000",
        "constraints": [
          "characters are lowercase English letters only",
          "sentence and dictionary contain only lowercase a-z"
        ]
      },
      "Core Constraint": {
        "word_break_rule": "a word in sentence can be recognized only if it exactly matches an entry in dictionary",
        "overlap_allowed": false,
        "segmentation_constraint": "the entire sentence must be partitioned into contiguous substrings (words), each either in dictionary or treated as unrecognized",
        "local_irreversibility": "once a substring is matched or skipped, decision affects future segmentation due to non-overlapping requirement"
      },
      "Objective Function": "minimize the total number of unrecognized characters in the segmentation",
      "Algorithmic Invariant": {
        "dp_invariant": "dp[i] = minimum number of unrecognized characters in sentence[0:i]",
        "transition_rule": "for each j < i, if sentence[j:i] is in dictionary, then dp[i] = min(dp[i], dp[j]); otherwise, dp[i] = min(dp[i], dp[j] + (i - j))",
        "monotonicity": "dp array is computed in increasing order of indices, ensuring optimal substructure",
        "prefix_coverage": "all prefixes are processed before longer ones, enabling correct state propagation"
      },
      "Transformable Parameters": {
        "n_range": "0 <= n <= 1000 (can be scaled for difficulty)",
        "dictionary_size": "total characters <= 150000 (adjustable for time complexity tuning)",
        "character_set": "currently lowercase a-z; can extend to alphanumeric or Unicode",
        "dictionary_structure": "unsorted list; could become sorted, trie-organized, or allow wildcards",
        "input_form": "single string input; can transform to multiple sentences or streaming characters",
        "output_requirement": "currently returns count only; could require reconstruction of segmentation",
        "online_offline": "offline processing assumed; can turn into online version with incremental input",
        "fuzzy_matching": "exact match required now; could allow edit distance or phonetic similarity",
        "case_sensitivity": "currently case-insensitive due to lowercasing; original case could be preserved as challenge"
      }
    }
  },
  {
    "title": "BiNode LCCI",
    "slug": "binode-lcci",
    "schema": {
      "Input Structure": "二叉树节点结构 TreeNode，其中每个节点包含 val, left, right；输入为一棵二叉搜索树（BST），节点数 ≤ 100000，中序遍历有序",
      "Core Constraint": "转换后仍保持原二叉搜索树的中序序列顺序；只能使用 right 指针作为链表 next，left 指针必须置空；操作需原地进行，不能创建新节点",
      "Objective Function": "构造并返回转换后的单向链表头节点（即原树中最小值节点）",
      "Algorithmic Invariant": "在中序遍历过程中，当前访问节点的前驱已被处理且其 right 指针指向当前节点；所有已处理子树形成一条以 right 链接的右偏链；未访问子树不影响已构建链的结构正确性",
      "Transformable Parameters": {
        "数据规模": "节点数量：≤ 100000；可扩展至 1e5 以上要求 O(n) 时间",
        "是否原地": "true（本题强制原地）；可变体允许非原地复制",
        "指针约束": "left 必须为空；可变体允许双向链表（利用 left 和 right）",
        "输出形式": "返回头节点；可改为返回头尾对便于合并",
        "是否平衡树": "原题无此限制；可设为平衡 BST 以探讨最优复杂度",
        "遍历方式": "隐式中序递归；可变为 Morris 遍历实现 O(1) 空间",
        "多组数据": "单实例输入；可扩展为多棵树批量转换"
      }
    }
  },
  {
    "title": "English Int LCCI",
    "slug": "english-int-lcci",
    "schema": {
      "Input Structure": "一个非负整数 num，0 ≤ num < 2^31（即最多十位数，涵盖个、十、百、千、百万、十亿位）",
      "Core Constraint": "英文读数按三位一组分段（个位段、千位段、百万段、十亿段），每段内部按 1-999 的规则转换，段间添加对应的量级词（Thousand, Million, Billion）；1-19 有特殊单词，20 以上按十位与个位拆分",
      "Objective Function": "构造该整数的标准英文读法字符串（首字母大写，无多余空格）",
      "Algorithmic Invariant": "高位到低位分治处理：每次提取最高非零三位组，递归或迭代地将其映射为英文并拼接量级词；已处理的高位部分不影响低位构造逻辑；同一数量级内数字映射是静态可查表的",
      "Transformable Parameters": [
        "num 是否为负数（扩展支持负数输入）",
        "是否支持更大的数值范围（如万亿、兆等）",
        "输出是否要求全小写或自定义格式",
        "是否在线输入多个查询（预建表优化）",
        "是否要求语音友好格式（如加入 'and'）",
        "是否需要支持其他语言（如中文、西班牙文）"
      ]
    }
  },
  {
    "title": "Factorial Zeros LCCI",
    "slug": "factorial-zeros-lcci",
    "schema": {
      "Input Structure": "一个正整数 n（表示阶乘的阶数）",
      "Core Constraint": "尾随零的个数由因子中 10 的个数决定，而 10 = 2 × 5；在 n! 的质因数分解中，2 的个数远多于 5 的个数，因此尾随零的个数等于因子 5 的个数",
      "Objective Function": "计算 n! 的十进制表示中尾随零的个数（即后缀零的个数）",
      "Algorithmic Invariant": "每轮将 n 除以 5，并累加商的值，直到 n 为 0；该过程等价于统计 1 到 n 中所有数字对因子 5 的贡献总和（包括 25、125 等高次幂的额外贡献）",
      "Transformable Parameters": {
        "n 的数量级": "可扩展至大整数（如 10^18），影响是否使用迭代或递归实现",
        "底数变化": "可推广到其他进制下的尾随零计数（如 b 进制下需分解 b 的质因数）",
        "目标因子变化": "可改为统计其他质因子的指数（如 n! 中 3 的个数）",
        "是否多组输入": "可设计为多组测试数据，提高算法复用性",
        "是否在线": "输入 n 可来自流式查询，要求快速响应"
      }
    }
  },
  {
    "title": "Sorted Matrix Search LCCI",
    "slug": "sorted-matrix-search-lcci",
    "schema": {
      "Input Structure": "二维矩阵 M×N，其中 matrix[1..M][1..N]；每行从左到右非递减，每列从上到下非递减；元素为整数",
      "Core Constraint": "矩阵的行列双重单调性：任意位置 matrix[i][j] 的左侧和上方元素均 ≤ 它，右侧和下方元素均 ≥ 它；该结构允许通过比较目标值剪枝搜索空间",
      "Objective Function": "判定是否存在一对 (i, j) 使得 matrix[i][j] == target",
      "Algorithmic Invariant": "从矩阵的右上角（或左下角）出发，每次比较当前元素与 target：\n- 若当前值 > target，则所在列可被排除（因列向下递增）\n- 若当前值 < target，则所在行可被排除（因行向右递增）\n- 每次移动保持目标若存在则仍在剩余子矩阵中的不变性",
      "Transformable Parameters": [
        "M 和 N 的数量级（如：1e3 vs 1e5，影响暴力是否可行）",
        "矩阵是否允许重复元素",
        "矩阵是否严格递增（或仅为非递减）",
        "是否多组查询（即多次查找不同 target，可预处理）",
        "是否在线输入（动态添加行/列）",
        "目标函数变换：返回坐标 / 计数出现次数 / 最近似值",
        "扩展维度：3D 升序数组查找",
        "约束放松：仅行有序，或仅局部有序"
      ]
    }
  },
  {
    "title": "Hanota LCCI",
    "slug": "hanota-lcci",
    "schema": {
      "Input Structure": [
        "三根柱子 A, B, C，表示为栈（列表）",
        "A 包含 N 个非负整数，按降序排列（自顶向下：A[0] 是顶部，A[-1] 是最大盘）",
        "B 和 C 初始为空",
        "N ≤ 14",
        "每个盘子大小唯一，值越小表示越小"
      ],
      "Core Constraint": [
        "每次只能移动一个盘子",
        "只能从栈顶取出并压入另一栈顶",
        "任何时刻不能将大盘放在小盘之上",
        "目标是从 A 经辅助柱 B 将所有盘子移动到 C",
        "状态转移具有递归依赖性：移动 n 层需先移开上 n-1 层"
      ],
      "Objective Function": [
        "构造合法移动序列，将所有盘子从 A 移动到 C",
        "输出最终状态：C 栈包含原 A 中所有元素，顺序相同",
        "要求原地修改，不返回移动步骤但改变栈内容"
      ],
      "Algorithmic Invariant": [
        "递归不变量：为移动 n 个盘子从源到目标，使用辅助柱：",
        "  1. 先将前 n-1 个盘子从源移动到辅助柱",
        "  2. 将第 n 个盘子（最大）从源移动到目标柱",
        "  3. 再将 n-1 个盘子从辅助柱移动到目标柱",
        "每层递归保持‘未处理部分’被更大盘保护，且中间状态满足塔规则",
        "移动过程中任意柱子始终维持栈内单调递增（自底向上）或为空"
      ],
      "Transformable Parameters": {
        "Number of Pegs": {
          "default": 3,
          "variants": [
            4,
            "k-peg Hanoi (更复杂的递推)"
          ]
        },
        "Number of Disks": {
          "range": "1 <= N <= 14",
          "variants": [
            "large N (需迭代/优化)",
            "online: one disk at a time"
          ]
        },
        "Order Constraint": {
          "default": "strictly decreasing on target",
          "variants": [
            "allow equal sizes?",
            "reverse goal: ascending on top?"
          ]
        },
        "Movement Rules": {
          "default": "standard: only smaller on larger",
          "variants": [
            "adjacent pegs only",
            "reverse order allowed?"
          ]
        },
        "Input Output Form": {
          "default": "in-place modify stacks A, B, C",
          "variants": [
            "return sequence of moves",
            "output step-by-step states"
          ]
        },
        "Data Flow": {
          "default": "offline, full state given",
          "variants": [
            "online: disks arrive over time",
            "partially revealed initial state"
          ]
        },
        "Objective Type": {
          "default": "construction: achieve final configuration",
          "variants": [
            "minimum moves count",
            "count number of valid sequences",
            "decision: is this move valid?"
          ]
        }
      }
    }
  },
  {
    "title": "Peaks and Valleys LCCI",
    "slug": "peaks-and-valleys-lcci",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中 n ≤ 10000，元素为整数",
      "Core Constraint": "峰与谷必须交替出现：即对于每个位置 i（1 < i < n），若 i-1 是谷，则 i 应为峰，i+1 应为谷，依此类推；边界位置只需满足单侧关系即可",
      "Objective Function": "构造一个峰与谷交替排列的数组排列方案",
      "Algorithmic Invariant": "通过贪心策略，在每一步确保当前元素与其前后元素满足峰/谷交替条件；局部调整不会破坏已构建的交替结构；可通过交换相邻元素来修正违反约束的位置",
      "Transformable Parameters": {
        "数据规模": "n 的数量级可变（如 n ≤ 100, n ≤ 1e5）",
        "值域": "nums[i] 是否有界（如有界在 [-1e9, 1e9]）",
        "是否有序": "输入是否部分有序或完全无序",
        "是否循环": "是否要求首尾也满足峰谷交替（环形结构）",
        "是否多组输入": "支持多组测试用例",
        "是否在线": "输入是否流式到达（动态插入）",
        "输出形式": "是否要求字典序最小解，或任意合法解即可"
      }
    }
  },
  {
    "title": "Sorted Merge LCCI",
    "slug": "sorted-merge-lcci",
    "schema": {
      "Input Structure": [
        "一维数组 A[1..m+n]，其中前 m 个元素为有效排序元素，后 n 个为占位符（值为0）",
        "一维数组 B[1..n]，包含 n 个已排序的整数",
        "A 和 B 均为非降序排列",
        "A 的长度恰好为 m + n"
      ],
      "Core Constraint": [
        "合并后的数组必须保持非降序排列",
        "要求在原地修改数组 A，不允许使用额外空间创建新数组",
        "比较操作具有传递性与可比性，数值有序"
      ],
      "Objective Function": "将数组 B 中的所有元素合并到数组 A 中，并使 A 成为一个完整的非降序数组",
      "Algorithmic Invariant": [
        "从后往前填充 A，维护三个指针：i 指向 A 当前待填入位置，pA 指向 A 未处理部分的最大值位置，pB 指向 B 未处理部分的最大值位置",
        "每次选择 A[pA] 与 B[pB] 中较大者填入 A[i]，保证后缀子数组已正确排序",
        "指针单向移动（递减），不回溯，已填充区域满足最终有序性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m 和 n 的数量级": [
            "小规模 (≤10^3)",
            "中等规模 (≤10^6)"
          ],
          "是否允许超大规模流式输入": false
        },
        "数组性质": {
          "是否严格递增": false,
          "是否存在重复元素": true,
          "是否允许负数": true,
          "是否循环数组": false
        },
        "输入形式": {
          "是否在线合并": false,
          "是否多组测试数据": true,
          "B 是否也需原地更新": false
        },
        "输出形式": {
          "是否只需返回长度而非实际排序结果": false,
          "是否要求去重合并": false,
          "是否要求稳定排序": true
        },
        "扩展变形点": [
          "二维矩阵行内合并",
          "多个有序数组依次合并（k-way merge）",
          "加入删除标记后的动态合并",
          "限定内存只能从前向后遍历（改变方向约束）"
        ]
      }
    }
  },
  {
    "title": "Robot in a Grid LCCI",
    "slug": "robot-in-a-grid-lcci",
    "schema": {
      "Input Structure": [
        "二维网格 grid[0..r-1][0..c-1]",
        "grid[i][j] ∈ {0, 1}",
        "0 表示空位置（可通过），1 表示障碍物（不可通过）",
        "起点为 (0, 0)，终点为 (r-1, c-1)",
        "r 和 c 均为正整数，且 r, c ≤ 100"
      ],
      "Core Constraint": [
        "机器人只能向右或向下移动",
        "路径不能经过值为 1 的格子（障碍物）",
        "路径必须从左上角 (0,0) 出发，到达右下角 (r-1,c-1)",
        "每一步移动必须保持在网格范围内"
      ],
      "Objective Function": [
        "构造一条从 (0,0) 到 (r-1,c-1) 的可行路径",
        "如果存在多条路径，返回任意一条即可",
        "如果没有可行路径，返回空数组"
      ],
      "Algorithmic Invariant": [
        "状态转移具有方向单调性：只能向右或向下，因此搜索空间无环",
        "若某个位置 (i,j) 可达，则其前驱 (i-1,j) 或 (i,j-1) 中至少一个可达",
        "使用动态可达性标记（DP 或 DFS + 记忆化）可避免重复计算",
        "路径重建可通过反向追踪父状态实现"
      ],
      "Transformable Parameters": [
        {
          "Grid Dimension": {
            "rows": "r ∈ [1, 100]",
            "cols": "c ∈ [1, 100]",
            "extension": "可扩展至三维网格或更高维、环形网格"
          }
        },
        {
          "Movement Rules": {
            "allowed_directions": [
              "right",
              "down"
            ],
            "variation": "可变更为允许上下左右移动、允许对角线移动等"
          }
        },
        {
          "Obstacle Configuration": {
            "type": "静态二值障碍（0/1）",
            "variation": "可变为动态障碍、概率性障碍、带权重的代价网格"
          }
        },
        {
          "Input Output Form": {
            "input_form": "离线一次性输入完整网格",
            "output_form": "返回路径坐标列表，格式为 [[row,col],...] or []",
            "variation": "可改为仅判断是否存在路径（判定问题）、计数路径总数、输出所有路径"
          }
        },
        {
          "Data Flow Mode": {
            "mode": "offline",
            "possible_extension": "在线流式输入行数据，要求实时决策是否可能到达"
          }
        },
        {
          "Multiple Queries": {
            "support": false,
            "extension": "支持多组起点终点查询、多次更新障碍后重查路径"
          }
        }
      ]
    }
  },
  {
    "title": "BST Sequences LCCI",
    "slug": "bst-sequences-lcci",
    "schema": {
      "Input Structure": {
        "type": "Binary Search Tree (BST)",
        "description": "A binary search tree with distinct nodes, represented as a rooted tree structure. Each node has a unique value in the range [1, 1e6]. The number of nodes is in [0, 1000].",
        "node_values": "Distinct positive integers",
        "tree_properties": "BST property: left subtree < root < right subtree"
      },
      "Core Constraint": {
        "constraint": "Order of insertion must preserve BST construction process",
        "details": [
          "The root must be inserted first",
          "For any node, its children can only be inserted after all ancestors on the path from root to that node are already in the tree",
          "Within different subtrees, insertion order is independent as long as parent is inserted before child"
        ],
        "implication": "Insertion sequences correspond to topological orderings of the tree where each node comes after its parent"
      },
      "Objective Function": {
        "goal": "Enumerate all valid insertion orders",
        "type": "Counting and Construction",
        "output": "List of all possible arrays (permutations of node values) that generate the given BST when inserted sequentially from left to right"
      },
      "Algorithmic Invariant": {
        "invariant": "Recursive merging of independent subtree sequences with fixed root-first condition",
        "rules": [
          "At each recursive step, the current root must appear first in any merged sequence",
          "Sequences from left and right subtrees can be interleaved arbitrarily, as long as internal order within each subtree's sequence is preserved",
          "This leads to a divide-and-conquer structure: result = merge(left_sequences, right_sequences), with root prepended"
        ],
        "proof_basis": "Topological sort over a forest with two independent trees (left and right subtrees), constrained by parent-before-child dependency"
      },
      "Transformable Parameters": {
        "n_range": "[0, 1000]",
        "value_domain": "[1, 1000000]",
        "uniqueness_of_values": true,
        "bst_property": true,
        "output_size_bound": 5000,
        "input_form": "Tree root pointer / hierarchical structure",
        "output_form": "List of lists of integers (all valid insertion sequences)",
        "multi_case_input": false,
        "online_query": false,
        "modifications_allowed": false,
        "variant_slots": [
          "Allow duplicate values (requires definition of tie-breaking rule in BST)",
          "Require only one valid sequence instead of all (decision variant)",
          "Count number of sequences without enumerating them (counting-only optimization)",
          "Extend to general binary tree (with known insertion rule)",
          "Add constraints on relative order (e.g., certain node must come early)"
        ]
      }
    }
  },
  {
    "title": "Paths with Sum LCCI",
    "slug": "paths-with-sum-lcci",
    "schema": {
      "Input Structure": "二叉树 T，每个节点包含整数值；节点数 n ≤ 10000；值域为整数（可正可负）",
      "Core Constraint": "路径方向必须向下（从父节点到子节点），但起点和终点可以是任意节点；局部路径和依赖于从根到当前节点的前缀和及其历史出现次数",
      "Objective Function": "计数：统计所有节点数值总和等于给定目标值的路径数量",
      "Algorithmic Invariant": "使用前缀和思想，维护从根到当前节点路径上各前缀和的出现频次；对于当前前缀和 prefixSum，若 prefixSum - target 在哈希表中存在，则说明存在若干条满足条件的路径；回溯时需撤销当前节点的前缀和影响以保证状态正确性",
      "Transformable Parameters": {
        "n 的数量级": "≤ 1000, ≤ 10000, 或扩展至动态在线场景",
        "值域": "非负整数 / 整数 / 大数模意义下",
        "是否有序": "树结构无序，但可通过 DFS/BFS 序转化为序列问题",
        "是否循环": "否（树无环）",
        "是否多组输入": "单组或多组目标和查询",
        "是否在线": "离线处理为主；可变式支持动态增删节点或在线查询",
        "路径方向约束": "严格向下 → 可允许向上 → 支持任意简单路径",
        "输出形式": "仅计数 / 输出所有路径方案 / 输出一条路径"
      }
    }
  },
  {
    "title": "Partition List LCCI",
    "slug": "partition-list-lcci",
    "schema": {
      "Input Structure": "链表 L = [Node(val)]，长度为 n，其中每个节点的值 val ∈ [-100, 100]；给定分割阈值 x ∈ [-200, 200]",
      "Core Constraint": "需将链表划分为两个逻辑段：第一段所有节点值 < x，第二段所有节点值 ≥ x；不要求保持各段内节点的原始相对顺序",
      "Objective Function": "构造一个满足分隔条件的新链表（结构重排），输出重排后的头节点",
      "Algorithmic Invariant": "使用双链表收集策略：维护两个临时链表——smaller 和 larger/equal；遍历原链表时，根据 node.val < x 将节点分别接入对应链表尾部；最后拼接 smaller → larger，保证分区正确性且无遗漏",
      "Transformable Parameters": {
        "n 的数量级": "0 ≤ n ≤ 200",
        "值域": "Node.val ∈ [-100, 100], x ∈ [-200, 200]",
        "是否有序": "输入链表无序，且不依赖顺序性",
        "是否循环": "否，输入为普通单向链表",
        "是否多组输入": "可扩展为多组测试用例",
        "是否在线": "否，离线一次性处理整个链表",
        "是否保留内部顺序": "可变参数：本题不要求保留；可改编为‘保持段内相对顺序’以改变解法复杂度"
      }
    }
  },
  {
    "title": "Kth Node From End of List LCCI",
    "slug": "kth-node-from-end-of-list-lcci",
    "schema": {
      "Input Structure": "单向链表 L，包含 n 个节点；每个节点具有整数值和指向下一个节点的指针；给定正整数 k（1 ≤ k ≤ n）",
      "Core Constraint": "链表为单向结构，无法直接访问倒数第 k 个节点；需在仅遍历一次的前提下定位目标节点；前后节点之间存在顺序依赖关系",
      "Objective Function": "返回链表中倒数第 k 个节点的值",
      "Algorithmic Invariant": "使用双指针技术：快指针先移动 k 步，随后快慢指针同步前进，当快指针到达末尾时，慢指针指向倒数第 k 个节点；该推进过程保持两指针间距离恒为 k，确保定位正确性",
      "Transformable Parameters": {
        "k 的取值范围": "是否保证 1 ≤ k ≤ n；或允许 k > n 时返回特殊值",
        "链表规模 n": "n 的数量级（如 10^3, 10^4, 10^5），影响是否支持多次遍历",
        "是否允许多次遍历": "约束为仅一次遍历 vs. 可两次遍历",
        "输入形式": "是否给出头指针；或提供链表数组表示及 k",
        "是否在线": "链表是否动态增长，要求实时维护倒数第 k 节点",
        "目标变化": "返回值 → 返回节点指针 / 修改节点值 / 删除该节点",
        "数据类型扩展": "节点值是否为泛型或复杂结构"
      }
    }
  },
  {
    "title": "One Away LCCI",
    "slug": "one-away-lcci",
    "schema": {
      "Input Structure": [
        "两个字符串 first[1..m] 和 second[1..n]",
        "字符集为小写英文字母（a-z）",
        "m 和 n 为非负整数，表示字符串长度"
      ],
      "Core Constraint": [
        "编辑操作仅限于三种：插入一个字符、删除一个字符、替换一个字符",
        "最多允许一次编辑（包括零次）",
        "两字符串的长度差不超过1时才可能通过一次操作转换"
      ],
      "Objective Function": "判定是否可以通过至多一次编辑操作将 first 转换为 second",
      "Algorithmic Invariant": [
        "双指针从左到右扫描公共前缀，直到首次出现不同字符",
        "若长度相等，则后续子串必须完全相同（对应替换操作）",
        "若长度差1，则较长字符串跳过当前字符后，剩余部分必须与较短字符串剩余部分完全匹配（对应插入/删除）",
        "至多允许一次差异，此后所有字符必须严格对齐"
      ],
      "Transformable Parameters": {
        "字符串长度规模": "m, n ≤ 10^4（可调整为更小或支持超长串）",
        "字符集类型": "可扩展为大小写、数字、Unicode",
        "编辑次数限制": "k 次编辑（k=0 或 1 为本题特例）",
        "是否要求构造方案": "仅判断存在性 / 输出具体操作序列",
        "是否多组查询": "单组输入 / 多组测试用例",
        "是否在线处理": "静态输入 / 流式字符输入动态判定"
      }
    }
  },
  {
    "title": "Pond Sizes LCCI",
    "slug": "pond-sizes-lcci",
    "schema": {
      "Input Structure": [
        "二维整数矩阵 land[1..m][1..n]",
        "每个元素为非负整数",
        "0 表示水域，>0 表示陆地",
        "m, n 满足 1 ≤ m, n ≤ 1000"
      ],
      "Core Constraint": [
        "水域连通性定义为八邻域连通（水平、垂直、对角）",
        "每个池塘是极大连通水域子图",
        "同一水域只能属于一个池塘",
        "连通区域需通过遍历显式构造"
      ],
      "Objective Function": [
        "计数：统计所有极大连通水域区域的大小",
        "输出要求：将各池塘大小按升序排序后返回"
      ],
      "Algorithmic Invariant": [
        "已访问标记数组 visited[i][j] 确保每个水域点仅被计入一个池塘",
        "DFS/BFS 扩展过程中，每次探索只朝未访问的 0 值位置进行",
        "局部连通块大小累加过程保持全局正确性",
        "排序前的结果集合独立于搜索顺序"
      ],
      "Transformable Parameters": {
        "Connectivity": {
          "description": "邻接方式",
          "options": [
            "4-directional",
            "8-directional"
          ]
        },
        "Value Criterion for Water": {
          "description": "水域判定条件",
          "options": [
            "==0",
            "≤K",
            "in set S"
          ]
        },
        "Output Format": {
          "description": "输出形式",
          "options": [
            "sorted list of sizes",
            "maximum pond size only",
            "count of ponds",
            "largest K ponds"
          ]
        },
        "Data Scale": {
          "description": "矩阵规模",
          "range": "1 ≤ m,n ≤ 10^6 (稀疏时可用哈希存储)"
        },
        "Input Type": {
          "description": "输入模式",
          "options": [
            "offline static grid",
            "online cell updates",
            "streaming rows"
          ]
        },
        "Multiple Queries": {
          "description": "是否支持多次查询动态变化后的池塘信息",
          "value": true
        },
        "Modification Operations": {
          "description": "是否允许修改某格海拔并重新查询",
          "value": false
        }
      }
    }
  },
  {
    "title": "Pattern Matching LCCI",
    "slug": "pattern-matching-lcci",
    "schema": "{\n  \"Input Structure\": [\n    \"给定两个字符串：pattern 和 value\",\n    \"pattern 是由字符 'a' 和 'b' 组成的长度为 m 的字符串（1 ≤ m ≤ 1000）\",\n    \"value 是由小写英文字母组成的长度为 n 的字符串（0 ≤ n ≤ 1000）\"\n  ],\n  \"Core Constraint\": [\n    \"整个匹配过程由 pattern 中 'a' 和 'b' 对应的子串（即 value 的连续片段）唯一决定\",\n    \"'a' 和 'b' 必须分别映射到固定的字符串（可以为空），且不能同时映射到相同的字符串（除非其中一个为空时允许另一方重复）\",\n    \"value 必须被完整切分为与 pattern 结构一致的一系列连续块，顺序和类型必须完全匹配\"\n  ],\n  \"Objective Function\": \"判定是否存在一种对 'a' 和 'b' 的非冲突赋值方式，使得将 pattern 按照该赋值展开后恰好等于 value\",\n  \"Algorithmic Invariant\": [\n    \"一旦确定 'a' 和 'b' 所代表的字符串长度（len_a, len_b），即可在线性时间内验证是否能构成完整匹配\",\n    \"枚举合法的 (len_a, len_b) 组合时，可通过 pattern 中 a 和 b 的出现次数建立等式约束：count_a * len_a + count_b * len_b = n\",\n    \"对于每个合法的 len_a（或 len_b），可唯一推导出对应的 len_b（或 len_a），从而避免双重循环暴力\",\n    \"在枚举过程中，已尝试的长度组合不会影响后续验证的正确性，状态独立\"\n  ],\n  \"Transformable Parameters\": {\n    \"pattern 字符种类\": {\n      \"原题为 'a'/'b' 两种，可扩展至 k 种模式字符（如 'a'~'z'）\"\n    },\n    \"映射约束\": {\n      \"是否允许空字符串映射\",\n      \"是否要求所有模式字符映射不同字符串（严格不等）\"\n    },\n    \"数据规模\": {\n      \"pattern 长度范围：[1, 1000] → 可调整为更大（如 1e5）以限制暴力可行性\",\n      \"value 长度范围：[0, 1000] → 可扩展至 1e5，推动使用数学优化而非枚举\"\n    },\n    \"输入形式\": {\n      \"单组测试用例 → 多组输入\",\n      \"离线处理 → 在线查询（动态更新 pattern 或 value）\"\n    },\n    \"目标函数变形\": {\n      \"判定是否存在匹配 → 计算所有可行方案数\",\n      \"构造字典序最小的映射方案\",\n      \"最小化 |len_a - len_b| 等优化目标\"\n    },\n    \"结构变换\": {\n      \"线性 pattern → 环形 pattern（首尾相连）\",\n      \"加入通配符（如 '*' 表示任意字符序列）\"\n    }\n  }\n}"
  },
  {
    "title": "Contiguous Sequence LCCI",
    "slug": "contiguous-sequence-lcci",
    "schema": {
      "Input Structure": "一维整数数组 A[1..n], 其中 n ≥ 1, A[i] ∈ ℤ",
      "Core Constraint": "最大连续子数组和必须由原数组中连续的一段构成；局部最优解的延伸依赖于前缀和的单调性或动态规划状态转移：dp[i] = max(A[i], dp[i-1] + A[i])",
      "Objective Function": "求所有连续子数组中元素和的最大值（最大化）",
      "Algorithmic Invariant": "维护以当前位置结尾的最大子数组和，该状态具有最优子结构与贪心选择性质：若前一段最大和为负，则舍弃并从当前重新开始；双指针或单遍扫描过程中，已处理部分的最优信息可压缩为常量状态（如当前最大和、全局最大和）",
      "Transformable Parameters": {
        "数据规模": "n 的数量级（例如 1e3 / 1e5 / 1e6），决定是否允许 O(n²) 或必须 O(n) 解法",
        "值域范围": "A[i] 是否有界（如全为正、全为负、包含零）、是否非负整数",
        "输入形式": "是否有序、是否循环数组（环形连续子数组）",
        "多组数据": "是否要求处理多组测试用例",
        "在线查询": "是否支持动态修改数组元素后查询最大连续子数组和（即带修线段树场景）",
        "输出形式": "仅返回最大和 / 同时返回起止下标 / 返回具体子数组",
        "约束变形": "是否存在长度限制（如子数组长度 ≤ K）或必须包含特定元素"
      }
    }
  },
  {
    "title": "Sub Sort LCCI",
    "slug": "sub-sort-lcci",
    "schema": {
      "Input Structure": "一维整数数组 A[1..n], 其中 0 <= n <= 1000000; 数组元素为整数，可重复，无序",
      "Core Constraint": "存在一个最短连续子区间 [m,n]，使得对该子区间排序后整个数组有序；该性质依赖于：左部 A[1..m-1] 已有序且 <= min(A[m..n])，右部 A[n+1..end] 已有序且 >= max(A[m..n])",
      "Objective Function": "找出满足条件的最短区间 [m,n]；若不存在则返回 [-1,-1]；目标是极小化 n - m（长度最小）",
      "Algorithmic Invariant": "双指针推进过程中维护：\n- 从左向右找到首个不满足 A[i] <= A[i+1] 的位置 left_break\n- 从右向左找到首个不满足 A[j-1] <= A[j] 的位置 right_break\n- 在 [left_break, right_break] 中求 min_val 和 max_val\n- 向左扩展左边界直到 A[i] <= min_val\n- 向右扩展右边界直到 A[j] >= max_val\n- 最终区间 [l, r] 满足：A[1..l-1] <= min_val <= max_val <= A[r+1..n]",
      "Transformable Parameters": [
        "n 的数量级：1e5 / 1e6 / 可变",
        "数组是否允许负值：是",
        "是否要求输出所有最短解（多解情况）",
        "是否改为非连续子序列排序（变形题）",
        "是否在线输入流形式",
        "是否支持多次查询或动态修改",
        "目标函数变换：从最小长度 → 最小字典序区间",
        "输入结构变换：二维矩阵中找最小矩形区域使排序后整体有序"
      ]
    }
  },
  {
    "title": "Master Mind LCCI",
    "slug": "master-mind-lcci",
    "schema": {
      "Input Structure": [
        "字符串 solution[1..n]",
        "字符串 guess[1..n]",
        "n = 4",
        "字符集：{ 'R', 'G', 'B', 'Y' }",
        "solution[i], guess[i] ∈ 字符集"
      ],
      "Core Constraint": [
        "猜中（exact match）要求位置和颜色均相同",
        "伪猜中（pseudo-match）指颜色正确但位置不同，且不能重复匹配已‘猜中’或已计入‘伪猜中’的位置",
        "每个槽位最多参与一次猜中或伪猜中",
        "猜中与伪猜中互斥：一旦位置 i 被计为猜中，则不能用于任何伪猜中"
      ],
      "Objective Function": [
        "计算两个整数：",
        "answer[0] = 猜中的次数（位置与颜色完全匹配的个数）",
        "answer[1] = 伪猜中的次数（颜色存在但位置错误，且未被猜中覆盖的可配对数量）"
      ],
      "Algorithmic Invariant": [
        "猜中可通过逐位比较直接确定，并从后续颜色计数中剔除对应字符",
        "剩余未匹配字符构成多重集合，伪猜中数量等于两字符串未匹配部分中各颜色频数的逐颜色最小值之和",
        "颜色频数统计具有可加性和独立性，支持分离处理"
      ],
      "Transformable Parameters": {
        "n 的数量级": [
          "n = 4（原题）",
          "可扩展至 n ≥ 1，在线判断"
        ],
        "字符集大小": [
          "4 种颜色（固定）",
          "可推广至 k 种颜色输入"
        ],
        "是否有序": "字符串顺序重要（位置敏感）",
        "是否多组输入": [
          "单组测试（原题）",
          "可改为多组查询批量处理"
        ],
        "是否在线": [
          "一次性输入",
          "可设计为流式猜测反馈系统"
        ],
        "输出形式": [
          "[hit, pseudoHit] 数组",
          "可要求仅返回伪猜中数、或比值、或判定是否完全匹配"
        ],
        "约束变化": [
          "允许重复颜色（当前已支持）",
          "加入额外限制如每种颜色最多出现 m 次",
          "引入新反馈类型（如‘近位’）"
        ]
      }
    }
  },
  {
    "title": "Best Line LCCI",
    "slug": "best-line-lcci",
    "schema": {
      "Input Structure": "二维平面上的点集 Points[1..n]，其中每个点 Points[i] = [X_i, Y_i]，坐标为整数，n ∈ [2, 300]",
      "Core Constraint": "三点共线当且仅当它们的斜率相同（需处理垂直情况）；任意两点确定一条直线，但多点共线需满足统一斜率和截距关系；通过哈希聚合相同直线上的点",
      "Objective Function": "最大化穿过点的数量；在多条最优直线中，选择所穿点编号列表字典序最小的前两个索引 [S[0], S[1]] 作为输出",
      "Algorithmic Invariant": "固定一个基准点 i，计算其与其他所有点 j (j > i) 的方向向量（归一化斜率），用哈希表统计共线点数；避免重复枚举同一直线；每条直线仅由最小索引点主动发起枚举以保证不重复且可比较字典序",
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 300（当前），可扩展至 O(n² log n) 可接受规模",
        "值域": "坐标为整数，可正可负，可扩展为浮点数（需处理精度）",
        "是否有序": "输入无序，但枚举时按索引顺序处理以保障字典序可比性",
        "是否循环": "否，非周期性结构",
        "是否多组输入": "单组数据，可扩展为多测例批量处理",
        "是否在线": "离线处理全部点，可变体支持动态增删点的在线查询",
        "特殊约束可调项": [
          "是否允许重合点",
          "是否要求返回完整点列 S 而非仅前两个",
          "目标函数变为判定是否存在过 K 点的直线",
          "从最大计数变为计数所有最多点直线的方案数"
        ]
      }
    }
  },
  {
    "title": "Bisect Squares LCCI",
    "slug": "bisect-squares-lcci",
    "schema": {
      "Input Structure": [
        "两个正方形，每个正方形表示为三元组 square = [X, Y, L]",
        "其中 (X, Y) 是正方形左下顶点坐标",
        "L > 0 是正方形边长",
        "正方形的边与坐标轴平行（axis-aligned）",
        "所有输入均为实数（题目未限定整数，按几何题惯例视为实数域）"
      ],
      "Core Constraint": [
        "所求直线必须将两个正方形各自分割为面积相等的两部分",
        "每个正方形被直线穿过形成两个交点线段，整体共4个交点",
        "满足条件的直线中，若有多条，选择斜率最大的一条（斜率无穷大优先于有限值）",
        "由于正方形中心对称，任何过其几何中心的直线均可将其面积二等分",
        "因此目标直线必须同时经过两个正方形的几何中心"
      ],
      "Objective Function": [
        "构造一条同时通过两个正方形几何中心的直线",
        "返回该直线与两个正方形边界交点中距离最远的两个端点（即线段的两端）",
        "输出格式为 {X1, Y1, X2, Y2}，要求：",
        "若 X1 != X2，则保证 X1 < X2；否则保证 Y1 <= Y2"
      ],
      "Algorithmic Invariant": [
        "所有能将一个轴对齐正方形等面积分割的直线，当且仅当其经过该正方形的几何中心",
        "两个正方形的几何中心唯一确定一条直线（除非重合）",
        "该直线与每个正方形最多相交于两条边上，产生两个交点",
        "四个交点共线，其中最远两点构成最终线段端点",
        "排序规则用于标准化输出，不改变几何结构"
      ],
      "Transformable Parameters": [
        "是否允许正方形旋转（改为任意方向） → 变为更复杂计算几何题",
        "从两个正方形扩展到 n 个矩形/凸多边形 → 多中心共线约束优化",
        "要求最小化交点数量或最大化斜率以外的目标（如截距）",
        "输入形式：离线批量处理 vs 在线动态添加正方形",
        "数据类型：整数坐标 vs 浮点坐标（影响精度处理）",
        "是否允许多条最优直线时返回所有解（而非选最大斜率）",
        "增加权重：不同正方形有不同权重，求加权中心连线"
      ]
    }
  },
  {
    "title": "Diving Board LCCI",
    "slug": "diving-board-lcci",
    "schema": {
      "Input Structure": [
        "整数 shorter（表示短木板长度，满足 0 < shorter <= longer）",
        "整数 longer（表示长木板长度，满足 longer >= shorter）",
        "整数 k（表示必须恰好使用的木板总数，0 <= k <= 100000）"
      ],
      "Core Constraint": [
        "必须恰好使用 k 块木板",
        "每块木板只能是 shorter 或 longer 类型",
        "所有可能长度由组合中 shorter 和 longer 的数量决定：总长度 = i * shorter + (k - i) * longer，其中 i ∈ [0, k]",
        "当 shorter == longer 时，只存在唯一一种长度"
      ],
      "Objective Function": [
        "生成所有可能的跳水板总长度",
        "结果需按从小到大顺序排列"
      ],
      "Algorithmic Invariant": [
        "长度随 longer 使用次数单调递增",
        "枚举使用 longer 的数量 j（从 0 到 k），对应 shorter 使用数量为 k - j，可线性生成所有可能值",
        "无需去重或排序：若 shorter < longer，则序列天然有序；若相等则直接返回单元素数组"
      ],
      "Transformable Parameters": [
        "k 的数量级（当前为 1e5，可扩展至支持更大规模或在线查询）",
        "shorter 与 longer 是否允许相等（已覆盖）",
        "是否允许多种材料类型（>2 类木板）——当前为二元选择",
        "是否要求输出构造方案（如各长度对应的 short/long 分布）",
        "是否改为求最长、最短、第 k 小长度（目标函数变换）",
        "是否加入成本约束（如每种木板有使用代价）",
        "是否支持动态更新 shorter / longer / k（在线版本）",
        "输入是否为多组测试数据"
      ]
    }
  },
  {
    "title": "Living People LCCI",
    "slug": "living-people-lcci",
    "schema": {
      "Input Structure": [
        "数组 birth[1..n]，表示每个人的出生年份",
        "数组 death[1..n]，表示每个人的死亡年份",
        "n ∈ [1, 10000]",
        "年份范围：1900 ≤ birth[i] ≤ death[i] ≤ 2000",
        "birth 和 death 长度相等"
      ],
      "Core Constraint": [
        "一个人在 [birth[i], death[i]] 区间内的每一年都应被计入生存人数",
        "年份跨度有限（仅 101 年：1900–2000），允许按年枚举",
        "区间覆盖问题，但目标是求最大重叠点（年份）而非总覆盖"
      ],
      "Objective Function": [
        "找出生存人数最多的年份",
        "若有多个，返回最小的年份",
        "目标函数为：maximize count(year)，tie-breaking by minimize year"
      ],
      "Algorithmic Invariant": [
        "使用差分数组或事件扫描法：每个 birth[i] 增加一个 +1 事件，death[i] + 1 增加一个 -1 事件（因死亡年份仍算存活）",
        "按时间顺序处理事件，维护当前人数并更新最大值",
        "由于年份范围小且固定，遍历年份即可模拟前缀和恢复原数组",
        "最优解可通过一次排序（或计数排序）+ 一次扫描完成"
      ],
      "Transformable Parameters": [
        "n 的数量级：可扩展至 1e5 或更高，迫使使用离散化+差分",
        "年份范围：若从 [1900,2000] 扩展到 [1, 1e9]，则需离线事件排序",
        "是否在线输入：动态增删个体，转为支持区间加、全局查询最大值的数据结构题",
        "是否要求输出所有最大年份（而不仅是第一个）",
        "是否允许多次查询不同时间段的最大生存人数（→ 转为 RMQ 问题）",
        "是否考虑权重（如不同人影响力不同）→ 加权版本",
        "是否改为求最大连续生存人数段（→ 滑动窗口变形）"
      ]
    }
  },
  {
    "title": "Operations LCCI",
    "slug": "operations-lcci",
    "schema": {
      "Input Structure": [
        "类成员函数调用：minus(a, b), multiply(a, b), divide(a, b)",
        "输入 a 和 b 均为整数（可正可负）",
        "只允许使用加法运算符 (+) 和逻辑运算符（如 !, &&, ||, ? :）",
        "允许使用正负常数，禁止使用位运算、乘除减法操作符"
      ],
      "Core Constraint": [
        "基本算术运算需通过加法和逻辑控制模拟实现",
        "减法是加法的逆运算：a - b = a + (-b)，但负号需通过逻辑或循环构造",
        "乘法是重复加法的累积，需处理符号与溢出边界",
        "除法是重复减法的计数过程，即求最大 k 使得 k * |b| ≤ |a|，再调整符号",
        "所有运算必须在有限步内完成，依赖于数值大小的迭代次数"
      ],
      "Objective Function": [
        "实现三个整数算术函数：减法、乘法、除法",
        "返回值为对应运算的整数结果（向零取整）"
      ],
      "Algorithmic Invariant": [
        "符号分离不变性：将运算拆分为绝对值计算 + 符号判断，保证正确性",
        "迭代逼近不变性：乘法通过累加、除法通过累减逐步逼近结果，每一步保持部分和/余数的有效性",
        "边界控制不变性：利用逻辑条件终止循环（如余数小于除数），防止无限循环",
        "加法构建不变性：所有非加法操作最终归约为加法序列与条件跳转"
      ],
      "Transformable Parameters": {
        "数据规模": "单次函数调用中 |a|, |b| ≤ 10^4，调用次数 ≤ 1000",
        "值域限制": "结果在 int 范围内（假设 32 位整数）",
        "是否有序": "不适用（标量输入）",
        "是否循环": "否",
        "是否多组输入": "是（支持多次方法调用）",
        "是否在线": "是（每次调用独立处理，无预处理依赖）",
        "是否允许位运算": "否（显式约束）",
        "是否可扩展至浮点": "否（当前仅限整数）",
        "错误处理": "假设输入有效，无需处理除零等异常"
      }
    }
  },
  {
    "title": "Maximum LCCI",
    "slug": "maximum-lcci",
    "schema": {
      "Input Structure": [
        "两个整数 a 和 b",
        "a, b ∈ ℤ（可为正、负或零）"
      ],
      "Core Constraint": [
        "不允许使用比较运算符（如 <, >, ==）和条件控制结构（如 if-else, switch）",
        "必须通过位运算、算术运算或逻辑运算实现数值大小判断",
        "解法依赖于符号位提取与溢出/借位行为的可预测性"
      ],
      "Objective Function": "返回 a 和 b 中较大的整数",
      "Algorithmic Invariant": [
        "利用整数相减后的符号位判断大小关系",
        "通过位移操作安全提取符号位，避免未定义行为",
        "构造无分支表达式：max(a, b) = a * (1 - k) + b * k，其中 k 表示 b >= a 的布尔结果（0 或 1）",
        "k 的计算基于 (b - a) 的符号位，且需处理整数溢出问题（例如通过异或判断是否同号）"
      ],
      "Transformable Parameters": {
        "数据类型": [
          "32位整数 → 64位整数",
          "有符号整数 → 无符号整数"
        ],
        "值域限制": [
          "是否存在溢出风险（如极端大/小值）",
          "是否保证 a ≠ b"
        ],
        "输入形式": [
          "单组输入 → 多组输入批量处理",
          "静态输入 → 在线查询流式输入"
        ],
        "约束强度": [
          "完全禁用比较 → 允许三元运算符 ? :",
          "仅禁止 if-else，允许 cmp 函数"
        ],
        "扩展方向": [
          "推广到三个数取最大值",
          "求最小值版本",
          "同时返回最大值与最小值"
        ]
      }
    }
  },
  {
    "title": "Permutation II LCCI",
    "slug": "permutation-ii-lcci",
    "schema": {
      "Input Structure": "字符串 S[1..n]，其中 n ∈ [1, 9]；字符为英文字母（可重复）",
      "Core Constraint": "存在重复字符，相同字符的排列视为等价，需去重；全排列基于交换或插入生成所有唯一序列",
      "Objective Function": "构造并返回字符串 S 的所有不重复排列方案",
      "Algorithmic Invariant": "在递归/回溯过程中维护已使用字符的状态；通过排序 + 相邻剪枝（跳过相同字符的重复分支）保证每个唯一排列仅生成一次；状态路径可撤销以支持搜索空间遍历",
      "Transformable Parameters": {
        "n 的数量级": "n ≤ 9（当前限制），可扩展至 n ≤ 12（指数级增长）",
        "值域": "字符集可从英文字母扩展至数字、符号或 Unicode 字符",
        "是否有序": "输入是否预排序影响剪枝效率，但不影响正确性",
        "是否循环": "可改编为环形排列（首尾相邻视为同构）",
        "是否多组输入": "单组输入为主，可扩展为多组字符串批量处理",
        "是否在线": "离线生成所有排列；可改造为按需生成（生成器模式 / 在线查询第 k 个排列）"
      }
    }
  },
  {
    "title": "寻找二叉树的最近公共祖先",
    "slug": "er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof",
    "schema": {
      "Input Structure": "二叉树 T，根节点为 root；两个指定节点 p 和 q；所有节点值唯一；p、q 为不同节点且均存在于树中",
      "Core Constraint": "最近公共祖先（LCA）是同时为 p 和 q 祖先的深度最大的节点；一个节点可以是它自己的祖先；树结构无序，父子关系通过指针隐式定义，无法直接访问父节点或路径",
      "Objective Function": "找到并返回节点 p 和 q 的最近公共祖先（LCA）节点",
      "Algorithmic Invariant": "在递归过程中，若当前节点为 p 或 q，则该节点可能是候选祖先；左右子树分别返回非空表示在对应子树中找到了 p 或 q；当某节点左右子树均返回非空，或其自身为 p/q 且另一子树返回非空时，该节点即为 LCA；自底向上回溯保证首次满足条件的节点即为深度最大者",
      "Transformable Parameters": [
        "树是否为二叉搜索树（有序性引入可优化解法）",
        "是否允许重复节点值",
        "是否提供父指针（变为链表求交点类问题）",
        "查询次数：单次查询 → 多次查询（需预处理，如 RMQ + Euler Tour）",
        "输入形式：完整树结构 → 边列表 + 根节点",
        "数据规模：n 的数量级（影响是否可用 O(n) 解法）",
        "是否在线：动态插入节点后查询 LCA（需要动态树维护）"
      ]
    }
  },
  {
    "title": "求二叉搜索树的最近公共祖先",
    "slug": "er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof",
    "schema": {
      "Input Structure": {
        "type": "Binary Search Tree (BST)",
        "node_definition": "TreeNode with val, left, right",
        "properties": [
          "所有节点值唯一",
          "二叉搜索树性质：对任意节点，左子树所有节点值 < 当前节点值 < 右子树所有节点值",
          "p 和 q 是树中两个不同的有效节点，且均存在于树中"
        ],
        "representation": "root 为树的根节点指针，p 和 q 为指向目标节点的指针"
      },
      "Core Constraint": {
        "constraint": "利用 BST 的有序性约束路径方向",
        "key_insight": "从根出发到 p 和 q 的路径上，首个分叉点即为最近公共祖先",
        "structural_property": "若当前节点值介于 p 和 q 的值之间（或等于其中之一），则该节点即为 LCA"
      },
      "Objective Function": {
        "goal": "找到两个指定节点 p 和 q 的最近公共祖先（LCA）",
        "objective_type": "构造方案（返回具体节点）",
        "optimality_criterion": "深度尽可能大（最深层的公共祖先）"
      },
      "Algorithmic Invariant": {
        "invariant": "当前遍历节点 cur 满足：若 p 和 q 分别位于 cur 的左右两侧（含等于），则 cur 即为 LCA；否则可安全进入某一侧子树而不丢失解",
        "movement_rule": "根据 p.val 和 q.val 与 cur.val 的大小关系决定搜索方向：\n- 若 p.val < cur.val 且 q.val < cur.val → 进入左子树\n- 若 p.val > cur.val 且 q.val > cur.val → 进入右子树\n- 否则，cur 即为 LCA",
        "correctness_guarantee": "BST 性质保证了路径唯一性和方向单调性，使得贪心推进不破坏最优性"
      },
      "Transformable Parameters": {
        "data_scale": "树节点数 n 的范围（如 1 ≤ n ≤ 10^4）",
        "value_domain": "节点值域范围（如 [-10^9, 10^9]）",
        "input_form": [
          "是否提供节点指针（原始形式）",
          "或仅给出层序遍历数组和 p.val, q.val"
        ],
        "online_query": "是否支持多次查询不同 (p, q) 对（可预处理建表）",
        "tree_modification": "是否允许动态插入/删除节点（在线更新结构）",
        "relax_bst_property": "推广至普通二叉树（变为 LeetCode 236 题，需递归回溯）",
        "multi_queries": "是否为多组测试数据输入"
      }
    }
  },
  {
    "title": "设计机械累加器",
    "slug": "qiu-12n-lcof",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "name": "target",
        "range": [
          1,
          10000
        ],
        "description": "目标累加数值，表示从 1 累加到 target 的正整数序列"
      },
      "Core Constraint": {
        "constraint": "只能使用加法操作，禁止使用乘除法、循环、条件判断语句（如 if-else、switch）、递归控制结构等高级编程功能",
        "implication": "无法显式迭代或分支选择，必须通过数据结构或函数调用机制隐式实现重复累加"
      },
      "Objective Function": {
        "goal": "计算从 1 到 target 所有整数的和",
        "type": "sum",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "invariant": "利用函数调用栈和短路运算（逻辑与/或）模拟递归与终止条件，每次调用完成一次加法并推进状态",
        "mechanism": "通过布尔表达式的短路特性触发递归调用，在无显式条件语句下实现控制流转移",
        "state_progression": "每层调用减少 target 值并累加当前值，直到 base case 隐式达成"
      },
      "Transformable Parameters": {
        "data_scale": {
          "target_range": "[1, 10000]",
          "potential_modification": "可扩展为更大范围，需考虑栈溢出限制"
        },
        "input_form": "单个整数输入",
        "multiple_cases": false,
        "online_query": false,
        "operation_restriction": {
          "allowed_operations": [
            "addition"
          ],
          "forbidden_operations": [
            "multiplication",
            "division",
            "loop",
            "conditional_statement",
            "explicit_recursion"
          ]
        },
        "structural_variation": [
          "允许位运算替代部分算术操作（变形题）",
          "要求非递归形式但仍禁用循环（如借助数组索引与函数指针表）",
          "多线程累加模拟（并发版本）"
        ]
      }
    }
  },
  {
    "title": "买卖芯片的最佳时机",
    "slug": "gu-piao-de-zui-da-li-run-lcof",
    "schema": {
      "Input Structure": [
        "一维数组 prices[1..n]",
        "prices[i] 表示第 i 天的芯片价格",
        "非负整数，0 <= prices[i] <= 10^4",
        "n = len(prices), 0 <= n <= 10^5"
      ],
      "Core Constraint": [
        "只能进行一次买入和一次卖出（且买入在卖出之前）",
        "交易顺序具有时间单向性：i < j",
        "利润由后一时刻价格与前一时刻最低价格决定",
        "局部最优依赖于历史最小值的维护"
      ],
      "Objective Function": [
        "最大化利润：max(prices[j] - prices[i])，其中 i < j",
        "若无法获利，返回 0",
        "目标类型：数值最大化（单一全局最大值）"
      ],
      "Algorithmic Invariant": [
        "遍历过程中维护已访问子数组中的最小价格 min_price",
        "当前利润为 prices[i] - min_price，全局最大利润 non_profit = max(non_profit, prices[i] - min_price)",
        "指针单向推进（从左到右），状态更新具有单调不可逆性",
        "历史最小值的更新不破坏未来最优解的可达性"
      ],
      "Transformable Parameters": [
        "数据规模：n 的数量级（如 1e3 / 1e5 / 1e7）",
        "是否允许多次交易（最多 k 次 / 无限次）",
        "是否加入手续费 / 冷却期",
        "输入形式：是否在线流式输入价格",
        "是否多组测试数据",
        "价格是否可为负值（如带借贷场景）",
        "是否要求输出买卖日期而非仅利润值",
        "是否环形时间序列（允许跨周期交易）"
      ]
    }
  },
  {
    "title": "破冰游戏",
    "slug": "yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof",
    "schema": {
      "Input Structure": [
        "整数 num，表示初始成员数量（编号从 0 到 num-1）",
        "整数 target，表示每次计数到第 target 位的成员出局",
        "成员围成环形排列，顺序为 0 → 1 → ... → num-1 → 0"
      ],
      "Core Constraint": [
        "每轮从当前起始位置开始顺时针计数，第 target 名成员被淘汰",
        "淘汰后下一轮从其下一位重新开始计数",
        "结构具有动态缩减与循环移位特性",
        "问题本质是约瑟夫环问题：存在递推关系 f(n, t) = (f(n-1, t) + t) % n"
      ],
      "Objective Function": "求最后剩下的唯一成员的编号（构造性判定问题）",
      "Algorithmic Invariant": [
        "状态可递推：n 个人的幸存者位置由 n-1 个人的结果决定",
        "每轮删除操作后，剩余序列可通过模运算重新映射为连续编号",
        "递推过程中保持相对偏移一致性：新增首段长度为 t % current_size 的虚拟前缀不影响后续模运算正确性"
      ],
      "Transformable Parameters": [
        "num 的数量级：可变范围 [1, 10^5] 或扩展至 10^9（影响是否可用模拟或需数学递推）",
        "target 是否为常数或随轮次变化（如递增、随机）",
        "是否多组查询（多个 num 和 target 组合）",
        "是否在线输入（动态增加成员或修改 target）",
        "环形方向：顺时针 vs 逆时针计数",
        "起始编号是否非零或初始位置偏移",
        "是否要求输出整个淘汰序列而非仅最终幸存者",
        "是否允许多个幸存者（终止条件改为剩下 k 人）"
      ]
    }
  },
  {
    "title": "判断是否为平衡二叉树",
    "slug": "ping-heng-er-cha-shu-lcof",
    "schema": {
      "Input Structure": "二叉树的根节点 root；树中节点数满足 0 <= n <= 10000；每个节点具有左子树和右子树指针，无显式父指针；节点值类型不影响结构判断",
      "Core Constraint": "平衡二叉树的定义约束：对任意节点，其左右子树深度之差的绝对值不超过 1；该约束具有递归结构性——整棵树平衡当且仅当左右子树均平衡且深度差 ≤1",
      "Objective Function": "判定整棵树是否为平衡二叉树（布尔值输出：true / false）",
      "Algorithmic Invariant": "在后序遍历过程中，每访问一个节点时，其左右子树的深度与平衡性已确定；可通过返回子树深度或特殊标记（如 -1）来同时传递深度信息与不平衡状态，避免重复计算；状态转移满足：当前节点平衡 ⇔ 左右子树平衡 ∧ |leftDepth - rightDepth| <= 1",
      "Transformable Parameters": [
        "树的节点数量级（当前为 1e4，可扩展至动态/在线建树场景）",
        "是否要求构造最接近的平衡二叉树（目标函数变为构造）",
        "深度差阈值 k 是否可变（当前为 1，可推广为 ≤k）",
        "输入形式是否支持序列化字符串输入（如层序数组）",
        "是否多组测试数据批量判定",
        "是否要求统计不平衡节点个数（目标函数变为计数）",
        "是否允许删除/插入操作下的动态平衡维护（转为 AVL 维护问题）"
      ]
    }
  },
  {
    "title": "文物朝代判断",
    "slug": "bu-ke-pai-zhong-de-shun-zi-lcof",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "length": 5,
        "element_type": "integer",
        "value_range": [
          0,
          13
        ],
        "special_value": {
          "0": "unknown dynasty (wildcard)"
        }
      },
      "Core Constraint": {
        "distinct_nonzero_elements": "must form a subset of consecutive integers when sorted",
        "wildcard_usage": "zeros can be used to fill gaps in the sequence",
        "uniqueness_constraint": "non-zero elements must be distinct (except zeros)",
        "sequence_length": 5
      },
      "Objective Function": "determine whether the non-zero elements, combined with any number of wildcards (0s), can form a continuous sequence of 5 consecutive integers",
      "Algorithmic Invariant": {
        "sorted_order_maintained": true,
        "gap_filling_with_wildcards": "number of zeros available >= number of missing values in the gap between min and max of non-zero elements",
        "bounded_sequence_length": "if non-zero elements span more than 5 numbers, impossible to fit in 5-length consecutive sequence",
        "min_max_span_condition": "max(non_zero) - min(non_zero) <= 4 when non-zero elements exist, otherwise trivially true"
      },
      "Transformable Parameters": {
        "array_length": 5,
        "is_fixed_length": true,
        "has_wildcard": true,
        "wildcard_value": 0,
        "number_of_wildcards_allowed": "variable (depends on input)",
        "value_domain": [
          0,
          13
        ],
        "requires_consecutive_sequence_length": 5,
        "allow_repetition": false,
        "input_sorted": false,
        "multiple_test_cases": false,
        "online_query": false
      }
    }
  },
  {
    "title": "把字符串转换成整数 (atoi)",
    "slug": "ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof",
    "schema": {
      "Input Structure": [
        "字符串 s[1..n]",
        "字符集：英文字母（大小写）、数字 '0'-'9'、空格 ' '、正负号 '+' '-'、小数点 '.'",
        "n ∈ [0, 200]"
      ],
      "Core Constraint": [
        "解析过程具有严格顺序性：前导空格 → 符号位 → 连续数字序列 → 截断于首个非数字字符",
        "仅允许一个符号位，且必须出现在数字前；多个符号或位置错误视为非法",
        "数字部分只接受连续的 0-9 字符，遇到其他字符立即终止读取",
        "结果必须限制在 32 位有符号整数范围 [−2^31, 2^31 − 1]"
      ],
      "Objective Function": "将合法前缀子串转换为一个 32 位有符号整数，并根据溢出情况截断至边界值",
      "Algorithmic Invariant": [
        "状态机推进不变性：当前处理阶段（空格/符号/数字）唯一确定下一步行为",
        "一旦进入数字读取阶段，后续字符若非数字则立即终止，不再回溯",
        "数值构建过程中可实时检测溢出，利用整数边界提前截断而不影响正确性",
        "符号位与数值部分分离处理，保证符号应用的唯一性和正确性"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的范围可调整（如扩展到 1e5 支持大数截断）",
        "值域约束": [
          "是否强制 32 位截断（可改为 64 位或不限）",
          "是否支持小数（如 '.' 后解析浮点）"
        ],
        "输入形式": [
          "是否允许多组测试数据",
          "是否在线流式输入（逐字符输入）"
        ],
        "空白字符定义": "是否扩展为空白字符集合（\\t, \\n 等）",
        "前导结构变化": [
          "是否允许符号和数字之间有空格",
          "是否支持科学计数法（如 '1e10'）"
        ],
        "错误处理策略": "返回 0 / 抛异常 / 返回布尔标记成功与否"
      }
    }
  },
  {
    "title": "统计结果概率",
    "slug": "nge-tou-zi-de-dian-shu-lcof",
    "schema": {
      "Input Structure": [
        "整数 num，表示骰子的个数",
        "每个骰子有 6 个面，点数为 1 到 6",
        "1 <= num <= 11"
      ],
      "Core Constraint": [
        "每个骰子独立掷出，点数等概率（1/6）",
        "总点数范围为 [num, 6 * num]",
        "不同路径可能得到相同点数和，需统计路径数",
        "问题具有重叠子问题结构：f(n, s) 表示 n 个骰子掷出和为 s 的方案数"
      ],
      "Objective Function": [
        "计算所有可能点数和的概率分布",
        "按点数从小到大顺序输出每个点数对应的概率",
        "目标函数类型：计数 → 归一化为概率"
      ],
      "Algorithmic Invariant": [
        "动态规划状态转移不变量：dp[i][s] = sum(dp[i-1][s-k]) for k in 1..6",
        "前 i 层 dp 值仅依赖于第 i-1 层，可滚动数组优化",
        "点数和的分布关于均值对称，可用于校验或优化（隐式不变量）"
      ],
      "Transformable Parameters": {
        "num 的数量级": "1 <= num <= 11（当前），可扩展至更大值（需高精度）",
        "骰子面数": "可变参数：如改为 8 面、12 面骰子",
        "骰子点数范围": "可变：如 0~5 或 2~7，影响最小/最大和",
        "是否要求模意义下的计数": "变形题中可改为求方案数 mod 1e9+7",
        "输出形式": [
          "输出全部概率数组（当前）",
          "只输出某个区间内的概率",
          "输出最大概率值或众数",
          "输出达到某概率阈值的所有点数"
        ],
        "是否多组输入": "可支持多个 num 查询，预处理打表加速",
        "是否在线": "可设计为在线查询系统，逐步返回结果"
      }
    }
  },
  {
    "title": "按规则计算统计结果",
    "slug": "gou-jian-cheng-ji-shu-zu-lcof",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "integers",
        "constraints": [
          "arrayA.length <= 100000",
          "all elements are non-zero integers (implied by product operation)",
          "product of all elements does not overflow 32-bit integer"
        ]
      },
      "Core Constraint": {
        "description": "Each output element depends on the global product of all input elements except the current one",
        "key_property": "multiplicative separability: B[i] = (total_product) / A[i]",
        "dependency": "each position's result is determined by total product and local value, assuming no zero values"
      },
      "Objective Function": {
        "type": "construction",
        "goal": "construct arrayB where arrayB[i] equals the product of all elements in arrayA except arrayA[i]"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "prefix product P[i] = A[0] * A[1] * ... * A[i-1] accumulates left-side contributions safely",
          "suffix product S[i] = A[i+1] * A[i+2] * ... * A[n-1] accumulates right-side contributions safely",
          "result[i] = prefix[i] * suffix[i], computed without division and avoids recomputation"
        ],
        "optimality_condition": "two-pass traversal (left-to-right and right-to-left) ensures O(1) auxiliary space per element and O(n) time",
        "zero_handling": "if zeros exist (not in this problem), logic must change; invariant assumes at most one zero implicitly avoided here"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n",
            "range": "1 <= n <= 10^5",
            "change_effect": "allows linear algorithms, rules out O(n^2)"
          },
          {
            "name": "value_range",
            "range": "integers, non-zero, product fits in 32-bit signed integer",
            "change_effect": "enables direct multiplication without big integer support"
          },
          {
            "name": "zero_allowed",
            "values": [
              false
            ],
            "possible_variation": true,
            "note": "allowing zero introduces special case: multiple zeros → all results zero; one zero → only that index has non-zero result"
          },
          {
            "name": "input_form",
            "type": "offline batch array",
            "possible_transformations": [
              "online streaming input (requires different memory model)",
              "dynamic updates (turns into segment tree / Fenwick tree problem)"
            ]
          },
          {
            "name": "output_requirement",
            "current": "full arrayB construction",
            "alternatives": [
              "query single index i (can be answered in O(1) with precomputed prefix/suffix)",
              "return modulo M (common in counting problems)"
            ]
          },
          {
            "name": "data_dimension",
            "current": "1D array",
            "extension": "2D grid: exclude row and column → analogous to 'product except self' in matrix form"
          }
        ]
      }
    }
  },
  {
    "title": "设计自助结算系统",
    "slug": "dui-lie-de-zui-da-zhi-lcof",
    "schema": {
      "Input Structure": [
        "一个支持动态插入和删除的队列 Q",
        "每个元素为整数 value，表示商品价格",
        "操作序列由三类函数构成：add(value), remove(), get_max()",
        "value ∈ [1, 10^5]",
        "总操作数 ≤ 10000"
      ],
      "Core Constraint": [
        "队列具有先进先出（FIFO）顺序",
        "最大值查询不能破坏队列原有结构",
        "需在不遍历全队列的前提下维护当前最大值信息",
        "均摊时间复杂度要求 O(1) 对所有操作"
      ],
      "Objective Function": [
        "设计数据结构以支持：",
        "- 在 O(1) 均摊时间内插入元素到队尾（add）",
        "- 在 O(1) 时间内移除队首元素（remove）",
        "- 在 O(1) 时间内获取当前队列中的最大值（get_max）",
        "若队列为空，get_max 和 remove 返回 -1"
      ],
      "Algorithmic Invariant": [
        "使用辅助双端队列（deque）维护可能成为未来最大值的候选元素",
        "辅助队列单调非增（monotonic decreasing）",
        "当新元素入队时，从辅助队列尾部弹出所有小于该元素的值，保证单调性",
        "当队首被移除时，若其等于主队列队首且等于辅助队列队首，则同步弹出辅助队列队首",
        "辅助队列队首始终是当前主队列的最大值",
        "主队列用于维护实际顺序，辅助队列用于维护最大值不变量"
      ],
      "Transformable Parameters": {
        "n 的数量级": "总操作数最多 1e4",
        "值域范围": "value ∈ [1, 1e5]",
        "是否有序": false,
        "是否循环": false,
        "是否多组输入": true,
        "是否在线": true,
        "目标函数可变形式": [
          "get_max → get_min",
          "get_max → get_median（提升难度）",
          "add/remove → 支持中间插入或删除（如双端队列）",
          "扩展为支持区间最大值查询（滑动窗口）"
        ],
        "数据流形式": "操作按时间顺序在线执行",
        "约束变化": [
          "允许负数价格（影响单调队列初始化）",
          "要求返回最大值索引而非数值",
          "加入 update 操作（修改某位置价格）"
        ]
      }
    }
  },
  {
    "title": "望远镜中最高的海拔",
    "slug": "hua-dong-chuang-kou-de-zui-da-zhi-lcof",
    "schema": {
      "Input Structure": "一维数组 heights[1..n]，其中 heights[i] ∈ ℤ（整数），表示每个位置的海拔高度；给定滑动窗口大小 limit，满足 1 <= limit <= n",
      "Core Constraint": "最大值仅由当前窗口内的元素决定；窗口滑动时，旧元素离开、新元素进入，需动态维护当前窗口中的最大值；由于窗口连续移动，存在前后状态重叠，可利用单调性优化更新过程",
      "Objective Function": "对每一个滑动窗口位置，输出其内部的最大值，构造长度为 (n - limit + 1) 的结果数组",
      "Algorithmic Invariant": "使用单调队列（双端队列）维护可能成为最大值的候选下标序列，保证队列头部始终为当前窗口最大值的下标；遍历过程中：(1) 移除超出窗口范围的旧下标；(2) 从队尾移除小于当前元素的候选（因其不可能再成为后续最大值）；(3) 当前元素下标入队；(4) 队首即为当前窗口最大值下标，取值加入结果",
      "Transformable Parameters": {
        "数据规模 n": "1 <= n <= 10^5（可调整至更高并要求在线处理）",
        "窗口大小 limit": "1 <= limit <= n（可变为可变窗口或多个固定窗口）",
        "heights 值域": "-10000 <= heights[i] <= 10000（可扩展为浮点数或更大范围）",
        "是否有序": "原数组无序（可设计为部分有序以测试边界情况）",
        "是否循环数组": "否（可变形为环形数组，即末尾与开头相连）",
        "是否多组输入": "单组输入（可改为多组测试用例）",
        "是否在线": "离线一次性输入（可改为流式数据，要求实时返回每步最大值）",
        "目标函数变化": "求最大值 → 求最小值 / 求中位数 / 求和 / 计数；本题为‘最大值’",
        "输出形式": "返回所有窗口的最大值列表（可改为仅返回全局最大值出现次数等）"
      }
    }
  },
  {
    "title": "加密运算",
    "slug": "bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof",
    "schema": {
      "Input Structure": [
        "两个整数 dataA 和 dataB",
        "dataA, dataB ∈ [-2^31, 2^31 - 1]",
        "表示两次通信的数据量（正数为发送，负数为接收，0为遗失）"
      ],
      "Core Constraint": [
        "不允许使用加法、减法、乘法、除法运算符",
        "必须通过位运算或其他低级操作模拟整数加法",
        "需正确处理符号数的二进制补码表示",
        "结果保证在32位有符号整数范围内"
      ],
      "Objective Function": "计算 dataA 与 dataB 的代数和（即：dataA + dataB）并返回",
      "Algorithmic Invariant": [
        "使用位运算模拟加法过程：异或（^）表示无进位加法，与运算（&）配合左移表示进位",
        "每次迭代将无进位和与进位相加，直到进位为0",
        "循环不变量：每轮结束后，(a ^ b) + ((a & b) << 1) 等价于原始 a + b",
        "支持负数运算，依赖补码特性保证符号位正确传播"
      ],
      "Transformable Parameters": [
        "数据范围：是否扩展到64位整数",
        "是否允许多个数连续求和（从两数到多数）",
        "是否要求不使用任何算术运算符的子集（如仅禁用 '+'，但可使用 '-'）",
        "是否在线输入（流式多个数据对）",
        "是否需要模意义下的和（如 mod 2^32）",
        "是否要求构造无循环/递归的解法（纯位并行）"
      ]
    }
  },
  {
    "title": "丑数",
    "slug": "chou-shu-lcof",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "name": "n",
        "range": "1 <= n <= 1690",
        "description": "表示要求的第 n 个丑数的位置"
      },
      "Core Constraint": {
        "constraint": "丑数仅包含质因数 2、3 和 5，且序列严格递增；每个后续丑数必为已有丑数乘以 2、3 或 5 得到",
        "key_insight": "新丑数只能由已生成的丑数 × {2,3,5} 产生，因此可通过维护三个指针追踪下一个候选值"
      },
      "Objective Function": {
        "goal": "返回第 n 个丑数",
        "function_type": "构造第 n 项"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护三个指针 p2, p3, p5，分别指向下一个可乘以 2、3、5 的丑数位置",
          "每次选择 min(dp[p2]*2, dp[p3]*3, dp[p5]*5) 作为下一个丑数",
          "所有已生成的丑数构成单调递增序列 dp[1..n]",
          "避免重复：若多个乘积相等，则对应指针同步前移"
        ],
        "optimality_preservation": "每次扩展均保证最小未被加入的丑数被选中，保持贪心最优性"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "parameter": "质因数集合",
            "example_values": [
              "[2,3,5]",
              "[2,7]",
              "[2,3,5,7]"
            ],
            "description": "可推广至任意给定质因数集合"
          },
          {
            "parameter": "数据规模 n",
            "example_values": [
              "n <= 1690",
              "n <= 1e5",
              "n <= 1e6"
            ],
            "description": "影响是否可用动态规划或预处理打表"
          },
          {
            "parameter": "输入形式",
            "example_values": [
              "单组查询",
              "多组查询",
              "在线查询"
            ],
            "description": "多组时可预处理全部结果"
          },
          {
            "parameter": "输出目标",
            "example_values": [
              "第 n 个丑数",
              "前 n 个丑数列表",
              "≤ N 的最大丑数"
            ],
            "description": "目标函数变换"
          },
          {
            "parameter": "数值限制",
            "example_values": [
              "无溢出限制",
              "模意义下输出",
              "判断是否为第 n 个"
            ],
            "description": "影响实现细节"
          }
        ]
      }
    }
  },
  {
    "title": "寻找二叉搜索树中的目标节点",
    "slug": "er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof",
    "schema": {
      "Input Structure": "二叉搜索树（BST）root，节点值为整数；树的结构隐式给出，满足 BST 性质：对任意节点，左子树所有节点值 < 当前节点值 < 右子树所有节点值；1 ≤ 节点个数 ≤ 10^4",
      "Core Constraint": "二叉搜索树的中序遍历具有严格单调递增性；第 cnt 大的节点对应于反向中序遍历（右-根-左）的第 cnt 个访问节点",
      "Objective Function": "返回 BST 中第 cnt 大的节点值",
      "Algorithmic Invariant": "在反向中序遍历过程中维护一个计数器，每访问一个节点计数器加一；当计数器等于 cnt 时，当前节点即为目标节点；利用 BST 的结构性质避免全遍历，可在找到目标后提前终止",
      "Transformable Parameters": [
        "cnt 的取值范围：是否保证 1 ≤ cnt ≤ 节点总数",
        "是否允许重复节点值（破坏 BST 标准定义）",
        "输入形式：树的数组表示（如层序遍历）或指针结构",
        "是否多组查询（例如多次求不同 cnt 的结果，可预处理中序序列）",
        "是否在线：动态插入/删除节点后查询第 cnt 大",
        "数据规模：节点数量级（影响是否可用 O(n) 空间存储遍历序列）",
        "目标函数变化：第 cnt 小、中位数、前 k 大之和等"
      ]
    }
  },
  {
    "title": "招式拆解 I",
    "slug": "zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof",
    "schema": {
      "Input Structure": [
        "字符串 arr，长度为 n（0 <= n <= 40000）",
        "字符集：英文字母（大小写）、数字、符号、空格",
        "输入为一维字符序列"
      ],
      "Core Constraint": [
        "子串必须连续",
        "子串中任意字符不能重复",
        "局部唯一性约束：窗口内每个字符的频次 ≤ 1",
        "扩展时若引入重复字符，则必须收缩左边界以恢复约束"
      ],
      "Objective Function": "求满足无重复字符条件的最长连续子串的长度（最大化）",
      "Algorithmic Invariant": [
        "使用滑动窗口维护当前无重复字符的子串",
        "右指针每前进一步，将新字符加入窗口",
        "左指针仅在出现重复字符时右移，直到窗口重新满足无重复约束",
        "窗口内字符频次哈希表可 O(1) 更新与查询",
        "移动过程中，窗口始终维持‘无重复字符’这一不变量"
      ],
      "Transformable Parameters": {
        "n 的数量级": "0 ~ 40000（可调整至 1e5 或更高以要求更优解法）",
        "字符集类型": [
          "ASCII（当前）",
          "扩展为 Unicode",
          "限制为小写字母 a-z（可降维为布尔数组优化）"
        ],
        "是否区分大小写": [
          "是（当前）",
          "否（可变形为不区分大小写）"
        ],
        "输入形式": [
          "单个字符串（当前）",
          "多组字符串（多测用例）",
          "流式输入（在线字符流，要求实时返回当前最长无重复子串长度）"
        ],
        "输出目标": [
          "最长长度（当前）",
          "所有最长子串的集合（构造方案）",
          "最短无重复子串（目标反转）",
          "恰好包含 k 个不同字符的最长子串（约束参数化）"
        ],
        "重复定义": [
          "字符频次 > 1 即为重复（当前）",
          "自定义重复规则（如：连续两个相同字符才视为重复）"
        ],
        "数据动态性": [
          "静态输入（当前）",
          "支持添加/删除字符的动态字符串（需设计数据结构维护）"
        ]
      }
    }
  },
  {
    "title": "点名",
    "slug": "que-shi-de-shu-zi-lcof",
    "schema": {
      "Input Structure": [
        "一维数组 records[1..n], 其中 n = length(records)",
        "records 严格递增（升序排列）",
        "元素类型为整数，取值范围为 [0, n]",
        "实际学生总数为 n + 1（即学号从 0 到 n），但 records 长度为 n",
        "records 中恰好缺失一个学号"
      ],
      "Core Constraint": [
        "学号序列本应是连续的 0 ~ n 的排列，现缺一位",
        "数组有序 → 缺失位置可通过下标与值的映射关系定位",
        "若 records[i] == i，则前 i+1 个数均未缺失；否则在位置 i 出现偏移",
        "第一个满足 records[i] > i 的位置 i 即为缺失值"
      ],
      "Objective Function": [
        "返回唯一缺失的学号（构造类目标：构造出那个不在数组中的整数）"
      ],
      "Algorithmic Invariant": [
        "二分查找过程中，维护区间 [l, r] 满足：",
        "  - 若 records[mid] == mid，则左半部分完整，缺失在右半",
        "  - 若 records[mid] > mid，则缺失发生在左半（含 mid）",
        "指针移动不破坏上述性质，最终 l == r 时收敛到首个偏移点",
        "也可用数学不变量：总和差 = (0+1+...+n) - sum(records)"
      ],
      "Transformable Parameters": [
        "数据规模：n 的数量级（当前 ≤ 1e4，可扩展至 1e5 或支持离线批量查询）",
        "是否保证恰好缺一个（→ 可变为计数类：缺多少个 / 找所有缺失）",
        "是否允许重复元素（破坏有序性假设）",
        "输入是否仍保持有序（→ 若无序则需排序或哈希）",
        "是否多组测试数据",
        "是否在线流式输入（需要动态维护缺失值）",
        "值域是否扩展为 [a, b] 而非 [0, n]",
        "是否存在多个缺失（改变问题结构，进入中间层母题范畴）"
      ]
    }
  },
  {
    "title": "动态口令",
    "slug": "zuo-xuan-zhuan-zi-fu-chuan-lcof",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "给定一个长度为 n 的字符串 password",
        "constraints": [
          "1 <= target < password.length <= 10000",
          "password 由可打印 ASCII 字符组成"
        ]
      },
      "Core Constraint": {
        "description": "字符串的前 target 个字符被整体移动到末尾，其余字符按原顺序前移，形成循环左移结构",
        "key_property": "操作等价于将字符串在位置 target 处切分为两段，并交换前后段顺序"
      },
      "Objective Function": {
        "type": "construction",
        "description": "构造并返回执行密码更新操作后的字符串"
      },
      "Algorithmic Invariant": {
        "invariant": "字符串拼接的结合性不变：S[0:target] + S[target:] 经变换后为 S[target:] + S[0:target]，可通过切片或双指针模拟保持线性时间复杂度",
        "optimality_condition": "无需比较或选择，每字符位置唯一确定，具有确定性映射关系"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_structure",
            "options": [
              "string",
              "character_array",
              "circular_buffer"
            ],
            "description": "输入形式是否为可变字符数组或支持旋转的数据结构"
          },
          {
            "name": "operation_type",
            "options": [
              "left_rotation",
              "right_rotation",
              "multiple_rotations"
            ],
            "description": "变换方向：左移 → 右移；或多次连续旋转"
          },
          {
            "name": "target_domain",
            "options": [
              "positive_integer",
              "modulo_length",
              "negative_shift_interpretation"
            ],
            "description": "target 是否可大于 length 或支持负数表示右移"
          },
          {
            "name": "input_size",
            "range": "n <= 10000 (当前), 扩展至 n <= 1e6 或更大",
            "description": "数据规模变化影响是否允许 O(n) 以上解法"
          },
          {
            "name": "query_mode",
            "options": [
              "single_query",
              "multiple_queries",
              "online_updates"
            ],
            "description": "是否多组 target 查询，或动态修改 password"
          },
          {
            "name": "output_requirement",
            "options": [
              "final_string",
              "each_step_result",
              "rotation_sequence"
            ],
            "description": "是否输出中间状态或仅最终结果"
          }
        ]
      }
    }
  },
  {
    "title": "统计目标成绩的出现次数",
    "slug": "zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof",
    "schema": {
      "Input Structure": "一维数组 scores[1..n]，其中 n >= 0；scores 为非递减（非严格递增）整数数组；元素值域：[-10^9, 10^9]；target 为整数，值域 [-10^9, 10^9]",
      "Core Constraint": "由于数组有序，相同值的元素在数组中连续分布；目标值 target 的出现区间可通过二分查找左右边界唯一确定",
      "Objective Function": "统计目标值 target 在数组中的出现次数（即频次计数）",
      "Algorithmic Invariant": "利用数组的单调性，通过两次二分查找分别确定 target 的左边界（第一个 >= target 的位置）和右边界（第一个 > target 的位置），两边界之差即为出现次数；二分过程中维护搜索区间 [l, r]，每次迭代缩小范围且不丢失解",
      "Transformable Parameters": [
        "n 的数量级：可从 10^5 扩展至 10^6（影响是否需考虑常数优化）",
        "数组是否允许重复：已隐含允许，但可改为‘无重复’作为变形",
        "数组是否严格递增：可切换为非严格或严格，影响边界判定逻辑",
        "target 是否一定存在：可变为‘保证存在’或‘可能不存在’",
        "是否多组查询：可扩展为多个 target 的批量查询（如离线处理或构建哈希表）",
        "数据流化：可改为在线查询模式，数组动态增加元素",
        "输出形式变化：可改为返回首次和末次出现位置（对应 LeetCode 34 题）",
        "输入结构变化：可推广到二维有序矩阵中的元素计数"
      ]
    }
  },
  {
    "title": "字符串中的单词反转",
    "slug": "fan-zhuan-dan-ci-shun-xu-lcof",
    "schema": {
      "Input Structure": [
        "字符串 message，长度 n ∈ [0, 1e4]",
        "字符集：英文字母、数字、空格",
        "可能包含前导空格、尾随空格、单词间多个空格"
      ],
      "Core Constraint": [
        "单词内容正确但整体顺序颠倒",
        "单词由连续非空格字符构成",
        "空格作为分隔符，但不规则分布（多空格、边界空格）",
        "输出需规范化：单词间仅保留一个空格，无前导/尾随空格"
      ],
      "Objective Function": "反转单词序列顺序，并返回规范化后的字符串",
      "Algorithmic Invariant": [
        "从右往左扫描时，每识别出一个完整单词，其在结果中的相对位置即确定",
        "已处理的单词子序列始终保持正确的逆序结构",
        "跳过多余空格不影响最终词序的唯一性",
        "双端处理：可先去除冗余空格再反转，或直接逆序提取有效单词"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e4（可变至 1e5 或支持流式输入）",
        "是否有序": "输入字符顺序固定，但单词序列需逆序",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "空格处理规则": [
          "严格单空格分隔（当前设定）",
          "可扩展为指定分隔符（如逗号、制表符）",
          "允许自定义空白字符集合"
        ],
        "单词定义": [
          "连续非空格字符（当前）",
          "可替换为正则模式（如仅字母、含标点等）"
        ],
        "输入形式": [
          "字符串（当前）",
          "可变为字符数组、流式输入、分块输入"
        ],
        "输出要求": [
          "仅返回字符串（当前）",
          "可要求返回单词列表、位置映射等辅助信息"
        ]
      }
    }
  },
  {
    "title": "珠宝的最高价值",
    "slug": "li-wu-de-zui-da-jie-zhi-lcof",
    "schema": {
      "Input Structure": [
        "二维矩阵 frame[1..m][1..n]",
        "frame[i][j] > 0（珠宝价值为正整数）",
        "m, n ≥ 1",
        "起点为左上角 (1,1)，终点为右下角 (m,n)",
        "每次只能向右或向下移动"
      ],
      "Core Constraint": [
        "路径必须从 (1,1) 出发，到 (m,n) 结束",
        "每一步只能向右或向下移动，形成单调行进路径",
        "路径上的总价值由经过的所有位置的值累加而成",
        "最优路径的选择依赖于子问题的最优性（重叠子问题 + 最优子结构）"
      ],
      "Objective Function": "最大化路径上珠宝价值的总和",
      "Algorithmic Invariant": [
        "动态规划状态定义：dp[i][j] 表示从 (1,1) 到 (i,j) 的最大路径和",
        "状态转移方程：dp[i][j] = frame[i][j] + max(dp[i-1][j], dp[i][j-1])",
        "边界条件：dp[1][1] = frame[1][1]，第一行和第一列只能单向到达",
        "每个状态仅依赖其上方和左侧的状态，满足无后效性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": "≤ 200（当前），可扩展至 ≤ 10^3 或更高以区分解法复杂度",
          "是否允许稀疏矩阵优化": false
        },
        "值域特性": [
          "frame[i][j] 是否可为负数（影响贪心可行性）",
          "frame[i][j] 是否有上限（如模意义下计算）"
        ],
        "移动规则变化": [
          "允许更多方向（如左、上）→ 需图论建模",
          "加入障碍格子（某些位置不可通过）",
          "加入传送点或特殊跳跃规则"
        ],
        "起点终点变化": [
          "多起点或多终点",
          "任意起点到任意终点的最大路径和"
        ],
        "目标函数变化": [
          "最小化路径和",
          "计数达到最大/最小路径的数量",
          "判断是否存在路径和等于某特定值"
        ],
        "输入形式": [
          "是否离线批量处理多个 frame",
          "是否在线流式输入行或列"
        ],
        "附加约束": [
          "路径长度必须为偶数",
          "不能连续两次向同一方向移动",
          "最多拐弯 k 次"
        ]
      }
    }
  },
  {
    "title": "训练计划 V",
    "slug": "liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof",
    "schema": {
      "Input Structure": {
        "type": "linked_list_pair",
        "description": "两个单向链表 l1 和 l2，节点值为整数，表示训练项目编号",
        "constraints": [
          "链表无环",
          "节点数 m, n ≥ 0",
          "节点值为非负整数",
          "链表结构在运行时保持不变"
        ]
      },
      "Core Constraint": {
        "description": "两个链表在某个节点之后完全共享同一段后缀（即从第一个相交节点开始到末尾所有节点相同）",
        "properties": [
          "相交后部分完全重合，不能分叉",
          "相交性由内存地址决定，而非仅值相等",
          "前半部分独立，后半部分共享"
        ]
      },
      "Objective Function": {
        "type": "find_first_common_node",
        "goal": "返回两个链表的第一个公共节点（正式训练起始点）",
        "output_behavior": "若不存在相交节点，返回 null"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "双指针遍历路径长度相同：p1 遍历 l1 + l2，p2 遍历 l2 + l1",
          "当 p1 == p2 时，该节点即为首个相交节点或同时到达 null（无交点）",
          "指针移动过程中不修改链表结构，满足 O(1) 空间约束",
          "相对位移差可通过拼接路径自动对齐"
        ],
        "proof_basis": "若存在交点，则从交点到末尾的路径一致；通过构造等长路径，两个指针将在第二轮同步到达交点"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "链表是否有环",
            "variation": "无环 → 有环（需额外判断）"
          },
          {
            "name": "输入形式",
            "variation": "静态头指针 → 在线流式节点输入"
          },
          {
            "name": "相交结构",
            "variation": "单一交点 → 多个交点 / 循环共享段"
          },
          {
            "name": "数据规模",
            "variation": "n ≤ 1e5 → 更大规模需考虑缓存友好性"
          },
          {
            "name": "是否允许多次查询",
            "variation": "单次匹配 → 多组链表对批量判断"
          },
          {
            "name": "输出要求",
            "variation": "返回节点引用 → 返回索引位置 / 构造新链表表示公共部分"
          },
          {
            "name": "空间限制",
            "variation": "O(1) 内存 → 允许哈希集合（O(n) 辅助空间）"
          }
        ]
      }
    }
  },
  {
    "title": "解密数字",
    "slug": "ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof",
    "schema": {
      "Input Structure": [
        "一个非负整数 ciphertext（表示为数字序列，长度 n ≤ 10）",
        "数字序列中的每一位是 0-9 的整数",
        "数值范围：0 <= ciphertext < 2^31，即最多 10 位十进制数字"
      ],
      "Core Constraint": [
        "每个数字或连续两位数字可映射为字母 a-z（0->a, 1->b, ..., 25->z）",
        "单个数字总是合法（0-9 → a-j）",
        "两位数字组合仅当值在 [10,25] 范围内时才可解密为一个字母（k-z）",
        "解密必须覆盖整个数字序列，无遗漏、无重叠"
      ],
      "Objective Function": "计数所有可能的解密方案数量（字符串形式不同即视为不同方案）",
      "Algorithmic Invariant": [
        "动态规划状态 dp[i] 表示前 i 位数字的解密方案数",
        "状态转移：dp[i] = dp[i-1] + (如果第 i-2 和 i-1 位构成 [10,25] 则加 dp[i-2])",
        "每一步决策只依赖前两个位置的结果，具有最优子结构和无后效性",
        "从左到右递推过程中，已计算的位置方案数不再改变"
      ],
      "Transformable Parameters": [
        "输入形式：整数输入 vs 字符串数组输入",
        "是否允许前导零（本题隐含允许，但不能单独以 '0' 开头组两位）",
        "映射范围变化：如改为 0-33 对应 a-z0-7 等（扩展字符集）",
        "目标函数变换：求是否存在至少一种解法 / 求字典序最小解 / 输出所有解",
        "加入非法字符（如负号、非数字）",
        "数据规模：ciphertext 长度是否可达 1e5（此时需滚动数组优化）",
        "是否多组测试数据",
        "是否在线流式输入数字位（逐位输入，要求实时更新答案）"
      ]
    }
  },
  {
    "title": "文件组合",
    "slug": "he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "description": "一个正整数 target（1 <= target <= 10^5）",
        "constraints": [
          "target ≥ 1",
          "target ≤ 100000"
        ]
      },
      "Core Constraint": {
        "description": "连续正整数序列的和等于给定目标值 target。序列长度至少为 2，且所有元素严格递增、连续。",
        "key_insight": "对于起始数 a 和长度 k 的连续序列，其和为 S = k * a + k*(k-1)/2 = target。因此 a = (target - k*(k-1)/2) / k 必须是正整数。"
      },
      "Objective Function": {
        "type": "enumeration",
        "goal": "找出所有满足条件的连续正整数序列（每个序列长度 ≥ 2），使得其元素之和等于 target",
        "output_ordering": [
          "每个序列按升序排列（自然满足）",
          "不同序列按首个元素从小到大排序"
        ]
      },
      "Algorithmic Invariant": {
        "invariant": "通过枚举序列长度 k 或双指针滑动窗口维护当前连续段的和，确保每次扩展或收缩都保持对候选解空间的完全覆盖",
        "method_specific_invariants": [
          "若使用数学法：随着 k 增大，起始值 a 单调递减；当 a < 1 时可提前终止",
          "若使用双指针：左指针 l 表示当前序列起点，右指针 r 动态扩展，维护 sum ∈ [target] 的状态；sum < target 则 r++，sum > target 则 l++；l < r 且 l ≥ 1"
        ],
        "optimality_guarantee": "所有可能的连续段都被唯一遍历一次，无遗漏也无重复"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "target_range",
            "description": "target 的数量级",
            "default": "1 <= target <= 10^5",
            "possible_variations": [
              "1 <= target <= 10^9（需切换至数学方法）",
              "在线查询多个 target"
            ]
          },
          {
            "name": "sequence_length_constraint",
            "description": "是否强制长度 ≥ 2",
            "possible_values": [
              "允许单元素序列",
              "限定长度在 [L,R] 范围内"
            ]
          },
          {
            "name": "number_domain",
            "description": "序列中数字的类型",
            "possible_variations": [
              "仅正整数（原题）",
              "允许整数（含负数）",
              "非负整数"
            ]
          },
          {
            "name": "input_structure",
            "description": "输入形式变化",
            "possible_variations": [
              "多组 target 输入",
              "离线批量处理",
              "在线流式输入 target"
            ]
          },
          {
            "name": "output_requirement",
            "description": "输出内容变形",
            "possible_variations": [
              "只返回组合数量（计数型）",
              "只返回最长/最短序列",
              "返回所有序列的起始位置"
            ]
          },
          {
            "name": "continuity_definition",
            "description": "“连续”的定义是否可变",
            "possible_variations": [
              "等差序列（公差 d ≥ 1）",
              "连续偶数/奇数",
              "间隔为 k 的等差数列"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "破解闯关密码",
    "slug": "ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof",
    "schema": {
      "Input Structure": [
        "一维数组 password[1..n]",
        "元素为非负整数",
        "1 <= n <= 100"
      ],
      "Core Constraint": [
        "两个元素 a 和 b 的拼接顺序由字符串比较 a+b < b+a 决定",
        "局部最优选择（较小拼接结果）可导致全局最优排列",
        "比较关系具有全序性和传递性（在标准字符串比较下）"
      ],
      "Objective Function": "构造使所有数字拼接后字典序最小的字符串",
      "Algorithmic Invariant": [
        "存在一种自定义比较规则：对于任意两个数 a 和 b，若 a + b <= b + a，则 a 应排在 b 前面",
        "该比较关系在排序过程中保持稳定性",
        "使用此规则进行排序后，相邻交换不会产生更优解（贪心选择性质）"
      ],
      "Transformable Parameters": {
        "数据规模": "n <= 100 或扩展至 n <= 1e5（在线场景）",
        "值域范围": "非负整数，可限定在 [0, 10^9] 内",
        "是否允许前导零": "是（题目明确保留）",
        "输入形式": "单组输入，可改为多组测试用例",
        "输出形式": "返回字符串形式拼接结果",
        "是否在线处理": "否，当前为离线；可改造为流式添加数字并动态维护最小拼接",
        "排序规则变体": [
          "目标变为最大拼接数（目标变换）",
          "加入长度限制或模数约束（如结果 mod (1e9+7)）",
          "元素可重复、是否去重"
        ]
      }
    }
  },
  {
    "title": "查找总价格为目标值的两个商品",
    "slug": "he-wei-sde-liang-ge-shu-zi-lcof",
    "schema": {
      "Input Structure": "一维有序数组 price[1..n]，其中 n >= 1；price[i] ∈ [1, 10^6]，严格升序排列",
      "Core Constraint": "数组已按升序排列，两数之和等于 target 的解若存在，则可通过双指针从两端逼近唯一确定候选对；利用有序性避免暴力枚举",
      "Objective Function": "判定是否存在两个不同位置的商品价格之和等于 target，并返回任意一组满足条件的数值对 [a, b]",
      "Algorithmic Invariant": "维护左右指针 L=0 和 R=n-1：当 price[L] + price[R] < target 时，L 必须右移以增大和值；当 price[L] + price[R] > target 时，R 必须左移以减小和值；每一步移动均保持潜在解在 [L, R] 区间内或已访问过",
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 10^5] 或可扩展至 10^6（在线场景）",
        "值域范围": "price[i] 和 target 的上下界可调整，如支持负数或更大整数",
        "有序性": "是否保持升序（若无序则退化为哈希表解法）",
        "输入形式": "单组输入 / 多组查询 target / 在线添加商品价格",
        "输出要求": "返回一对值 / 返回索引 / 返回所有解的个数 / 判定是否存在",
        "扩展变形": "三数之和 / 固定偏移量查找 / 环形数组中找两数和"
      }
    }
  },
  {
    "title": "训练计划 VI",
    "slug": "shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "integers",
        "constraints": [
          "actions.length >= 1 and actions.length <= 10000",
          "actions[i] is integer, 1 <= actions[i] < 2^31",
          "all elements except one appear exactly three times",
          "exactly one element appears once (the coach)"
        ],
        "sorted": false,
        "duplicates": true
      },
      "Core Constraint": {
        "description": "所有学员的动作编号出现恰好三次，教练的编号只出现一次。利用异或与三进制计数性质可分离唯一元素。",
        "key_idea": "在模3意义下进行位计数，每一位上出现3次的数字对总和贡献为0，仅出现1次的数字保留其位模式"
      },
      "Objective Function": {
        "goal": "find_single_element",
        "type": "existence_and_extraction",
        "output_single_value": true
      },
      "Algorithmic Invariant": {
        "invariant_type": "bitwise_state_accumulation",
        "description": "维护一个位计数器（或两个变量 ones 和 twos），表示每一位上1出现次数模3的结果；遍历过程中，每加入一个数，更新状态，确保重复三次的数最终清零其影响，唯一出现一次的数保留在状态中",
        "proof_condition": "状态转移满足三进制异或加法群结构，支持撤销三次重复的影响"
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 10000",
        "value_domain": "positive integers, up to 2^31 - 1",
        "frequency_pattern": {
          "coach_appearance": 1,
          "student_appearance": 3
        },
        "variations": [
          "change frequency: k times vs 1 time (generalized 'single number')",
          "allow negative numbers",
          "input as stream (online version)",
          "multiple queries or dynamic updates (insert/delete)",
          "output position instead of value",
          "multi-coach: find all numbers appearing once (if others appear 3 times)"
        ],
        "input_form": "offline, static array",
        "multiple_test_cases": false,
        "cyclic_or_structured_input": false
      }
    }
  },
  {
    "title": "撞色搭配",
    "slug": "shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "description": "一维整数数组 sockets[1..n]",
        "constraints": [
          "2 <= n <= 10000",
          "每个颜色编号为整数",
          "除两个唯一颜色外，其余每种颜色恰好出现两次"
        ]
      },
      "Core Constraint": {
        "description": "数组中仅存在两个出现次数为1的颜色编号，其余所有颜色编号均出现且仅出现两次",
        "implication": "利用异或运算的自反性与交换律，相同数异或为0，不同数异或保留差异信息"
      },
      "Objective Function": {
        "goal": "找出两个仅出现一次的颜色编号",
        "type": "construction",
        "output_form": "返回包含这两个数字的数组（顺序任意）"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "异或运算具有结合性和交换性：a ^ a = 0, a ^ 0 = a",
          "所有成对元素异或后结果为0，整体异或得两目标数的异或值：x ^ y",
          "通过 x ^ y 中任一低位1位可将原数组划分为两组，每组各含一个目标数且其他数仍成对",
          "分组异或后分别得到 x 和 y"
        ],
        "complexity_constraint": {
          "time": "O(n)",
          "space": "O(1)"
        }
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "array_size",
            "range": "2 <= n <= 10000",
            "can_scale": true,
            "example_values": [
              100,
              1000,
              10000
            ]
          },
          {
            "name": "value_domain",
            "range": "integer",
            "can_be_negative": true,
            "can_be_large": true
          },
          {
            "name": "duplicate_count",
            "description": "是否扩展为多数出现k次，仅两个出现m次",
            "default": "其余均出现2次，目标出现1次",
            "variants": [
              "其余出现3次",
              "模3计数问题"
            ]
          },
          {
            "name": "input_structure",
            "form": "single array",
            "can_be_streaming": true,
            "online_query": false
          },
          {
            "name": "output_requirement",
            "options": [
              "返回两个数",
              "要求有序输出",
              "返回任意一组解即可"
            ]
          },
          {
            "name": "number_of_unique_elements",
            "default": 2,
            "can_change": true,
            "example": "推广至k个只出现一次的元素（需其他算法）"
          }
        ]
      }
    }
  },
  {
    "title": "计算二叉树的深度",
    "slug": "er-cha-shu-de-shen-du-lcof",
    "schema": {
      "Input Structure": "二叉树 root，节点数 n ≤ 10000，每个节点包含 val、left、right 指针",
      "Core Constraint": "树的层级结构具有递归子结构：当前节点的深度等于其左右子树最大深度加一；叶节点深度为 1",
      "Objective Function": "求二叉树的最大深度（即从根到最远叶节点的最长路径上的节点数）",
      "Algorithmic Invariant": "在深度优先遍历中，每一层递归调用返回其子树的最大深度，父节点基于子结果正确更新全局最大深度；状态可合并且无后效性",
      "Transformable Parameters": {
        "数据规模": "节点总数上限（如 1000, 10000, 1e5）",
        "树形态约束": "是否为平衡树 / 完全二叉树 / 退化链表",
        "输入形式": "数组表示法（如层序遍历序列含 null）或指针结构",
        "是否多组数据": "单棵树 / 多棵独立树批量处理",
        "是否在线": "静态一次性输入 / 动态插入删除后的实时查询",
        "目标变形": "最小深度 / 最长同值路径 / 直径长度"
      }
    }
  },
  {
    "title": "交易逆序对的总数",
    "slug": "shu-zu-zhong-de-ni-xu-dui-lcof",
    "schema": {
      "Input Structure": "一维数组 record[1..n]，其中 n <= 50000；元素为非负整数（表示股价）；数组无序、可重复",
      "Core Constraint": "逆序对定义为 i < j 且 record[i] > record[j]；局部比较无法直接得出全局计数，需利用分治或有序结构维护历史信息",
      "Objective Function": "计数：统计所有满足 i < j 且 record[i] > record[j] 的索引对 (i, j) 的总数",
      "Algorithmic Invariant": "使用归并排序过程中左右子数组已排序的性质，在合并时，若左子数组当前元素大于右子数组当前元素，则左子数组剩余所有元素均与该右元素构成逆序对；该计数方式不重复、不遗漏，且保持稳定性",
      "Transformable Parameters": {
        "数据规模": "n 的数量级：1e4 → 1e5 → 更大（影响是否可用 O(n²) 暴力）",
        "值域范围": "股价是否为小整数（可考虑树状数组/离散化）",
        "数组有序性": "输入是否部分有序（影响分治效率）",
        "是否在线": "数据是否流式输入（需支持动态插入和前缀查询，可转为 Fenwick Tree 或平衡 BST）",
        "是否多组数据": "是否存在多个测试用例，要求预处理或缓存结果",
        "目标变换": "从计数 → 输出所有逆序对（构造方案）、或求最长逆序子序列（DP 扩展）",
        "约束反转": "改为统计顺序对（record[i] <= record[j]）或相等对",
        "输入维度扩展": "从一维数组扩展到二维价格矩阵（如多只股票），定义跨行/跨列逆序"
      }
    }
  },
  {
    "title": "二叉树中和为目标值的路径",
    "slug": "er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof",
    "schema": {
      "Input Structure": [
        "二叉树的根节点 root，类型为 TreeNode",
        "每个节点包含整数值 val",
        "树中节点总数 n ∈ [0, 5000]",
        "节点值域：-1000 <= Node.val <= 1000",
        "目标和 targetSum，整数，范围 [-1000, 1000]"
      ],
      "Core Constraint": [
        "路径必须从根节点出发，终止于叶子节点（无子节点）",
        "路径总和定义为路径上所有节点值的累加",
        "路径结构具有前缀依赖性：父节点路径决定子路径起点",
        "解空间由树的分支结构自然分割，不可跳转"
      ],
      "Objective Function": [
        "找出所有满足路径总和等于 targetSum 的路径",
        "目标函数类型：构造方案（枚举所有合法路径）",
        "输出形式：二维整数列表，每个子列表表示一条路径"
      ],
      "Algorithmic Invariant": [
        "深度优先搜索过程中维护当前路径前缀和与路径列表",
        "回溯时弹出当前节点，保证路径状态正确性",
        "剪枝条件：若当前路径和已超过 targetSum 且后续节点均为正，则可提前终止（仅在值有符号约束下弱有效）",
        "递归展开不破坏路径唯一性和完整性"
      ],
      "Transformable Parameters": {
        "数据规模": "节点数量 n ∈ [0, 5000]，可调整为更大规模或限制为平衡树/链状树",
        "值域特性": "Node.val 和 targetSum 的符号性（全正、全负、混合），影响是否可剪枝",
        "路径定义变化": [
          "路径起点/终点不限于根到叶（如任意两点间路径）",
          "允许重复访问或跨子树路径（需重新定义结构）"
        ],
        "目标函数变换": [
          "求路径数量（计数型）",
          "求最长/最短满足条件的路径长度",
          "是否存在至少一条路径（判定型）"
        ],
        "输入形式": [
          "离线处理（完整树输入）",
          "在线构建树并查询（动态场景）"
        ],
        "附加约束": [
          "路径节点数不超过 k",
          "路径中不能包含负数节点",
          "路径必须经过特定类型节点"
        ]
      }
    }
  },
  {
    "title": "招式拆解 II",
    "slug": "di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof",
    "schema": {
      "Input Structure": [
        "一维字符数组 arr[1..n]",
        "arr[i] ∈ {'a'..'z'}",
        "n = |arr|, 0 <= n <= 50000"
      ],
      "Core Constraint": [
        "每个字符的出现次数决定其是否满足‘仅出现一次’条件",
        "首次满足条件的字符由其首次出现的位置顺序决定",
        "判定依赖全局频次统计与首次位置记录"
      ],
      "Objective Function": "返回第一个（按从左到右顺序）只出现一次的字符；若不存在，返回空格",
      "Algorithmic Invariant": [
        "使用哈希表统计字符频次，遍历一次可完成频率累积",
        "第二次遍历中，首个满足 frequency[c] == 1 的字符即为最优解",
        "顺序遍历保证了‘第一性’的正确性，且不会遗漏更优前缀解"
      ],
      "Transformable Parameters": {
        "n 的数量级": "0 <= n <= 50000",
        "字符集范围": "小写字母 a-z（可扩展至 ASCII 或 Unicode）",
        "是否区分大小写": false,
        "是否多组输入": false,
        "是否在线输入": false,
        "输出形式": "单个字符或空格",
        "目标函数变体": [
          "求最后一个只出现一次的字符",
          "求第 k 个只出现一次的字符",
          "计数：共有多少个只出现一次的字符",
          "要求不使用额外空间（原地变换）"
        ],
        "数据流化支持": false,
        "输入结构变形": "可改为字符串列表或含重复动作的指令流"
      }
    }
  },
  {
    "title": "验证二叉搜索树的后序遍历序列",
    "slug": "er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "properties": [
          "length n ≤ 1000",
          "distinct elements",
          "represents postorder traversal sequence of a binary search tree"
        ]
      },
      "Core Constraint": {
        "description": "In a valid BST postorder traversal, the root is the last element; all left subtree elements are less than root, and all right subtree elements are greater than root. This partition must hold recursively.",
        "structural_property": "The array can be partitioned around the root into two contiguous segments: left subtree (all < root) and right subtree (all > root), with no mixing."
      },
      "Objective Function": {
        "type": "decision",
        "goal": "Determine whether the given array can represent a valid postorder traversal of some binary search tree"
      },
      "Algorithmic Invariant": {
        "invariant_rules": [
          "For any subarray being processed, the last element is treated as the current root.",
          "All elements before the root must be partitionable into a prefix (left subtree) where every value < root, followed by a suffix (right subtree) where every value > root.",
          "This property must hold recursively on both subtrees."
        ],
        "recursion_safety": "Once the split point between left and right subtrees is found (first element > root), all subsequent elements must remain > root; otherwise, invalid.",
        "boundary_preservation": "Recursive validation preserves correctness: if all recursive calls return true and local partitioning is valid, then the entire sequence is valid."
      },
      "Transformable Parameters": {
        "constraints": [
          "Array length n (current: ≤1000 → can scale to 1e5 for optimized variants)",
          "Element uniqueness (can allow duplicates → defines different BST semantics)",
          "Value range (integers: arbitrary vs bounded domain)"
        ],
        "input_form": [
          "Single query vs multiple test cases",
          "Offline batch input vs online stream of nodes"
        ],
        "output_form": [
          "Boolean decision only",
          "Extended: return one possible BST construction",
          "Count how many BSTs yield this postorder",
          "Recover preorder/inorder from postorder under BST constraint"
        ],
        "structural_variants": [
          "Binary Search Tree → Cartesian Tree or other heap-like structures with order constraints",
          "Postorder → Preorder/Inorder with similar verification task",
          "Allow missing values or wildcard positions ('?' in traversal)"
        ]
      }
    }
  },
  {
    "title": "彩灯装饰记录 III",
    "slug": "cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof",
    "schema": {
      "Input Structure": "二叉树 root，节点数 n ≤ 1000，每个节点具有整数值（颜色编号）",
      "Core Constraint": "每一层的遍历顺序与上一层相反：奇数层（根为第1层）从左到右，偶数层从右到左；即锯齿形（Zigzag）层次遍历",
      "Objective Function": "返回二叉树的锯齿形层序遍历结果，按层输出节点值列表的列表",
      "Algorithmic Invariant": "使用队列进行广度优先搜索（BFS），并通过层数奇偶性控制每层结果的存储顺序（反转或正序）；或使用双端队列根据方向选择头插/尾插以维持正确顺序",
      "Transformable Parameters": {
        "n 的数量级": "≤ 1000, 可调整至 1e5 以要求更优实现",
        "是否完整二叉树": "原题为一般二叉树，可变体包括完全二叉树、满二叉树等",
        "遍历方向规则": "可改为周期性变化（如每三层翻转）、基于节点值奇偶性决定方向等",
        "输出形式": "是否要求返回每层原始顺序+方向标记；或仅返回展平后的序列",
        "是否多组数据": "单棵树 → 多棵连续输入的树",
        "是否在线": "支持动态插入节点并实时更新遍历结果"
      }
    }
  },
  {
    "title": "找到第 k 位数字",
    "slug": "shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof",
    "schema": {
      "Input Structure": "正整数 k（表示字符序列中的第 k 位，从 1 开始计数）；隐式输入为自然数序列拼接形成的无限数字串 S = '123456789101112...'，其中每个整数按顺序连接成字符串",
      "Core Constraint": "数字串由连续正整数依次拼接而成，不同位数的整数占据不同长度的字符区间：1~9 占1位，10~99 占2位，100~999 占3位，依此类推。因此可将序列划分为按位数分组的块结构",
      "Objective Function": "定位第 k 位数字所在的整数，并提取该位置上具体的数字字符（返回其数值）",
      "Algorithmic Invariant": "通过逐位数层级（digit-length level）累加总字符长度，确定目标位 k 所在的整数的位数范围；在此基础上计算偏移量以定位具体整数和其内部的数字位，过程中保持位数分组与字符总数之间的单调映射关系",
      "Transformable Parameters": {
        "k 的数量级": "k < 2^31，适用于 O(log k) 算法",
        "起始序号": "是否从 0 或 1 开始计数",
        "数字进制": "是否改为二进制、十六进制等非十进制拼接序列",
        "是否多组查询": "单次查询 vs 多组 k 值在线查询",
        "是否支持逆向查询": "给定数字 d 和位置类型（如首位、末位），求其第几次出现",
        "序列起始值": "是否从 1 开始，或从任意整数 m 起始拼接"
      }
    }
  },
  {
    "title": "彩灯装饰记录 II",
    "slug": "cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof",
    "schema": {
      "Input Structure": "二叉树 root，节点数 n ≤ 1000；每个节点具有整数值（颜色编号）；结构为链式指针形式（left, right）",
      "Core Constraint": "同一层的节点必须在一次遍历中被集中访问；父子节点之间存在层级依赖关系：子节点的深度 = 父节点深度 + 1；从左到右顺序由树的结构天然决定",
      "Objective Function": "按层序顺序返回每一层的节点值列表，每层结果独立成一个子数组，整体构成二维数组",
      "Algorithmic Invariant": "使用队列维护当前待访问的节点，并记录其层级信息；每次取出队列头部节点时，将其子节点按左→右顺序加入队尾，保证同层节点连续、顺序正确；已处理的层不会被重新访问",
      "Transformable Parameters": {
        "n 的数量级": "≤ 1000（可改为更大规模或动态限制）",
        "是否多组数据": false,
        "是否在线": false,
        "输出形式": "逐层输出（可变为锯齿形、反向层序、仅奇数层等）",
        "遍历方向": "从左到右（可变换为从右到左）",
        "树的形态约束": "普通二叉树（可扩展为 N 叉树）",
        "值域范围": "整数（可限定正数、非负、有重复等）"
      }
    }
  },
  {
    "title": "彩灯装饰记录 I",
    "slug": "cong-shang-dao-xia-da-yin-er-cha-shu-lcof",
    "schema": {
      "Input Structure": "二叉树 root，节点数 n ≤ 1000；每个节点具有整数值（彩灯颜色编号）；树以指针形式给出，无显式数组存储",
      "Core Constraint": "同一层的节点需按从左到右顺序输出；下一层的输出必须在上一层之后（层级遍历顺序）；父子关系决定了访问依赖：子节点只能在其父节点被访问后才可被访问",
      "Objective Function": "返回一个一维整数数组，按层序遍历（广度优先）顺序包含所有节点的值",
      "Algorithmic Invariant": "使用队列维护待访问节点，保证先进先出（FIFO）；每处理一个节点，将其子节点依次加入队尾；已出队节点即确定其在输出中的位置，不会被修改或重排",
      "Transformable Parameters": {
        "n 的数量级": "≤ 1000, 可扩展至 1e5（影响是否可用递归或需迭代优化）",
        "是否多组数据": "否，当前为单棵树输入，可改为多组测试用例",
        "是否在线": "否，整棵树一次性给出；可设计为动态插入节点后的实时遍历查询",
        "输出形式": "仅返回值列表；可变更为逐层输出（二维列表）、反向层序、奇偶层反向等",
        "遍历方向": "从左到右；可变换为从右到左或交替方向（Zigzag 层序遍历）",
        "树的结构特性": "普通二叉树；可限定为完全二叉树、满二叉树、BST 等以引入额外性质"
      }
    }
  },
  {
    "title": "库存管理 II",
    "slug": "shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof",
    "schema": {
      "Input Structure": "一维数组 stock[1..n]，其中 stock[i] 表示商品 id；n ≥ 1，数组非空且元素为整数；可能存在重复值",
      "Core Constraint": "存在唯一一个元素出现次数大于 n / 2（多数元素），其余元素总和不足一半，因此局部投票可抵消非主元素影响",
      "Objective Function": "返回数组中出现次数大于 length / 2 的唯一商品 id（判定 + 构造）",
      "Algorithmic Invariant": "使用摩尔投票法：维护候选元素 candidate 和计数器 count；当新元素等于 candidate 时 count++，否则 count--；count == 0 时更换候选者；由于多数元素 > n/2，最终存活的 candidate 必为结果",
      "Transformable Parameters": [
        "n 的数量级：当前 1 <= n <= 50000，可调整至 1e5 或更高以限制暴力解法",
        "是否多组数据：可改为连续多个库存表输入",
        "是否在线：元素逐个流入，要求在线返回当前多数元素",
        "约束条件变化：从 > n/2 变为 ≥ n/2 或恰好 k 次，或求所有频次超过 n/3 的元素（Boyer-Moore 扩展）",
        "输入形式：是否排序、是否加密传输（需边解码边处理）",
        "值域范围：商品 id 是否在小范围内（可用计数数组），或大范围哈希映射"
      ]
    }
  },
  {
    "title": "数字 1 的个数",
    "slug": "1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof",
    "schema": {
      "Input Structure": [
        "一个非负整数 num",
        "0 <= num < 10^9",
        "表示上界：计算 [0, num] 范围内所有整数"
      ],
      "Core Constraint": [
        "数字 '1' 的出现次数需按位独立统计",
        "高位变化影响低位的完整周期性",
        "每一位上的数字分布具有递推结构和数学规律性"
      ],
      "Objective Function": "计数 - 统计所有小于等于 num 的非负整数中，十进制表示下数字 '1' 出现的总次数",
      "Algorithmic Invariant": [
        "从低到高逐位处理时，可将数字分为三个部分：高位、当前位、低位",
        "对于当前位，其贡献可基于高位值、当前位数值、低位值与该位权重（10^k）确定",
        "每处理完一位，剩余未处理位的状态可通过数学公式归纳，不影响已计算部分的正确性",
        "存在统一的分段函数规则来判断当前位对总答案的贡献：",
        "  - 若当前位 > 1: 贡献为 (high + 1) * base",
        "  - 若当前位 == 1: 贡献为 high * base + low + 1",
        "  - 若当前位 < 1: 贡献为 high * base"
      ],
      "Transformable Parameters": {
        "目标数字": [
          "1",
          "可替换为任意数字 d ∈ [0,9]（注意前导零问题）"
        ],
        "计数目标": [
          "出现次数 → 可改为 '0' 的个数（需处理前导零）",
          "改为各数字频次向量"
        ],
        "输入形式": [
          "单个整数 → 可扩展为区间 [L, R] 内计数",
          "多组查询"
        ],
        "数据规模": [
          "num < 10^9 → 可扩大至大整数或字符串输入",
          "支持在线输入"
        ],
        "进制系统": [
          "十进制 → 可变换为 b 进制下数字 d 的出现次数"
        ],
        "输出要求": [
          "仅总数 → 可要求输出每个数中是否含1",
          "构造首次超过阈值的位置"
        ]
      }
    }
  },
  {
    "title": "套餐内商品的排列顺序",
    "slug": "zi-fu-chuan-de-pai-lie-lcof",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "给定一个长度为 n 的字符串 goods",
        "constraints": [
          "1 <= n <= 8",
          "goods[i] 属于小写英文字母",
          "字符串中可能包含重复字符"
        ]
      },
      "Core Constraint": {
        "description": "需要生成所有字符的全排列，但结果中不能包含重复的排列序列",
        "key_point": "输入字符串可能存在重复字符，因此必须去重：相同字符在相同相对位置只能被扩展一次（需剪枝）",
        "structural_property": "排列问题具有深度优先搜索结构，状态由已选字符路径和剩余字符决定"
      },
      "Objective Function": {
        "type": "constructive",
        "goal": "构造所有不重复的字符排列方案",
        "output_form": "返回字符串列表，每个元素是一个唯一的排列"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "在递归生成过程中，同一层递归中相同字符只应被选择一次（避免重复排列）",
          "通过排序 + 剪枝保证：若当前字符与前一字符相同，且前一字符未被使用（即不在当前路径中），则跳过当前字符",
          "使用访问标记数组（used）维护当前路径中已使用的字符位置，确保每个字符仅使用一次",
          "搜索空间的分解满足子问题独立性和可回溯性"
        ],
        "paradigm": "DFS + 回溯 + 剪枝（基于字符排序去重）"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n 的数量级",
            "range": "1 <= n <= 8 (原始), 可扩展至 n <= 10 或更大以要求迭代实现或优化剪枝)"
          },
          {
            "name": "字符类型",
            "options": [
              "小写字母",
              "大写字母",
              "数字",
              "混合字符",
              "Unicode 字符"
            ]
          },
          {
            "name": "是否允许重复字符",
            "options": [
              true,
              false
            ],
            "effect": "影响是否需要去重剪枝"
          },
          {
            "name": "输出顺序要求",
            "options": [
              "无序",
              "字典序升序",
              "字典序降序"
            ],
            "effect": "决定是否需要对结果排序"
          },
          {
            "name": "是否多组输入",
            "options": [
              false,
              true
            ],
            "effect": "是否处理多个测试用例"
          },
          {
            "name": "是否在线",
            "options": [
              false,
              true
            ],
            "effect": "例如动态添加字符并实时更新排列集合"
          },
          {
            "name": "目标函数变形",
            "options": [
              "全部排列（本题）",
              "第 k 个排列（康托展开）",
              "是否存在某个特定排列",
              "计数不同排列总数（数学公式）"
            ]
          },
          {
            "name": "约束条件增强",
            "options": [
              "相邻字符限制（如不能连续出现某两个字符）",
              "回文排列限定",
              "前缀固定"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "序列化与反序列化二叉树",
    "slug": "xu-lie-hua-er-cha-shu-lcof",
    "schema": {
      "Input Structure": "二叉树根节点 root；树中节点数 ∈ [0, 10^4]；每个节点值 val ∈ [-1000, 1000]",
      "Core Constraint": "序列化结果必须唯一对应原树结构，反序列化能无歧义重建原始二叉树；空子树需显式编码以保留结构信息",
      "Objective Function": "实现双向映射：将二叉树序列化为字符串，并能从该字符串反序列化恢复原树结构",
      "Algorithmic Invariant": "遍历顺序与重建过程保持一致（如前序/层序）；空节点标记可唯一确定子树边界；解码时可通过读取顺序逐步重构父子关系",
      "Transformable Parameters": {
        "n 的数量级": "节点数上限可调（如 10^2 → 10^6）",
        "值域范围": "Node.val 范围可扩展或压缩",
        "输入输出形式": [
          "是否要求紧凑编码（如省略括号）",
          "是否允许使用非字符串媒介（如字节流）",
          "序列化格式可变（前序+中序组合、层序+BFS索引等）"
        ],
        "是否多组数据": "支持批量序列化多个树",
        "是否在线": "支持流式序列化/反序列化（边接收边解析）",
        "结构变体": "可推广至 N 叉树、二叉搜索树（利用有序性优化编码）"
      }
    }
  },
  {
    "title": "验证图书取出顺序",
    "slug": "zhan-de-ya-ru-dan-chu-xu-lie-lcof",
    "schema": {
      "Input Structure": [
        "一维数组 putIn[1..n]",
        "一维数组 takeOut[1..n]",
        "putIn 和 takeOut 均为长度相等的整数序列",
        "所有元素互不相同",
        "putIn 是 takeOut 的排列",
        "n <= 1000"
      ],
      "Core Constraint": [
        "书架行为等价于栈：后进先出（LIFO）",
        "书籍必须按 putIn 顺序依次入栈，但可以在任意时刻执行出栈操作",
        "takeOut 序列合法当且仅当存在一组合法的入栈/出栈操作序列，使其输出顺序与之完全一致",
        "局部决策依赖栈顶状态：只有栈顶元素可以被取出"
      ],
      "Objective Function": "判定是否存在一组合法的入栈和出栈操作，使得输出序列为 takeOut",
      "Algorithmic Invariant": [
        "使用模拟栈维护当前已入栈但未出栈的书籍集合",
        "遍历 putIn 执行入栈，并在栈非空且栈顶等于 takeOut 当前目标时持续出栈",
        "若最终所有 takeOut 元素都被成功匹配，则序列合法",
        "贪心策略正确性：只要栈顶匹配当前目标就应立即出栈，延迟不会增加可行性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "<= 1000",
            "可扩展至 1e5（需优化）"
          ]
        },
        "输入形式": [
          "单组输入",
          "多组测试用例（可选）"
        ],
        "是否在线": [
          "离线处理（标准）",
          "在线查询 takeOut 序列（变形）"
        ],
        "栈行为约束": [
          "标准栈（LIFO）",
          "双端栈（允许两端弹出）",
          "带容量限制的栈"
        ],
        "元素唯一性": [
          "所有书籍编号不同（当前设定）",
          "允许重复编号（更难变体）"
        ],
        "目标函数变换": [
          "判定合法性（当前）",
          "计数：有多少种合法的 takeOut 序列",
          "构造：生成一个合法的 takeOut 序列"
        ],
        "输入维度扩展": [
          "1D 栈序列（当前）",
          "2D：多个并行书架（队列+栈混合结构）",
          "树形书架访问顺序（DFS/BFS 约束）"
        ]
      }
    }
  },
  {
    "title": "将二叉搜索树转化为排序的双向链表",
    "slug": "er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof",
    "schema": {
      "Input Structure": [
        "二叉搜索树的根节点 root",
        "每个节点具有左子节点、右子节点和值 val",
        "Node.val ∈ [-1000, 1000]",
        "所有节点值唯一",
        "节点数 n ∈ [0, 2000]"
      ],
      "Core Constraint": [
        "二叉搜索树的中序遍历是递增序列",
        "需利用树结构本身的指针（left 作为前驱，right 作为后继）进行就地转换",
        "不能创建新节点，只能重用原有空间",
        "最终结果为双向循环链表：最小节点的 left 指向最大节点，最大节点的 right 指向最小节点"
      ],
      "Objective Function": [
        "将二叉搜索树原地转化为一个按值升序排列的双向循环链表",
        "返回链表中最小元素（即最左下节点）的指针"
      ],
      "Algorithmic Invariant": [
        "中序遍历过程中维护当前已构建链表的最后一个节点（prev）",
        "每次访问新节点时，将其左指针指向 prev，prev 的右指针指向该节点（若 prev 存在）",
        "遍历完成后，首尾节点通过指针连接形成循环",
        "整个过程保持部分链表的双向有序性和连接完整性"
      ],
      "Transformable Parameters": {
        "是否允许重复值": false,
        "树的形态约束": "必须为二叉搜索树",
        "数据规模": "节点数量 ≤ 2000",
        "输入形式": "树形结构根节点指针",
        "输出形式": "指向最小节点的指针",
        "是否多组数据": false,
        "是否在线处理": false,
        "是否要求非递归实现": false,
        "是否扩展至森林合并": false,
        "是否支持删除/插入操作": false,
        "是否循环链表": true
      }
    }
  },
  {
    "title": "连续天数的最高销售额",
    "slug": "lian-xu-zi-shu-zu-de-zui-da-he-lcof",
    "schema": {
      "Input Structure": "一维数组 sales[1..n]，其中 n >= 1，元素为整数，值域范围：-100 <= sales[i] <= 100",
      "Core Constraint": "子数组必须是连续的；任意位置的局部最优解依赖于前缀和的累积状态，且负贡献可被舍弃以重启区间",
      "Objective Function": "求所有非空连续子数组中元素和的最大值（最大化）",
      "Algorithmic Invariant": "维护一个当前子数组和的累加器 cur_sum 和全局最大值 max_sum；当 cur_sum < 0 时，丢弃此前区间（贪心选择），因为其对后续无正向增益；每步更新保证 max_sum 始终为已遍历部分的最优解",
      "Transformable Parameters": {
        "数据规模": "n 的数量级：1 <= n <= 1e5",
        "值域范围": "sales[i] ∈ [-100, 100]",
        "是否有序": "数组无序",
        "是否循环": "可扩展为环形数组（如首尾相连）",
        "输入形式": "单组离线输入",
        "是否在线": "可变更为支持动态添加销售数据的在线模式",
        "目标函数变化": "可改为最小和子数组、最长/最短长度达到某阈值、计数满足条件的子数组个数",
        "约束变化": "可加入长度限制（如子数组长度不超过k）、非空约束放松等"
      }
    }
  },
  {
    "title": "数据流中的中位数",
    "slug": "shu-ju-liu-zhong-de-zhong-wei-shu-lcof",
    "schema": {
      "Input Structure": [
        "数据流形式输入的一维整数序列",
        "元素逐个动态加入，无初始全量数据",
        "数值类型：int，值域未限定但调用次数 ≤ 50000"
      ],
      "Core Constraint": [
        "中位数依赖于全局有序性",
        "无法存储完整排序序列（隐含对时间/空间效率要求）",
        "每次插入后需快速响应查询，要求均摊高效"
      ],
      "Objective Function": [
        "支持两种操作：addNum（插入）、findMedian（返回当前中位数）",
        "目标函数为构造一个动态中位数查询结构，输出为 double 类型的中位数值"
      ],
      "Algorithmic Invariant": [
        "使用两个堆维护数据分布：一个最大堆（left）存较小的一半，一个最小堆（right）存较大的一半",
        "堆大小满足 |right.size - left.size| ≤ 1",
        "最大堆顶 ≤ 最小堆顶，且二者至多相差1个元素，此时中位数可由堆顶计算得出",
        "每次插入通过比较和转移维持上述不变量，保证 findMedian 的 O(1) 查询"
      ],
      "Transformable Parameters": {
        "数据规模": "最多 50000 次操作（可调整为更大或更小以控制复杂度）",
        "输入形式": "在线数据流（可改为离线批量插入 + 单次查询）",
        "是否多组数据": "否，单个数据结构实例（可扩展为多实例并发场景）",
        "值域限制": "无显式限制（可添加如非负、有界等约束以生成变体）",
        "有序性要求": "运行时维护逻辑有序（可改为近似中位数以支持流式近似算法）",
        "操作类型": [
          "当前为 addNum + findMedian",
          "可变形为支持 deleteNum、updateNum 等操作",
          "或变为仅查询第 k 大（推广为 Quantile Finder）"
        ],
        "输出精度": "精确中位数（可变为概率性/近似中位数，适用于大数据场景）"
      }
    }
  },
  {
    "title": "最小栈",
    "slug": "bao-han-minhan-shu-de-zhan-lcof",
    "schema": {
      "Input Structure": "一维数据流序列，支持 push、pop 操作的栈 S[1..n]；元素为整数 val ∈ [-2^31, 2^31 - 1]；操作序列最多 3 * 10^4 次",
      "Core Constraint": "栈结构具有后进先出（LIFO）顺序；最小值的维护必须与栈顶状态同步演化；局部最小信息不足以代表全局最小，需在每次操作中保持历史最小状态的可追溯性",
      "Objective Function": "在常数时间内实现 getMin() 查询：返回当前栈中所有元素的最小值；同时支持标准栈操作（push、pop、top）",
      "Algorithmic Invariant": "辅助栈或元组存储法保证：每个栈位置 i 对应一个从栈底到 i 的前缀最小值；该最小值随 push/pop 变化单调不增（非严格）；任意时刻主栈与最小值栈同步更新，保持长度一致和位置对齐",
      "Transformable Parameters": {
        "数据规模": "操作次数范围：1 到 3 * 10^4",
        "值域": "val ∈ [-2^31, 2^31 - 1]",
        "是否多组数据": true,
        "输入形式": "离线指令序列（方法调用与参数列表）",
        "是否在线": true,
        "输出形式": "每步操作返回值构成的结果数组（null 或整数）",
        "约束变形": [
          "getMin 要求 O(1) → 可改为 O(log n) 允许使用堆",
          "空间限制：是否允许使用额外栈 → 可改为单栈差值编码法",
          "支持 getMin 的同时支持 getMax → 双端查询扩展",
          "加入 removeMin 操作 → 动态删除全局最小元素"
        ]
      }
    }
  },
  {
    "title": "库存管理 III",
    "slug": "zui-xiao-de-kge-shu-lcof",
    "schema": {
      "Input Structure": "一维数组 stock[1..n]，其中 stock[i] ∈ [0, 10000]，n ≤ 10000",
      "Core Constraint": "最小的 cnt 个元素仅由值的大小决定，与原位置无关；无顺序依赖或局部结构约束",
      "Objective Function": "返回库存余量最少的 cnt 个商品余量，顺序不限",
      "Algorithmic Invariant": "部分排序或优先队列维护过程中，已选出的元素始终是全局最小的前 cnt 个；使用快速选择时，划分操作保持左侧小于等于右侧的相对顺序不变性",
      "Transformable Parameters": {
        "数据规模 n": "1e4（可扩展至 1e5 或更大以区分解法）",
        "值域范围": "[0, 10000]（可改为负数或更大范围）",
        "是否有序": "输入无序（可变为部分有序以测试稳定性）",
        "cnt 的取值": "0 <= cnt <= n（可设为动态查询或多组查询）",
        "是否多组数据": "单组输入（可扩展为多组测试用例）",
        "是否在线": "离线一次性输入（可改为流式输入要求实时输出前 cnt 小）",
        "输出要求": "顺序不限（可改为要求稳定排序或原始索引顺序）"
      }
    }
  },
  {
    "title": "随机链表的复制",
    "slug": "fu-za-lian-biao-de-fu-zhi-lcof",
    "schema": {
      "Input Structure": "链表结构，每个节点包含三个字段：val（整数），next（指向下一个节点的指针），random（指向任意节点或null的指针）；节点数 n ≤ 1000，val ∈ [-10000, 10000]，链表无环或有环未知",
      "Core Constraint": "新链表必须是原链表的深拷贝，即所有节点均为新创建的实例，且 next 和 random 指针关系与原链表完全一致；random 指针的目标可能尚未创建，因此不能一次性完成映射",
      "Objective Function": "构造并返回原链表的一个深拷贝（新链表头节点）",
      "Algorithmic Invariant": "通过哈希表建立原节点到新节点的映射，确保每个原节点只被复制一次；在遍历过程中，若 random 或 next 目标未构建，则延迟连接，后续补全；或使用指针缝合技巧实现 O(1) 空间算法时，保持原链表与副本交替排列的结构不变性",
      "Transformable Parameters": {
        "数据规模": "节点数 n 的范围：0 ≤ n ≤ 1000；可扩展至更大规模并要求在线处理",
        "链表形态": "是否保证无环；是否为双向链表扩展",
        "random 指针约束": "random 是否允许指向自身；是否允许多重引用形成 DAG 结构",
        "输入形式": "是否以数组形式给出（如 [[val, random_index]]）；index = -1 表示 null",
        "输出要求": "是否仅需验证结构同构而非返回头节点；是否要求保持节点地址无关性",
        "空间限制": "是否要求 O(1) 额外空间解法（排除哈希表）",
        "多组数据": "是否连续处理多个测试用例，共享全局状态",
        "在线变体": "是否支持动态插入/删除节点后的增量复制"
      }
    }
  },
  {
    "title": "删除链表的节点",
    "slug": "shan-chu-lian-biao-de-jie-dian-lcof",
    "schema": {
      "Input Structure": {
        "type": "Singly Linked List",
        "node_value_domain": "Integer",
        "head_pointer": "Given",
        "val_to_delete": "Integer",
        "constraints": [
          "链表中节点值互不相同",
          "链表为单向（无前驱指针）",
          "至少有一个节点",
          "目标值 val 一定存在于链表中"
        ]
      },
      "Core Constraint": {
        "constraint": "删除操作只能通过遍历完成，无法直接访问父节点",
        "implication": "必须在遍历时维护当前节点的前驱信息，或使用指针的指针技巧跳过目标节点",
        "structural_dependency": "后继依赖：后续结构依赖于当前节点是否被保留"
      },
      "Objective Function": "删除链表中值等于给定 val 的唯一节点，并返回修改后链表的头节点",
      "Algorithmic Invariant": {
        "invariant": [
          "遍历过程中，始终保证已处理部分的链表结构正确且连续",
          "若当前节点值等于 val，则将其从前驱节点的 next 指针中跳过，连接其后继",
          "头节点可能被删除，因此需特殊处理或引入虚拟头节点（dummy）以统一逻辑"
        ],
        "pointer_behavior": "使用一个指针遍历，prev 指针或双指针机制确保可修改前驱链接"
      },
      "Transformable Parameters": {
        "n_size": "1 ≤ n ≤ 1000",
        "value_range": "节点值 ∈ [-1000, 1000]",
        "val_existence": "保证存在且唯一",
        "duplicates_allowed": false,
        "multiple_deletions": false,
        "input_form": "head pointer + target value",
        "output_form": "head of modified list",
        "online_query": false,
        "data_update": "static structure (no further operations)",
        "extension_slots": [
          "是否允许多个相同值（→ 删除所有匹配节点）",
          "是否允许 val 不存在（→ 需判断边界）",
          "变为双向链表（→ 可反向定位）",
          "加入插入 / 修改操作 → 构成链表编辑器问题",
          "要求 O(1) 时间删除给定节点指针（经典变体：此时可复制后继值并删除后继）"
        ]
      }
    }
  },
  {
    "title": "训练计划 III",
    "slug": "fan-zhuan-lian-biao-lcof",
    "schema": {
      "Input Structure": "单链表 head，节点数 n ∈ [0, 5000]，每个节点值 val ∈ [-5000, 5000]",
      "Core Constraint": "链表为单向结构，只能从头到尾顺序访问；反转操作需通过指针重连实现，不能使用额外数组存储",
      "Objective Function": "返回原链表的逆序链表（即头尾颠倒后的链表头节点）",
      "Algorithmic Invariant": "维护三个指针：prev（已反转部分的头）、curr（当前待反转节点）、nextTemp（暂存 curr 的后继）；每次将 curr 指向 prev，并推进三指针，保持已处理段始终为原序列的逆序",
      "Transformable Parameters": {
        "数据规模": "n ∈ [0, 5000]，可调整至更大（如支持 1e6）或更小",
        "值域范围": "Node.val ∈ [-5000, 5000]，可扩展或限制",
        "链表类型": "可变为双向链表、循环链表、带虚拟头节点等",
        "是否允许额外空间": "是否允许使用栈或数组辅助（影响解法选择）",
        "是否在线": "是否逐个接收节点并动态维护逆序结构",
        "多组数据": "是否处理多个独立链表输入"
      }
    }
  },
  {
    "title": "模糊搜索验证",
    "slug": "zheng-ze-biao-da-shi-pi-pei-lcof",
    "schema": {
      "Input Structure": [
        "一维字符串 article[1..m], 其中 m ∈ [1, 20]",
        "一维字符串 input[1..n], 其中 n ∈ [1, 20]",
        "article 只包含小写字母 a-z",
        "input 包含小写字母 a-z，以及特殊字符 '.' 和 '*'",
        "保证每个 '*' 前面都有一个有效字符（即非起始位置且前一字符为普通字符或 '.'）"
      ],
      "Core Constraint": [
        "通配符 '.' 可匹配任意单个字符",
        "通配符 '*' 依赖于其前一个字符 c，表示匹配零个或多个 c",
        "模式串 input 的匹配具有局部依赖性：'*' 的语义由前一字符决定",
        "匹配过程需按顺序覆盖整个 article 字符串，不能跳过中间字符",
        "存在回溯必要性：某些 '*' 可能需要尝试多种匹配长度（如 0、1、2...）才能确定是否可行"
      ],
      "Objective Function": [
        "判定是否存在一种方式，使得 input 模式完全匹配 article 整个字符串",
        "目标函数类型：判定型（Yes/No）"
      ],
      "Algorithmic Invariant": [
        "动态规划状态不变量：dp[i][j] 表示 article 前 i 个字符能否被 input 前 j 个字符匹配",
        "状态转移可分解为以下情形：",
        "  - 若 input[j] 是普通字符：匹配当且仅当 article[i] == input[j] 且 dp[i-1][j-1]",
        "  - 若 input[j] 是 '.'：直接匹配任意 article[i]，依赖 dp[i-1][j-1]",
        "  - 若 input[j] 是 '*'：考察 input[j-1]，有两种选择：",
        "      ① 匹配零次：则 dp[i][j] ← dp[i][j-2]",
        "      ② 匹配一次或多次：要求当前字符可被前一字符匹配（article[i] == input[j-1] 或 input[j-1]=='.'），且 dp[i-1][j] 成立",
        "指针推进方向为从左上到右下，状态更新具有最优子结构和重叠子问题性质",
        "递归+记忆化搜索亦满足相同不变量，搜索空间受 (m,n) 维度限制"
      ],
      "Transformable Parameters": [
        {
          "parameter": "字符串长度规模",
          "values": [
            "m, n ≤ 20（原题）",
            "扩展至 ≤ 1000（需优化DP）",
            "在线流式输入（高级变形）"
          ]
        },
        {
          "parameter": "通配符集合",
          "values": [
            "仅支持 '.' 和 '*'",
            "增加 '?'（匹配单个字符但不可重复）",
            "增加 '+'（至少一次重复）",
            "支持 '[a-z]' 范围匹配等正则语法"
          ]
        },
        {
          "parameter": "input 是否保证合法性",
          "values": [
            "保证 '*' 前有有效字符（原题）",
            "不保证，需预处理校验"
          ]
        },
        {
          "parameter": "目标函数类型",
          "values": [
            "判定是否完全匹配（原题）",
            "计数：有多少种不同匹配路径",
            "构造：输出所有可能的匹配方案",
            "最小编辑距离使其可匹配"
          ]
        },
        {
          "parameter": "匹配模式",
          "values": [
            "必须完整匹配整个 article",
            "允许前缀匹配",
            "允许子串匹配"
          ]
        },
        {
          "parameter": "数据形式",
          "values": [
            "单组测试用例",
            "多组测试用例批量处理",
            "在线查询：频繁更换 pattern 查询多个文本"
          ]
        },
        {
          "parameter": "算法复杂度约束",
          "values": [
            "O(mn) 动态规划可接受（原题规模）",
            "要求 O(n) 或近线性解法（限制更强条件如无 '*'）"
          ]
        }
      ]
    }
  },
  {
    "title": "报数",
    "slug": "da-yin-cong-1dao-zui-da-de-nwei-shu-lcof",
    "schema": {
      "Input Structure": "整数 cnt，表示最大数字的位数；生成从 1 到最大的 cnt 位十进制数的序列",
      "Core Constraint": "输出范围为 [1, 10^cnt - 1] 的所有整数，按升序排列；不存在跳过或重复的数字；数值顺序与自然数一致",
      "Objective Function": "构造并返回一个包含所有满足条件整数的升序数组",
      "Algorithmic Invariant": "数字按自然顺序递增生成，每次增加 1 不会破坏顺序性；起始点为 1，终止点为 10^cnt - 1 可预先确定；遍历过程无分支遗漏或越界",
      "Transformable Parameters": {
        "cnt 的数量级": "例如 cnt ≤ 1（个位）到 cnt ≤ 9（long long 范围）再到高精度场景（字符串处理）",
        "是否需要处理大数溢出": "是/否；若需支持极大 cnt，则需用字符串模拟加法",
        "起始数字": "可变，如从 0 开始或从指定数开始",
        "输出形式": "返回数组 / 逐个打印 / 生成器模式",
        "是否多组数据": "单次输入 / 多组测试用例",
        "是否在线": "离线一次性生成 / 在线逐项查询第 k 个数"
      }
    }
  },
  {
    "title": "Pow(x, n)",
    "slug": "shu-zhi-de-zheng-shu-ci-fang-lcof",
    "schema": {
      "Input Structure": [
        "浮点数 x，满足 -100.0 < x < 100.0",
        "整数 n，满足 -2^31 <= n <= 2^31 - 1",
        "输入为标量（非数组、非序列），但指数具有位结构"
      ],
      "Core Constraint": [
        "幂运算满足结合律：x^n = x^(a+b) = x^a * x^b",
        "指数可分解为二进制表示下的位权叠加：n = Σ b_i * 2^i",
        "负指数转化为倒数问题：x^(-n) = 1 / x^n",
        "计算过程中需避免线性时间复杂度 O(|n|)，必须利用指数的对数级位宽"
      ],
      "Objective Function": "计算并返回 x 的 n 次幂函数值（即 x^n）",
      "Algorithmic Invariant": [
        "通过二进制拆分维护当前底数幂：cur_power = x^(2^k)，每次自乘实现倍增",
        "从低位到高位扫描 n 的二进制位，若第 i 位为 1，则将 x^(2^i) 累乘入结果",
        "结果变量 res 始终满足：res = x^(已处理的二进制位所代表的指数)",
        "每轮迭代保持：res * (x^(2^k))^remaining_bits = x^n（不变式）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": [
            -2147483648,
            2147483647
          ],
          "x 的精度": "浮点数（保留5位小数）",
          "输出值域限制": [
            -10000,
            10000
          ]
        },
        "输入形式": [
          "单组输入（可扩展为多组测试用例）",
          "离线计算（可改造为在线查询多个幂次）"
        ],
        "数值类型变化": [
          "x 是否为整数",
          "n 是否非负（去掉负指数）",
          "是否支持模意义下快速幂（如大数取模）"
        ],
        "运算约束": [
          "是否要求高精度浮点",
          "是否允许溢出或需要异常处理",
          "是否加入矩阵/多项式快速幂（结构推广）"
        ],
        "算法路径变体": [
          "递归 vs 迭代实现",
          "左移位扫描 vs 右移位扫描",
          "是否隐藏快速幂意图（例如伪装成字符串指数）"
        ]
      }
    }
  },
  {
    "title": "训练计划 II",
    "slug": "lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof",
    "schema": {
      "Input Structure": {
        "type": "Singly Linked List",
        "node_value_range": "0 <= head[i] <= 100",
        "length_range": "1 <= n <= 100",
        "head": "head node of the linked list",
        "element_type": "integer"
      },
      "Core Constraint": {
        "constraint": "The kth node from the end can only be determined after traversing the full length of the list, due to singly linked structure.",
        "implication": "No random access; position from end requires either two passes or pointer separation in one pass."
      },
      "Objective Function": {
        "goal": "Return the node at position (n - cnt + 1) from the beginning, i.e., the cnt-th node from the end",
        "output_type": "ListNode* (sub-list starting from the target node)"
      },
      "Algorithmic Invariant": {
        "invariant": "Maintain two pointers: fast and slow. The fast pointer leads by exactly cnt steps. When fast reaches the end, slow is at the target node.",
        "proof_condition": "Distance between fast and slow remains constant (cnt); correctness follows from relative positioning in a linear sequence.",
        "movement_rule": "Both pointers move one step at a time after initial gap is established."
      },
      "Transformable Parameters": {
        "n_magnitude": "Small scale (≤ 100), suitable for single traversal",
        "data_order": "Sequential, irreversible traversal",
        "is_circular": false,
        "multiple_test_cases": false,
        "online_input": false,
        "operation_variants": [
          "Support delete operation on found node",
          "Find middle node (cnt = n//2)",
          "Check if list is palindrome (using reverse from mid)",
          "Input as array with skip links (simulate linked behavior)"
        ],
        "extension_dimensions": [
          "Doubly linked list variant",
          "Return value instead of node/sublist",
          "cnt > length allowed (return null)"
        ]
      }
    }
  },
  {
    "title": "螺旋遍历二维数组",
    "slug": "shun-shi-zhen-da-yin-ju-zhen-lcof",
    "schema": {
      "Input Structure": [
        "二维数组 A[0..m-1][0..n-1]",
        "m 和 n 表示行数和列数，满足 0 <= m <= 100, 0 <= n <= 100",
        "数组元素为整数（类型未限定，但通常为 int）",
        "矩阵可能为空（即 m=0 或 n=0）"
      ],
      "Core Constraint": [
        "遍历顺序严格遵循螺旋模式：向右 → 向下 → 向左 → 向上",
        "每完成一圈外层边界遍历，进入内层子矩阵重复相同过程",
        "每个元素仅被访问一次",
        "方向切换发生在当前边界已完全遍历或即将越界时"
      ],
      "Objective Function": "构造并返回一个一维数组，表示按螺旋顺序访问的所有元素序列",
      "Algorithmic Invariant": [
        "使用四个指针维护当前待遍历的边界：top, bottom, left, right",
        "每次沿一个方向遍历完整的一行或一列后，相应边界收缩（如 top++）",
        "指针移动保证不会重复访问已处理的元素",
        "循环终止条件为 top > bottom 或 left > right",
        "方向轮转顺序固定，且与边界状态一致"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m 和 n 的范围": [
            "小规模（≤100）",
            "可扩展至更大规模（如 1e5，需考虑效率变形）"
          ]
        },
        "矩阵形状": [
          "矩形（m ≠ n）",
          "正方形（m = n）",
          "退化情况（单行、单列、空矩阵）"
        ],
        "输入形式": [
          "静态离线输入",
          "在线流式输入（逐行/逐元素输入，要求实时输出螺旋序列）"
        ],
        "是否多组数据": false,
        "遍历模式变体": [
          "起始位置变化（如从右上角开始）",
          "旋转方向变化（顺时针 vs 逆时针）",
          "步长控制（跳跃式螺旋）"
        ],
        "输出要求": [
          "仅返回遍历序列",
          "同时返回坐标路径",
          "可视化动画模拟（非算法题但可衍生）"
        ],
        "结构维度扩展": [
          "三维螺旋遍历（立方体层序展开）",
          "环形缓冲区映射",
          "不规则区域的螺旋填充"
        ]
      }
    }
  },
  {
    "title": "位 1 的个数",
    "slug": "er-jin-zhi-zhong-1de-ge-shu-lcof",
    "schema": {
      "Input Structure": [
        "无符号32位整数（以二进制串形式输入）",
        "固定长度为32的二进制序列",
        "每一位为 '0' 或 '1'"
      ],
      "Core Constraint": [
        "数字的二进制表示是固定的、不可变的",
        "每一位独立，仅需判断是否为 '1'",
        "不存在依赖关系或顺序约束，可逐位处理"
      ],
      "Objective Function": "计数：统计二进制串中 '1' 的位数（汉明重量）",
      "Algorithmic Invariant": [
        "已处理的高位部分的计数结果不会受后续低位影响",
        "可通过位运算逐位剥离最低位 '1'（如 n & (n-1)）",
        "每次操作减少一个 '1'，直到 n 变为 0",
        "循环不变量：当前计数值等于已访问的 '1' 的个数"
      ],
      "Transformable Parameters": {
        "数据规模": "32位（固定），也可扩展至64位或任意k位",
        "输入形式": [
          "原始整数形式（内部按位处理）",
          "直接输入二进制字符串"
        ],
        "是否多组数据": "可支持批量查询多个整数的汉明重量",
        "是否在线": "可设计为动态更新整数并实时返回权重",
        "值域变化": "从无符号到有符号整数（不影响二进制表示）",
        "目标变形": [
          "改为统计 '0' 的个数",
          "求最长连续 '1' 子串长度",
          "判断是否为2的幂（恰好一个'1'）",
          "计算与全1串的汉明距离"
        ],
        "操作类型扩展": "支持单点修改某一位后重新计算权重（可结合树状数组/线段树）"
      }
    }
  },
  {
    "title": "训练计划 I",
    "slug": "diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "0 <= n <= 50000",
        "value_range": "0 <= actions[i] <= 10000",
        "duplicates_allowed": true,
        "sorted": false
      },
      "Core Constraint": {
        "partition_condition": "odd numbers must precede even numbers",
        "relative_order_not_preserved": true,
        "inplace_rearrangement": true
      },
      "Objective Function": "rearrange the array such that all odd numbers appear before all even numbers",
      "Algorithmic Invariant": {
        "two_pointers": true,
        "left_pointer_property": "all elements to the left of left pointer are odd",
        "right_pointer_property": "all elements to the right of right pointer are even",
        "pointer_movement_rule": "if left element is odd, move left forward; if right element is even, move right backward; otherwise swap and adjust both",
        "invariance_guarantee": "after each step, the partial solution maintains correctness in partitioned regions"
      },
      "Transformable Parameters": {
        "n_value": "50000",
        "value_domain": "[0, 10000]",
        "order_preservation_required": false,
        "input_dimensions": "1D",
        "data_streaming": false,
        "online_queries": false,
        "multiple_test_cases": false,
        "custom_predicate": true,
        "generalized_partition": [
          "separate based on modulo condition (e.g., %3==0)",
          "tri-partition (e.g., negative/non-negative/positive)",
          "circular array variant",
          "stable version requiring relative order preservation"
        ]
      }
    }
  },
  {
    "title": "有效数字",
    "slug": "biao-shi-shu-zhi-de-zi-fu-chuan-lcof",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n（1 ≤ n ≤ 20）",
        "字符集：数字 '0'-'9'，符号 '+' 和 '-'，指数标记 'e' 或 'E'，小数点 '.'，空格 ' '",
        "输入为单个字符串，表示一个可能包含前导/尾随空格的数值表达式"
      ],
      "Core Constraint": [
        "有效数字的结构是分段确定的：可选空格 → 符号位 → 数字/小数部分 → 可选指数部分 → 可选空格",
        "小数和整数有明确定义的语法结构，不允许非法组合（如孤立的 '.' 或 'e'）",
        "指数部分必须后跟一个完整的整数（含可选符号），不能是小数",
        "整个解析过程具有状态转移特性：当前字符只能在合法状态下被接受，并转移到下一状态"
      ],
      "Objective Function": "判定给定字符串是否构成一个有效数字（布尔判断：存在性判定）",
      "Algorithmic Invariant": [
        "使用有限状态自动机（FSA）时，每一步转移保持‘当前前缀合法’的不变性",
        "双指针或逐字符扫描过程中，维护当前所处的语法阶段（如符号位、整数部、小数部、指数部等），确保转移路径唯一且完整",
        "一旦进入非法状态，不可恢复；最终必须处于“合法终止状态”"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题较小（≤20），可扩展至长串流式处理",
        "值域": "仅限于 ASCII 字符子集，可考虑 Unicode 数字或科学计数法变体",
        "是否有序": "输入顺序固定，但可设计乱序干扰字符版本",
        "是否循环": "否，线性结构",
        "是否多组输入": "原题单例，可改为多组测试用例",
        "是否在线": "原始为离线，可改造为字符流在线判断（支持回滚或增量解析）",
        "语法灵活性": [
          "允许/禁止前导零",
          "是否接受 '.45' 或 '45.' 形式",
          "是否允许多个指数符号（如 'e10e2'）",
          "是否支持 '+' 单独出现"
        ]
      }
    }
  },
  {
    "title": "判断对称二叉树",
    "slug": "dui-cheng-de-er-cha-shu-lcof",
    "schema": {
      "Input Structure": {
        "type": "Binary Tree",
        "representation": "TreeNode root",
        "node_count_range": "0 <= n <= 1000",
        "value_domain": "Integer, no restriction on values",
        "structure_property": "Unordered binary tree, each node has at most two children"
      },
      "Core Constraint": {
        "constraint": "Tree symmetry is defined recursively: two subtrees are symmetric if their roots have equal values, and the left subtree of one is symmetric to the right subtree of the other, and vice versa.",
        "structural_dependency": "Symmetry requires mirror-like correspondence between left and right subtrees across the root",
        "local_global_relationship": "Global symmetry depends on pairwise local symmetry of corresponding nodes in mirrored positions"
      },
      "Objective Function": {
        "objective": "Determine whether the binary tree is symmetric around its center (i.e., axisymmetric)",
        "function_type": "Decision Problem",
        "output": "boolean: true if the tree is symmetric, false otherwise"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "At each recursive step, two nodes are compared for value equality and structural mirroring.",
          "The traversal follows a synchronized path: (left child of node1 vs right child of node2) and (right child of node1 vs left child of node2).",
          "Null nodes are handled symmetrically: both null → valid; only one null → invalid.",
          "State correctness is preserved: if all recursive calls return true, the overall tree is symmetric."
        ],
        "main_method": "Recursive dual traversal (symmetric DFS)",
        "alternative_formulation": "Iterative BFS using queue to compare pairs of nodes level by level"
      },
      "Transformable Parameters": {
        "n_size": "0 <= n <= 1000",
        "value_range": "Node values can be any integer",
        "tree_properties": [
          "Whether the tree is complete/full/perfect",
          "Whether node values are distinct or repeated"
        ],
        "input_form": [
          "Root pointer (standard)",
          "Array representation of tree (e.g., [6,7,7,8,9,9,8])"
        ],
        "output_form": [
          "Single boolean decision",
          "Return the list of asymmetric node pairs (debug mode)",
          "Count number of symmetric levels"
        ],
        "data_mode": [
          "Offline: entire tree given upfront",
          "Online: stream of queries checking symmetry after dynamic updates (insert/delete)"
        ],
        "constraint_variants": [
          "k-ary tree symmetry (not just binary)",
          "Rotational symmetry instead of reflection symmetry",
          "Fuzzy symmetry: allow up to k mismatches"
        ]
      }
    }
  },
  {
    "title": "翻转二叉树",
    "slug": "er-cha-shu-de-jing-xiang-lcof",
    "schema": {
      "Input Structure": "二叉树的根节点 root；每个节点具有左子树、右子树和整数值 val；节点数目范围 [0, 100]；-100 <= Node.val <= 100",
      "Core Constraint": "左右翻转操作定义为：对每个非叶子节点，交换其左子树与右子树；结构上仅依赖局部子树可独立递归处理；翻转后原左子树成为右子树，原右子树成为左子树",
      "Objective Function": "返回完成左右翻转后的二叉树根节点（构造类问题）",
      "Algorithmic Invariant": "后序遍历或先序遍历时，子树翻转完成后父节点才进行指针交换；任意子树的翻转状态不影响其他分支的处理顺序；递归过程中树的拓扑结构保持完整",
      "Transformable Parameters": {
        "数据规模": "节点数 ∈ [0, 100] → 可扩展至 [0, 1e5] 支持大规模树",
        "值域": "-100 <= val <= 100 → 可推广至任意整数或浮点数",
        "是否多组数据": "否 → 可改为多组测试用例输入",
        "是否在线": "离线处理单棵树 → 可设计为支持动态插入/删除后的实时翻转维护",
        "输入形式": "数组表示层序遍历 → 可变更为前序+中序输入或指针引用结构",
        "树类型限制": "普通二叉树 → 可限定为满二叉树、完全二叉树、BST（此时翻转破坏有序性）"
      }
    }
  },
  {
    "title": "子结构判断",
    "slug": "shu-de-zi-jie-gou-lcof",
    "schema": "{\n  \"Input Structure\": [\n    \"二叉树 tree1，节点数 n ∈ [0, 10000]\",\n    \"二叉树 tree2，节点数 m ∈ [0, 10000]\",\n    \"每个节点包含整数值 val 和左右子节点指针\",\n    \"树以根节点引用形式给出\"\n  ],\n  \"Core Constraint\": [\n    \"子树匹配要求结构完全相同且对应节点值相等\",\n    \"tree2 必须与 tree1 中某一子树精确匹配（从某个节点出发的完整子树）\",\n    \"空树不视为合法子树（即 tree2 为空时返回 false）\",\n    \"匹配具有局部性：只需存在一个起始节点使得递归匹配成功\"\n  ],\n  \"Objective Function\": \"判定是否存在 tree1 的某个节点，以其为根的子树与 tree2 具有相同的结构和节点值（布尔判定问题）\",\n  \"Algorithmic Invariant\": [\n    \"递归匹配过程中，当前节点值相等是继续深入的前提\",\n    \"一旦发现某路径上结构或值不匹配，则该分支可剪枝\",\n    \"主遍历可在任意节点触发子树匹配检查，失败不影响其他候选节点尝试\",\n    \"子树匹配过程满足自相似性：两棵树根节点匹配 ⇒ 递归检查左右子树\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"tree1 节点数上限\": 10000,\n      \"tree2 节点数上限\": 10000,\n      \"可扩展至更大规模并引入时间复杂度约束\"\n    },\n    \"输入形式\": [\n      \"是否以数组形式序列化输入（如层序遍历表示）\",\n      \"是否支持多组测试用例批量输入\",\n      \"是否在线流式构建树结构\"\n    ],\n    \"树的性质\": [\n      \"是否为二叉搜索树（可优化搜索范围）\",\n      \"是否允许空树作为有效子树（改变边界条件）\",\n      \"是否考虑同构而非严格结构一致（如左右子树交换视为相同）\"\n    ],\n    \"目标函数变化\": [\n      \"计数类：统计 tree1 中与 tree2 相同的子树数量\",\n      \"最小化：寻找最小子树满足包含 tree2 为子结构\",\n      \"构造类：输出所有匹配的子树根节点\"\n    ],\n    \"约束变换\": [\n      \"放宽匹配条件：允许值近似（如差值 ≤ ε）\",\n      \"加入标签匹配：仅部分节点需匹配值\",\n      \"动态更新：支持插入/删除节点后重新判断\"\n    ]\n  }\n}"
  },
  {
    "title": "训练计划 IV",
    "slug": "he-bing-liang-ge-pai-xu-de-lian-biao-lcof",
    "schema": {
      "Input Structure": [
        "两个有序单向链表 l1 和 l2，每个节点包含一个整数值和指向下一个节点的指针",
        "链表长度 n, m 满足 0 <= n, m <= 1000",
        "节点值为整数（可重复）"
      ],
      "Core Constraint": [
        "输入链表各自保持升序排列",
        "合并过程只能通过移动指针拼接原有节点，不能创建新节点（除虚拟头节点外）",
        "输出链表必须维持全局升序性质"
      ],
      "Objective Function": "将两个有序链表合并为一个新的有序链表并返回其头节点",
      "Algorithmic Invariant": [
        "维护两个指针分别指向当前待比较的 l1 和 l2 节点",
        "使用一个结果指针按序链接较小值节点，保证已合并部分始终有序",
        "每一步选择不会破坏后续可合并性：即局部最优选择（较小值）是全局最优解的一部分",
        "双指针推进满足贪心选择性质：一旦某节点被选中，其前驱关系不再改变"
      ],
      "Transformable Parameters": {
        "数据规模": "链表长度范围 [0, 1000]，可调整至更大（如支持 1e5）以要求 O(n) 解法",
        "值域": "节点值是否允许负数、大整数或浮点数",
        "有序性": "是否严格递增 / 非递减；是否降序输入需升序输出",
        "链表类型": "是否循环链表、双向链表、带哨兵节点",
        "输入形式": "是否多组测试用例、是否在线流式输入两个链表",
        "操作限制": "是否禁止修改原链表结构（强制拷贝）、是否允许递归实现",
        "输出要求": "返回头节点 vs 返回数组形式 vs 输出遍历序列"
      }
    }
  },
  {
    "title": "砍竹子 II",
    "slug": "jian-sheng-zi-ii-lcof",
    "schema": {
      "Input Structure": "正整数 bamboo_len（表示竹子的总长度，2 <= bamboo_len <= 1000）",
      "Core Constraint": "必须将 bamboo_len 拆分为至少两个正整数段，且每段长度之和等于原长度；乘积最大化依赖于尽可能多地使用长度为 3 的段（数学可证：当 n > 4 时，拆分成多个 3 可逼近最大乘积）",
      "Objective Function": "求所有可能拆分方案中，各段长度乘积的最大值（结果对 1e9+7 取模）",
      "Algorithmic Invariant": "贪心策略成立：优先拆出尽可能多的 3；若剩余部分为 1，则回退一个 3 并改为拆成两个 2（因 3*1 < 2*2）；该策略在所有最优解中保持不变",
      "Transformable Parameters": {
        "n 的数量级": "bamboo_len ∈ [2, 1000]（可扩展至更大规模如 1e9，在线性或对数时间算法下）",
        "值域限制": "是否允许段长为 1（本题允许），或加入最小段长约束（如每段 ≥2）",
        "目标函数变化": "从最大乘积 → 最小乘积 / 不同目标（如最大 GCD / LCM）",
        "是否取模": "是否需要取模 1e9+7，或输出完整大数",
        "拆分数目约束": "是否指定恰好拆成 k 段（变为参数化 DP 问题）",
        "是否多组输入": "单次输入 vs 多组测试数据批量处理",
        "在线/离线": "是否支持动态查询不同 bamboo_len 的结果（预处理表）"
      }
    }
  },
  {
    "title": "砍竹子 I",
    "slug": "jian-sheng-zi-lcof",
    "schema": {
      "Input Structure": [
        "正整数 bamboo_len（表示竹子总长度）",
        "2 <= bamboo_len <= 58",
        "需将 bamboo_len 分割为若干个正整数之和"
      ],
      "Core Constraint": [
        "分割后的每段长度必须为正整数",
        "至少分割成 2 段",
        "乘积最大化依赖于尽可能多地使用长度为 2 和 3 的段，尤其是优先使用 3（数学可证）",
        "当剩余长度为 4 时应保留为 2+2 而非继续拆出 3+1"
      ],
      "Objective Function": "求所有可能分割方案中，各段长度乘积的最大值（最大化）",
      "Algorithmic Invariant": [
        "若当前长度 > 4，则每次尽可能拆出长度为 3 的段不会破坏最优性",
        "局部贪心选择（取3）可导致全局最优解",
        "动态规划状态转移：dp[i] = max(max(j, dp[j]) * max(i-j, dp[i-j])) for j in [1, i//2]]",
        "状态单调性：随着长度增加，最大乘积非递减"
      ],
      "Transformable Parameters": [
        "bamboo_len 的范围：[2, 58] → 可扩展至更大规模（如 1e6，在线处理）",
        "是否允许段长为 1：本题允许，但最优解中尽量避免",
        "是否限定分割段数 k：可变为‘恰好分为 k 段’的约束变体",
        "目标函数变化：从‘最大乘积’变为‘最小乘积’或‘乘积计数’",
        "输入形式：单次输入 → 多组测试数据批量输入",
        "是否在线：静态输入 → 动态询问不同 bamboo_len 的结果（可预处理打表）",
        "是否要求构造最优方案：仅返回值 vs 返回具体分段方式"
      ]
    }
  },
  {
    "title": "推理二叉树",
    "slug": "zhong-jian-er-cha-shu-lcof",
    "schema": {
      "Input Structure": [
        "长度相等的两个一维数组 preorder[1..n] 和 inorder[1..n]",
        "preorder 表示二叉树的先序遍历序列",
        "inorder 表示二叉树的中序遍历序列",
        "数组元素均为整数，且无重复值",
        "1 <= n <= 3000",
        "值域：-3000 <= preorder[i], inorder[i] <= 3000"
      ],
      "Core Constraint": [
        "先序遍历的结构为 [根 | 左子树先序 | 右子树先序]",
        "中序遍历的结构为 [左子树中序 | 根 | 右子树中序]",
        "通过 preorder 确定当前子树的根节点",
        "通过 inorder 定位根的位置，从而划分左右子树的节点集合",
        "左右子树的节点集合在 preorder 和 inorder 中保持一致"
      ],
      "Objective Function": [
        "构造并返回原始二叉树的根节点",
        "输出形式为二叉树的层序遍历表示（题目隐含）"
      ],
      "Algorithmic Invariant": [
        "每次递归调用都能唯一确定当前子树的根节点（来自 preorder 的当前首元素）",
        "通过哈希表快速定位根在 inorder 中的位置，保证分割正确性",
        "子问题规模严格递减（子树节点数减少），确保递归终止",
        "已处理的 preorder 元素不再重复使用（可通过索引推进或切片保证）"
      ],
      "Transformable Parameters": [
        "n 的数量级：可扩展至支持更大的树（如 1e5，需优化为迭代或索引传递）",
        "是否允许重复值（当前不允许，若允许则需额外约束）",
        "输入形式：是否使用链表结构 / 是否在线流式输入 preorder 和 inorder",
        "是否多组数据：批量构造多棵二叉树",
        "遍历类型变化：例如 preorder + postorder（无法唯一构造）、postorder + inorder",
        "是否要求非递归实现（栈模拟）",
        "是否只返回某种遍历结果而非树结构（简化输出）",
        "是否加入删除操作（动态重构）"
      ]
    }
  },
  {
    "title": "图书整理 I",
    "slug": "cong-wei-dao-tou-da-yin-lian-biao-lcof",
    "schema": {
      "Input Structure": {
        "type": "linked_list",
        "node_value": "integer",
        "length_range": "0 <= n <= 10000",
        "order": "arbitrary",
        "duplicates_allowed": true
      },
      "Core Constraint": {
        "constraint": "链表结构仅支持顺序访问，无法随机访问；必须通过遍历完成逆序",
        "implication": "直接逆序输出需要额外空间或修改原链表指针"
      },
      "Objective Function": {
        "type": "constructive",
        "goal": "返回链表节点值的逆序序列"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "栈中元素始终为已遍历节点值的逆序存储",
          "递归调用栈深度与链表长度一致，回溯时自然形成逆序",
          "若原地反转链表，则反转后的链表头指向原尾部，遍历即得逆序输出"
        ],
        "optimality_condition": "三种方法（辅助栈、递归、原地反转）在时间复杂度 O(n) 下均为最优，空间复杂度分别为 O(n) 和 O(1)（原地反转）"
      },
      "Transformable Parameters": {
        "n_range": [
          0,
          10000
        ],
        "value_domain": "integer",
        "input_form": [
          "array_representation",
          "head_pointer"
        ],
        "output_form": [
          "array",
          "print_each_element"
        ],
        "online_query": false,
        "mutable_structure": false,
        "multiple_test_cases": true,
        "allow_modification": true
      }
    }
  },
  {
    "title": "衣橱整理",
    "slug": "ji-qi-ren-de-yun-dong-fan-wei-lcof",
    "schema": {
      "Input Structure": [
        "二维网格 grid[0..m-1][0..n-1]",
        "整数 m, n 表示网格行数和列数，1 <= m, n <= 100",
        "整数 cnt 表示阈值，0 <= cnt <= 20",
        "digit(x) 定义为 x 的十进制各位数字之和"
      ],
      "Core Constraint": [
        "机器人只能从 (0,0) 出发，每次向右或向下移动一格",
        "不能进入满足 digit(i) + digit(j) > cnt 的格子 (i,j)",
        "移动路径必须在网格范围内（不越界）"
      ],
      "Objective Function": "计数：统计所有可以从 (0,0) 出发通过合法移动到达的格子数量（即能整理的格子总数）",
      "Algorithmic Invariant": [
        "可达性具有单调性：若 (i,j) 不可达，则其右下区域（i',j' >= i,j）中大多数状态也无法通过更优路径到达（结合剪枝）",
        "使用 BFS 或 DFS 遍历时，每个格子只需访问一次（无环图上的连通分量搜索）",
        "状态转移仅依赖当前位置是否合法及前驱是否可达，满足动态规划或搜索的最优子结构"
      ],
      "Transformable Parameters": [
        "网格维度：1D（线性路径）↔ 2D ↔ 3D 或环形网格",
        "移动方向约束：仅右/下 → 四方向 → 八方向 → 自定义跳转规则",
        "进入条件变化：digit(i)+digit(j) ≤ cnt → ≥ cnt / ≡ k mod p / 包含某数字等",
        "目标函数变换：计数 → 判定是否存在路径到终点 → 求最长路径长度 → 构造字典序最小路径",
        "数据规模：m,n ≤ 100 → 可扩展至 1e5（要求 O(1) 或数学解法）",
        "起始点变化：固定 (0,0) → 给定起点 (si,sj) → 多个起点联合覆盖",
        "是否在线：静态输入 → 动态修改 cnt 或网格障碍后查询",
        "是否允许重复访问：否 → 是（需考虑状态去重机制）"
      ]
    }
  },
  {
    "title": "路径加密",
    "slug": "ti-huan-kong-ge-lcof",
    "schema": {
      "Input Structure": [
        "字符串 path",
        "字符集：可包含字母、数字、点号 '.' 等 ASCII 字符",
        "以字符 '.' 作为分隔符",
        "0 <= path.length <= 10000"
      ],
      "Core Constraint": [
        "分隔符 '.' 必须被替换为空格 ' '",
        "非分隔符字符保持原顺序不变",
        "连续的 '.' 应被替换为多个空格（即逐个替换）",
        "路径中不涉及相对路径或特殊语义（如 \"..\" 或 \".\" 表示当前目录）"
      ],
      "Objective Function": "构造并返回将所有 '.' 替换为空格后的字符串",
      "Algorithmic Invariant": [
        "遍历过程中，已处理部分的字符替换是最终确定的",
        "未处理部分的结构不影响已替换区域",
        "替换操作具有局部独立性与顺序不变性"
      ],
      "Transformable Parameters": {
        "分隔符类型": [
          ".",
          "可变参数：例如改为 ',' 或 ';'"
        ],
        "替换目标字符": [
          " ",
          "可变参数：例如替换为 '-' 或 '+'"
        ],
        "是否压缩空白": [
          false,
          "例如多个 '.' 只替换为一个空格"
        ],
        "输入形式": [
          "单字符串",
          "可扩展为字符串数组批量处理"
        ],
        "数据规模": [
          "path.length <= 10000",
          "可调整至在线流式输入场景"
        ],
        "是否允许通配替换": [
          false,
          "例如正则模式替换，升级为更复杂加密规则"
        ],
        "是否原地操作": [
          false,
          "在可变字符串语言中可考虑原地优化"
        ]
      }
    }
  },
  {
    "title": "字母迷宫",
    "slug": "ju-zhen-zhong-de-lu-jing-lcof",
    "schema": {
      "Input Structure": {
        "type": "2D grid",
        "dimensions": "m x n",
        "element_type": "string (single character)",
        "grid_values": "uppercase/lowercase English letters",
        "target_word": "string of length ≥ 1",
        "constraints": [
          "1 <= m, n <= 6",
          "1 <= target.length <= 15"
        ]
      },
      "Core Constraint": {
        "path_continuity": "word must be formed by horizontally or vertically adjacent cells",
        "no_reuse": "each cell can be used at most once in a single path",
        "sequential_match": "characters must match the target word in exact order",
        "local_branching": "at each step, only four possible directions to explore"
      },
      "Objective Function": "determine whether the target word exists in the grid following the movement and usage rules (boolean decision problem)",
      "Algorithmic Invariant": {
        "backtrack_invariant": "when exploring a path, if current prefix matches target[0:k], then remaining suffix must be found in unvisited neighbors without violating constraints",
        "state_preservation": "visited status is maintained per DFS branch and restored upon backtracking",
        "pruning_condition": "if current character does not match target[k], prune this branch",
        "progress_guarantee": "each recursive call increases matched length by 1 or backtracks"
      },
      "Transformable Parameters": {
        "grid_size": "variable m, n; currently small (≤6), but can scale",
        "word_length": "bounded; can be extended or constrained",
        "character_set": "currently English letters; can generalize to arbitrary alphabet",
        "movement_rules": [
          "4-directional adjacency (can change to 8-directional)",
          "wrap-around (toroidal grid) as variant"
        ],
        "cell_usage_policy": [
          "no reuse (current)",
          "allow reuse with cooldown (dynamic constraint)"
        ],
        "input_mode": [
          "offline static grid",
          "online updates to grid or target"
        ],
        "output_type": [
          "existence (current)",
          "count of distinct paths",
          "shortest path to form word",
          "construct all valid paths"
        ],
        "additional_constraints": [
          "require path to avoid certain regions",
          "time-variant characters",
          "multi-player interference"
        ]
      }
    }
  },
  {
    "title": "库存管理 I",
    "slug": "xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof",
    "schema": {
      "Input Structure": "一维数组 stock[1..n]，表示非严格递增排序后经过旋转的整数序列；元素范围：-5000 <= stock[i] <= 5000；可能存在重复元素；1 <= n <= 5000",
      "Core Constraint": "原数组为非严格递增（升序）排列，后被旋转一次（即将前若干个元素依次移到末尾），导致形成一个或两个单调非减段；最小值位于第二段的起始位置（若存在旋转）或整个数组首部（无旋转）",
      "Objective Function": "返回旋转后数组中的最小元素值",
      "Algorithmic Invariant": "使用二分查找维护搜索区间 [l, r]，比较中点 mid 与右端点 r 的值：\n- 若 stock[mid] < stock[r]，则最小值在左半部分（含mid）\n- 若 stock[mid] > stock[r]，则最小值在右半部分（不含mid）\n- 若 stock[mid] == stock[r]，无法判断方向，缩小区间（r--）以保持正确性\n该过程保持最小值始终在当前区间内",
      "Transformable Parameters": {
        "是否允许重复元素": true,
        "原始顺序": "非严格递增",
        "旋转方式": "前k个元素移至末尾（k>=0）",
        "数据规模": "n <= 5000",
        "值域范围": [
          -5000,
          5000
        ],
        "是否多组输入": false,
        "是否在线处理": false,
        "目标函数变体": [
          "求最小值",
          "求旋转点索引",
          "判定是否发生旋转"
        ],
        "输入形式扩展": [
          "可改为循环数组形式输入",
          "支持动态修改后查询"
        ]
      }
    }
  },
  {
    "title": "跳跃训练",
    "slug": "qing-wa-tiao-tai-jie-wen-ti-lcof",
    "schema": {
      "Input Structure": "一维非负整数 n，表示平台格子数量（0 <= n <= 100）",
      "Core Constraint": "每次只能跳 1 个或 2 个格子；跳跃方式由前序状态唯一决定，具有无后效性",
      "Objective Function": "计算从起点跳到第 n 个格子的不同跳跃方式总数（计数问题），结果对 1e9+7 取模",
      "Algorithmic Invariant": "当前状态的方案数 = 前一个位置的方案数 + 前两个位置的方案数（斐波那契递推关系）；可通过滚动变量维护前两个状态，保证空间优化下的正确性",
      "Transformable Parameters": {
        "n 的数量级": "0 <= n <= 100（可扩展至更大规模，如 1e5 或 1e9）",
        "跳跃步长选项": "可变，例如 [1,2] → [1,3] → 任意给定集合 S",
        "是否取模": "是，模数为 1e9+7（可改为其他模数或不取模）",
        "是否多组输入": "否（可扩展为 T 组测试数据）",
        "是否在线": "否（可设计为动态查询不同 n 的结果）",
        "是否有障碍格": "无（可加入某些格子不可落脚的约束）"
      }
    }
  },
  {
    "title": "寻找目标值 - 二维数组",
    "slug": "er-wei-shu-zu-zhong-de-cha-zhao-lcof",
    "schema": {
      "Input Structure": "二维数组 plants[1..m][1..n]，其中每行从左到右非递减，每列从上到下非递减；元素为整数；m 和 n 满足 0 <= m, n <= 1000",
      "Core Constraint": "由于每行和每列为非递减序列，任意位置 (i,j) 的值不大于其右侧和下侧的元素；该结构支持从特定角点出发的单调路径搜索",
      "Objective Function": "判定目标值 target 是否存在于二维数组 plants 中",
      "Algorithmic Invariant": "从右上角 (0, n-1) 或左下角 (m-1, 0) 出发，根据当前值与 target 的比较决定移动方向（左移或下移/上移）：\n- 若 plants[i][j] == target，则找到解；\n- 若 plants[i][j] > target，则当前列下方所有元素均大于 target，可安全左移；\n- 若 plants[i][j] < target，则当前行左侧所有元素均小于 target，可安全下移（或上移，视起点而定）；\n- 每次移动保持目标若存在则仍在未访问子区域中的不变性",
      "Transformable Parameters": {
        "数据规模": "m 和 n 的数量级可变（如 1e3 → 1e5），影响是否允许 O(m+n) 解法",
        "数组性质": "是否严格递增 / 允许重复值 / 是否可为空矩阵",
        "目标函数变化": "由判定存在性改为计数出现次数或返回所有坐标位置",
        "输入形式": "是否多组查询（在线）、target 是否动态给出",
        "结构变形": "扩展至三维单调阵列、环形边界、非矩形网格",
        "约束隐藏": "不显式说明行列单调性，通过上下文暗示"
      }
    }
  },
  {
    "title": "寻找文件副本",
    "slug": "shu-zu-zhong-zhong-fu-de-shu-zi-lcof",
    "schema": {
      "Input Structure": "一维数组 documents[1..n]，其中每个元素为整数，满足 0 ≤ documents[i] ≤ n-1，且 2 <= n <= 100000",
      "Core Constraint": "所有文件 id 均在 [0, n-1] 范围内，数组长度为 n，存在至少一个重复元素；问题本质是利用值域与索引空间的映射关系进行原地判重",
      "Objective Function": "返回任意一个重复的文件 id",
      "Algorithmic Invariant": "由于值域为 [0, n-1]，可将数组本身作为哈希表：遍历过程中，将每个元素视为下标，并将其对应位置标记为负数以表示已访问；一旦遇到已为负数的位置，说明该下标对应的值重复出现",
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 100000",
        "值域约束": "documents[i] ∈ [0, n-1]（关键约束，支持原地哈希）",
        "是否有序": "否",
        "是否循环": "否",
        "是否多组输入": "否（可扩展为多组）",
        "是否在线": "否（可设计为流式输入下的布隆过滤器变形）",
        "输出要求": "任一重复元素（可变更为：所有重复元素 / 最早重复的元素 / 重复次数最多的元素）",
        "数据修改操作": "不允许修改原数组时需额外空间或 Floyd 判圈法"
      }
    }
  },
  {
    "title": "斐波那契数",
    "slug": "fei-bo-na-qi-shu-lie-lcof",
    "schema": {
      "Input Structure": [
        "整数 n，表示斐波那契数列的索引",
        "n 是非负整数，0 <= n <= 100",
        "输入为单一标量，无复杂数据结构"
      ],
      "Core Constraint": [
        "递推关系具有前向依赖性：F(n) = F(n-1) + F(n-2)，其中 n > 1",
        "初始条件固定：F(0) = 0, F(1) = 1",
        "每一项仅依赖于前两项，具有局部状态可压缩性"
      ],
      "Objective Function": [
        "计算第 n 项斐波那契数 F(n)",
        "目标函数为构造型（输出一个数值）",
        "结果需对 1e9+7 取模"
      ],
      "Algorithmic Invariant": [
        "状态转移过程中，只需维护前两个状态值即可推导当前值",
        "迭代推进时，历史状态可被安全丢弃而不影响后续计算",
        "模运算可在每一步进行，不影响最终结果（模运算的同余保持性）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题为 n <= 100；可扩展至 1e18（触发矩阵快速幂变形）",
        "初始条件是否可变": "如改为 F(0)=a, F(1)=b，变为广义斐波那契",
        "递推式形式": "可变换为线性递推：F(n) = a*F(n-1) + b*F(n-2)",
        "模数设置": "模数是否为质数、是否可变（影响逆元等操作）",
        "是否多组查询": "单次查询 → 多组 n 值在线查询（预处理可行性）",
        "是否要求输出路径或方案": "仅求值 → 输出所有中间项"
      }
    }
  },
  {
    "title": "图书整理 II",
    "slug": "yong-liang-ge-zhan-shi-xian-dui-lie-lcof",
    "schema": {
      "Input Structure": [
        "类方法调用序列：包含 'BookQueue'（构造）、'push(bookID)'、'pop()'",
        "每个 push 操作输入一个整数 bookID ∈ [1, 10000]",
        "操作总数 ≤ 10000",
        "数据结构需支持 FIFO 访问语义"
      ],
      "Core Constraint": [
        "只能使用栈结构（后进先出）实现队列（先进先出）",
        "每次 pop 必须返回最早未被取出的元素",
        "仅允许从容器顶部插入和删除元素",
        "必须在 O(1) 均摊时间内完成每个操作"
      ],
      "Objective Function": [
        "模拟队列行为：返回每次 pop 操作所借出的书籍值",
        "若队列为空则返回 -1",
        "输出为所有 pop 调用的结果序列"
      ],
      "Algorithmic Invariant": [
        "使用两个栈 s1（主栈）、s2（辅助栈）维护元素顺序",
        "当 s2 非空时，s2 栈顶即为当前最老元素",
        "当 s2 为空且需要 pop 时，将 s1 所有元素依次压入 s2，从而反转顺序",
        "每个元素最多被移动一次（保证均摊 O(1) 时间复杂度）"
      ],
      "Transformable Parameters": {
        "数据规模": "操作次数范围：1 到 10000",
        "值域约束": "bookID ∈ [1, 10000]",
        "是否多组数据": false,
        "是否在线": true,
        "输入形式": "离散的方法调用流（事件驱动）",
        "可变结构": [
          "改为使用单个队列模拟栈（逆向问题）",
          "扩展为支持 peek 操作",
          "加入 cancel 操作（取消最近还书）",
          "支持批量 push/pop",
          "限制栈深度，超出则拒绝还书"
        ]
      }
    }
  },
  {
    "title": "Smallest Difference LCCI",
    "slug": "smallest-difference-lcci",
    "schema": {
      "Input Structure": [
        "一维数组 a[1..n]，元素为整数",
        "一维数组 b[1..m]，元素为整数",
        "n, m ≥ 1，最大可达 10^5",
        "a[i], b[i] ∈ [-2147483648, 2147483647]"
      ],
      "Core Constraint": [
        "最小差绝对值仅可能出现在两个数组排序后相邻元素之间",
        "无全局依赖，但局部最优可通过排序+双指针逼近",
        "跨数组比较，需避免暴力枚举 O(nm)"
      ],
      "Objective Function": "求 min(|a[i] - b[j]|)，即两个数组中各取一个元素的最小绝对差值",
      "Algorithmic Invariant": [
        "双指针 i ∈ a, j ∈ b，初始指向各自首元素",
        "若 a[i] ≤ b[j]，则移动 i（因增大 a[i] 可能缩小差距）",
        "若 a[i] > b[j]，则移动 j",
        "每次移动后更新当前最小差，且不会遗漏更优解"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 数量级": [
            "1e3",
            "1e5",
            "可扩展至 1e6 在线场景"
          ]
        },
        "数组性质": [
          "是否已排序",
          "是否允许重复值",
          "是否为非负整数"
        ],
        "目标函数变形": [
          "返回差值 → 返回数值对",
          "最小差 → 最大差",
          "计数：有多少对差值等于最小值"
        ],
        "输入形式": [
          "静态一次性输入",
          "在线流式添加元素",
          "多组数组配对查询"
        ],
        "维度扩展": [
          "从两个数组 → 多个数组选最小差对",
          "从一维 → 二维坐标点集间最近距离"
        ],
        "约束变化": [
          "差值必须 ≤ K 的第一对",
          "要求 a[i] ≤ b[j] 条件下的最小差"
        ]
      }
    }
  },
  {
    "title": "Tic-Tac-Toe LCCI",
    "slug": "tic-tac-toe-lcci",
    "schema": {
      "Input Structure": "二维字符数组 board[1..N][1..N]，其中 N ≥ 1；每个元素 ∈ {'X', 'O', ' '}；表示 N×N 井字棋棋盘状态",
      "Core Constraint": "获胜条件由连续 N 个相同非空字符在任一行、列或一条主对角线上构成；游戏遵循轮流落子规则（先'O'后'X'），且输入保证符合历史合法性（无非法填充）",
      "Objective Function": "判断当前游戏状态：若存在胜者，返回胜者字符（'X' 或 'O'）；若无胜者但棋盘满，返回 'Draw'；若无胜者且仍有空位，返回 'Pending'",
      "Algorithmic Invariant": "胜负状态仅依赖于当前棋盘布局的行、列、对角线是否形成完整同字符序列；检查过程可独立遍历每行、每列和两条对角线；空位存在性可通过扫描判定而不影响胜负判断的正确性",
      "Transformable Parameters": [
        "N 的数量级（如 N ≤ 3, N ≤ 100, 或更大规模）",
        "是否允许不合法输入（需额外验证走子顺序）",
        "是否扩展为 K-in-a-row 胜利条件（K ≤ N）",
        "是否支持多组测试数据",
        "是否在线更新棋盘并实时查询状态",
        "输出形式变化：返回所有获胜路径 / 返回获胜步数估计 / 布尔判定是否可赢"
      ]
    }
  },
  {
    "title": "Intersection LCCI",
    "slug": "intersection-lcci",
    "schema": {
      "Input Structure": [
        "两条线段，每条线段由两个二维点表示：line = {start = (x1, y1), end = (x2, y2)}",
        "所有坐标均为实数，绝对值 ≤ 2^7",
        "输入保证为有效二维坐标"
      ],
      "Core Constraint": [
        "线段交点的存在性依赖于两线段所在直线的相对位置（相交、平行、重合）",
        "若两线段共线，则需判断是否有重叠区间",
        "交点必须同时落在两条线段的参数化区间 [0,1] 内",
        "浮点计算误差容忍度为 1e-6"
      ],
      "Objective Function": [
        "判定两条线段是否存在交点",
        "若存在唯一交点，返回该交点坐标",
        "若存在多个交点（即线段部分重叠），返回 X 值最小的点；X 相同则返回 Y 最小的点",
        "若无交点，返回空值"
      ],
      "Algorithmic Invariant": [
        "使用参数化方程表示线段：P = A + t*(B-A), t ∈ [0,1]",
        "通过叉积判断线段相对方向，利用方向性剪枝（如快速排斥、跨立实验）",
        "当且仅当两条线段互相‘跨立’或共线重叠时，才存在交点",
        "在共线情况下，投影到 x 或 y 轴求区间交集，并取字典序最小点",
        "数值稳定性保障：使用误差容限 1e-6 判断相等（如 t ≈ 0, t ≈ 1, 叉积 ≈ 0）"
      ],
      "Transformable Parameters": {
        "坐标值域": "abs(x), abs(y) ≤ 2^7 → 可扩展至 1e9 或支持浮点高精度",
        "维度扩展": "2D → 3D 线段求交（变为异面直线最近点对）",
        "输入形式": "单组两条线段 → 多组查询 / 批量线段求交",
        "数据流模式": "离线处理 → 在线插入线段并查询交点",
        "输出要求": "仅一个交点 → 返回所有交点 / 交点数量 / 重叠长度",
        "精度要求": "误差 1e-6 → 可调节 epsilon 或要求精确分数输出",
        "退化情况处理": "是否包含点线段（起点=终点）",
        "几何对象变更": "线段→射线→直线，改变参数区间 t ∈ [0,∞) 或 (-∞,∞)"
      }
    }
  },
  {
    "title": "Words Frequency LCCI",
    "slug": "words-frequency-lcci",
    "schema": {
      "Input Structure": [
        "字符串数组 book[1..n]",
        "每个元素 book[i] 是仅由小写字母组成的字符串",
        "1 <= n <= 100000",
        "1 <= len(book[i]) <= 10"
      ],
      "Core Constraint": [
        "单词出现频率的统计依赖于全局遍历与哈希映射的构建",
        "查询操作需在构造后高效响应，不能每次重新扫描全文",
        "相同字符串视为同一单词，区分大小写（但本题中输入全为小写）"
      ],
      "Objective Function": [
        "构造阶段：预处理书中所有单词，建立从单词到频次的映射",
        "查询阶段：对任意给定单词 word，返回其在 book 中的出现次数（计数型目标函数）"
      ],
      "Algorithmic Invariant": [
        "构造完成后，频次映射表保持不变，支持多次 O(1) 查询",
        "映射表的正确性由首次全量扫描保证，后续查询不改变状态",
        "即使查询未出现过的单词，也能通过默认值（如0）正确返回"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "book.length": "可变范围 [1, 100000] 或扩展至更大（如离线批处理场景）",
          "单词长度": "可扩展至更长（如支持自然语言文本）"
        },
        "输入形式": [
          "是否允许大写/混合大小写（影响是否需要归一化）",
          "是否支持标点符号或分词预处理（如从句子流中提取单词）",
          "输入由数组变为流式文本（在线读取文件）"
        ],
        "查询模式": [
          "是否单次查询 → 可变为多组批量查询",
          "是否支持模糊匹配（如前缀、拼写纠错）",
          "是否支持动态更新（插入新书页、删除单词等）→ 动态词频表"
        ],
        "存储与性能约束": [
          "是否限制内存使用 → 影响是否可用哈希表",
          "是否要求分布式处理（大数据量下使用 MapReduce 模式）"
        ],
        "输出形式": [
          "仅返回频次 → 可改为返回所有出现位置索引列表",
          "是否返回相对频率（占比）而非绝对计数"
        ],
        "多组数据": "支持多个独立的 book 实例并行存在",
        "在线/离线": "当前为离线构造 + 在线查询；可改造为完全在线（边读边查）"
      }
    }
  },
  {
    "title": "Swap Numbers LCCI",
    "slug": "swap-numbers-lcci",
    "schema": {
      "Input Structure": [
        "长度为 2 的整数数组 numbers = [a, b]",
        "numbers.length == 2",
        "元素值域：-2147483647 <= numbers[i] <= 2147483647",
        "输入类型：一维、定长、可含负数的整型数组"
      ],
      "Core Constraint": [
        "不允许使用临时变量进行交换",
        "只能通过数学运算或位运算原地修改两个变量",
        "操作必须满足可逆性与无损性",
        "核心限制：空间约束（O(1) 额外空间，且不能使用第三个变量）"
      ],
      "Objective Function": [
        "构造函数实现 a 与 b 的值交换",
        "目标函数类型：构造方案（输出交换后的数组）",
        "不涉及最优化、计数或判定，而是确定性变换"
      ],
      "Algorithmic Invariant": [
        "通过加减法或异或运算保持信息守恒：x ^ x = 0, x ^ 0 = x",
        "两次相同位运算可还原原值（自反性）",
        "中间状态包含原始两数的联合信息，支持无损分解",
        "每一步操作后系统状态唯一对应原始输入"
      ],
      "Transformable Parameters": {
        "数据类型": [
          "整数",
          "扩展可为浮点数（加减法适用）",
          "位运算仅适用于整型"
        ],
        "是否允许临时变量": [
          false,
          "true 则退化为平凡题"
        ],
        "数组长度": [
          2,
          "固定槽位：若 >2 则问题结构改变"
        ],
        "值域限制": [
          "存在溢出风险（加减法时）",
          "可设定是否检测溢出"
        ],
        "运算方式约束": [
          "仅允许算术运算",
          "仅允许位运算",
          "不限制方法"
        ],
        "是否在线": [
          false,
          "可设计为支持多次交换的交互式场景"
        ],
        "多组数据": [
          false,
          "可扩展为处理多对数字的批量输入"
        ]
      }
    }
  },
  {
    "title": "Sparse Array Search LCCI",
    "slug": "sparse-array-search-lcci",
    "schema": {
      "Input Structure": [
        "有序字符串数组 words[1..n]",
        "数组中包含非空字符串和空字符串（\"\"）",
        "字符串字典序排列（忽略空字符串）",
        "目标字符串 s"
      ],
      "Core Constraint": [
        "非空字符串保持升序排列，但空字符串随机散布",
        "无法直接使用标准二分查找，因存在空串干扰中点判断",
        "必须利用有序性加速搜索，避免线性扫描"
      ],
      "Objective Function": "在有序但含空串的数组中查找给定字符串 s 的索引；若不存在则返回 -1",
      "Algorithmic Invariant": [
        "维护搜索区间 [left, right]，保证目标若存在则必在此区间内",
        "每次选择中点 mid：若 words[mid] 为空，则向右寻找最近非空位置作为有效中点",
        "若有效中点值小于 s，则左边界可安全右移",
        "若有效中点值大于 s，则右边界可安全左移",
        "指针移动不破坏目标存在的可能性范围"
      ],
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 1000000]",
        "是否多组数据": false,
        "输入形式": "一次性离线输入",
        "是否在线": false,
        "空字符串密度": "可变（稀疏/密集）",
        "字符串内容类型": "仅小写字母 / 可扩展至大小写、特殊字符",
        "排序方式": "字典序 / 自定义排序规则",
        "输出要求": "首次出现索引 / 所有匹配位置列表",
        "是否允许修改数组": false
      }
    }
  },
  {
    "title": "Permutation I LCCI",
    "slug": "permutation-i-lcci",
    "schema": {
      "Input Structure": [
        "字符串 S，长度为 n",
        "字符均不相同（无重复字符）",
        "字符集为英文字母（大小写可能区分，但本题未指定，默认视为给定字符集）",
        "1 ≤ n ≤ 9"
      ],
      "Core Constraint": [
        "所有字符必须恰好使用一次",
        "每个排列是原字符串字符的一个全排列",
        "无重复字符 → 无需去重剪枝（基于字符值）",
        "排列顺序需按某种枚举顺序生成（如字典序或任意，题目未强制）"
      ],
      "Objective Function": "构造并返回字符串所有字符的全排列（即所有可能的排列方案）",
      "Algorithmic Invariant": [
        "递归/回溯过程中，已选字符集合与剩余字符集合互补且不相交",
        "每层递归选择一个未使用的字符，状态转移具有可逆性",
        "搜索空间为 n! 个叶子节点的排列树，路径构成合法解",
        "交换法或标记法可保证每个排列唯一生成"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题 [1,9] → 可扩展至更大但需考虑输出规模爆炸（指数级）",
        "字符是否重复": "可变为「含重复字符」→ 需增加去重逻辑（中间层母题）",
        "是否要求字典序输出": "原题未强制 → 可作为参数开关",
        "是否只计数而非构造": "目标函数可改为 '求排列总数' → 答案恒为 n!（数学解）",
        "输入形式": "单组输入 → 可改为多组字符串批量处理",
        "数据流化": "一次性输入 → 在线查询模式：每次添加一个字符，动态更新排列集（变形复杂）",
        "输出限制": "可限定只输出第 k 个排列（对应康托展开类题目）"
      }
    }
  },
  {
    "title": "Magic Index LCCI",
    "slug": "magic-index-lcci",
    "schema": {
      "Input Structure": [
        "一维数组 A[0..n-1]",
        "有序整数数组（非递减）",
        "元素可重复",
        "n ∈ [1, 1000000]",
        "A[i] 为整数（无显式值域限制，但通常在 int 范围内）"
      ],
      "Core Constraint": [
        "数组有序（非递减），允许重复元素",
        "魔术索引定义为满足 A[i] = i 的下标 i",
        "由于数组有序，若 A[i] > i，则对所有 j > i，有 A[j] ≥ A[i] > i ≤ j 不一定成立，但可利用跳跃剪枝",
        "存在多个魔术索引时，要求返回最小的索引"
      ],
      "Objective Function": [
        "判定是否存在魔术索引",
        "若存在，返回满足 A[i] = i 的最小索引 i",
        "若不存在，返回 -1"
      ],
      "Algorithmic Invariant": [
        "线性扫描时：遍历过程中一旦找到 A[i] = i 即可返回，因从左到右扫描保证第一个即最小",
        "跳跃优化剪枝：若当前 A[i] > i，则下一个可能的候选位置至少为 A[i]（因为数组非递减，A[j] ≥ A[i] > i，当 j < A[i] 时不可能有 A[j] = j），故可跳至 j = A[i]",
        "状态单调性：索引 i 单调递增，且利用数组有序性可跳过部分区间"
      ],
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 1000000]，支持大数组，需考虑 O(n) 或更优剪枝",
        "是否有序": "必须有序（非递减），否则无法剪枝；变形题可考虑无序下的暴力枚举",
        "是否允许重复": "是（本题关键点，区别于严格递增版本）",
        "值域范围": "A[i] 可为负数、零或正数，影响跳跃行为（如 A[i] < i 时不能跳）",
        "输入形式": "单组离线输入",
        "是否在线": "否，一次性输入数组",
        "目标函数变体": [
          "返回所有魔术索引（计数 / 列表）",
          "返回最大魔术索引",
          "判断是否存在（布尔型）"
        ],
        "约束变换": [
          "A[i] = i + c（偏移魔术索引）",
          "A[A[i]] = i（嵌套条件）",
          "二维数组中的魔术索引（如矩阵中 A[i][j] = i + j）"
        ],
        "算法优化空间": "是否启用跳跃剪枝（基于 A[i] 值跳转）以实现均摊亚线性时间"
      }
    }
  },
  {
    "title": "Eight Queens LCCI",
    "slug": "eight-queens-lcci",
    "schema": {
      "Input Structure": "二维棋盘 grid[1..n][1..n]；整数 n 表示棋盘大小（N×N）；每行、每列、每条对角线至多放置一个皇后",
      "Core Constraint": "任意两个皇后不能位于同一行、同一列或同一条对角线（包括所有主对角线和反对角线）；即：对于任意两个皇后位置 (i, j) 和 (k, l)，需满足 i ≠ k, j ≠ l, |i - k| ≠ |j - l|",
      "Objective Function": "构造并输出所有合法的 N 皇后摆放方案（构造方案类问题）",
      "Algorithmic Invariant": "逐行放置皇后，利用列、主对角线、反对角线的占用状态进行剪枝；已放置的皇后不会影响后续合法性的判断前提下，递归扩展当前部分解；使用 visited 数组或哈希集合维护列与两条对角线的状态单调性",
      "Transformable Parameters": {
        "n 的数量级": "n ≤ 10（经典离线求解）；可扩展为 n 较大时仅计数或输出前 k 个解",
        "值域": "n ≥ 1；允许 n = 0 的边界情况",
        "是否有序": "固定按行优先顺序生成方案",
        "是否循环": "否",
        "是否多组输入": "可支持多个 n 的测试用例",
        "是否在线": "通常为离线；可变形为在线查询某个特定 n 的第 k 个解",
        "输出形式": "输出所有完整方案；可变体：只返回方案总数（LeetCode 52）、返回字典序第 k 个方案、仅验证某一布局是否合法",
        "约束变化": "可改为 M 皇后在 N×N 棋盘上；或允许某些格子禁止放置；或加入旋转/翻转去重"
      }
    }
  },
  {
    "title": "Search Rotate Array LCCI",
    "slug": "search-rotate-array-lcci",
    "schema": {
      "Input Structure": "一维整数数组 arr[1..n]，长度 n ∈ [1, 1000000]；数组原本为非递减有序序列，经若干次左/右循环移位（旋转）得到；可能存在重复元素",
      "Core Constraint": "数组具有单一旋转点（或无旋转），即存在分界点 p，使得 arr[p+1..n] + arr[1..p] 构成非递减序列；目标元素的查找需利用局部有序性进行区间判定",
      "Objective Function": "在旋转后的有序数组中查找指定 target 元素，若存在则返回其索引值最小的位置，否则返回 -1",
      "Algorithmic Invariant": "使用双指针二分搜索框架：维护搜索区间 [l, r]，每次取中点 mid。通过比较 arr[mid] 与 arr[r] 判断哪一侧保持单调性；若 target 落在单调区间内，则收缩至该侧，否则进入另一侧；重复此过程直到定位最小索引的目标值",
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 1000000]",
        "是否允许重复元素": true,
        "是否要求最小索引": true,
        "原数组顺序": "升序",
        "旋转方向": "可左旋或右旋（等效处理）",
        "目标函数变体": [
          "返回任意位置索引",
          "返回是否存在（布尔型输出）",
          "返回所有匹配索引"
        ],
        "输入形式": "单组离线输入",
        "是否在线查询": false,
        "数组维度扩展": "可推广至二维旋转矩阵搜索（如 LeetCode 240 类结构）",
        "约束变化": [
          "限制最多旋转一次 → 可旋转多次（当前题设）",
          "引入负数或浮点数"
        ]
      }
    }
  },
  {
    "title": "Coin LCCI",
    "slug": "coin-lcci",
    "schema": {
      "Input Structure": [
        "整数 n，表示目标金额（0 <= n <= 1000000）",
        "硬币面值集合 C = {1, 5, 10, 25}，数量不限"
      ],
      "Core Constraint": [
        "每个硬币可重复使用无限次",
        "组合顺序不同但组成相同的视为同一种方案（即组合问题，非排列）",
        "子问题具有最优子结构与重叠子问题性质"
      ],
      "Objective Function": "计算凑出总金额 n 的不同组合数（结果模 1000000007）",
      "Algorithmic Invariant": [
        "动态规划状态 dp[i] 表示凑出金额 i 的方案数",
        "状态转移按硬币种类逐层更新：对每种硬币 c，执行 dp[j] += dp[j - c]（j 从小到大）",
        "外层循环遍历硬币，内层循环遍历金额，保证每种硬币被整体考虑，避免重复计数"
      ],
      "Transformable Parameters": {
        "n 的数量级": "0 <= n <= 1e6",
        "硬币面值集合": "可变，如 {1,2,5} 或自定义数组",
        "是否模运算": "是，模 1000000007；可改为其他模数或不取模",
        "是否允许硬币顺序不同视为不同方案": "否；若为是，则变为‘排列’问题，解法需调整",
        "是否多组输入": "否；可扩展为多组测试数据",
        "是否在线查询": "否；可改造为预处理 dp 后支持多次查询",
        "硬币数量是否受限": "否；可改为有限个数，转化为多重背包"
      }
    }
  },
  {
    "title": "Reverse Bits LCCI",
    "slug": "reverse-bits-lcci",
    "schema": {
      "Input Structure": "32位有符号整数 num（可转换为长度为32的二进制位数组，每位为0或1）",
      "Core Constraint": "最多允许将一个0翻转为1；翻转后连续1的长度由该位两侧连续1段是否可通过此翻转连接决定",
      "Objective Function": "最大化翻转后连续1的最长长度",
      "Algorithmic Invariant": "维护当前连续1段的长度，并记录前一段连续1的长度；当遇到0时，若可翻转，则新长度 = 前一段长度 + 1（翻转位）+ 当前段长度；使用滑动窗口或状态机保证每段只被处理一次且状态转移不破坏最优性",
      "Transformable Parameters": {
        "数据规模": "固定为32位（可推广至n位二进制串）",
        "值域": "32位整数范围 [-2^31, 2^31-1]（当前仅非负有效，因负数补码含前导1）",
        "是否有序": "二进制位序列按从低到高或高到低顺序排列，顺序影响遍历方向但不影响结构",
        "是否循环": "否（可变形为环形二进制串，首位相连）",
        "是否多组输入": "单组输入（可扩展为多组查询）",
        "是否在线": "离线处理（可设计为支持位动态更新的场景）",
        "翻转次数限制": "1次（可参数化为k次翻转，退化为'最多k次替换的最长全1子串'问题）"
      }
    }
  },
  {
    "title": "Check SubTree LCCI",
    "slug": "check-subtree-lcci",
    "schema": {
      "Input Structure": "两棵二叉树 T1 和 T2，节点数范围 [0, 20000]；每个节点具有左子、右子和整数值；树以指针/引用形式给出（非数组表示）",
      "Core Constraint": "T2 是 T1 的子树当且仅当存在 T1 中的某个节点 n，使得以 n 为根的子树与 T2 在结构和所有节点值上完全相同；子树匹配要求精确递归同构",
      "Objective Function": "判定是否存在这样的节点 n ∈ T1，使得 subtree(n) ≡ T2（完全同构）",
      "Algorithmic Invariant": "在遍历 T1 的过程中，一旦发现某节点值与 T2 根节点相等，则启动同步深度优先比较：两棵树的左右子树递归向下比对，任何差异即可剪枝；若未找到匹配，则继续在 T1 中搜索其他候选节点",
      "Transformable Parameters": {
        "数据规模": "T1 和 T2 节点数上限可变（如从千级到百万级），影响是否需哈希优化",
        "是否有序": "若树为二叉搜索树，则可利用中序性质加速剪枝",
        "输入形式": "是否以序列化字符串输入（如先序+空标记）、是否支持离线预处理",
        "多组查询": "是否多次查询不同 T2 对同一 T1 的子树关系，决定是否构建 T1 的子树指纹库",
        "在线性": "T1 是否动态更新（插入/删除），要求在线判断子树包含",
        "同构定义": "是否允许值映射同构（如双射替换）而非严格相等",
        "输出要求": "仅判定存在性 / 输出所有匹配位置 / 输出首次匹配路径"
      }
    }
  },
  {
    "title": "Animal Shelter LCCI",
    "slug": "animal-shelter-lcci",
    "schema": {
      "Input Structure": [
        "双队列结构：两个 FIFO 队列分别存储猫和狗的入列记录",
        "每个动物表示为二元组 [id: int, type: int]，其中 type ∈ {0 (猫), 1 (狗)}",
        "操作序列由字符串指令数组与对应参数构成",
        "收纳所最大容量为 20000"
      ],
      "Core Constraint": [
        "整体收养顺序基于动物进入时间（全局时间戳）",
        "dequeueAny 必须返回所有现存动物中最早入所者",
        "dequeueCat / dequeueDog 返回对应种类中最老动物",
        "不同种类之间共享全局时间顺序，但按类型隔离存储"
      ],
      "Objective Function": [
        "模拟先进先出的多类型队列系统",
        "支持按类型或全局最小时间戳出队",
        "实现 enqueue、dequeueAny、dequeueDog、dequeueCat 四种操作"
      ],
      "Algorithmic Invariant": [
        "每个类型的队列内部保持时间单调递增（即 FIFO 顺序）",
        "全局最老动物必为 catQueue.head 与 dogQueue.head 中时间戳更小者",
        "enqueue 操作仅追加到对应类型队列尾部，不破坏有序性",
        "dequeueAny 可通过比较两队列头部时间戳决定出队来源"
      ],
      "Transformable Parameters": {
        "数据规模": "最大动物数量 ≤ 20000",
        "种类数量": "可扩展至 K 种动物（当前 K=2）",
        "是否有序": "各类型队列必须维持入队时间序",
        "输入形式": "批量操作序列输入，含方法名与参数列表",
        "是否多组数据": "支持连续调用，状态跨操作持久化",
        "是否在线": "是，操作实时生效",
        "类型编码方式": "当前为 0/1 编码，可改为字符串或其他标识",
        "时间戳管理方式": "隐式通过入队顺序确定，无需显式存储时间戳",
        "输出格式": "返回 [id, type] 或 [-1,-1] 表示空"
      }
    }
  },
  {
    "title": "Binary Number to String LCCI",
    "slug": "binary-number-to-string-lcci",
    "schema": {
      "Input Structure": "一个介于 0 和 1 之间的实数 x（double 类型），0 < x < 1，输入小数位数最多 6 位",
      "Core Constraint": "二进制小数每一位对应 1/2^k 的权重；每次将当前数乘以 2，取整数部分作为下一位二进制位，余下小数部分继续处理；若过程中出现循环或长度超过 30 位（总长度超 32 包括 '0.'）则无法精确表示",
      "Objective Function": "构造该实数的二进制字符串表达式；若无法在 32 位内精确表示，则返回 \"ERROR\"",
      "Algorithmic Invariant": "每一步中，当前剩余数值 r 满足：r = Σ_{k=1}^{m} b_k / 2^k + ε，其中 b_k 是已确定的二进制位，ε 是待处理的余项；乘 2 操作等价于左移一位并提取最高位；一旦余项为 0 则表示结束；长度控制保证过程可在有限步终止",
      "Transformable Parameters": {
        "精度位数限制": "32 位（包含 '0.'），有效二进制位最多 30 位",
        "是否允许循环小数输出": "否，仅允许有限表示",
        "输入范围": "严格在 (0,1) 区间内",
        "输入形式": "double 类型浮点数",
        "输出形式": "字符串格式 \"0.b_1b_2...b_n\" 或 \"ERROR\"",
        "是否多组数据": false,
        "是否在线处理": false,
        "值域扩展可能性": "可推广到负小数或大于 1 的数，但本题限定为正纯小数"
      }
    }
  },
  {
    "title": "Pile Box LCCI",
    "slug": "pile-box-lcci",
    "schema": {
      "Input Structure": [
        "给定 n 个箱子，每个箱子表示为三元组 [w_i, d_i, h_i]",
        "所有值均为正整数",
        "输入形式：二维数组 box[1..n][3]，其中 box[i] = [w_i, d_i, h_i]"
      ],
      "Core Constraint": [
        "箱子不能旋转（即维度固定）",
        "堆叠时，下方箱子的宽度、深度、高度必须严格大于上方箱子对应维度",
        "堆叠关系构成有向无环图（DAG），若箱子 j 可放在箱子 i 上，则存在边 i → j",
        "问题等价于在 DAG 上求最长路径（最大权重路径，权重为箱子高度）"
      ],
      "Objective Function": "最大化堆叠箱子的总高度（即路径上所有节点权重之和）",
      "Algorithmic Invariant": [
        "排序某一维度可打破循环依赖，实现动态规划状态转移",
        "按某一维（如宽度）升序排序后，对于任意 j < i，若 box[j] 可置于 box[i] 下方，则可在 dp[i] 中考虑 dp[j] + h_i",
        "状态单调性：dp[i] 表示以第 i 个箱子为顶箱时的最大高度，可通过枚举所有合法前驱更新",
        "贪心不可行，但 DP 状态间独立且满足最优子结构"
      ],
      "Transformable Parameters": {
        "n 的数量级": "≤ 3000（当前），可扩展至 1e4 或更高以要求优化）",
        "是否允许翻转箱子": "否（当前），可改为允许翻转 → 每个箱子生成多个变体",
        "维度数": "3D（当前），可降为 2D（如仅宽深）或升为 k 维",
        "比较方式": "严格大于（>），可改为 ≥（非严格堆叠）",
        "输入形式": "一次性离线输入，可改为在线流式添加箱子",
        "输出目标": "最大高度（当前），可改为计数方案数 / 输出具体堆叠序列",
        "是否多组数据": "单组（当前），可支持多组测试用例",
        "排序维度选择": "可自由选择按 w/d/h 排序，影响 DP 枚举顺序"
      }
    }
  },
  {
    "title": "Color Fill LCCI",
    "slug": "color-fill-lcci",
    "schema": {
      "Input Structure": [
        "二维数组 image[0..m-1][0..n-1]，其中 m = image.length, n = image[0].length",
        "每个元素为非负整数，表示颜色值，取值范围 [0, 65535]",
        "给定起始坐标 (sr, sc)，满足 0 <= sr < m, 0 <= sc < n",
        "给定新颜色 newColor ∈ [0, 65535]"
      ],
      "Core Constraint": [
        "连通区域由四连通（上下左右）且颜色相同的格子构成",
        "仅当一个格子与起始点 (sr, sc) 所在连通块四连通可达且原始颜色相同，才被填充",
        "若 newColor 等于初始位置的原始颜色，则无需修改（避免无限递归或重复访问）"
      ],
      "Objective Function": [
        "构造并返回填充后的新图像",
        "目标是将起始点所处的四连通同色区域全部更改为 newColor"
      ],
      "Algorithmic Invariant": [
        "使用 DFS 或 BFS 遍历时，已访问的节点不会被重复处理",
        "每一步扩展仅限于四邻域中颜色等于原始颜色 oldColor 的节点",
        "遍历过程中保持连通性不变：当前访问节点始终属于原连通区域",
        "若 oldColor == newColor，则直接返回原图，避免无效操作"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": [
            "小规模：≤ 50",
            "中等规模：≤ 1000",
            "大规模：支持 > 1e4"
          ],
          "是否可接受稀疏矩阵优化": false
        },
        "连通性定义": [
          "四连通（上下左右）",
          "八连通（包括对角线）——可作为变形题"
        ],
        "颜色约束": [
          "颜色值是否允许负数",
          "是否允许多种原始颜色同时被填充（如阈值范围内）"
        ],
        "目标函数变化": [
          "计数被填充的像素个数",
          "判断某个目标坐标是否被影响",
          "最小步数到达某点（引入路径代价）"
        ],
        "输入形式": [
          "单次离线输入",
          "在线查询：多次填充操作，支持撤销 / 历史版本"
        ],
        "边界条件": [
          "是否循环网格（环形图像：首尾行/列相连）",
          "是否有障碍格子（不可访问）"
        ],
        "算法要求": [
          "是否强制使用迭代而非递归（防栈溢出）",
          "是否要求最优空间复杂度（如用原数组标记）"
        ]
      }
    }
  },
  {
    "title": "Bracket LCCI",
    "slug": "bracket-lcci",
    "schema": {
      "Input Structure": "整数 n（表示括号对数）",
      "Core Constraint": "生成的字符串必须由 n 个 '(' 和 n 个 ')' 组成，且任意前缀中 '(' 的数量不少于 ')' 的数量",
      "Objective Function": "构造所有合法的括号组合方案",
      "Algorithmic Invariant": "在递归/回溯过程中，维护当前左括号和右括号的使用数量；只有当剩余可用的左括号数 ≤ 右括号数时，才能添加 ')' 以保证合法性；每一步扩展都保持部分解的合法性",
      "Transformable Parameters": {
        "n 的数量级": "1 ≤ n ≤ 8（可调整为更大规模，引入剪枝或打表优化）",
        "是否允许重复子集": "否（可变：是否去重）",
        "括号类型": "单类型 '()'（可扩展为多类型：'[]', '{}', '<>' 等）",
        "输出形式": "返回字符串列表（可变为在线生成器、计数、第 k 个序列等）",
        "是否多组输入": "否（可改为多组测试用例）",
        "是否在线查询": "否（可设计为支持动态查询第 k 个合法序列）"
      }
    }
  },
  {
    "title": "Recursive Mulitply LCCI",
    "slug": "recursive-mulitply-lcci",
    "schema": {
      "Input Structure": [
        "两个正整数 A 和 B",
        "A ≥ 1, B ≥ 1",
        "数据类型为整数，值域在不溢出范围内"
      ],
      "Core Constraint": [
        "不能使用乘法运算符 *",
        "仅允许使用加法 (+)、减法 (-)、位移操作 (<<, >>)",
        "必须使用递归实现",
        "要求操作次数尽可能少（吝啬使用）"
      ],
      "Objective Function": "计算两正整数 A 与 B 的乘积（即返回 A * B）",
      "Algorithmic Invariant": [
        "利用位移将乘法转化为加法：A * B = A * (2^k * B') → 转化为 A << k 的加法累加",
        "每次递归分解较大的乘数（如 B）为偶数/奇数情况处理：若 B 为偶数，则 mul(A, B) = mul(A + A, B >> 1)；若 B 为奇数，则 mul(A, B) = A + mul(A, B - 1)",
        "递归过程中保持数值等价性不变：每一步变换后总乘积值不变",
        "通过选择较小的数作为递归深度控制变量，保证递归深度最小化"
      ],
      "Transformable Parameters": {
        "数据规模": "A 和 B 的值域范围（例如：≤ 1e9，是否支持大整数）",
        "是否允许非递归解法": "约束是否强制递归",
        "可用操作集": [
          "是否允许位移",
          "是否允许加法",
          "是否允许减法",
          "是否允许比较操作"
        ],
        "优化目标": [
          "最小化递归深度",
          "最小化加法次数",
          "最小化总操作数"
        ],
        "输入形式": [
          "是否支持负整数扩展",
          "是否支持零值输入",
          "是否多组测试用例"
        ],
        "在线处理": "是否要求支持动态查询或连续乘法任务"
      }
    }
  },
  {
    "title": "Power Set LCCI",
    "slug": "power-set-lcci",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "元素互不重复",
        "元素类型为整数",
        "无序集合"
      ],
      "Core Constraint": [
        "子集由原集合中元素的选或不选决定",
        "每个元素在子集中至多出现一次",
        "所有子集必须唯一，且不能包含重复组合"
      ],
      "Objective Function": "生成原集合的所有可能子集（幂集），即求集合的全部组合（包括空集）",
      "Algorithmic Invariant": [
        "通过逐个添加元素扩展已有子集，保持已生成子集的完整性",
        "使用递归/回溯时，每层决策对应一个元素的选取状态（选或不选）",
        "使用位运算枚举时，每一位对应一个元素的存在状态，0 表示不选，1 表示选",
        "生成过程中不会产生重复子集（因输入无重复且控制枚举方式）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "n ≤ 20（适合枚举）",
        "值域": "整数范围可变（如 int 范围）",
        "是否有序": "输入是否有序可作为变形（影响输出顺序）",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "输出形式": [
          "返回所有子集的列表",
          "是否要求按字典序输出",
          "是否只返回特定大小的子集（如 k-subsets）",
          "是否仅需返回子集数量（计数问题）"
        ],
        "操作类型扩展": [
          "支持动态增删元素下的幂集维护（在线版本）",
          "加入去重逻辑以处理含重复元素的输入（变为子集 II 类型题）"
        ]
      }
    }
  },
  {
    "title": "Three Steps Problem LCCI",
    "slug": "three-steps-problem-lcci",
    "schema": {
      "Input Structure": "正整数 n，表示楼梯的阶数（一维离散规模参数），n ∈ [1, 1000000]",
      "Core Constraint": "每一步只能走 1 阶、2 阶或 3 阶；上楼方式由当前台阶数依赖前三个台阶的路径总数决定，具有线性递推结构",
      "Objective Function": "计算从第 0 阶到第 n 阶的所有不同上楼方式总数，并对结果取模 1000000007",
      "Algorithmic Invariant": "设 dp[i] 表示到达第 i 阶的方法数，则有 dp[i] = (dp[i-1] + dp[i-2] + dp[i-3]) % 1000000007；状态转移仅依赖前三个状态，且顺序推进可保证无后效性",
      "Transformable Parameters": {
        "n 的数量级": "1 ≤ n ≤ 10^6",
        "步长选项": "可改为 {1,2}, {1,3}, {1,2,4} 等集合",
        "模数": "可变模数（如 1e9+7, 998244353）或无需取模",
        "是否多组输入": "可扩展为多个 n 的查询",
        "是否在线": "可设计为动态增加台阶或实时询问某阶方案数",
        "限制条件": "可加入某些台阶不可踩、连续走相同步数受限等约束"
      }
    }
  },
  {
    "title": "Draw Line LCCI",
    "slug": "draw-line-lcci",
    "schema": "{\n  \"Input Structure\": [\n    \"一维数组 screen[0..length-1]，每个元素为 int（32 位有符号整数）\",\n    \"屏幕共有若干行，每行 w 个像素点（w 可被 32 整除）\",\n    \"每 32 个像素点打包成一个 int 存储\",\n    \"总长度 length 满足：length >= ceil(w / 32) * (y + 1)\",\n    \"初始所有像素为 0\",\n    \"绘制直线的参数：x1, x2, y（起点列、终点列、行号）\"\n  ],\n  \"Core Constraint\": [\n    \"像素按行主序存储，每行分为若干 int 单元，每个 int 表示连续 32 列\",\n    \"一个 int 内的像素从高位到低位对应列索引从小到大\",\n    \"同一行内绘制区间 [x1, x2] 所在的像素需置为 1\",\n    \"int 是有符号类型，但操作应基于其二进制位进行（补码表示）\"\n  ],\n  \"Objective Function\": [\n    \"构造并返回更新后的 screen 数组\",\n    \"目标是输出绘制直线后的一维数组表示\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"对每一整数单元（int），可通过位运算快速构造连续 1 的掩码\",\n    \"对于跨多个 int 的区间，首尾单元部分覆盖，中间单元全覆盖\",\n    \"位掩码构造满足：lowbit 到 highbit 连续置 1，其余为 0\",\n    \"每次更新不依赖前一个 int 的状态，可独立处理每个受影响的 int\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"length\": \"1 <= length <= 1e5\",\n      \"w\": \"1 <= w <= 3e5，且 w % 32 == 0\",\n      \"y\": \"0 <= y <= 10（行数少，可视为常数级）\"\n    },\n    \"值域与类型\": {\n      \"int 为 32 位有符号整数，但按位操作\",\n      \"输出中允许负数（如 -1 表示全 1）\"\n    },\n    \"输入形式\": {\n      \"一次性离线输入\",\n      \"给定 x1, x2, y 直接计算\"\n    },\n    \"是否多组数据\": false,\n    \"是否在线\": false,\n    \"结构变形空间\": [\n      \"w 不被 32 整除（需跨 int 边界处理）\",\n      \"支持删除/撤销操作\",\n      \"支持多条线绘制\",\n      \"支持斜线或矩形绘制\",\n      \"改为 bitset 或 byte 数组存储\",\n      \"查询某位置是否被绘制（转为判定问题）\"\n    ]\n  }\n}"
  },
  {
    "title": "Stack of Plates LCCI",
    "slug": "stack-of-plates-lcci",
    "schema": {
      "Input Structure": [
        "一个整数 capacity，表示每个子栈的最大容量（cap > 0）",
        "一系列操作序列：包含 'StackOfPlates'（构造）、'push(val)'、'pop()'、'popAt(index)'",
        "所有操作以字符串方法名和对应参数的形式给出",
        "数据类型：操作为字符串数组，参数为整数或整数数组"
      ],
      "Core Constraint": [
        "当某个子栈的大小达到 capacity 时，后续 push 操作必须创建新的子栈",
        "pop() 行为等价于单一栈：即从最后一个非空子栈中弹出元素",
        "popAt(index) 从第 index 个子栈弹出元素，若该栈存在且非空；否则返回 -1",
        "任何栈在变为空后必须被删除，以维持结构紧凑性",
        "索引从 0 开始，子栈按插入顺序编号"
      ],
      "Objective Function": [
        "模拟具有分段容量限制的栈集合行为",
        "支持标准栈操作（push/pop）的同时，提供按子栈索引的 popAt 操作",
        "目标是正确返回每次操作的结果（特别是 pop 和 popAt 的返回值）"
      ],
      "Algorithmic Invariant": [
        "子栈列表始终按顺序存储，且不包含任何空栈（空栈立即被移除）",
        "push 操作只影响最后一个子栈，除非其已满，则新建一个",
        "pop 操作逻辑上等同于全局栈，即作用于最后一个非空子栈",
        "popAt 操作不影响其他子栈的完整性，但可能导致中间子栈被删除",
        "每个子栈的 size <= capacity，且仅在添加元素时可能达到上限"
      ],
      "Transformable Parameters": {
        "capacity 的取值范围": "1 <= cap <= 1000（可调整至更大或极小值）",
        "操作次数规模": "1 <= operations.length <= 1000（可扩展为大规模在线操作）",
        "是否允许负值元素": "当前允许任意整数，可限制为非负或正整数",
        "是否保持连续性": "当前 pop 后删除空栈，可改为保留空位（如模拟物理位置）",
        "多组测试数据": "示例为单组，可设计为多组独立用例",
        "在线/离线模式": "当前为离线操作序列，可改造为实时在线请求流",
        "扩展操作": [
          "peek(), peekAt(index)",
          "pushAt(index, val)",
          "支持 roll-back 或 undo 操作"
        ],
        "子栈类型变化": "可将子栈替换为队列或其他容器，形成变体"
      }
    }
  },
  {
    "title": "Sum Lists LCCI",
    "slug": "sum-lists-lcci",
    "schema": {
      "Input Structure": "两个单向链表 L1 和 L2，每个节点包含一个非负整数（0–9），表示一个十进制整数的数位；基础版本中数位逆序存储（个位在头），进阶版本中数位正序存储（高位在头）；链表长度分别为 n 和 m",
      "Core Constraint": "加法运算需按位进行，当前位之和可能产生进位，影响下一位计算；逆序结构天然支持从低位到高位顺序处理；正序结构则需要后序遍历或栈辅助以实现从低位开始相加",
      "Objective Function": "构造一个新的链表，表示两个输入链表所代表整数的和，结果链表也应按相同存储方式（逆序/正序）返回",
      "Algorithmic Invariant": "维护一个进位变量 carry，初始为 0；每轮处理一对对应位（若存在）与 carry 的和，生成新节点值并更新 carry；对于逆序结构，可直接同步遍历；对于正序结构，可通过双栈或递归回溯保证从最低位开始处理，且不破坏原链表结构",
      "Transformable Parameters": [
        "链表是否逆序存放数位（基础：是，进阶：否）",
        "是否允许前导零节点",
        "数值范围是否导致溢出长整型（需完全链表模拟）",
        "是否多组数据输入",
        "是否要求原地修改（空间优化）",
        "进位机制是否扩展为 k 进制（如二进制链表加法）",
        "是否在线流式输入（逐位动态到达）",
        "是否推广至多个链表求和"
      ]
    }
  },
  {
    "title": "Delete Middle Node LCCI",
    "slug": "delete-middle-node-lcci",
    "schema": {
      "Input Structure": "单向链表 ListNode *node，其中 node 是某个中间节点（非头、非尾），链表节点值为整数，节点数量 ≥ 3",
      "Core Constraint": "只能访问给定的中间节点，无法访问其前驱节点；删除操作必须通过修改当前节点及其后继节点实现",
      "Objective Function": "在不返回任何值的前提下，将给定的中间节点从链表中逻辑删除，使链表结构正确且仅缺失该节点",
      "Algorithmic Invariant": "通过将后继节点的值复制到当前节点，并删除后继节点，可等价实现当前节点的删除；此操作不会影响链表其余部分的连通性与顺序",
      "Transformable Parameters": [
        "是否允许多次调用删除（连续删除场景）",
        "链表是否为循环链表",
        "输入是否可能为头节点或尾节点（边界条件变化）",
        "节点值是否唯一（影响复制值的语义清晰性）",
        "是否要求保持内存地址一致性（即真正释放原节点）",
        "是否在线：动态插入后立即删除",
        "数据规模：链表长度 n 的范围（如 3 ≤ n ≤ 1000）"
      ]
    }
  },
  {
    "title": "Zero Matrix LCCI",
    "slug": "zero-matrix-lcci",
    "schema": {
      "Input Structure": "二维矩阵 M × N，元素为整数；M ≥ 1, N ≥ 1",
      "Core Constraint": "若某个元素为0，则其所在行和列的所有元素必须被清零；清零操作具有传播性但不可重复触发新清零",
      "Objective Function": "构造清零后的矩阵",
      "Algorithmic Invariant": "使用第一行和第一列作为标记空间记录哪些行/列需要清零；通过额外布尔变量记录第一行/第一列本身是否原始包含0，避免信息冲突；遍历顺序保证标记阶段与更新阶段分离，不破坏未处理状态",
      "Transformable Parameters": {
        "Matrix Dimensions": "M, N 的数量级（如：≤100，≤10^4）",
        "Element Value Range": "整数范围（如：含负数、非负、仅0/1）",
        "Zero Density": "初始0的分布密度（稀疏/密集）",
        "In-place Required": "是否要求原地算法（空间O(1)）",
        "Online Variant": "是否支持动态修改后批量清零",
        "Output Form": "返回新矩阵或修改原矩阵",
        "Multiple Queries": "是否多次查询不同清零规则下的结果"
      }
    }
  },
  {
    "title": "Rotate Matrix LCCI",
    "slug": "rotate-matrix-lcci",
    "schema": {
      "Input Structure": "二维方阵 matrix[1..N][1..N]，其中 N ≥ 1；每个元素为整数（像素值）",
      "Core Constraint": "旋转操作必须在原地完成（不分配额外的二维数组空间）；旋转方向为顺时针90度；矩阵结构具有对称的环形分层结构，每一圈可独立处理",
      "Objective Function": "将输入矩阵顺时针旋转90度，并修改原矩阵实现原地变换",
      "Algorithmic Invariant": "将矩阵按同心环分层，每层由外向内依次旋转；每一环上的四个对应位置（上、右、下、左）可通过三次或四次交换完成轮换；任意时刻，已处理的环不会被后续操作影响",
      "Transformable Parameters": [
        "N 的数量级（如 N ≤ 10, N ≤ 1000）",
        "是否允许使用 O(N²) 额外空间（即非原地解法）",
        "旋转方向：顺时针 vs 逆时针",
        "旋转角度：90°, 180°, 270°, k×90°",
        "是否多组测试数据",
        "输入形式：是否在线输入矩阵（流式）",
        "矩阵形状：从 N×N 扩展到 M×N 矩形矩阵（变形题）",
        "是否要求输出每次交换的中间状态（调试模式）"
      ]
    }
  },
  {
    "title": "Palindrome Permutation LCCI",
    "slug": "palindrome-permutation-lcci",
    "schema": {
      "Input Structure": [
        "字符串 s",
        "s 的长度为 n",
        "字符集为小写英文字母（可扩展）",
        "输入为一维字符数组形式"
      ],
      "Core Constraint": [
        "回文串的排列中，至多允许一个字符出现奇数次（中心对称结构）",
        "其余所有字符必须成对出现（偶数次）",
        "字符顺序无关，仅频次分布决定可行性"
      ],
      "Objective Function": [
        "判定是否存在一种排列方式使得字符串构成回文串",
        "目标函数类型：判定问题（是/否）"
      ],
      "Algorithmic Invariant": [
        "字符频次的奇偶性统计具有不变性：交换字符位置不改变各字符出现次数的奇偶性",
        "使用哈希表或位掩码记录奇偶状态，遍历过程中可动态维护",
        "最终只需检查奇数频次字符个数 ≤ 1"
      ],
      "Transformable Parameters": {
        "n 的数量级": [
          "1 <= n <= 10^4",
          "可扩展至 10^6（在线处理）"
        ],
        "字符集类型": [
          "仅小写字母",
          "扩展至大写字母、数字、ASCII",
          "Unicode 支持"
        ],
        "是否区分大小写": [
          true,
          false
        ],
        "是否忽略空格与标点": [
          false,
          true
        ],
        "输入形式": [
          "单次字符串",
          "多组测试数据",
          "流式字符输入（在线）"
        ],
        "输出要求": [
          "返回布尔值",
          "返回具体回文构造方案",
          "返回最小修改步数以使其可排列为回文"
        ]
      }
    }
  },
  {
    "title": "Closed Number LCCI",
    "slug": "closed-number-lcci",
    "schema": {
      "Input Structure": "正整数 num，表示一个32位有符号整数范围内的正整数（1 ≤ num ≤ 2^31 - 1）",
      "Core Constraint": "目标数的二进制中1的个数必须与输入num相同；寻找的是严格大于和严格小于num的最接近值",
      "Objective Function": "找出两个数：一个是大于num且二进制中1的个数相同的最小整数（略大者），另一个是小于num且二进制中1的个数相同的最大整数（略小者）；若不存在则对应位置返回-1",
      "Algorithmic Invariant": "利用位运算性质：\n- 略大数：找到最右侧可左移的'10'模式，并将后续所有1紧缩到最低位\n- 略小数：找到最右侧可右移的'01'模式，并将后续所有0紧缩到低位，1集中于高位\n- 该构造过程保证了变化幅度最小，且保持popcount不变",
      "Transformable Parameters": {
        "数据规模": "num ∈ [1, 2147483647]，即32位有符号整数正数范围",
        "值域扩展": "是否允许负数？是否扩展到64位整数？",
        "输出形式": "返回数组长度为2，[next_larger, next_smaller]；可变体如仅求一个方向、或返回多个邻近值",
        "多组查询": "是否支持批量查询多个num的结果？",
        "在线性": "是否要求实时响应（如交互式系统中按需计算）？",
        "约束变形": "将'1的个数相同'替换为'0的个数相同'或'汉明权重±1'等"
      }
    }
  },
  {
    "title": "Exchange LCCI",
    "slug": "exchange-lcci",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "value_range": "[0, 2^30 - 1]",
        "representation": "binary bit array of length up to 30",
        "bit_indexing": "0-indexed from least significant bit (LSB)"
      },
      "Core Constraint": {
        "pairing_rule": "bits are paired as (0,1), (2,3), (4,5), ..., (2k, 2k+1)",
        "swap_scope": "only adjacent odd-even bit positions within each pair",
        "independence": "each pair is independent; no carry or arithmetic propagation"
      },
      "Objective Function": "construct a new integer by swapping every odd bit with its adjacent even bit (i.e., swap bit 2k and bit 2k+1 for all valid k)",
      "Algorithmic Invariant": {
        "mask_invariance": "use fixed bitmasks (e.g., 0xAAAAAAAA for odd bits, 0x55555555 for even bits) to isolate bit positions safely",
        "non_overlap": "odd and even bit masks are disjoint, ensuring no overlapping contribution during reconstruction",
        "reconstruction_rule": "after shifting isolated even bits left by 1 and odd bits right by 1, bitwise OR combines them without interference"
      },
      "Transformable Parameters": {
        "data_size": "bit width: 30 bits (can be generalized to n-bit integers)",
        "input_form": "single integer (can be extended to array of integers)",
        "output_form": "single transformed integer",
        "instruction_cost_model": "minimize number of operations (bitwise ops); suitable for low-level optimization",
        "generalization_potential": [
          "variable stride pairing (e.g., swap bits with distance d)",
          "cyclic bit pairing (ring structure)",
          "multi-group swaps (e.g., group by 4 bits and rotate)",
          "online version: support dynamic updates and queries on bit pairs"
        ],
        "constraints_on_num": {
          "signedness": "non-negative integers only",
          "overflow_behavior": "guaranteed no overflow in result"
        }
      }
    }
  },
  {
    "title": "Convert Integer LCCI",
    "slug": "convert-integer-lcci",
    "schema": {
      "Input Structure": [
        "两个32位整数 A 和 B",
        "A, B ∈ [-2147483648, 2147483647]",
        "按二进制位进行比较"
      ],
      "Core Constraint": [
        "位变化的判定基于异或（XOR）操作：相同位为0，不同位为1",
        "每一位独立影响结果，无前后依赖",
        "总变化位数等于 A XOR B 的二进制表示中1的个数（即汉明权重）"
      ],
      "Objective Function": "计算将整数 A 转换为整数 B 所需改变的二进制位的数量（最小位翻转次数）",
      "Algorithmic Invariant": [
        "异或运算保持位差异的完整性：(A ^ B) 的每一位为1当且仅当对应位不同",
        "汉明重量的计算过程可通过位运算技巧（如 n & (n-1)）逐步消除末尾1而不影响其余位的统计正确性",
        "位操作过程中数值的变化不改变已统计的位数"
      ],
      "Transformable Parameters": {
        "数据类型维度": [
          "从32位整数扩展到64位整数",
          "支持无符号整数"
        ],
        "目标函数变换": [
          "改为判定是否恰好需要k次位变化",
          "求最小/最大可能的位变化数（在A或B有约束时）",
          "计数满足转换代价≤K的B的个数"
        ],
        "输入形式": [
          "多组测试数据",
          "在线查询模式：动态给出A和B，实时返回答案"
        ],
        "操作限制": [
          "只允许使用特定位操作（如不能用内置__builtin_popcount）",
          "要求构造具体哪几位需要翻转"
        ],
        "扩展结构": [
          "推广到位向量或字符串（如二进制字符串间的编辑距离）",
          "多个目标数B₁, B₂,..., Bₖ，找最接近的"
        ]
      }
    }
  },
  {
    "title": "Insert Into Bits LCCI",
    "slug": "insert-into-bits-lcci",
    "schema": "{\n  \"Input Structure\": [\n    \"整数 N（32位有符号或无符号整型）\",\n    \"整数 M（32位有符号或无符号整型）\",\n    \"非负整数 i, j，表示比特位置区间，0 ≤ i ≤ j < 32\",\n    \"M 的二进制位数 ≤ j - i + 1\"\n  ],\n  \"Core Constraint\": [\n    \"N 的第 i 到 j 位将被完全替换为 M 的所有位\",\n    \"替换时 M 左对齐到 i 位（即 M 的最低位对应第 i 位）\",\n    \"未被覆盖的 N 的高位和低位保持不变\",\n    \"位操作需在不使用循环或条件判断的前提下可构造（适合位运算解法）\"\n  ],\n  \"Objective Function\": \"构造并返回更新后的整数 N，其第 i ~ j 位被 M 插入，其余位保留原值\",\n  \"Algorithmic Invariant\": [\n    \"通过位掩码（bitmask）隔离并清除 N 的第 i 到 j 位，保持其他位不变\",\n    \"M 可通过左移 i 位对齐到目标位置\",\n    \"掩码的构造具有确定性：low_mask = (1 << i) - 1，high_mask = ~((1 << (j + 1)) - 1)，中间段清零\",\n    \"最终结果 = (N & (high_mask | low_mask)) | (M << i)，操作满足结合性与无副作用\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n_bits\": 32,\n      \"支持扩展至64位\"\n    },\n    \"输入形式\": [\n      \"单组输入 / 多组测试用例\",\n      \"是否在线输入（动态参数流）\"\n    ],\n    \"M的填充方式\": [\n      \"左对齐插入（当前题设）\",\n      \"右对齐插入（变形：M 对齐到 j 位）\"\n    ],\n    \"约束条件变化\": [\n      \"i ~ j 不足以容纳 M → 需截断或报错\",\n      \"允许负数的补码表示参与操作\"\n    ],\n    \"输出要求\": [\n      \"仅返回数值\",\n      \"要求输出二进制字符串表示\",\n      \"逐位验证插入正确性\"\n    ],\n    \"操作类型扩展\": [\n      \"插入后要求统计 1 的个数（计数型目标函数）\",\n      \"支持多次插入（在线更新）\",\n      \"加入撤销操作（历史版本管理）\"\n    ]\n  }\n}"
  },
  {
    "title": "First Common Ancestor LCCI",
    "slug": "first-common-ancestor-lcci",
    "schema": {
      "Input Structure": "二叉树 T，根节点为 root；两个指定节点 p 和 q。所有节点值唯一，p ≠ q，且 p、q 均存在于树中。树以指针形式给出（非数组表示），每个节点包含 val, left, right。",
      "Core Constraint": "最近公共祖先（LCA）定义为：在树中同时是 p 和 q 的祖先的最低层节点。由于不是二叉搜索树，无法利用中序性质；必须通过递归路径回溯或路径追踪判断共同祖先。",
      "Objective Function": "找出并返回节点 p 和 q 的最近公共祖先节点（返回节点本身，而非值或路径）。",
      "Algorithmic Invariant": "采用后序遍历（DFS）递归结构：\n- 若当前子树同时包含 p 和 q，则该子树根可能是 LCA；\n- 一旦在某一节点左右子树分别找到 p 和 q，或一子树找到而另一子树为空但当前节点为 p 或 q，则当前节点即为 LCA；\n- 利用递归返回值传播已发现目标节点的信息，避免额外存储路径。",
      "Transformable Parameters": [
        "是否为二叉搜索树（可引入 BST 性质作为变形）",
        "树的形态：链状 / 完全二叉树 / 平衡树（影响时间复杂度分析）",
        "输入形式：树指针直接输入 vs 层序数组重建",
        "是否允许使用辅助数据结构（如显式保存路径）",
        "是否在线查询：多组 (p, q) 查询 → 可引入 Tarjan 离线算法或倍增预处理",
        "节点值是否唯一（若不唯一则需额外标识）",
        "是否支持动态更新（插入/删除节点）→ 动态树 LCA",
        "目标函数变化：求所有祖先集合 vs 仅最近一个",
        "扩展到普通树（N 叉树）"
      ]
    }
  },
  {
    "title": "Successor LCCI",
    "slug": "successor-lcci",
    "schema": {
      "Input Structure": "二叉搜索树（BST）的根节点 root，以及指向某个节点 p 的指针；树中每个节点具有左子、右子和父节点结构（或可通过遍历访问路径），节点值互不相同",
      "Core Constraint": "二叉搜索树的中序遍历具有严格单调递增性；目标节点 p 的中序后继取决于其在树中的位置：若 p 有右子树，则后继为其右子树中的最左节点；否则，需向上回溯至第一个以左子树包含 p 的祖先节点",
      "Objective Function": "找出并返回节点 p 在中序遍历序列中的下一个节点（即中序后继）；若不存在，则返回 null",
      "Algorithmic Invariant": "1. 若节点 p 存在右子树，则其中序后继为右子树中值最小（最左侧）的节点\n2. 若无右子树，则从 p 向上回溯时，保持一个候选祖先变量，仅当当前路径是从左子树向上返回时，该祖先才是合法后继\n3. 利用 BST 性质剪枝：在自顶向下搜索过程中，可比较节点值与 p->val 的大小关系来缩小搜索空间",
      "Transformable Parameters": {
        "是否包含父指针": "true / false（影响实现方式：是否需要显式维护路径栈）",
        "树的高度与数据规模 n": "n ≤ 1e5（离线静态树）或动态插入场景下的在线查询",
        "节点值是否唯一": "是（BST 假设）→ 可变形为允许重复值的扩展 BST",
        "输入形式": "root 根节点指针 + 节点 p；或仅给出值 p_val 并要求先定位再求后继",
        "多组查询": "单次查询 → 多次查询下的预处理优化（如构建中序数组、打表后继）",
        "输出要求": "返回节点指针 / 返回值 / 返回在中序序列中的索引位置"
      }
    }
  },
  {
    "title": "Legal Binary Search Tree LCCI",
    "slug": "legal-binary-search-tree-lcci",
    "schema": {
      "Input Structure": "二叉树 T，节点数为 n；每个节点包含整数值 val，以及左右子节点指针 left 和 right；树以根节点引用形式给出",
      "Core Constraint": "二叉搜索树的定义约束：对于任意节点，其左子树所有节点值均严格小于该节点值，右子树所有节点值均严格大于该节点值；且左右子树均为二叉搜索树",
      "Objective Function": "判定给定二叉树是否为合法的二叉搜索树（布尔判定问题）",
      "Algorithmic Invariant": "中序遍历过程中节点值序列单调递增；或递归过程中维持每个子树的取值区间约束（lower_bound < node.val < upper_bound），该区间随父子关系传递并收紧",
      "Transformable Parameters": {
        "数据规模": "n 的数量级（如 1e2, 1e4, 1e5），影响是否允许 O(n) 解法",
        "值域范围": "节点值是否可能为 int_min / int_max，影响边界处理方式",
        "输入形式": "树的表示方式（如层序数组 [5,1,4,null,...] 或指针结构）",
        "是否多组数据": "是否需连续判断多个独立树",
        "是否在线": "树结构是否动态更新（插入/删除节点）后需重新判定",
        "BST 定义变体": "是否允许等于（即 ≤ 或 ≥）——影响比较条件"
      }
    }
  },
  {
    "title": "Check Balance LCCI",
    "slug": "check-balance-lcci",
    "schema": {
      "Input Structure": "二叉树 T，节点类型为 TreeNode，包含 val、left、right；树的节点数 n 满足 0 ≤ n ≤ 10^4",
      "Core Constraint": "一棵树是平衡的当且仅当其每个节点的左右子树高度差不超过 1；该性质具有递归结构性：全局平衡 ⇔ 左右子树平衡且高度差 ≤ 1",
      "Objective Function": "判定整棵树是否为平衡二叉树（布尔值存在性判断）",
      "Algorithmic Invariant": "后序遍历中，每个节点返回其子树的高度或特殊标记（如 -1 表示不平衡）；若任一子树不平衡或高度差 > 1，则向上传播不平衡状态；否则返回当前树高。该过程保证每个节点仅访问一次，且状态传递保持正确性",
      "Transformable Parameters": {
        "高度差阈值": "可从 1 改为 K，形成 'K-平衡树' 判定问题",
        "平衡定义范围": "可限定仅根节点 / 叶路径长度差 / 所有叶子所在层差 ≤ 1 等变体",
        "输出形式": "可改为返回最小修复操作数、最深不平衡节点、或所有不平衡节点列表",
        "输入形式": "可改为数组表示的完全二叉树、流式输入、多叉树扩展",
        "数据规模": "n 的范围可调整至 10^5 或更高，要求 O(n) 解法",
        "是否在线": "支持动态插入/删除后实时判断平衡性（转为数据结构设计题）"
      }
    }
  },
  {
    "title": "List of Depth LCCI",
    "slug": "list-of-depth-lcci",
    "schema": {
      "Input Structure": "二叉树 root，节点类型为 TreeNode，包含 val, left, right；树的深度为 D，节点值可重复，无序；输入形式为层序遍历数组（可能含 null 表示空节点）",
      "Core Constraint": "同一深度的节点必须被收集到同一个链表中；深度之间互不干扰，且深度从根开始逐层递增 1；每个节点仅属于唯一一层",
      "Objective Function": "构造 D 个链表，每个链表包含对应深度上所有非空节点，并按从左到右顺序连接；返回链表头节点组成的数组",
      "Algorithmic Invariant": "使用队列进行广度优先搜索（BFS），每轮处理完整的一层：\n- 队列中始终只保存当前层的所有节点\n- 每次取出当前层节点数目的元素，保证层间隔离\n- 新加入的子节点自动归入下一层，不干扰当前层结果构造",
      "Transformable Parameters": {
        "树的形态": "满二叉树 / 完全二叉树 / 偏斜树",
        "数据规模": "节点数量 n 的范围（如 1 ≤ n ≤ 10^4）",
        "是否多组数据": "单棵树 / 多组测试用例",
        "输入形式": "层序遍历数组 / 先序+中序重建 / 指针直接输入",
        "输出形式": "返回链表数组 / 只打印每层值列表 / 返回双向链表",
        "是否在线": "静态构建 / 动态插入后重新分层",
        "扩展变形": "按奇偶深度分组 / Z 字形顺序建链表 / 只对叶子所在层建表"
      }
    }
  },
  {
    "title": "Minimum Height Tree LCCI",
    "slug": "minimum-height-tree-lcci",
    "schema": {
      "Input Structure": [
        "一维有序数组 A[1..n]",
        "元素为整数，互不相同",
        "数组按升序排列"
      ],
      "Core Constraint": [
        "二叉搜索树的中序遍历等于原数组",
        "要求构造的树高度最小，即必须为平衡树（左右子树高度差 ≤ 1）",
        "最优结构具有递归子结构性：全局最优解由子区间最优解构成"
      ],
      "Objective Function": "构造一棵高度最小的二叉搜索树（即平衡二叉搜索树）",
      "Algorithmic Invariant": [
        "每次选择中间元素作为根节点，可保证左右子树节点数差值最小",
        "递归处理左半区间构建左子树，右半区间构建右子树，维持BST性质与平衡性",
        "分治过程中，子问题与原问题结构一致，且规模减小"
      ],
      "Transformable Parameters": {
        "n 的数量级": "n ≤ 10^4（可调整至支持更大规模或流式输入）",
        "是否允许重复元素": false,
        "是否保持有序": true,
        "是否要求唯一解输出": false,
        "是否多组输入": false,
        "是否在线": false,
        "输出形式": [
          "返回树的根节点（指针/引用）",
          "可扩展为输出层序遍历序列"
        ],
        "树的类型约束": [
          "AVL结构（隐式满足）",
          "可变形为要求特定平衡条件（如红黑树结构，但不改变母题核心）"
        ]
      }
    }
  },
  {
    "title": "Sort of Stacks LCCI",
    "slug": "sort-of-stacks-lcci",
    "schema": {
      "Input Structure": [
        "栈 S，支持 push、pop、peek 和 isEmpty 操作",
        "元素为整数，数目在 [0, 5000] 范围内",
        "仅允许使用一个额外的临时栈作为辅助空间",
        "不允许使用其他数据结构（如数组、队列等）"
      ],
      "Core Constraint": [
        "必须通过两个栈之间的元素转移实现排序",
        "目标状态：栈顶为最小元素，从顶到底非递减（即最小值在顶，之后不小于前一个）",
        "每次操作需保持栈的合法性，且不能复制元素到非栈结构",
        "排序过程需在运行时动态维护有序性"
      ],
      "Objective Function": [
        "构造一个数据结构 SortedStack，使得其内部栈始终维持最小值在栈顶的有序状态",
        "支持动态插入（push）和删除（pop）的同时保持排序",
        "正确实现 peek 返回栈顶元素（空则-1），isEmpty 判断是否为空"
      ],
      "Algorithmic Invariant": [
        "主栈从栈顶到栈底是非递减序列（min at top）",
        "临时栈用于暂存主栈中大于当前待入栈元素的值，以腾出位置插入正确位置",
        "每次 push 操作后，通过双栈来回调整，恢复主栈的有序性",
        "pop 操作只影响主栈，且不破坏后续有序性前提",
        "整个过程中最多只有一个辅助栈被使用，空间复杂度 O(n)，但辅助空间受限为单栈"
      ],
      "Transformable Parameters": {
        "数据规模": "元素个数 n ∈ [0, 5000]，可调整为更大或在线场景",
        "输入形式": "命令流式输入（字符串操作名 + 参数列表），支持多组操作序列",
        "是否多组数据": true,
        "是否在线": true,
        "有序方向": [
          "可变换为目标：最大元素在顶（降序）",
          "或要求从顶到底非递增"
        ],
        "辅助结构限制": [
          "可改为不允许任何额外栈 → 需递归模拟（隐式栈）",
          "或允许两个以上临时栈 → 简化策略"
        ],
        "操作集扩展": [
          "是否支持 peekMin、peekMax、size 等附加操作"
        ],
        "值域特性": "整数范围未限定，可设定为负数、重复元素等情形"
      }
    }
  },
  {
    "title": "Three in One LCCI",
    "slug": "three-in-one-lcci",
    "schema": "{\n  \"Input Structure\": [\n    \"一维数组 A[1..3*stackSize], 初始为空（或全零）\",\n    \"整数 stackSize，表示每个栈的最大容量\",\n    \"操作序列：包含 'push(stackNum, value)', 'pop(stackNum)', 'peek(stackNum)', 'isEmpty(stackNum)'\",\n    \"stackNum ∈ {0, 1, 2}\"\n  ],\n  \"Core Constraint\": [\n    \"三个栈共享同一数组空间，不能越界访问\",\n    \"每个栈独立增长，遵循后进先出（LIFO）原则\",\n    \"栈的边界由 stackNum 和 stackSize 静态划分：栈0使用 [0, stackSize), 栈1使用 [stackSize, 2*stackSize), 栈2使用 [2*stackSize, 3*stackSize)\",\n    \"当栈满时 push 不执行；当栈空时 pop/peek 返回 -1\"\n  ],\n  \"Objective Function\": [\n    \"支持对指定栈进行 push、pop、peek、isEmpty 操作\",\n    \"正确维护各栈状态，确保逻辑隔离\",\n    \"所有操作时间复杂度 O(1)\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"每个栈的当前指针（top pointer）独立维护，记录下一个可写入位置\",\n    \"对于栈 i，其有效范围为 [i * stackSize, (i + 1) * stackSize)\",\n    \"top[i] 初始为 i * stackSize，每 push 加 1，每 pop 减 1\",\n    \"top[i] == i * stackSize 表示栈空；top[i] == (i + 1) * stackSize 表示栈满\",\n    \"数组访问始终通过映射 index = top[stackNum] 实现，不越界\"\n  ],\n  \"Transformable Parameters\": {\n    \"stackCount\": {\n      \"type\": \"integer\",\n      \"default\": 3,\n      \"range\": [2, 10],\n      \"description\": \"合并的栈数量，可从3变为k个\"\n    },\n    \"stackSize\": {\n      \"type\": \"integer\",\n      \"default\": \"given at construction\",\n      \"range\": [1, 1e5],\n      \"description\": \"每个栈的固定大小\"\n    },\n    \"sharedArrayInitialization\": {\n      \"options\": [\"zero-filled\", \"uninitialized\"],\n      \"default\": \"zero-filled\"\n    },\n    \"behaviorOnOverflow\": {\n      \"options\": [\"ignore\", \"throw error\", \"resize dynamically\"],\n      \"default\": \"ignore\"\n    },\n    \"behaviorOnUnderflow\": {\n      \"options\": [\"return -1\", \"throw error\", \"return null\"],\n      \"default\": \"return -1\"\n    },\n    \"operationSequence\": {\n      \"type\": \"list of method calls\",\n      \"format\": [\"methodName\", [...args]],\n      \"multiCase\": true,\n      \"description\": \"是否支持多组测试数据\"\n    },\n    \"onlineOperations\": {\n      \"supported\": true,\n      \"description\": \"所有操作均为在线实时调用\"\n    },\n    \"memoryConstraint\": {\n      \"onlyOneArrayAllowed\": true,\n      \"auxiliarySpace\": \"O(stackCount) only for top pointers\"\n    }\n  }\n}"
  },
  {
    "title": "Route Between Nodes LCCI ",
    "slug": "route-between-nodes-lcci",
    "schema": {
      "Input Structure": [
        "有向图 G = (V, E)",
        "节点数 n ∈ [0, 1e5]",
        "边集 graph ⊆ V × V，表示有向边列表",
        "节点编号 ∈ [0, n-1]",
        "允许自环和平行边",
        "输入形式：边列表 + 起点 start + 终点 target"
      ],
      "Core Constraint": [
        "路径存在性仅依赖于图的连通性（弱连通下的可达性）",
        "边方向不可逆，必须沿有向边传播",
        "局部信息不足，需通过遍历累积状态判断全局可达性",
        "起点与终点固定，问题具有单源单汇特性"
      ],
      "Objective Function": "判定从 start 到 target 是否存在一条有向路径（布尔型输出）",
      "Algorithmic Invariant": [
        "已访问节点集合 closed 随搜索推进单调扩展",
        "队列/栈中待处理节点 frontier 构成当前可达边界",
        "一旦 target 被加入 closed，则答案为 true 且后续操作不改变结果",
        "BFS/DFS 探索过程中不会遗漏任何可达路径"
      ],
      "Transformable Parameters": {
        "n 的数量级": [
          "[0, 1e3]",
          "[0, 1e5]",
          "[0, 1e6]"
        ],
        "图的表示形式": [
          "边列表",
          "邻接表",
          "邻接矩阵"
        ],
        "是否离线处理": [
          true,
          false
        ],
        "是否在线查询多组 (start, target)": [
          false,
          true
        ],
        "是否允许多次查询并预处理": [
          false,
          true
        ],
        "是否存在动态更新（加边/删边）": [
          false,
          true
        ],
        "是否要求输出路径方案": [
          false,
          true
        ],
        "图类型变换": [
          "有向图",
          "无向图",
          "DAG",
          "树"
        ],
        "数据流化": [
          "一次性输入",
          "流式边输入"
        ]
      }
    }
  },
  {
    "title": "Implement Queue using Stacks LCCI",
    "slug": "implement-queue-using-stacks-lcci",
    "schema": {
      "Input Structure": [
        "两个后进先出（LIFO）栈 S1, S2",
        "支持标准栈操作：push to top, peek/pop from top, size, is empty",
        "输入为一系列队列操作序列（push, pop, peek, empty）",
        "所有操作在有效前提下执行（无无效 pop/peek）"
      ],
      "Core Constraint": [
        "队列需满足先进先出（FIFO）语义，与栈的 LIFO 特性冲突",
        "必须仅通过栈接口实现队列行为",
        "数据只能从输入栈经反转后导入输出栈，不可随机访问"
      ],
      "Objective Function": [
        "模拟队列的四个操作：push(x), pop(), peek(), empty()",
        "目标是构造一个功能正确的队列抽象数据类型（ADT）",
        "重点在于操作的正确性而非时间或空间最优化"
      ],
      "Algorithmic Invariant": [
        "S1 用于 enqueue 操作（压入新元素）",
        "S2 用于 dequeue 和 peek 操作（提供最早进入的元素）",
        "当 S2 非空时，其栈顶即为队首元素；若 S2 为空，则将 S1 全部弹出并压入 S2，实现一次顺序反转",
        "每个元素最多经历两次压栈和两次弹栈，摊还时间复杂度 O(1)",
        "S1 和 S2 不同时承担同一元素的长期存储，状态无冗余"
      ],
      "Transformable Parameters": {
        "数据规模": "操作次数 n 的数量级（例如 1e3, 1e5）",
        "是否多组数据": "支持多个独立测试用例",
        "输入形式": "离线：预知操作序列 / 在线：逐个调用方法",
        "栈的行为约束": [
          "是否允许使用辅助数据结构（如限制只能用两个栈）",
          "是否允许语言内置栈以外的结构（如 list 模拟栈视为合法）"
        ],
        "异常处理要求": [
          "原始题设假设操作有效",
          "可变形为需要判断空状态后再 pop（加入健壮性检查）"
        ],
        "性能要求": [
          "基础版本：仅要求正确性",
          "高阶版本：要求 push/pop 均摊 O(1) 时间",
          "挑战版本：要求所有操作最坏情况 O(1)，需更复杂设计（非主流解法）"
        ],
        "扩展方向": [
          "支持 undo 操作（回退上次 push 或 pop）",
          "支持双端队列（用两个栈实现 deque）",
          "用队列实现栈（逆向问题）",
          "用一个栈实现队列（借助递归调用栈隐式保存）"
        ]
      }
    }
  },
  {
    "title": "Min Stack LCCI",
    "slug": "min-stack-lcci",
    "schema": {
      "Input Structure": [
        "支持三种操作的栈数据结构：push(x), pop(), getMin()",
        "元素为整数（可正可负）",
        "操作序列是离线或在线均可"
      ],
      "Core Constraint": [
        "每次执行 getMin 时必须返回当前栈中所有元素的最小值",
        "push、pop 和 getMin 操作的时间复杂度均需为 O(1)",
        "空间可以额外使用，但不能通过遍历求最小值"
      ],
      "Objective Function": [
        "设计一个支持常数时间获取最小值的栈",
        "目标函数为：min(S)，其中 S 是当前栈内元素集合"
      ],
      "Algorithmic Invariant": [
        "辅助栈（或变量）维护到当前位置的前缀最小值",
        "每入栈一个元素，对应的最小值状态也同步更新",
        "出栈时，最小值状态也能 O(1) 回滚",
        "主栈与辅助栈（或双变量）之间保持状态同步不变性"
      ],
      "Transformable Parameters": {
        "值域范围": "整数（可扩展至浮点、大数）",
        "是否允许重复元素": true,
        "是否支持其他查询": [
          "getMax",
          "getMean",
          "getMedian"
        ],
        "是否多组数据": false,
        "输入形式": "类 API 调用（命令流式）",
        "是否在线": true,
        "数据规模 n": "1e5 ~ 1e6 次操作",
        "能否扩展为支持区间 min 查询": true,
        "空间限制": "宽松（允许 O(n) 额外空间）"
      }
    }
  },
  {
    "title": "Linked List Cycle LCCI",
    "slug": "linked-list-cycle-lcci",
    "schema": {
      "Input Structure": "单链表 ListNode *head，其中每个节点包含整数值和指向下一个节点的指针 next；链表长度为 n，节点值可重复，链表可能为空（head = null）",
      "Core Constraint": "若链表存在环，则从某个节点出发沿 next 指针可再次访问到该节点；环的入口定义为从链表头开始遍历时第一个被重复访问的节点；问题的关键约束是：一旦进入环，就无法通过常规遍历终止",
      "Objective Function": "判断链表是否存在环，并返回环路的起始节点；若无环，返回 null",
      "Algorithmic Invariant": "使用快慢双指针（Floyd 判圈算法）：慢指针每次移动一步，快指针每次移动两步；若存在环，则两指针必在环内相遇；相遇后将一个指针重置至头节点，再以相同速度移动两个指针，则它们将在环的入口处相遇",
      "Transformable Parameters": [
        "链表长度 n 的数量级（如 1e3, 1e5, 1e6）",
        "是否允许额外空间（进阶要求 O(1) 空间）",
        "是否多组测试数据",
        "是否在线构造链表（动态插入/删除影响环结构）",
        "是否要求输出环的长度或所有环上节点",
        "输入形式是否提供 pos 参数（教学场景 vs 实际算法场景）",
        "链表是否为双向链表（变形题）",
        "是否存在多个环（需额外建模）"
      ]
    }
  },
  {
    "title": "Intersection of Two Linked Lists LCCI",
    "slug": "intersection-of-two-linked-lists-lcci",
    "schema": {
      "Input Structure": [
        "两个单链表 headA 和 headB，分别包含 m 和 n 个节点",
        "每个节点为 ListNode 类型，具有 val 和 next 字段",
        "链表无环（题目保证）",
        "链表结构不可修改（必须保持原始结构）"
      ],
      "Core Constraint": [
        "若两链表相交，则从某节点开始到末尾的所有节点完全共享（即指针相同）",
        "相交不依赖于节点值，而依赖于内存地址（指针）是否相同",
        "相交前的路径长度可能不同（skipA ≠ skipB）",
        "只能使用 O(1) 额外空间（进阶要求）"
      ],
      "Objective Function": [
        "判定两个链表是否存在交点（布尔判定）",
        "若存在，返回第一个相交节点（构造方案）",
        "若不存在，返回 null"
      ],
      "Algorithmic Invariant": [
        "双指针同步遍历：设指针 pA 遍历 headA 后接 headB，pB 遍历 headB 后接 headA",
        "当 pA == pB 时，该位置即为首个相交节点或同时为 null（表示无交点）",
        "由于路径总长均为 m + n，若有交点，则在第二段遍历时必然相遇于首个交点",
        "指针移动过程不破坏链表结构，满足只读约束"
      ],
      "Transformable Parameters": [
        "链表是否有环（当前为无环，可变形为有环情况）",
        "是否允许修改链表结构（如反转、标记）",
        "内存限制：O(1) 或允许哈希表 O(n)",
        "时间复杂度要求：是否严格 O(n)",
        "输入形式：是否在线给出链表流（而非头节点）",
        "是否多组查询：多个链表对的交点判定",
        "相交模式：单点相交 → 多段重叠 → Y 型 / X 型结构",
        "数据规模：m, n 的数量级（当前 ≤ 3×10⁴）",
        "是否提供 skipA/skipB 信息（本题中未暴露给函数）"
      ]
    }
  },
  {
    "title": "Palindrome Linked List LCCI",
    "slug": "palindrome-linked-list-lcci",
    "schema": {
      "Input Structure": "链表 L，长度为 n，节点值为整数；链表无环，头节点为 head，每个节点包含 val 和 next 指针",
      "Core Constraint": "回文性质依赖于序列的对称性：第 i 个节点与倒数第 i 个节点值相等；链表仅支持单向遍历，无法直接随机访问",
      "Objective Function": "判定链表是否为回文（布尔判定问题）",
      "Algorithmic Invariant": "通过快慢指针定位中点，反转后半段链表后与前半段逐一对比；比较过程中若所有对应节点值相等，则保持回文性质不变；比较完成后可选择恢复链表结构以满足空间约束",
      "Transformable Parameters": {
        "n 的数量级": "1 ≤ n ≤ 10^5",
        "值域": "节点 val ∈ [-1000, 1000]",
        "是否有序": "否（但回文结构隐含对称顺序）",
        "是否循环链表": "否（可作为变形题扩展）",
        "是否多组输入": "否（可扩展为多测案例）",
        "是否在线": "否（离线处理整个链表）",
        "空间复杂度要求": "O(1)（进阶条件，决定是否需原地反转）",
        "时间复杂度要求": "O(n)"
      }
    }
  },
  {
    "title": "Remove Duplicate Node LCCI",
    "slug": "remove-duplicate-node-lcci",
    "schema": {
      "Input Structure": {
        "type": "linked_list",
        "element_domain": "non_negative_integers",
        "size_range": "[0, 20000]",
        "ordering": "arbitrary",
        "duplicates_allowed": true
      },
      "Core Constraint": {
        "constraint": "保留首次出现的节点，移除后续重复值节点",
        "dependency": "全局唯一性依赖：一个节点是否被保留取决于其值是否在前面已出现"
      },
      "Objective Function": {
        "goal": "construct",
        "target": "modified_linked_list",
        "criterion": "keep_first_occurrence_only"
      },
      "Algorithmic Invariant": {
        "invariant": "已处理部分链表中所有节点值唯一",
        "progression_rule": "遍历过程中维护已见值集合；每步判断当前节点值是否已见，若已见则跳过（删除），否则标记并保留",
        "pointer_maintenance": "前驱指针始终指向结果链表尾部合法节点"
      },
      "Transformable Parameters": {
        "value_domain": "[0, 20000]",
        "list_length": "[0, 20000]",
        "use_auxiliary_space": {
          "standard": true,
          "constrained_version": false
        },
        "input_ordering": "unordered",
        "online_input": false,
        "multiple_cases": false,
        "operation_type": [
          "remove_duplicates"
        ],
        "output_format": "linked_list"
      }
    }
  },
  {
    "title": "String Rotation LCCI",
    "slug": "string-rotation-lcci",
    "schema": {
      "Input Structure": [
        "两个字符串 s1 和 s2",
        "s1 长度为 n，s2 长度为 m",
        "字符集：任意可比较字符（通常为小写字母）",
        "长度范围：[0, 100000]"
      ],
      "Core Constraint": [
        "若 s2 是 s1 的旋转，则存在一个分割点 k（0 ≤ k < n），使得 s1 = A + B 且 s2 = B + A",
        "等价地，s2 是 s1 旋转 ⇔ s2 是 s1 + s1 的子串",
        "问题被转化为子串匹配问题"
      ],
      "Objective Function": "判定 s2 是否为 s1 旋转后的结果（布尔值判断）",
      "Algorithmic Invariant": [
        "s1 的所有可能旋转构成的集合 ⊆ s1 + s1 的所有子串",
        "若 s2 是 s1 的旋转，则必然满足 |s1| == |s2| 且 s2 ∈ substr(s1 + s1)",
        "通过构造 s1 + s1，覆盖所有循环移位状态，无需显式枚举"
      ],
      "Transformable Parameters": {
        "字符串长度规模": "n ∈ [0, 100000]",
        "是否要求常数空间": false,
        "是否允许调用多次子串方法": false,
        "输入形式": "单组输入，离线处理",
        "是否区分大小写": true,
        "是否允许多次旋转": false,
        "是否推广到多维字符串（如二维字符阵旋转）": false,
        "是否在线查询多个 s2": false,
        "是否支持删除/插入后仍保持旋转关系": false
      }
    }
  },
  {
    "title": "Compress String LCCI",
    "slug": "compress-string-lcci",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "uppercase and lowercase English letters (a-z)",
        "length_range": "[0, 50000]",
        "properties": [
          "ordered",
          "repeating characters allowed"
        ]
      },
      "Core Constraint": {
        "description": "Consecutive identical characters must be grouped and replaced by the character followed by their count. The compression is only beneficial if the resulting string is shorter than the original.",
        "key_condition": "Compression rule applies locally to maximal contiguous blocks of the same character"
      },
      "Objective Function": "If the compressed string is shorter than the original, return the compressed string; otherwise, return the original string.",
      "Algorithmic Invariant": {
        "traversal_invariant": "During a single left-to-right pass, the start and length of each maximal block of identical characters can be determined without backtracking.",
        "compression_safety": "Each block 'ccc...c' of length k is safely encoded as 'c' + str(k), and this transformation is irreversible but deterministic.",
        "optimality_condition": "No rearrangement or alternative encoding is allowed; the greedy grouping of consecutive characters yields the uniquely correct compression."
      },
      "Transformable Parameters": {
        "n_value": "50000",
        "value_domain": "a-z, A-Z",
        "input_form": "single string",
        "output_form": "compressed string or original if not shorter",
        "multiple_test_cases": false,
        "online_processing": false,
        "case_sensitive": true,
        "allow_non_alphabetic": false,
        "compression_threshold": "strictly shorter (not ≤ original length)"
      }
    }
  },
  {
    "title": "String to URL LCCI",
    "slug": "string-to-url-lcci",
    "schema": {
      "Input Structure": [
        "字符数组 char[] s，长度为 n",
        "整数 trueLength，表示字符串的真实长度（不包含尾部冗余空格）",
        "s 的尾部有足够的额外空间容纳替换后新增的字符",
        "字符集为 ASCII",
        "字符串中可能包含空格、字母、数字及其他可见字符"
      ],
      "Core Constraint": [
        "每个空格需被替换为三个字符 '%', '2', '0'",
        "原字符串真实长度小于等于数组容量，替换后的总长度不超过数组大小",
        "必须在原地修改（in-place），不能使用额外的字符串存储空间",
        "只能操作前 (最终长度) 范围内的字符"
      ],
      "Objective Function": "将输入字符串中所有空格替换为 %20，并返回修改后的字符串（以字符数组形式体现）",
      "Algorithmic Invariant": [
        "从后往前双指针扫描可保证未处理区域与已处理区域不重叠",
        "维护两个指针：readIndex 指向原始字符串末尾（trueLength - 1），writeIndex 指向替换后字符串末尾（计算得出）",
        "当 readIndex < writeIndex 时仍安全写入，不会覆盖未读取字符",
        "每遇到一个非空格字符，向前复制一位；每遇到一个空格，向前写入 '%20' 三位"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5 ~ 5e5，要求 O(n) 时间",
        "值域": "ASCII 字符，空格为 '\\u0020'",
        "是否有序": "输入按字符串顺序排列，不可重排",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "替换模式可变": "如空格替换为 '+', 或通用编码规则（如 UTF-8 percent-encoding）",
        "扩展变形": [
          "支持多种特殊字符替换（如 < → %3C）",
          "输入为动态流（在线处理）",
          "要求最小化移动次数",
          "不允许修改原数组 → 需额外空间"
        ]
      }
    }
  },
  {
    "title": "Check Permutation LCCI",
    "slug": "check-permutation-lcci",
    "schema": {
      "Input Structure": [
        "两个字符串 s1 和 s2",
        "每个字符串由小写字母组成",
        "长度范围：0 <= len(s1), len(s2) <= 100"
      ],
      "Core Constraint": [
        "字符重排等价性判定依赖于字符频次的完全一致性",
        "顺序无关，仅统计信息决定结果",
        "若两字符串互为字母异位词，则其字符频率分布相同"
      ],
      "Objective Function": "判定是否存在一种字符重排方式，使得 s1 可以变为 s2（即判断 s1 和 s2 是否互为字母异位词）",
      "Algorithmic Invariant": [
        "字符频次直方图的对称不变性：s1 的频次统计与 s2 的频次统计相减应为零向量",
        "使用固定大小数组或哈希表维护计数差值时，增减操作保持可逆且不影响最终判定逻辑",
        "遍历过程中，频次差累计为零是充要条件"
      ],
      "Transformable Parameters": {
        "字符集类型": "小写字母 → 大写字母 / 数字 / Unicode 字符",
        "输入形式": "两个独立字符串 → 多个字符串间两两判定",
        "数据规模": "长度 ≤100 → 可扩展至 1e5 并要求在线处理",
        "是否有序": "无序 → 要求保持某种相对顺序（如稳定重排）",
        "是否允许通配符": "否 → 引入 '?' 等通配符字符",
        "操作模式": "一次性判定 → 支持字符插入/删除/修改的动态版本",
        "输出目标": "布尔判定 → 输出最少编辑步数使其成为异位词",
        "是否多组数据": "单组 → 多组测试用例批量处理"
      }
    }
  },
  {
    "title": "Is Unique LCCI",
    "slug": "is-unique-lcci",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "s[1..n]",
        "length": "0 <= n <= 100",
        "character_set": "lowercase English letters (a-z)",
        "formal": "A string s of length n where each character s[i] ∈ {a..z}"
      },
      "Core Constraint": {
        "uniqueness_condition": "字符互异当且仅当无重复出现的字符",
        "dependency_structure": "全局字符频率决定解，局部信息不足以判定整体",
        "information_requirement": "需维护已见字符集合以判断重复"
      },
      "Objective Function": {
        "goal": "判定是否存在重复字符",
        "type": "decision problem",
        "output": "boolean: true if all characters are distinct, false otherwise"
      },
      "Algorithmic Invariant": {
        "invariant_type": "membership tracking monotonicity",
        "description": "遍历过程中维护一个已访问字符的集合；每读入一个新字符，其是否已在集合中决定了答案。一旦发现重复，可提前终止（短路优化）。",
        "optimization_property": "若使用位掩码（bitmask），则利用整数的位状态表示字符出现情况，实现O(1)空间与O(n)时间下的不变性维护"
      },
      "Transformable Parameters": {
        "alphabet_size": {
          "default": 26,
          "can_be_changed_to": [
            "extended ASCII",
            "Unicode",
            "arbitrary alphabet"
          ]
        },
        "data_access_mode": [
          "offline sequential",
          "online streaming"
        ],
        "space_constraint": {
          "allow_extra_ds": true,
          "bonus_for_no_extra_ds": true,
          "alternative_approaches": [
            "sort in-place if mutable",
            "bit vector",
            "hash set",
            "brute-force pairwise comparison"
          ]
        },
        "input_mutability": "immutable string",
        "case_sensitivity": "case-sensitive (only lowercase given)",
        "multi_query": false,
        "online_updates": false,
        "n_scale": [
          "n ≤ 100",
          "can scale to larger n with efficient DS"
        ],
        "output_detail": [
          "boolean result",
          "optional: index of first duplicate"
        ]
      }
    }
  },
  {
    "title": "Guess Numbers",
    "slug": "guess-numbers",
    "schema": {
      "Input Structure": [
        "一维数组 guess[1..3]",
        "一维数组 answer[1..3]",
        "guess[i] ∈ {1, 2, 3}",
        "answer[i] ∈ {1, 2, 3}",
        "两个数组长度均为3"
      ],
      "Core Constraint": [
        "猜对当且仅当 guess[i] == answer[i]",
        "每个位置的比较独立，无前后依赖",
        "结果由逐位等值判定决定"
      ],
      "Objective Function": "计数：统计满足 guess[i] == answer[i] 的位置个数",
      "Algorithmic Invariant": [
        "逐位比较的正确性不依赖于其他位置",
        "比较操作具有可分离性（separability）",
        "累加过程保持计数不变量"
      ],
      "Transformable Parameters": {
        "n 的数量级": "固定为3，可推广至 n ≤ 10^5",
        "值域": "可从 {1,2,3} 扩展至正整数或字符串",
        "是否有序": "无关（顺序影响配对）",
        "是否循环": "否",
        "是否多组输入": "当前单组，可扩展为多组测试用例",
        "是否在线": "否，可改为流式输入 pair by pair",
        "输入形式变化": [
          "合并为二维数组 pairs[i] = [guess_i, answer_i]",
          "支持不同长度输入并要求对齐"
        ],
        "目标函数变形": [
          "判定是否全对（判定问题）",
          "求最长连续猜对子段（最大连续段）",
          "引入权重：不同数字猜对得分不同（加权计数）"
        ]
      }
    }
  },
  {
    "title": "Programmable Robot",
    "slug": "programmable-robot",
    "schema": {
      "Input Structure": [
        "字符串 command，由 'U' 和 'R' 组成，长度 m ∈ [2, 1000]",
        "二维平面上的障碍物集合 obstacles，每个元素为坐标 [ox, oy]，其中 ox, oy ≥ 0",
        "目标终点坐标 (x, y)，满足 0 ≤ x, y ≤ 1e9",
        "机器人从原点 (0, 0) 出发，按 command 无限循环执行移动：'U' → (dx=0, dy=1)，'R' → (dx=1, dy=0)"
      ],
      "Core Constraint": [
        "机器人的路径是周期性重复的：每轮执行 command 后，位置增量为 (Δx, Δy) = (count_R, count_U)",
        "机器人在任意时刻若位于障碍物点，则立即损毁，无法继续移动",
        "仅当机器人在**到达终点前未触碰任何障碍物**时，才算成功到达",
        "障碍物不影响路径结构，但构成提前终止条件"
      ],
      "Objective Function": "判定是否存在一个非负整数 k 和步骤索引 t < |command|，使得机器人在第 k 个完整周期 + 第 t 步后恰好到达 (x, y)，且在此路径上所有经过的点均不与 obstacles 中任一坐标重合",
      "Algorithmic Invariant": [
        "单周期路径可预计算：设 basePath = [(0,0), (x1,y1), ..., (Δx,Δy)] 表示一轮 command 的轨迹",
        "第 k 周期第 t 步的位置为：(k * Δx + xt, k * Δy + yt)，其中 (xt, yt) 是 basePath[t]",
        "对于任意目标点 (x, y)，其所属周期 k 可通过线性同余方程求解：k = min{ floor((x - xt)/Δx), floor((y - yt)/Δy) }，需满足整除关系",
        "每个障碍物是否被命中，可通过判断其是否落在某个周期的对应偏移路径上来确定",
        "一旦某点在到达 (x, y) 前被命中，则返回 false；终点之后命中不影响结果"
      ],
      "Transformable Parameters": {
        "command 长度": "2 <= m <= 1000",
        "坐标范围": "x, y 最大可达 1e9，obstacles 数量最多 1000",
        "obstacles 是否存在": "可为空，也可含多个点",
        "是否包含终点后的碰撞检测": "当前规则下忽略终点后碰撞，可改为全程检测",
        "command 是否允许其他方向（如 D, L）": "当前仅 U/R，可扩展为 4 方向或更多动作",
        "是否支持动态修改 command 或 obstacles": "当前离线静态输入，可改造为在线更新",
        "是否多组查询": "当前单次查询，可扩展为对多个 (x, y) 批量判断",
        "是否环形坐标系或模意义下移动": "当前为无限平面，可变形为模格空间"
      }
    }
  },
  {
    "title": "Coin Bonus",
    "slug": "coin-bonus",
    "schema": {
      "Input Structure": [
        "一棵有根树，节点编号为 1 到 N，根节点为 1",
        "leadership 是大小为 (N - 1) × 2 的二维数组，表示父子关系：[a, b] 表示 b 是 a 的子节点",
        "operations 是长度为 Q 的二维数组，每个操作形如 [type, target, value?]，其中 type ∈ {1, 2, 3}",
        "所有成员初始 LeetCoin 值为 0"
      ],
      "Core Constraint": [
        "树形结构具有唯一的父-子继承关系，无环且连通",
        "子树可通过 DFS 序映射为连续区间",
        "操作 2 和操作 3 都作用于某节点及其整个子树（闭包）",
        "信息更新与查询均在子树闭包上进行，支持批量更新和聚合查询"
      ],
      "Objective Function": [
        "对每次操作类型 3：查询指定节点及其管理的所有下属当前累计获得的 LeetCoin 总和（模 1e9+7）",
        "输出为所有查询操作的结果序列"
      ],
      "Algorithmic Invariant": [
        "通过一次 DFS 预处理得到每个节点的进入时间戳 in[u] 和离开时间戳 out[u]，使得 u 的子树对应区间 [in[u], out[u]]",
        "将树上子树操作转化为序列上的区间操作",
        "使用支持区间加、单点加、区间求和的数据结构（如线段树或树状数组）维护时间戳序列上的权值",
        "任何时刻，节点 u 子树的硬币总和 = 序列上 [in[u], out[u]] 区间的元素和"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "N": "1 <= N <= 50000",
          "Q": "1 <= Q <= 50000"
        },
        "输入形式": {
          "树的构建方式": "边列表（父子对）",
          "操作序列": "按时间顺序给出，离线处理"
        },
        "是否在线": false,
        "更新类型": [
          "单点加（操作1）",
          "子树批量加（操作2 → 对应区间加）"
        ],
        "查询类型": "子树和查询（操作3 → 对应区间求和）",
        "模数": "1000000007",
        "可变扩展点": [
          "改为支持动态加边/删边（动态树）",
          "改为在线询问（需持久化数据结构）",
          "增加撤销操作",
          "值域范围变化：operations[i][2] 范围调整",
          "目标函数变换：改为最大值、最小值、异或和等聚合函数",
          "输入结构变形：森林而非树",
          "约束反转：只允许对叶子节点发币",
          "隐藏条件：DFS 序不再显式给出，需自行建图遍历"
        ]
      }
    }
  },
  {
    "title": "Broken Board Dominoes",
    "slug": "broken-board-dominoes",
    "schema": {
      "Input Structure": [
        "二维网格 G[0..n-1][0..m-1]，大小为 n × m",
        "broken 是一个 b × 2 的数组，表示坏掉的格子坐标 (r, c)",
        "每个格子要么完好，要么坏掉",
        "骨牌大小为 1×2，可横放或竖放",
        "n, m ∈ [1, 8]"
      ],
      "Core Constraint": [
        "每块骨牌必须恰好覆盖两个相邻的完好格子",
        "相邻指上下或左右方向（四连通）",
        "骨牌不能重叠，也不能覆盖坏掉的格子",
        "问题等价于在二分图上求最大匹配：将网格建模为黑白染色二分图，边连接相邻的完好格子"
      ],
      "Objective Function": "最大化可放置的骨牌数量（即最大匹配数）",
      "Algorithmic Invariant": [
        "网格可视为二分图：基于 (i + j) % 2 将格子分为黑、白两类节点",
        "每条可能的骨牌对应一条连接黑白节点的边",
        "最大匹配的大小等于最大可放置骨牌数",
        "匈牙利算法或最大流算法可以维护增广路径不变性以逐步构造最优解",
        "状态空间可通过状态压缩动态规划（在行间转移）保持子结构最优性"
      ],
      "Transformable Parameters": {
        "Grid Dimensions": {
          "n_range": [
            1,
            8
          ],
          "m_range": [
            1,
            8
          ],
          "can_be_rectangular": true,
          "can_be_larger": false
        },
        "Broken Cells": {
          "b_count": "0 <= b <= n * m",
          "input_form": "list of coordinates",
          "can_be_infinite_query": false
        },
        "Tile Size and Orientation": {
          "tile_shape": [
            "1*2",
            "2*1"
          ],
          "can_use_L_shaped": false,
          "can_use_1x1": false
        },
        "Board Type": {
          "is_cyclic": false,
          "is_3D": false,
          "is_hexagonal_grid": false
        },
        "Input Mode": {
          "is_online": false,
          "is_multiple_test_cases": false
        },
        "Output Requirement": {
          "output_type": "integer (max count)",
          "can_require_constructive_solution": false
        },
        "Algorithmic Alternatives": [
          "二分图最大匹配（匈牙利算法）",
          "最大流建模（源点→黑点→白点→汇点）",
          "状压DP + 轮廓线（逐格推进，适用于小网格）"
        ],
        "Complexity Constraints": {
          "expected_time_complexity": "O((n*m)^1.5) for bipartite matching, or O(n * m * 2^min(n,m)) for DP",
          "feasible_due_to_small_n_m": true
        }
      }
    }
  },
  {
    "title": "Deep Dark Fraction",
    "slug": "deep-dark-fraction",
    "schema": {
      "Input Structure": "一维数组 cont[0..n-1]，其中 n ∈ [1, 10]，cont[i] ≥ 0 且为整数，cont[n-1] ≠ 0",
      "Core Constraint": "连分数结构具有递归嵌套形式：a₀ + 1/(a₁ + 1/(a₂ + ...))，每一层依赖下一层的倒数；最终结果可表示为最简分数 n/m",
      "Objective Function": "构造一个长度为2的数组 [n, m]，使得该分数等于连分数的值，且 gcd(n, m) = 1（即最简分数）",
      "Algorithmic Invariant": "从末尾向前迭代化简时，每一步都保持当前值为一个最简分数 p/q；更新规则满足：新分子 = a_i * p + q，新分母 = p，且可通过约分维持最简性（或延迟至最后约分）",
      "Transformable Parameters": {
        "数据规模": "cont 长度 ≤ 10 → 可扩展至 1e5（若支持高精度或模意义）",
        "系数范围": "cont[i] ≥ 0 → 可允许负整数（改变符号处理逻辑）",
        "输出形式": "返回 [n, m] 最简分数 → 可改为返回浮点近似值、模意义下的分子（如 mod 1e9+7）",
        "是否最简": "必须最简 → 可改为不要求最简（仅正确值即可）",
        "输入结构变化": "线性连分数 → 树状/嵌套更深的分式结构",
        "在线性": "一次性输入 → 在线逐个输入系数并动态维护当前分数值"
      }
    }
  },
  {
    "title": "Most Common Course Pairs",
    "slug": "most-common-course-pairs",
    "schema": {
      "Input Structure": [
        "二维关系表 course_completions[user_id, course_id, course_name, completion_date, course_rating]",
        "每行表示一个用户完成的一门课程记录",
        "主键为 (user_id, course_id)，即同一用户不会重复完成同一门课程",
        "completion_date 为日期类型，用于排序课程序列",
        "course_rating ∈ [1,5] 的整数"
      ],
      "Core Constraint": [
        "只考虑‘顶尖学生’：完成至少 5 门课程且平均评分 ≥ 4",
        "每个用户的课程序列必须按 completion_date 时间顺序排列",
        "连续课程对定义为：在同一个用户的时间序列中，相邻的两门课程 (A → B)",
        "课程路径具有方向性和时序依赖性"
      ],
      "Objective Function": [
        "统计所有顶尖学生中出现的所有连续课程对 (first_course → second_course) 的频次",
        "输出每个课程对及其 transition_count",
        "最终结果按 transition_count 降序排序；频率相同时，按 first_course 升序，再按 second_course 升序"
      ],
      "Algorithmic Invariant": [
        "用户筛选条件是独立可判定的：基于 group by user_id 聚合后判断 count(course_id) ≥ 5 且 avg(course_rating) ≥ 4",
        "每个用户的课程序列可通过 window function（如 ROW_NUMBER 或 LAG）按 completion_date 排序并提取相邻课程对",
        "课程对的计数满足可加性：不同用户之间的 transition_count 可累加",
        "排序稳定性：先按频次降序，再按字典序升序可在聚合后统一排序保证正确性"
      ],
      "Transformable Parameters": {
        "Top Student Criteria": {
          "min_courses": {
            "value": 5,
            "type": "int",
            "range": "≥1"
          },
          "min_avg_rating": {
            "value": 4,
            "type": "float",
            "range": "[1,5]"
          }
        },
        "Sequence Definition": {
          "ordering_field": "completion_date",
          "tie_breaking_policy": "same day courses: undefined / lexicographical by name / arbitrary stable order"
        },
        "Transition Unit": {
          "pair_type": "consecutive adjacent pairs in time series",
          "allow_self_loop": false,
          "consider_direction": true
        },
        "Output Granularity": {
          "group_by_fields": [
            "first_course",
            "second_course"
          ],
          "aggregate_function": "COUNT(*)",
          "sort_order": [
            {
              "field": "transition_count",
              "order": "DESC"
            },
            {
              "field": "first_course",
              "order": "ASC"
            },
            {
              "field": "second_course",
              "order": "ASC"
            }
          ]
        },
        "Data Variants": [
          "是否多组输入（Multiple test cases）: 可扩展为多个时间段或平台分区",
          "是否在线更新: 支持新记录插入后的增量更新",
          "课程名称是否去重映射: course_id 与 course_name 是否一一对应",
          "输入形式变化: 从静态表 → 流式日志事件"
        ]
      }
    }
  },
  {
    "title": "Maximum Total Sum with Threshold Constraints",
    "slug": "maximum-total-sum-with-threshold-constraints",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 height，height[i] 表示第 i 根柱子的高度。"
      },
      "Core Constraint": {
        "constraint": "每个位置的盛水量由其左右两侧最高柱子中的较小值决定，且水只能在低点处被保留。",
        "independence": "左侧最大值和右侧最大值可独立维护，但共同决定当前点的容量上限。",
        "global_dependency": "局部盛水量依赖于全局极值信息（左/右最大高度）"
      },
      "Objective Function": {
        "goal": "sum",
        "objective": "计算整个数组能接住的雨水总量",
        "type": "numerical_aggregation"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示 [0, L) 区间的最大高度，maxRight 表示 (R, n-1] 区间的最大高度",
          "若 maxLeft ≤ maxRight，则 height[L] 处的积水可以确定，因为右边界不会变得更小",
          "同理，若 maxRight < maxLeft，则 height[R] 处的积水可以确定",
          "每次只移动较小一侧的指针，保证决策的安全性和最优性",
          "已处理区域的结果不再改变"
        ]
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          "0",
          "10^5"
        ],
        "allow_negative_heights": false,
        "input_dimension": "1D",
        "extension_to_2D": true,
        "online_queries": false,
        "support_updates": false,
        "output_detail_level": "total_sum_only",
        "multiple_test_cases": false,
        "circular_array": false,
        "sorted_input": false
      }
    }
  },
  {
    "title": "Absolute Difference Between Maximum and Minimum K Elements",
    "slug": "absolute-difference-between-maximum-and-minimum-k-elements",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中每个元素为正整数；给定整数 k，满足 1 <= k <= n",
      "Core Constraint": "k 个最大元素和 k 个最小元素可通过全局排序唯一确定；两组元素的选取互不重叠且完全由排序后的位置决定",
      "Objective Function": "计算数组中 k 个最大元素的总和与 k 个最小元素的总和之间的绝对差值",
      "Algorithmic Invariant": "排序后，前 k 个元素即为最小的 k 个元素，后 k 个元素即为最大的 k 个元素；排序保持相对顺序不变性，确保极值集合的正确性",
      "Transformable Parameters": {
        "n 的数量级": "n <= 100（可扩展至更大规模以引入堆优化）",
        "值域": "nums[i] ∈ [1, 100]（可推广到含负数或零的情况）",
        "是否有序": "输入无序，但可通过排序转化为有序结构（可设为已排序以降低难度）",
        "是否循环": "否（可设计环形变体要求在循环数组中选择连续段）",
        "是否多组输入": "单组输入（可改为多组测试用例）",
        "是否在线": "离线处理（可改编为数据流中动态维护 top-k 和 bottom-k 的和）",
        "目标函数变化": "可变为求比值、相对误差、或判定差值是否超过阈值",
        "操作类型扩展": "支持插入/删除元素后的实时查询（转为设计数据结构题）"
      }
    }
  },
  {
    "title": "Reverse Words With Same Vowel Count",
    "slug": "reverse-words-with-same-vowel-count",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "由小写英文字母和单个空格组成的字符串 s",
        "constraints": [
          "1 <= s.length <= 10^5",
          "单词之间以单个空格分隔",
          "不含前导或尾随空格",
          "仅包含小写英文字母和空格"
        ],
        "parsed_form": "字符串被分割为单词列表 words[0..k], k >= 0",
        "element_type": "word: string of lowercase letters"
      },
      "Core Constraint": {
        "constraint": "后续单词是否反转，完全取决于其元音字母数量是否与第一个单词相等",
        "dependency": "所有决策依赖于第一个单词的元音数（全局阈值）",
        "independence": "各单词处理相互独立，无前后状态依赖"
      },
      "Objective Function": {
        "goal": "构造一个新的字符串",
        "rules": [
          "保留原词序",
          "对元音数等于首词元音数的单词进行反转",
          "其他单词保持原样"
        ],
        "output_type": "string"
      },
      "Algorithmic Invariant": {
        "invariant": "首单词元音数一旦确定，即成为整个处理过程的不变判定条件",
        "processing_property": "每个单词可独立判断并转换，无需回溯或重处理",
        "order_preservation": "输出顺序与输入顺序一致，仅内容可能反转"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "vowel_definition",
            "description": "元音字母集合",
            "default": [
              "a",
              "e",
              "i",
              "o",
              "u"
            ],
            "possible_variants": [
              "大小写敏感（加入 A,E,I,O,U）",
              "扩展定义（如加入 y）"
            ]
          },
          {
            "name": "comparison_condition",
            "description": "反转触发条件",
            "default": "元音数 == first_word_vowel_count",
            "possible_transforms": [
              ">= first_word_vowel_count",
              "< first_word_vowel_count",
              "奇偶性相同则反转"
            ]
          },
          {
            "name": "transformation_operation",
            "description": "满足条件时执行的操作",
            "default": "反转整个单词",
            "possible_variants": [
              "将元音字母反转",
              "辅音字母反转",
              "替换为 '*' * length",
              "转换为大写"
            ]
          },
          {
            "name": "reference_word_index",
            "description": "基准元音数来自哪个单词",
            "default": 0,
            "possible_values": [
              0,
              -1,
              "median_word",
              "longest_word"
            ]
          },
          {
            "name": "input_dimension",
            "description": "输入结构维度",
            "default": "1D flat word list",
            "possible_extensions": [
              "2D grid of words",
              "nested sentences (list of strings)"
            ]
          },
          {
            "name": "space_handling",
            "description": "空格处理方式",
            "default": "single space separator",
            "possible_variants": [
              "multiple spaces preserved",
              "tab or newline separated"
            ]
          },
          {
            "name": "data_streaming",
            "description": "输入模式",
            "default": "offline batch processing",
            "possible_modes": [
              "online streaming (process word by word)",
              "interactive query per word"
            ]
          },
          {
            "name": "output_format",
            "description": "输出形式",
            "default": "single string with spaces",
            "possible_forms": [
              "list of processed words",
              "yield generator of words",
              "only return changed words"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Maximum Number of Equal Length Runs",
    "slug": "maximum-number-of-equal-length-runs",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 height，表示 n 个竖直线段的高度，第 i 条线段位于 x = i 处"
      },
      "Core Constraint": {
        "constraint": "容器的水量由两个边界中较短的一边和它们之间的距离共同决定",
        "key_insight": "任意两个端点 (i, j) 构成的容器容量为 min(height[i], height[j]) * |j - i|",
        "dependency": "全局最优解依赖于双指针在两端向中间收缩过程中的状态演化"
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "container area",
        "description": "找出能够盛最多水的两条线段，使得构成的容器面积最大"
      },
      "Algorithmic Invariant": {
        "invariant": "双指针推进过程中保持当前最优解不被遗漏",
        "rules": [
          "初始化左指针 L=0，右指针 R=n-1",
          "每次移动高度较小的一侧指针，因为固定短板时，内移长板不可能获得更大的面积",
          "移动后重新计算面积并更新最大值",
          "指针相遇时终止"
        ],
        "proof_basis": "贪心选择性质：若 height[L] < height[R]，则对于所有 L < k < R，(L, k) 不可能优于当前候选解，因此可以安全地将 L 右移"
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 1e5",
          "small: n <= 100",
          "large: n up to 1e5"
        ],
        "value_range": "height[i] >= 0, up to 1e4",
        "ordering": "unsorted",
        "circular": false,
        "online": false,
        "multiple_queries": false,
        "modifications_allowed": false,
        "output_type": "single integer (maximum area)",
        "variants": [
          "2D version: matrix with elevation map",
          "with obstacles or forbidden positions",
          "dynamic updates: support insert/delete/update operations",
          "count the number of optimal pairs instead of maximum area",
          "minimum area ≥ K: decision problem variant",
          "three lines forming two containers: multi-segment extension"
        ]
      }
    }
  },
  {
    "title": "Maximum Subgraph Score in a Tree",
    "slug": "maximum-subgraph-score-in-a-tree",
    "schema": {
      "Input Structure": [
        "无向树 T = (V, E)，其中 |V| = n，节点编号为 0 到 n-1",
        "边集 edges 是长度为 n-1 的二维整数数组，edges[i] = [a_i, b_i] 表示一条无向边",
        "整数数组 good[0..n-1]，good[i] ∈ {0,1}，表示节点 i 是否为好节点（1 为好，0 为坏）"
      ],
      "Core Constraint": [
        "子图必须是连通的且包含指定节点 i",
        "得分定义为：子图中 good 节点数减去 bad 节点数（即 sum_{v∈S} (2*good[v] - 1)）",
        "由于是树结构，任意连通子图对应一棵子树（或森林中的连通部分），具有最优子结构性质",
        "每个节点的最大得分依赖于其所在连通块中可扩展的正增益分支"
      ],
      "Objective Function": [
        "对每个节点 i，求包含 i 的所有连通子图中的最大得分",
        "目标函数类型：构造性计数 + 最大化",
        "输出：长度为 n 的整数数组 ans，ans[i] 表示节点 i 对应的最大得分"
      ],
      "Algorithmic Invariant": [
        "使用树形 DP 与二次扫描（换根 DP）技术",
        "状态定义：dp[u] 表示以 u 为根的子树中，包含 u 的最大连通子图得分（可选择性加入子树）",
        "转移规则：dp[u] = value[u] + Σ max(0, dp[v])，其中 v 是 u 的子节点，value[u] = 1 if good[u]==1 else -1",
        "换根时维护父子间贡献独立性：当从父转移到子时，可撤销父节点对当前子树的贡献，并重新计算子节点作为根的影响",
        "贪心性质成立：若子树贡献为负，则不纳入当前连通块"
      ],
      "Transformable Parameters": [
        "n 的数量级：2 <= n <= 1e5（支持线性算法）",
        "good 数组值域：{0,1} → 可推广为整数权重数组 w[i]",
        "是否允许环图（→ 图变为一般无向图，问题变为 NP-hard）",
        "是否要求输出方案路径（构造具体子图）",
        "是否多组查询（在线地询问某个节点的最大得分）",
        "输入形式：静态离线输入 → 动态修改 good 值或增删边",
        "约束反转：最大化得分 → 最小化得分 或 求得分等于 0 的方案数",
        "目标变换：改为求全局最大得分的连通子图（而非每个节点）"
      ]
    }
  },
  {
    "title": "Sort Integers by Binary Reflection",
    "slug": "sort-integers-by-binary-reflection",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element": "integer",
        "domain": "positive integers",
        "size": "n",
        "range": "1 <= nums[i] <= 1e9",
        "ordered": false,
        "duplicates_allowed": true
      },
      "Core Constraint": {
        "binary_reflection_definition": "Reverse the binary representation (ignoring leading zeros) and convert back to decimal",
        "comparison_rule": "Sort primarily by binary reflection value in ascending order; break ties by original value in ascending order",
        "functional_dependency": "Reflection value is a deterministic function of the input number's binary form"
      },
      "Objective Function": {
        "goal": "sort",
        "primary_criterion": "ascending order of binary reflection values",
        "secondary_criterion": "ascending order of original values when reflection values are equal"
      },
      "Algorithmic Invariant": {
        "invariant": "The relative order of elements with equal reflection values is determined solely by their original numeric values",
        "stability_property": "Stable sorting on original value after grouping by reflection value preserves correctness",
        "computation_independence": "Each element's reflection value can be computed independently, enabling parallel evaluation"
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 100",
        "value_domain": "positive integers up to 1e9",
        "binary_handling": {
          "leading_zeros": "ignored during reversal",
          "bit_width_constraint": "variable-length binary representation"
        },
        "tie_breaking_rule": "modifiable (e.g., larger original value first, or index-based)",
        "reflection_definition": "swappable (e.g., reverse with leading zeros preserved, or cyclic shift)",
        "sorting_direction": "primary objective可变为降序，或按反射奇偶性分组",
        "input_form": "single array, static offline input",
        "online_possible": false,
        "multi_dimensional_extension": false,
        "data_updates": "static — no insertions/deletions"
      }
    }
  },
  {
    "title": "Convert Number Words to Digits",
    "slug": "convert-number-words-to-digits",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "notation": "H[1..n]",
        "description": "一维非负整数数组，表示柱子的高度"
      },
      "Core Constraint": {
        "left_right_dependency": true,
        "local_contribution_global_bound": true,
        "constraint_description": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定；左右边界约束独立但需全局一致"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "total_water_capacity",
        "objective_description": "计算所有位置可累计的雨水容量总和"
      },
      "Algorithmic Invariant": {
        "two_pointers": true,
        "invariant_rules": [
          "维护左指针 L 和右指针 R，以及从左侧到 L 的最大值 maxLeft，从右侧到 R 的最大值 maxRight",
          "若 maxLeft ≤ maxRight，则 L 处的积水可确定，移动 L",
          "否则，R 处的积水可确定，移动 R",
          "指针移动过程中，已确定区域的解保持不变且最优"
        ],
        "monotonicity_preserved": true,
        "optimality_invariant": true
      },
      "Transformable Parameters": {
        "value_domain": {
          "allow_negative_heights": false,
          "possible_extension": "允许负值作为变形题（如地下坑洞）"
        },
        "spatial_dimension": {
          "current": "1D",
          "extendible_to": [
            "2D",
            "3D",
            "circular_array"
          ]
        },
        "input_mode": {
          "default": "offline_batch",
          "variants": [
            "online_streaming",
            "dynamic_updates_with_insert_delete"
          ]
        },
        "output_requirements": {
          "current": "total_sum",
          "possible_changes": [
            "per_position_contribution",
            "maximum_single_pool",
            "number_of_pools"
          ]
        },
        "data_properties": {
          "sortedness": "unsorted",
          "duplicates_allowed": true,
          "cyclic": false,
          "multi_instance": false
        },
        "scale": {
          "n_range": "[1, 10^5]",
          "value_range": "[0, 10^4]"
        }
      }
    }
  },
  {
    "title": "Total Score of Dungeon Runs",
    "slug": "total-score-of-dungeon-runs",
    "schema": {
      "Input Structure": [
        "正整数 hp，表示初始生命值",
        "长度为 n 的正整数数组 damage[1..n]，damage[i] 表示进入第 i 个房间所受伤害",
        "长度为 n 的正整数数组 requirement[1..n]，requirement[i] 表示在第 i 个房间获得分数所需的最低剩余生命值",
        "数组下标从 1 开始，n >= 1"
      ],
      "Core Constraint": [
        "每个起始位置 j 对应一条路径：依次经过房间 j, j+1, ..., n",
        "生命值随路径线性递减（不可恢复），但即使生命值 ≤ 0 仍可继续进入后续房间",
        "在房间 i 获得分数当且仅当：进入该房间并承受伤害后，剩余生命值 ≥ requirement[i]",
        "score(j) 是从房间 j 开始的路径上能获得的总分",
        "最终目标是求所有 score(j) 的和（j 从 1 到 n）"
      ],
      "Objective Function": "计算并返回所有起始位置 j 的得分之和：score(1) + score(2) + ... + score(n)",
      "Algorithmic Invariant": [
        "对于每个起始点 j，模拟其路径时的生命值变化具有前缀可减性：hp - sum(damage[j..i]) 即为进入房间 i 后的生命值",
        "score(j) 的贡献可以转化为对每个房间 i 的‘被多少个起始点覆盖且满足条件’的计数",
        "若固定房间 i，则所有满足 j <= i 且从 j 出发能活着（满足 requirement[i]）通过房间 i 的起始点 j 都会对 room i 贡献 1 分",
        "因此问题可转化为：对每个房间 i，统计有多少个起始点 j ∈ [1,i] 满足从 j 到 i 的累计扣血后剩余生命值 ≥ requirement[i]"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前为 1e5，可调整至 1e6（推动使用差分或树状数组优化）",
        "hp 的范围：当前为 1e9，可设为变量或在线更新",
        "damage 和 requirement 是否允许零或负值（当前均为正整数）",
        "是否支持修改操作（如动态更改某个房间的 damage 或 requirement）→ 支持数据结构维护",
        "是否多组测试用例",
        "是否要求输出每个 score(j) 而非总和",
        "路径方向变化：从右往左遍历 → 环形地牢 → 多分支图结构",
        "是否允许跳过房间 → 引入选择策略 → 动态规划",
        "是否加入回复机制（如某些房间回血）→ 破坏单调性 → 需要更复杂状态维护"
      ]
    }
  },
  {
    "title": "Minimum Inversion Count in Subarrays of Fixed Length",
    "slug": "minimum-inversion-count-in-subarrays-of-fixed-length",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": "[1, 10^9]",
        "constraints": [
          "nums.length == n",
          "1 <= n <= 10^5",
          "1 <= k <= n"
        ]
      },
      "Core Constraint": {
        "description": "逆序对定义为 i < j 且 nums[i] > nums[j]；子数组是连续的非空序列；需在所有长度为 k 的子数组中统计逆序对数量",
        "key_properties": [
          "逆序对具有局部性，但跨窗口转移时存在可增量维护的结构",
          "滑动窗口过程中，移除左端点和加入右端点对逆序对数的影响可分别计算",
          "元素相对大小关系决定逆序贡献"
        ]
      },
      "Objective Function": {
        "goal": "minimize",
        "target": "number of inversion pairs",
        "scope": "over all contiguous subarrays of length k"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "使用滑动窗口维护当前子数组的逆序对总数",
          "当窗口从 [i-k+1, i] 滑动到 [i-k+2, i+1] 时，可通过删除 nums[i-k+1] 和插入 nums[i+1] 增量更新逆序对数量",
          "若配合有序数据结构（如树状数组、线段树或平衡 BST）维护窗口内元素，则每次插入/删除时可 O(log k) 计算新元素与已有元素形成的逆序数",
          "窗口移动过程中，逆序对总数的变化仅由边界元素与内部元素的相对大小决定"
        ],
        "monotonicity": false,
        "incremental_property": true
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "k",
            "description": "子数组长度",
            "type": "integer",
            "range": "1 <= k <= n",
            "can_vary": true
          },
          {
            "name": "n",
            "description": "数组总长度",
            "type": "integer",
            "range": "1 <= n <= 10^5",
            "can_vary": true
          },
          {
            "name": "nums_value_domain",
            "description": "数组元素值域",
            "type": "integer",
            "range": "[1, 10^9]",
            "can_vary": true,
            "possible_variations": [
              "允许负数",
              "值域缩小至 [1, n] 可离散化",
              "值域极大需在线处理"
            ]
          },
          {
            "name": "input_form",
            "description": "输入形式",
            "possible_forms": [
              "单组数据",
              "多组测试用例",
              "在线查询：每次扩展一个元素并询问当前窗口逆序对"
            ],
            "can_vary": true
          },
          {
            "name": "objective_variation",
            "description": "目标函数变化",
            "possible_targets": [
              "最小逆序对数量（原题）",
              "最大逆序对数量",
              "逆序对数量计数超过阈值的子数组个数",
              "求逆序对数量第 k 小的子数组"
            ],
            "can_vary": true
          },
          {
            "name": "array_dimension",
            "description": "输入维度扩展",
            "possible_extensions": [
              "2D 矩阵中 k×k 子矩阵的逆序对",
              "环形数组"
            ],
            "can_vary": true
          },
          {
            "name": "operation_support",
            "description": "是否支持修改",
            "possible_features": [
              "静态数组（原题）",
              "支持单点修改",
              "支持区间添加"
            ],
            "can_vary": true
          }
        ]
      }
    }
  },
  {
    "title": "Count Elements With at Least K Greater Values",
    "slug": "count-elements-with-at-least-k-greater-values",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n ≥ 1，nums[i] ∈ [1, 10^9]；给定整数 k，满足 0 ≤ k < n",
      "Core Constraint": "一个元素是合格的，当且仅当在数组中存在至少 k 个其他元素严格大于它；元素之间的比较是全局性的，依赖于整个数组的值分布",
      "Objective Function": "计数：统计数组中合格元素的总数",
      "Algorithmic Invariant": "排序后，对于第 i 小的元素（从 0 起始），若其右侧（更大侧）至少有 k 个元素，则该元素合格；等价地，若其排名为 r（去重或重复计数下），则只需判断 n - r - 1 >= k 是否成立",
      "Transformable Parameters": {
        "数据规模": "n 的范围可调，当前为 1 <= n <= 1e5",
        "值域": "nums[i] 的范围可扩展至负数或更大范围，如 [-1e9, 1e9]",
        "是否有序": "输入是否已排序（影响解法选择：排序 vs 桶/计数）",
        "是否多组数据": "可改为多组测试用例输入",
        "是否在线": "可设计为动态添加元素并实时查询合格元素个数",
        "k 的性质": "k 可变为每个元素独立的阈值（如 per-element k_i）",
        "比较关系": "‘严格大于’可变换为‘大于等于’或‘小于’，改变判定逻辑",
        "输出形式": "可要求输出所有合格元素的位置或值列表，而非仅计数"
      }
    }
  },
  {
    "title": "Evaluate Valid Expressions",
    "slug": "evaluate-valid-expressions",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧和右侧最大高度的较小值决定；若该值大于当前高度，则可积水",
      "Objective Function": "计算整个数组在雨水填充后能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max：当 left_max ≤ right_max 时，左指针当前位置的积水可唯一确定；反之右指针位置可确定；指针移动不破坏已计算部分的正确性",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许为负数（如沟壑模型）",
        "维度扩展": "从 1D 数组扩展到 2D 矩阵（二维接雨水问题）",
        "操作类型": "是否支持动态更新（如单点修改、区间赋值）",
        "输入模式": "是否在线输入或流式数据处理",
        "输出要求": "是否需要输出每个位置的具体积水量而非总和",
        "多组数据": "是否存在多组测试用例连续输入",
        "数组性质": "数组是否有序、是否循环（环形接雨水）"
      }
    }
  },
  {
    "title": "Minimum Absolute Distance Between Mirror Pairs",
    "slug": "minimum-absolute-distance-between-mirror-pairs",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "n ∈ [1, 1e5]",
        "nums[i] ∈ [1, 1e9]",
        "整数元素，允许前导零在反转中被忽略"
      ],
      "Core Constraint": [
        "镜像对定义为下标对 (i, j) 满足 i < j 且 reverse(nums[i]) == nums[j]",
        "reverse(x) 表示将 x 的十进制数字逆序排列并忽略前导零",
        "每个位置的值仅通过其数字反转与其他位置建立匹配关系",
        "匹配关系具有方向性：i → j 要求 reverse(nums[i]) == nums[j]，而非对称"
      ],
      "Objective Function": [
        "最小化 abs(i - j)",
        "在所有满足 reverse(nums[i]) == nums[j] 且 i < j 的镜像对中寻找最小下标距离",
        "若不存在任何镜像对，返回 -1",
        "目标类型：最小化（Minimization）"
      ],
      "Algorithmic Invariant": [
        "对于每个位置 i，只需查找后续最早出现的 j（j > i）使得 nums[j] == reverse(nums[i])",
        "一旦对某个 i 找到最近的合法 j，该 i 的局部最优距离即确定",
        "可使用哈希表记录每个数值最后一次（或第一次）出现的位置以支持 O(1) 查询",
        "遍历过程中维护已访问数值的最新下标，保证后续匹配时距离最小化"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e5",
            "可扩展至 1e6（在线场景）"
          ],
          "nums[i] 值域": [
            "[1, 1e9]",
            "可改为 [0, 1e18] 支持更大整数"
          ]
        },
        "输入形式": [
          "单组数组输入",
          "可变更为多组测试用例",
          "可支持流式输入（在线查询）"
        ],
        "reverse 规则": [
          "默认忽略前导零",
          "可变形为保留前导零（如 reverse(120)=021=21 仍视为字符串处理）",
          "可改为 reverse 后必须等于原数（回文约束）"
        ],
        "匹配方向": [
          "当前为单向匹配：i < j 且 reverse(nums[i]) == nums[j]",
          "可扩展为双向匹配：允许 reverse(nums[j]) == nums[i] 同时计入"
        ],
        "目标函数变换": [
          "最小绝对距离 → 最大绝对距离",
          "计数镜像对总数",
          "构造所有镜像对方案"
        ],
        "结构变换": [
          "1D 数组 → 环形数组（允许 j < i 且循环下标）",
          "加入删除/修改操作（动态版本）"
        ],
        "输出要求": [
          "返回最小距离",
          "可改为返回具体下标对",
          "是否存在判定（布尔型输出）"
        ]
      }
    }
  },
  {
    "title": "Concatenate Non-Zero Digits and Multiply by Sum II",
    "slug": "concatenate-non-zero-digits-and-multiply-by-sum-ii",
    "schema": {
      "Input Structure": [
        "长度为 m 的字符串 s，其中 s[i] ∈ {'0','1',..., '9'}",
        "二维整数数组 queries，其中每个查询 queries[i] = [l_i, r_i] 满足 0 <= l_i <= r_i < m"
      ],
      "Core Constraint": [
        "子串中非零数字需按原始顺序提取并连接形成整数 x",
        "若子串无非零数字，则 x = 0",
        "x 的数字和 sum 定义为 x 各位数字之和（注意：即使某位是 0，只要在 x 中出现才计入）",
        "实际计算中 x 可能极大（如 10^5 位），不能直接构造大整数进行运算",
        "必须通过预处理支持高效区间查询"
      ],
      "Objective Function": [
        "对每个查询 [l_i, r_i]，计算 f(s[l_i..r_i]) = (x * sum) mod (10^9 + 7)",
        "其中 x 是由子串中非零数字拼接而成的整数（视为十进制）",
        "sum 是该整数 x 的各位数字之和"
      ],
      "Algorithmic Invariant": [
        "可通过预处理建立两个前缀数组：",
        "  - 非零数字的位置序列及其前缀数字和（用于快速求 sum）",
        "  - 非零数字构成的数值的带权前缀和（考虑十进制权重，模意义下）",
        "利用离散化后的非零位置索引，将任意区间 [l, r] 映射到其对应的非零数字段",
        "使用二分查找定位区间内第一个和最后一个非零数字在全局非零序列中的位置",
        "在模运算下，x 的值可通过带权前缀和差分 + 权重偏移修正得到",
        "整个过程满足：单次查询可在 O(log k) 内完成（k 为非零字符总数）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m": "1e5",
          "queries.length": "1e5"
        },
        "值域": {
          "字符集": "仅数字字符 '0'-'9'",
          "结果模数": "10^9 + 7"
        },
        "是否有序": true,
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "可变参数位": [
          "模数是否变化（例如改为 1e9+9 或不取模）",
          "是否允许负号或其他字符（扩展字符集）",
          "是否改为浮点或科学计数法表示 x",
          "目标函数变为 x + sum 或 sum^2 等",
          "是否要求输出 x 和 sum 分别是多少",
          "是否加入更新操作（如修改某个字符）→ 转为动态问题",
          "是否离线批量处理查询 → 可排序优化",
          "是否限制只能使用滑动窗口或双指针解法（禁止预处理）"
        ]
      }
    }
  },
  {
    "title": "Concatenate Non-Zero Digits and Multiply by Sum I",
    "slug": "concatenate-non-zero-digits-and-multiply-by-sum-i",
    "schema": {
      "Input Structure": "一个非负整数 n，0 <= n <= 10^9",
      "Core Constraint": "所有非零数字必须保持原始顺序连接形成新整数 x；若无非零数字，则 x = 0",
      "Objective Function": "计算 x * sum 的值，其中 x 是由 n 中非零数字按原序拼接而成的整数，sum 是 x 的各位数字之和",
      "Algorithmic Invariant": "遍历 n 的每一位数字时，可以在线性过程中同时构建 x 和累加 sum；x 的构造与 sum 的计算相互独立但同步进行；最终结果仅依赖于 x 和 sum 的乘积，无需回溯或状态回滚",
      "Transformable Parameters": [
        "n 的数据范围（例如扩展到 10^18 或支持负数）",
        "是否允许跳过某些非零数字（如每隔一位取一个）",
        "是否改变数字顺序（如逆序、升序、降序排列后再拼接）",
        "目标函数变换：返回 x + sum / 返回 sum / 返回 x 的位数等",
        "输入形式：从单个整数变为数组形式的数字序列或多组数据输入",
        "是否在线处理流式输入的数字位"
      ]
    }
  },
  {
    "title": "Number of Effective Subsequences",
    "slug": "number-of-effective-subsequences",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "constraints": [
          "1 <= n <= 1e5",
          "1 <= nums[i] <= 1e6"
        ],
        "special_properties": [
          "bitwise OR of empty array is 0",
          "subsequence maintains relative order"
        ]
      },
      "Core Constraint": {
        "definition": "A subsequence is valid if removing it causes the bitwise OR of the remaining elements to strictly decrease.",
        "key_insight": "The total OR of the full array determines the threshold; a valid removal must result in a lower OR value.",
        "dependency": "Global OR depends on presence of bits across all elements; removal is effective only if it eliminates at least one bit that no other remaining element preserves."
      },
      "Objective Function": {
        "goal": "Count",
        "target": "Number of non-empty subsequences whose removal strictly reduces the strength (bitwise OR) of the array.",
        "output_modification": "Return result modulo 1e9 + 7"
      },
      "Algorithmic Invariant": {
        "invariant_1": "An element contributes to maintaining a bit in the global OR if no other surviving element has that bit set.",
        "invariant_2": "For each bit in the total OR, identify critical elements that are the sole carriers of that bit — their removal (and absence from remainder) can reduce OR.",
        "invariant_3": "Use inclusion-exclusion or DP over bits: once we know which subsets of removed elements cause at least one bit loss, count them without duplication.",
        "invariant_4": "Complement counting: total non-empty subsequences minus invalid ones (those whose removal leaves OR unchanged), may be efficient.",
        "complexity_constraint": "Must avoid enumerating all 2^n subsequences; requires bit-based grouping and combinatorial aggregation."
      },
      "Transformable Parameters": {
        "data_size": [
          "n ∈ [1, 1e5]",
          "Can scale down for small-case DP validation"
        ],
        "value_range": [
          "nums[i] ∈ [1, 1e6]",
          "Implies up to ~20 bits active (log2(1e6) ≈ 20)"
        ],
        "modular_arithmetic": true,
        "input_form": "Single batch offline input",
        "multi_query_variants": false,
        "online_updates": false,
        "structural_variations": [
          "Change objective: minimize size of valid subsequence",
          "Change objective: return lexicographically smallest valid subsequence",
          "Reverse constraint: find subsequences whose removal does NOT change OR",
          "Extend to 2D: matrix rows as elements with row-wise OR",
          "Add constraints: contiguous subsequence only"
        ],
        "bit_operation_variants": [
          "Replace OR with AND or XOR",
          "Define strength as sum instead of OR"
        ],
        "empty_subsequence_handling": "Excluded: subsequence must be non-empty"
      }
    }
  },
  {
    "title": "Total Waviness of Numbers in Range II",
    "slug": "total-waviness-of-numbers-in-range-ii",
    "schema": {
      "Input Structure": [
        "两个整数 num1 和 num2，表示一个闭区间 [num1, num2]",
        "每个数字被视为其十进制数位序列",
        "数位序列长度可变（最多 16 位）",
        "输入数值范围：1 <= num1 <= num2 <= 10^15"
      ],
      "Core Constraint": [
        "波动值仅由中间数位（非首尾）决定",
        "峰定义：当前数位严格大于左右相邻数位",
        "谷定义：当前数位严格小于左右相邻数位",
        "判断峰/谷需要局部三元组信息（i-1, i, i+1）",
        "全局目标是累加多个数字的波动值之和，而非单个数字最大波动"
      ],
      "Objective Function": [
        "计算 [num1, num2] 范围内所有整数的波动值之和",
        "目标函数为‘计数型’：统计满足峰/谷条件的数位总数"
      ],
      "Algorithmic Invariant": [
        "数位DP的状态可编码最后两位的值以及前一位的变化趋势（上升/下降）",
        "高位决策不影响低位合法性，但影响峰谷判定依赖关系",
        "可通过记忆化搜索避免重复子问题计算",
        "状态转移保持数位构造过程中的局部一致性，确保峰谷判断正确"
      ],
      "Transformable Parameters": {
        "数据规模": "n 最多为 10^15 → 数位长度 ≤ 16",
        "值域限制": "正整数，无前导零",
        "是否有序": "区间自然有序，用于数位遍历",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "波动定义可变": [
          "可改为非严格比较",
          "允许首尾为峰谷",
          "改变峰谷判定邻域（如五邻域）"
        ],
        "目标函数可变": [
          "求最大波动值的数字",
          "求波动值等于 k 的数字个数",
          "判定是否存在波动值 ≥ k 的数字"
        ],
        "维度扩展": [
          "二维网格上的波动点计数",
          "字符串字符ASCII值的波动分析"
        ],
        "操作类型扩展": [
          "支持区间更新或查询（在线版本）",
          "加入数位修改约束"
        ]
      }
    }
  },
  {
    "title": "Minimum Distance Excluding One Maximum Weighted Edge",
    "slug": "minimum-distance-excluding-one-maximum-weighted-edge",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱子高度",
      "Core Constraint": "每个位置 i 能够接住的雨水量由其左侧最大高度和右侧最大高度中的较小值决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组中能够接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max：当 left_max ≤ right_max 时，左指针所在位置的蓄水量仅受限于 left_max，可安全计算并右移左指针；反之亦然。移动过程中保持已遍历区域的最优性不变",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许为负数（如沟壑模型）",
        "维度扩展": "从 1D 扩展到 2D 网格（二维接雨水问题）",
        "输入模式": "是否在线输入（数据流形式），支持动态更新",
        "操作类型": "是否支持单点修改、区间删除等操作（可持久化或树状数组变体）",
        "输出要求": "是否需要输出每个位置的具体蓄水量而非总和",
        "结构变形": "数组是否为环形结构（首尾相连）",
        "多组数据": "是否存在多组测试用例连续输入",
        "数据规模": "n 的数量级（如 1e3 / 1e5 / 1e7），影响解法选择"
      }
    }
  },
  {
    "title": "Minimum Number of Flips to Reverse Binary String",
    "slug": "minimum-number-of-flips-to-reverse-binary-string",
    "schema": {
      "Input Structure": [
        "正整数 n (1 <= n <= 10^9)",
        "令 s 为 n 的二进制表示字符串（不含前导零）",
        "s 是长度为 L 的二进制字符串，L = floor(log2(n)) + 1"
      ],
      "Core Constraint": [
        "目标是使原串 s 等于其反转串 reverse(s)",
        "只能通过翻转单个位（0↔1）来修改 s",
        "每一位最多翻转一次，每次翻转代价为 1",
        "最优策略必须利用对称性：比较 s[i] 与 s[L-1-i]"
      ],
      "Objective Function": "最小化翻转次数，使得 s 经翻转后等于其反转串",
      "Algorithmic Invariant": [
        "对于每一对对称位置 (i, L-1-i)，若 s[i] ≠ s[L-1-i]，则必须至少翻转其中一个以达成一致",
        "由于翻转任意一位均可，最优选择是无论哪边都只需一次操作，因此每对不匹配贡献 1 次翻转",
        "中间位（当长度为奇数时）无需配对比较，始终满足对称性要求"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^9 → 可扩展至大整数或支持 long long",
        "是否含前导零": "当前不含；可改为固定位宽（如32位）补前导零再处理",
        "输入形式": "当前为单个整数 n；可改为直接输入二进制字符串",
        "是否多组数据": "否；可改为 T 组测试用例",
        "是否在线": "否；可设计为流式输入多个 n 并实时响应",
        "操作类型扩展": "仅允许翻转 → 可加入插入/删除/交换位等操作形成变形题",
        "目标变换": "最小翻转次数 → 判定是否可在 K 次内完成 / 计数所有可行方案数"
      }
    }
  },
  {
    "title": "Minimum Distance Between Three Equal Elements II",
    "slug": "minimum-distance-between-three-equal-elements-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "constraints": [
          "n == nums.length, 1 <= n <= 10^5",
          "1 <= nums[i] <= n",
          "array values are positive integers with possible duplicates"
        ]
      },
      "Core Constraint": {
        "description": "有效三元组要求三个不同下标 i, j, k 满足 nums[i] == nums[j] == nums[k]。对于每个数值，其所有出现位置构成候选集；最小距离三元组必由同一数值的三个最近位置构成。",
        "key_insight": "对每个值而言，最优三元组仅可能出现在其索引列表中相邻或接近的三个位置之间 —— 距离函数具有局部性，全局最小值可在每类值内部局部搜索得到。",
        "dependency": "同值索引间的相对顺序和间距决定解空间结构"
      },
      "Objective Function": {
        "goal": "minimize",
        "target": "有效三元组的距离",
        "expression": "abs(i - j) + abs(j - k) + abs(k - i)",
        "return_type": "integer",
        "edge_case": "若不存在有效三元组，返回 -1"
      },
      "Algorithmic Invariant": {
        "invariant_description": "对于任意固定数值 v，设其出现的下标按升序排列为 [i₁, i₂, ..., iₘ]，则最小距离三元组必在连续三个下标 (iₖ, iₖ₊₁, iₖ₊₂) 中取得（或至少可通过滑动窗口枚举）。因为距离表达式在有序下标下是凸的。",
        "proof_hint": "abs(i−j)+abs(j−k)+abs(k−i) = 2*(max(i,j,k) - min(i,j,k))，当 i ≤ j ≤ k 时简化为 2*(k - i)，因此只与首尾有关。要使该值最小，只需对每个值在其索引序列上维护滑动窗口取最小 (k - i)。",
        "optimality_condition": "枚举每个值的所有连续三元组下标即可覆盖全局最优解"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n_size",
            "values": [
              "1e1",
              "1e3",
              "1e5"
            ],
            "note": "影响是否可用 O(n²) 暴力"
          },
          {
            "name": "value_range",
            "values": [
              "[1, n]",
              "[1, 1e9]"
            ],
            "note": "决定是否需要离散化"
          },
          {
            "name": "array_order",
            "values": [
              "unordered",
              "sorted"
            ],
            "note": "若已排序，则需额外记录原下标"
          },
          {
            "name": "duplication_density",
            "values": [
              "sparse",
              "dense"
            ],
            "note": "影响每类值的索引数量"
          },
          {
            "name": "objective_variation",
            "values": [
              "minimize distance",
              "maximize distance",
              "count valid triples"
            ],
            "note": "目标函数变换"
          },
          {
            "name": "triplet_size",
            "values": [
              "3",
              "k"
            ],
            "note": "推广到 k 元组"
          },
          {
            "name": "input_mode",
            "values": [
              "offline",
              "online"
            ],
            "note": "是否动态添加元素"
          },
          {
            "name": "spatial_dimension",
            "values": [
              "1D",
              "2D"
            ],
            "note": "如二维坐标点上的相同值三元组"
          }
        ]
      }
    }
  },
  {
    "title": "Minimum Moves to Equal Array Elements III",
    "slug": "minimum-moves-to-equal-array-elements-iii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "nums.length >= 1",
          "nums.length <= 100",
          "nums[i] >= 1",
          "nums[i] <= 100"
        ],
        "description": "一维整数数组 nums，表示初始元素值"
      },
      "Core Constraint": {
        "constraint": "只能通过增加操作使元素相等，不能减少；因此最终目标值必为原数组中的某个值（最优情况下为目标值 ≥ max(nums)）",
        "implication": "所有元素必须被提升至同一目标值，且该目标值至少为数组最大值"
      },
      "Objective Function": {
        "type": "minimization",
        "goal": "最小总操作次数",
        "description": "求将所有元素通过 +1 操作变为相等所需的最少操作步数"
      },
      "Algorithmic Invariant": {
        "invariant": "目标值取为数组最大值时总操作数最小",
        "proof_hint": "若目标值 > max(nums)，则每个元素需更多操作；而由于只能增加，目标值不能 < max(nums)。因此最优目标值 = max(nums)",
        "consequence": "问题转化为：对每个元素计算 (max_value - nums[i]) 的和"
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          100
        ],
        "value_range": [
          1,
          100
        ],
        "operation_type": [
          "increment_only",
          "decrement_only",
          "both"
        ],
        "target_equality_constraint": "all_equal",
        "input_form": "single_array",
        "online_query": false,
        "multiple_test_cases": false,
        "modifications_allowed": false,
        "dimension_extension": "1D",
        "hidden_constraints": []
      }
    }
  },
  {
    "title": "Minimum Distance Between Three Equal Elements I",
    "slug": "minimum-distance-between-three-equal-elements-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "integer",
        "size": "n",
        "value_range": [
          1,
          "n"
        ],
        "constraints": [
          "nums.length == n",
          "1 <= n <= 100",
          "1 <= nums[i] <= n",
          "indices are 0-based"
        ]
      },
      "Core Constraint": {
        "description": "有效三元组要求三个不同下标 i, j, k 满足 nums[i] == nums[j] == nums[k]。距离由三者两两绝对差之和决定，且该表达式可化简为 2*(max(i,j,k) - min(i,j,k))。",
        "mathematical_form": "abs(i - j) + abs(j - k) + abs(k - i) = 2 * (max(i,j,k) - min(i,j,k))",
        "implication": "对于相同数值的下标序列，最优三元组必然是连续或紧凑排列的三个下标（即局部极小跨度），全局最小值必出现在某一数值对应下标列表的某三个相邻位置。"
      },
      "Objective Function": {
        "type": "minimization",
        "goal": "返回所有有效三元组中的最小距离",
        "fallback": "若不存在有效三元组，返回 -1"
      },
      "Algorithmic Invariant": {
        "invariant_description": "对每个数值 v，将其所有出现的下标收集为有序列表 L_v。在 L_v 中，任意三元组的最小距离一定出现在三个连续下标 (L_v[i], L_v[i+1], L_v[i+2]) 中。",
        "proof_hint": "由于目标函数等价于 2*(最大下标 - 最小下标)，固定中间点不会减少跨度；因此非连续三元组跨度必然不小于其包含的连续子集。",
        "optimality_preservation": "只需遍历每个值对应的下标列表中所有长度为3的连续滑动窗口，即可覆盖所有候选最优解。"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n_size",
            "range": [
              "small: <= 100",
              "medium: ~1e5",
              "large: ~1e6"
            ],
            "impact": "当前暴力可解；若增大需优化至线性扫描每类值"
          },
          {
            "name": "value_domain",
            "options": [
              "bounded: [1,n]",
              "unbounded: arbitrary integers",
              "negative_allowed"
            ],
            "impact": "影响哈希表或数组索引的使用方式"
          },
          {
            "name": "input_structure",
            "options": [
              "1D array",
              "2D grid",
              "circular array",
              "streaming input"
            ],
            "impact": "环形结构需考虑模意义下的距离；流式输入需在线维护下标"
          },
          {
            "name": "objective_variation",
            "options": [
              "min_distance",
              "max_distance",
              "count_triplets",
              "expected_distance"
            ],
            "impact": "计数问题转为组合数学；最大化可能需要首尾取极端"
          },
          {
            "name": "triplet_definition",
            "options": [
              "exactly three indices",
              "at least three with sub-triplet",
              "weighted distance"
            ],
            "impact": "扩展为四元组或加权距离将改变状态空间"
          },
          {
            "name": "data_modification",
            "options": [
              "static",
              "supports update/delete/query",
              "online queries"
            ],
            "impact": "动态场景需设计支持插入删除的数据结构"
          },
          {
            "name": "output_requirement",
            "options": [
              "return minimum distance",
              "return triplet indices",
              "return all minimal triplets"
            ],
            "impact": "构造方案输出增加信息存储需求"
          }
        ]
      }
    }
  },
  {
    "title": "Find Kth Character in Expanded String",
    "slug": "find-kth-character-in-expanded-string",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度的较小值决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组能接的雨水总量（求和）",
      "Algorithmic Invariant": "维护两个指针 L 和 R，分别从左右两端向中间移动；维护 left_max 和 right_max 表示截至目前左右两侧的最大高度；若 left_max ≤ right_max，则左指针位置的蓄水量可确定，并向右移动左指针；反之则确定右指针位置并左移右指针；移动过程中保持已遍历区域的最优性不变",
      "Transformable Parameters": {
        "H 是否允许负值": false,
        "维度扩展": "可以扩展至二维矩阵（如 2D 接雨水问题）",
        "输入模式": "支持离线批量输入或在线流式更新（加入删除操作）",
        "输出要求": "可变：总容量 / 每个位置的容量 / 最大单区储水量",
        "数据规模 n": "1 ≤ n ≤ 3×10^4（标准范围），可调整为更大规模以测试复杂度边界",
        "是否有序": "原始无序，但可通过预处理构造单调结构",
        "是否循环": "非环形结构，可变形为环形数组以增加难度"
      }
    }
  },
  {
    "title": "Maximize Expression of Three Elements",
    "slug": "maximize-expression-of-three-elements",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "3 <= n <= 100",
        "value_range": "-100 <= nums[i] <= 100",
        "duplicates_allowed": true,
        "order": "unordered"
      },
      "Core Constraint": {
        "constraint_description": "三个元素 a, b, c 必须来自不同下标，表达式为 a + b - c",
        "key_insight": "最大化 a + b - c 等价于选择最大的两个数作为 a 和 b，最小的数作为 c",
        "dependency_structure": "全局极值决定最优解，局部组合无效"
      },
      "Objective Function": {
        "type": "maximization",
        "target_expression": "a + b - c",
        "output_type": "single_integer",
        "solution_type": "value_only"
      },
      "Algorithmic Invariant": {
        "invariant_description": "最优解必然由数组中最大两个元素和最小一个元素构成",
        "proof_idea": "a 和 b 的系数为正，应取最大；c 的系数为负，应取最小以使 -c 最大",
        "greedy_condition": "存在可证明的贪心策略：选 max1, max2 作为 a,b，min1 作为 c",
        "optimality_preservation": "任何偏离该选择的方案都不会更优"
      },
      "Transformable Parameters": {
        "n_size": [
          "small: 3~100"
        ],
        "value_domain": [
          "signed integers",
          "non-negative",
          "positive-only",
          "negative-heavy"
        ],
        "input_order": [
          "unordered",
          "sorted",
          "reverse-sorted"
        ],
        "distinct_indices_required": true,
        "number_of_queries": "single_instance",
        "data_streaming": false,
        "operation_support": [],
        "objective_variants": [
          "minimize a + b - c",
          "count number of triples achieving maximum",
          "maximize a - b + c",
          "generalize to k-element expression"
        ],
        "structural_variants": [
          "2D array input",
          "circular array constraint",
          "with constraints on index differences"
        ]
      }
    }
  },
  {
    "title": "Count Stable Subarrays",
    "slug": "count-stable-subarrays",
    "schema": {
      "Input Structure": {
        "nums": "一维整数数组 A[1..n], 其中 n = len(nums), 1 <= n <= 10^5, 元素为非负整数（实际为正整数）",
        "queries": "二维整数数组 Q[1..q], 每个查询为 [l_i, r_i], 表示子数组范围的闭区间, 1 <= q <= 10^5"
      },
      "Core Constraint": {
        "Stable Subarray Definition": "子数组是稳定的当且仅当其中不存在逆序对，即对所有 i < j，都有 nums[i] <= nums[j]",
        "Monotonicity Implication": "稳定子数组等价于单调不降子数组（非严格递增）",
        "Local-Global Consistency": "一个子数组是否稳定仅由其内部元素顺序决定，且局部稳定性不能直接推出全局，但可通过扩展规则验证"
      },
      "Objective Function": {
        "Primary Goal": "计数（Counting）",
        "Target": "对每个查询 [l_i, r_i]，统计完全位于该区间内的所有稳定子数组的数量",
        "Subtype": "离线区间内满足单调性约束的连续子结构计数问题"
      },
      "Algorithmic Invariant": {
        "Expansion Rule": "对于固定左端点 l，向右扩展 r 直到出现 nums[r] < nums[r-1] 时停止，此时从 l 开始的所有前缀子数组均稳定",
        "Two Pointers / Sliding Window": "使用双指针维护极大稳定子数组：若 [i, j] 稳定，则其任意子区间也稳定；可基于此预处理所有极大段",
        "Contribution Counting": "长度为 L 的极大稳定子数组包含 L*(L+1)/2 个稳定子数组，可用于批量贡献计算",
        "Offline Query Handling": "可结合莫队算法或离线排序 + 扫描线处理，但在值域和数据规模下更优解为预处理 + 二分/前缀和"
      },
      "Transformable Parameters": {
        "Array Properties": [
          "是否有序（当前无序）",
          "是否允许重复元素（允许）",
          "值域范围（当前 1~10^5）",
          "是否可负（当前不可）"
        ],
        "Query Settings": [
          "是否多组输入（是）",
          "是否在线查询（当前为离线）",
          "查询形式：单次区间 vs 多区间聚合",
          "输出形式：仅总数 / 列出所有子数组"
        ],
        "Constraint Variants": [
          "稳定定义变化：无逆序 → 无顺序对 → 最多k个逆序对",
          "目标函数变换：最大长度 / 存在性判定 / 构造最长者",
          "维度扩展：从 1D 数组到 2D 矩阵中的稳定行/列块"
        ],
        "Data Flow Mode": [
          "静态数组 → 支持单点修改 → 在线流式添加元素"
        ],
        "Complexity Boundaries": {
          "Desired Time Complexity": "O(n + q log n) 或 O((n + q) α(n))，避免 O(n^2)",
          "Feasible Algorithm Class": "预处理所有极大稳定段 + 区间查询加速（如前缀和 + 二分查找）"
        }
      }
    }
  },
  {
    "title": "Maximum Calories Burnt from Jumps",
    "slug": "maximum-calories-burnt-from-jumps",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 H[1..n]，表示每个位置上的柱子高度"
      },
      "Core Constraint": {
        "left_right_dependency": true,
        "local_contribution_global_bound": true,
        "constraint_description": "每个位置 i 能储存的水量由其左侧最大值和右侧最大值中的较小者决定；若该值大于当前高度，则可储水"
      },
      "Objective Function": {
        "goal": "sum",
        "objective_description": "计算整个数组所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "two_pointers": true,
        "invariant_rules": [
          "维护左指针 L 和右指针 R，以及从左到 L 的最大值 maxLeft，从右到 R 的最大值 maxRight",
          "若 maxLeft ≤ maxRight，则位置 L 处的储水量仅受限于 maxLeft，可以直接计算并左移 L",
          "否则，位置 R 处的储水量受限于 maxRight，可以计算并右移 R",
          "指针移动过程中，已确定区域的贡献始终保持正确"
        ]
      },
      "Transformable Parameters": {
        "value_domain": {
          "allows_negative": false,
          "possible_extension": "允许负值作为变形（如地下凹陷）"
        },
        "dimensionality": {
          "current": "1D",
          "possible_transformation": "扩展至 2D（二维接雨水问题）"
        },
        "input_mode": {
          "current": "offline",
          "possible_extensions": [
            "在线输入流（数据逐步到达）",
            "支持删除/插入/修改操作（动态版本）"
          ]
        },
        "output_form": {
          "current": "总容量",
          "possible_variants": [
            "输出每个位置的具体储水量",
            "输出最大单段连续储水区间"
          ]
        },
        "data_properties": {
          "sorted": false,
          "circular": false,
          "duplicate_values": true,
          "possible_transformations": [
            "环形数组（首尾相连）",
            "有序输入（用于优化或构造特例）"
          ]
        },
        "multiple_test_cases": false,
        "possible_enhancement": "支持多组测试数据批量处理"
      }
    }
  },
  {
    "title": "Minimum Operations to Make the Array Beautiful",
    "slug": "minimum-operations-to-make-the-array-beautiful",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"array\",\n    \"dimension\": 1,\n    \"elements\": \"non-negative integers\",\n    \"size\": \"n\",\n    \"sorted\": false,\n    \"duplicates\": true\n  },\n  \"Core Constraint\": {\n    \"description\": \"Each position's water capacity is determined by the minimum of the maximum heights to its left and right, minus its own height. The constraint couples local structure with global extremal values.\"\n  },\n  \"Objective Function\": {\n    \"type\": \"sum\",\n    \"goal\": \"total accumulated water capacity\",\n    \"output\": \"scalar integer representing total trapped water\"\n  },\n  \"Algorithmic Invariant\": {\n    \"invariant\": \"Two pointers (left and right) maintain the maximum heights encountered so far on each side. At each step, if the left max is less than or equal to the right max, the left pointer's contribution can be finalized because the bottleneck is known; similarly for the right. Pointer movement preserves correctness of already-computed regions.\"\n  },\n  \"Transformable Parameters\": {\n    \"n_range\": [1, 3 * 10^4],\n    \"value_range\": [0, 10^5],\n    \"allow_negative_heights\": false,\n    \"input_dimensionality\": \"1D\",\n    \"online_queries\": false,\n    \"support_updates\": false,\n    \"output_detail_level\": \"total sum only\",\n    \"multiple_test_cases\": false,\n    \"circular_array\": false,\n    \"monotonicity_assumed\": false\n  }\n}"
  },
  {
    "title": "Find Missing Elements",
    "slug": "find-missing-elements",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "元素互不相同",
        "nums[i] 为整数，值域 [1, 100]",
        "2 <= n <= 100",
        "最小值 min_val 和最大值 max_val 均存在于数组中"
      ],
      "Core Constraint": [
        "缺失的整数位于闭区间 [min(nums), max(nums)] 内",
        "原数组应包含该区间内所有整数，现部分缺失",
        "数组无重复元素，且边界值（最小和最大）始终存在"
      ],
      "Objective Function": [
        "构造并返回一个有序列表",
        "列出 [min(nums), max(nums)] 范围内所有不在 nums 中的整数",
        "按从小到大排序",
        "若无缺失，则返回空列表"
      ],
      "Algorithmic Invariant": [
        "排序后遍历可保证顺序连续性",
        "对于每个整数 i ∈ [min, max]，其是否在 nums 中是唯一判定条件",
        "可通过集合哈希或双指针归并方式线性补全缺失项",
        "遍历过程中维护当前期望整数值，逐步推进至 max"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的范围：[2, 100]",
        "值域": "[1, 100]，可扩展至更大范围或负数",
        "是否有序": "输入无序，但可排序；可变参数为 '是否预排序'",
        "是否多组数据": "可设计为多组测试用例输入",
        "是否在线": "当前为离线输入；可改为流式输入数字并动态检测缺失",
        "输入形式": "可变为已排序数组、链表、区间合并形式等",
        "输出要求": "可改为仅返回缺失个数、最长连续缺失段、或任意顺序输出后排序"
      }
    }
  },
  {
    "title": "Lexicographically Smallest String After Reverse II",
    "slug": "lexicographically-smallest-string-after-reverse-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置能接住的雨水量由其左侧最大高度和右侧最大高度中的较小值决定，且左右边界约束独立但需全局一致",
        "key_insight": "局部水量受限于‘短板’（min(left_max, right_max)），而该值只能通过全局信息确定"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组所有位置能够接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft = max(H[0..L]) 和 maxRight = max(H[R..n-1])",
          "若 maxLeft ≤ maxRight，则位置 L 处的可接雨水量为 max(0, maxLeft - H[L])，随后 L += 1",
          "否则，位置 R 处的可接雨水量为 max(0, maxRight - H[R])，随后 R -= 1",
          "指针移动过程中，已确定区域的贡献始终保持最优且不可变"
        ],
        "proof_basis": "当 maxLeft ≤ maxRight 时，右端存在更高的边界，因此左指针当前位置的瓶颈仅由左侧历史最大值决定，无需等待右侧完全扫描"
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 3 * 10^4",
          "可改为：n <= 1e5 或支持在线流式输入"
        ],
        "value_range": [
          "0 <= H[i] <= 3 * 10^4",
          "可扩展为允许负值（表示凹陷地形）"
        ],
        "ordering": "数组无序，但隐含单调性可用于优化",
        "dimensionality": "可变换为 2D 矩阵接雨水问题（如 LeetCode 407）",
        "input_mode": "单次离线输入；可改造为支持动态更新或查询（加入修改操作）",
        "output_mode": [
          "仅求总和（当前）",
          "也可要求输出每个位置的具体储水量",
          "或返回最多能接水的区间"
        ],
        "additional_constraints": [
          "是否环形排列（首尾相连）",
          "是否限制使用额外空间（推动双指针而非预处理数组）",
          "是否多组测试数据"
        ]
      }
    }
  },
  {
    "title": "Find Churn Risk Customers",
    "slug": "find-churn-risk-customers",
    "schema": {
      "Input Structure": [
        "二维表格 subscription_events",
        "每行包含：event_id (int), user_id (int), event_date (date), event_type (varchar ∈ {'start', 'upgrade', 'downgrade', 'cancel'}), plan_name (varchar), monthly_amount (decimal ≥ 0)",
        "按时间顺序排列的用户订阅事件流，同一 user_id 可有多条记录",
        "数据为离线批处理形式，完整历史可见"
      ],
      "Core Constraint": [
        "用户状态演化依赖于其事件序列的时间顺序",
        "最终状态由最后一条事件记录决定（是否 cancel 判断有效性）",
        "历史最大 monthly_amount 必须在所有非-cancel事件中取值",
        "降级行为(downgrade)必须至少出现一次且发生在当前有效订阅前",
        "当前订阅费用 < 历史最高费用 × 0.5 构成经济动机流失信号",
        "订阅时长 = 最后事件日期 - 首次事件日期 ≥ 60 天构成活跃度约束"
      ],
      "Objective Function": [
        "筛选满足全部四个条件的用户集合",
        "构造输出表：user_id, current_plan, current_monthly_amount, max_historical_amount, days_as_subscriber",
        "排序目标：先按 days_as_subscriber 降序，再按 user_id 升序"
      ],
      "Algorithmic Invariant": [
        "每个用户的事件序列可独立处理（用户间无依赖）",
        "通过分组聚合可安全提取每个用户的首/末事件、最大金额、是否含 downgrade",
        "状态判定可在单遍扫描中完成：对每个 user_id 提取关键统计量后做逻辑判断",
        "排序操作可在过滤后执行，不影响正确性"
      ],
      "Transformable Parameters": {
        "n 的数量级": [
          "10^3 ~ 10^6 行",
          "用户数可变"
        ],
        "值域": {
          "monthly_amount": "正实数，典型范围 [9.99, 49.99]",
          "event_date 跨度": "支持跨月/跨年计算"
        },
        "是否有序": "输入按 event_date 时间顺序给出（隐式），但未强制索引",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": "离线批量处理；可扩展为每日增量更新（改为在线流式）",
        "条件参数化": {
          "最低订阅天数阈值": "60 天 → 可调整为 K 天",
          "费用下降比例阈值": "50% → 可设为 α%",
          "关注的行为类型": [
            "downgrade → 可加入多次 downgrade 或特定 plan 路径"
          ]
        },
        "输出变化": [
          "仅返回 user_id → 返回完整风险画像",
          "静态快照 → 按周/月滚动检测流失风险"
        ]
      }
    }
  },
  {
    "title": "Maximum Product of Three Elements After One Replacement",
    "slug": "maximum-product-of-three-elements-after-one-replacement",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": [
          3,
          100000
        ],
        "value_range": [
          -100000,
          100000
        ],
        "description": "一维整数数组 nums，长度在 [3, 1e5] 范围内，元素值在 [-1e5, 1e5] 范围内"
      },
      "Core Constraint": {
        "constraint": "必须恰好替换一个元素为 [-1e5, 1e5] 范围内的任意整数，且选择三个不同下标的元素构成乘积",
        "implication": "最优解依赖于原数组中最大/最小值的分布以及替换操作对极值的影响",
        "key_insight": "最大三元组乘积由最大正数或最小负数组合决定，替换操作可人为构造极值（±1e5）来优化结果"
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "product of three distinct elements",
        "output_type": "integer",
        "description": "在执行一次替换后，所有可能三元组中能达到的最大乘积"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "最大乘积三元组一定由排序后最左端（最小）或最右端（最大）的若干元素构成",
          "替换一个元素的最优策略是将其改为 -1e5 或 1e5，取决于其对符号和绝对值的贡献",
          "若原数组已有足够大的正值或负值组合，则最优替换位置通常位于非极值位置以提升整体极值",
          "通过枚举每个位置被替换为 ±1e5 的情况，并结合剩余元素选取最大/最小候选，可覆盖所有可能最优解"
        ],
        "optimality_condition": "贪心选择：每次替换都尝试增强当前潜在最优三元组的乘积（如用大正数替代中间负数，或用大负数创造双负得正）"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "array_size",
            "type": "integer",
            "range": [
              3,
              "inf"
            ],
            "default": 100000,
            "description": "数组长度 n，影响是否可用排序或枚举策略"
          },
          {
            "name": "value_domain",
            "type": "integer",
            "range": [
              -100000,
              100000
            ],
            "mutable": true,
            "description": "原数组与替换值的取值范围，可扩展至更大或限制更小"
          },
          {
            "name": "number_of_replacements",
            "type": "integer",
            "possible_values": [
              1,
              "k"
            ],
            "default": 1,
            "description": "是否允许替换多个元素（本题固定为恰好一个）"
          },
          {
            "name": "replacement_value_choice",
            "type": "constrained",
            "options": [
              "fixed_extremes",
              "arbitrary_in_range"
            ],
            "default": "arbitrary_in_range",
            "description": "替换值是否必须为 ±1e5，或可在范围内任选"
          },
          {
            "name": "input_order",
            "type": "boolean",
            "sorted": false,
            "description": "数组是否有序；若有序可优化枚举过程"
          },
          {
            "name": "online_queries",
            "type": "boolean",
            "possible_values": [
              false,
              true
            ],
            "default": false,
            "description": "是否支持多次查询或动态更新（本题为离线单次输入）"
          },
          {
            "name": "output_requirement",
            "type": "string",
            "options": [
              "max_product",
              "construct_triplet",
              "count_optimal_solutions"
            ],
            "default": "max_product",
            "description": "是否仅返回数值，或还需构造方案"
          }
        ]
      }
    }
  },
  {
    "title": "Complete Prime Number",
    "slug": "complete-prime-number",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "range": "1 <= num <= 10^9",
        "description": "一个正整数 num，表示待判断的数字"
      },
      "Core Constraint": {
        "prefix_suffix_decomposition": true,
        "prime_definition": "大于 1 且仅能被 1 和自身整除的自然数",
        "constraint_logic": "一个数是完全质数，当且仅当它的每一个非空前缀（从最高位开始的连续前 k 位）和每一个非空后缀（从最低位开始的连续后 k 位）都是质数",
        "edge_case_handling": "个位数只需自身为质数即可"
      },
      "Objective Function": {
        "type": "decision",
        "goal": "判定给定整数 num 是否为完全质数",
        "output": "boolean: true 如果所有前缀和后缀均为质数，否则 false"
      },
      "Algorithmic Invariant": {
        "digit_extraction_invariance": "从前向后提取前缀、从后向前提取后缀的过程中，每个子串对应的整数值可依次计算，且不会重复或遗漏",
        "primality_check_reusability": "对每个前缀和后缀进行质数判断时，可以复用统一的质数检测函数",
        "monotonic_structure": "前缀和后缀的生成具有顺序性和完整性，遍历所有长度 k ∈ [1, len(num)] 可覆盖全部情况",
        "early_termination": "一旦发现某个前缀或后缀不是质数，可立即返回 false，不影响最终正确性"
      },
      "Transformable Parameters": {
        "value_range": "1 <= num <= 10^9",
        "digit_length": "最多 10 位十进制数字",
        "prime_check_method": [
          "试除法（适用于小值域）",
          "预处理质数表（如筛法预计算 sqrt(10^9) ≈ 31622 内的质数）",
          "Miller-Rabin 等概率算法（扩展到更大范围）"
        ],
        "input_form": [
          "单个整数输入",
          "是否支持多组测试数据",
          "是否在线流式输入多个 num 进行批量判断"
        ],
        "output_form": [
          "仅返回布尔值",
          "返回首个非法前缀/后缀",
          "返回所有合法前缀与后缀列表"
        ],
        "structural_variation": [
          "是否要求前缀和后缀去重后再判断",
          "是否允许前导零（本题不适用，因输入为正整数）",
          "是否推广到其他进制（如二进制、十六进制）"
        ],
        "relaxation_constraints": [
          "放宽为‘至少 K 个前缀和后缀是质数’",
          "改为计数问题：统计有多少个前缀和后缀同时为质数",
          "目标变换：求最小/最大完全质数在某区间内"
        ]
      }
    }
  },
  {
    "title": "Minimum Operations to Make Binary Palindrome",
    "slug": "minimum-operations-to-make-binary-palindrome",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element": "integer",
        "dimension": 1,
        "length_range": [
          1,
          5000
        ],
        "value_range": [
          1,
          5000
        ],
        "description": "一维整数数组 nums[1..n]，每个元素在 [1, 5000] 范围内"
      },
      "Core Constraint": {
        "constraint": "每个数字可独立变换为任意整数，目标是找到离原值最近的二进制回文数",
        "key_insight": "二进制回文数的判定与数值大小无关，仅依赖其二进制表示的对称性；且每个位置的转换操作相互独立",
        "independence": "各 nums[i] 的最小操作次数可独立求解，无跨元素依赖"
      },
      "Objective Function": {
        "goal": "对于每个 nums[i]，求将其变为某个二进制回文数所需的最小加减操作次数",
        "output_type": "array of integers",
        "objective": "minimization per element"
      },
      "Algorithmic Invariant": {
        "invariant": "对任意整数 x，距离 x 最近的二进制回文数必然出现在以 x 为中心、向两侧扩展的有限邻域内",
        "search_property": "由于值域受限（≤5000），所有可能的二进制回文数可预先生成并排序，形成候选集",
        "optimality_preservation": "对每个 nums[i]，在其邻近候选回文数中取绝对差最小者，即可保证局部最优解即全局最优解"
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          5000
        ],
        "value_domain": [
          1,
          5000
        ],
        "palindrome_definition": "binary representation is palindromic (no leading zeros)",
        "operation_set": [
          "add 1",
          "subtract 1"
        ],
        "input_form": "batch offline array",
        "output_form": "array of minimal steps per element",
        "multi_query": false,
        "online_input": false,
        "allow_negative": false,
        "variable_objective": [
          "count how many can become palindrome within k moves",
          "find the closest palindrome value (not just step count)",
          "return all possible nearest palindromes if tie"
        ],
        "structural_variation": [
          "change base: e.g., ternary palindrome",
          "require non-adjacent transformation (e.g., only bit flips allowed)",
          "extend to 2D grid where cells must reach palindrome via diffusion"
        ]
      }
    }
  },
  {
    "title": "Longest Non-Decreasing Subarray After Replacing at Most One Element",
    "slug": "longest-non-decreasing-subarray-after-replacing-at-most-one-element",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 1e5",
        "value_range": "-1e9 <= nums[i] <= 1e9",
        "continuity_required": true,
        "sortedness": "unsorted",
        "modifiability": "at most one element can be replaced with any integer"
      },
      "Core Constraint": {
        "constraint": "子数组必须是非递减的（即 nums[i] >= nums[i-1]）",
        "violation_handling": "允许至多一次任意值替换来修复一处或连续多处下降",
        "local_dependency": "当前最长非递减段依赖于前一个元素的值以及是否已使用替换操作",
        "segmentation": "非递减段在遇到严格下降且无法通过替换修复时中断"
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "length of contiguous non-decreasing subarray",
        "optimization_type": "construction and maximization under single modification allowance"
      },
      "Algorithmic Invariant": {
        "invariant": "维护两个状态：以当前位置结尾、未使用替换和已使用替换的最长非递减长度",
        "state_monotonicity": "dp[i][0] 和 dp[i][1] 均基于 i-1 的状态转移，保持局部最优可扩展性",
        "transition_rule": [
          "若 nums[i] >= nums[i-1]，则两个状态均可从前一状态延续",
          "否则，未使用替换的状态只能从头开始；而已使用替换的状态可尝试将 nums[i-1] 替换为 <= nums[i] 的值以延续前面的段",
          "也可考虑将 nums[i] 替换为 >= nums[i-1] 的值，从而接续前面的非递减段"
        ],
        "greedy_choice": "每次替换的选择不显式构造，而是通过状态转移隐式覆盖最优替换位置"
      },
      "Transformable Parameters": {
        "k_replacements": "1 (可推广至 k)",
        "array_dimension": "1D (可变：2D 滑窗+修改)",
        "modification_type": [
          "replace → delete / insert / swap"
        ],
        "order_type": [
          "non-decreasing → non-increasing / strictly increasing"
        ],
        "input_form": [
          "single array → multiple queries / online stream"
        ],
        "output_form": [
          "length only → reconstruct the modified subarray"
        ],
        "constraints_on_modification": [
          "free replace → cost-limited replacement / restricted value domain after replace"
        ],
        "data_streaming": false,
        "multiple_test_cases": false,
        "circular_array": false
      }
    }
  },
  {
    "title": "Find Golden Hour Customers",
    "slug": "find-golden-hour-customers",
    "schema": {
      "Input Structure": [
        "表 restaurant_orders",
        "列：order_id (int, 主键)",
        "customer_id (int)",
        "order_timestamp (datetime, 包含日期和时间)",
        "order_amount (decimal)",
        "payment_method (varchar, 取值为 'cash', 'card', 'app')",
        "order_rating (int, 范围 1-5, 可为 NULL)"
      ],
      "Core Constraint": [
        "每个客户的订单行为需满足多维复合条件：频次、时间分布、评分完成率、平均评分",
        "高峰时间定义为两个固定区间：11:00-14:00 或 18:00-21:00，仅依赖时间部分（忽略日期）",
        "条件之间相互独立但必须同时满足（合取约束）",
        "聚合统计基于 customer_id 分组，且各指标可局部计算（总订单数、高峰订单数、评分订单数、评分总和）"
      ],
      "Objective Function": [
        "筛选出满足全部四个条件的客户（判定 + 构造结果集）",
        "输出字段包括：customer_id, total_orders, peak_hour_percentage（整数百分比）, average_rating（保留两位小数）",
        "结果按 average_rating 降序，再按 customer_id 降序排序"
      ],
      "Algorithmic Invariant": [
        "分组聚合过程中，每个 customer_id 的各项计数（总数、高峰数、评分存在性、评分和）可增量维护",
        "高峰时间判断是确定性函数：time ∈ [11:00,14:00) ∪ [18:00,21:00)",
        "平均评分与评分完成率可由局部累加值推导，无需全局信息",
        "最终筛选条件为静态阈值比较，支持一次性过滤"
      ],
      "Transformable Parameters": {
        "订单数量阈值": "至少k笔订单（原题k=3）",
        "高峰时间窗口": "可变时间段（如改为 9:00-11:00）、多个区间、周期性或动态定义",
        "高峰占比要求": "≥p%（原题60%），可反转为 ≤p% 或删除",
        "评分完成率要求": "已评价比例 ≥r%（原题50%），可调整或移除",
        "平均评分阈值": "≥s（原题4.0），可变为 >s 或引入方差约束",
        "评分处理方式": "是否四舍五入、是否排除低分订单、是否加权",
        "输出格式": "是否输出中间指标、是否只返回 customer_id 列表",
        "排序规则": "主次键可变（如按订单数升序，再按评分降序）",
        "数据范围": "是否限定时间区间（如最近30天）、是否多表关联",
        "输入形式": "单表输入 → 多源流式输入（在线统计）",
        "NULL处理逻辑": "order_rating为NULL时视为未评分 vs 视为最低分"
      }
    }
  },
  {
    "title": "Minimum String Length After Balanced Removals",
    "slug": "minimum-string-length-after-balanced-removals",
    "schema": {
      "Input Structure": {
        "type": "string",
        "alphabet": [
          "a",
          "b"
        ],
        "length": "n",
        "n_range": [
          1,
          100000
        ],
        "description": "仅由字符 'a' 和 'b' 组成的字符串 s"
      },
      "Core Constraint": {
        "removal_condition": "任意子字符串中 'a' 和 'b' 的数量相等时可被移除",
        "concatenation_rule": "移除后剩余部分无缝拼接",
        "operation_freedom": "可进行任意次数的移除操作，顺序和选择自由"
      },
      "Objective Function": {
        "goal": "最小化",
        "target": "字符串在所有合法操作序列后的最小可能长度"
      },
      "Algorithmic Invariant": {
        "invariant": "字符串中不可再移除的部分的长度等于 |count('a') - count('b')|",
        "proof_sketch": "每次移除操作不改变 a 和 b 的数量差（模意义下），最终无法继续移除当且仅当不存在包含等量 a 和 b 的子串，此时剩余字符全为某一种字符，其数量为绝对差值",
        "greedy_optimality": "无论移除顺序如何，最终结果的最小长度是固定的，仅取决于初始计数差"
      },
      "Transformable Parameters": {
        "string_length_n": "1 <= n <= 1e5",
        "alphabet_size": 2,
        "character_set": [
          "a",
          "b"
        ],
        "is_ordered": true,
        "is_circular": false,
        "multiple_test_cases": false,
        "online_queries": false,
        "allow_modification": false,
        "output_type": "integer (minimum length)",
        "variation_slots": [
          "将字符集扩展至 k 个字符（如 'a','b','c'），要求移除各字符数量相等的子串",
          "改为求最少移除次数而非最小长度",
          "限制只能移除特定模式的平衡子串（如必须相邻交替 abab）",
          "加入权重：每个字符有权重，目标是最小化剩余权重和",
          "变为在线版本：逐字符输入，支持查询当前最小可达到长度"
        ]
      }
    }
  },
  {
    "title": "Maximize Points After Choosing K Tasks",
    "slug": "maximize-points-after-choosing-k-tasks",
    "schema": {
      "Input Structure": {
        "type": "two_arrays",
        "description": "两个长度均为 n 的一维整数数组 technique1 和 technique2，表示每个任务使用不同技巧的得分；一个整数 k，表示必须使用 technique1 完成的最少任务数量。",
        "constraints": {
          "n": "1 <= n <= 1e5",
          "array_values": "1 <= technique1[i], technique2[i] <= 1e5",
          "k_range": "0 <= k <= n"
        }
      },
      "Core Constraint": {
        "constraint": "必须从至少 k 个位置选择 technique1[i] 的值，其余位置可自由选择 technique1[i] 或 technique2[i]",
        "implication": "选择策略需在满足强制使用 technique1 的前提下，最大化总收益；局部最优依赖于 technique1[i] 与 technique2[i] 的相对增益"
      },
      "Objective Function": {
        "goal": "最大化总得分",
        "type": "maximization"
      },
      "Algorithmic Invariant": {
        "invariant": "优先保留 technique1 中相对于 technique2 增益最大的项用于强制选择，其余位置尽可能选择 technique2 中更高分的任务",
        "strategy": [
          "初始假设所有任务都使用 technique2，总分为 sum(technique2)",
          "对于必须使用的 k 个 technique1 任务，选择那些 (technique1[i] - technique2[i]) 最大的位置进行替换",
          "贪心正确性基于：每替换一个位置 i 的 technique2[i] 为 technique1[i]，带来的增量是固定的且独立"
        ],
        "proof_basis": "交换论证法：若存在更优解未选取 top-k 增益差的位置，则可通过替换提升总分，矛盾"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "k_constraint_type",
            "values": [
              "at_least_k",
              "exactly_k",
              "at_most_k"
            ],
            "description": "改变约束类型：从‘至少k’变为‘恰好k’或‘至多k’"
          },
          {
            "name": "input_dimension",
            "values": [
              "1D",
              "2D"
            ],
            "description": "扩展为二维任务网格，每行/列有独立约束"
          },
          {
            "name": "online_input",
            "values": [
              false,
              true
            ],
            "description": "是否支持在线添加任务（动态更新）"
          },
          {
            "name": "multiple_constraints",
            "values": [
              false,
              true
            ],
            "description": "加入额外约束，如 technique2 使用次数上限"
          },
          {
            "name": "data_range",
            "values": "integers can be negative or zero",
            "description": "允许 technique1[i], technique2[i] ≤ 0，影响贪心方向"
          },
          {
            "name": "output_type",
            "values": [
              "max_score",
              "construction",
              "count_optimal_schemes"
            ],
            "description": "输出最大分数 / 构造方案 / 计算最优方案数"
          },
          {
            "name": "grouped_tasks",
            "values": [
              false,
              true
            ],
            "description": "任务分组，每组内有独立 k 约束"
          }
        ]
      }
    }
  },
  {
    "title": "Maximum Substrings With Distinct Start",
    "slug": "maximum-substrings-with-distinct-start",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n",
        "constraints": [
          "1 <= n <= 1e5",
          "non-empty contiguous substrings",
          "composed only of 'a' to 'z'"
        ]
      },
      "Core Constraint": {
        "description": "Each substring in the partition must start with a distinct character; no two substrings can have the same starting character.",
        "implication": "At most 26 substrings are possible (one per letter), and once a character is used as a starting character, it cannot be reused."
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "maximum number of substrings",
        "condition": "each substring starts with a unique character"
      },
      "Algorithmic Invariant": {
        "invariant": "Greedy choice: whenever a new character appears that has not been used as a starting character, it is optimal to start a new substring at its first occurrence.",
        "proof_basis": "Early commitment to a new segment when encountering an unused character does not reduce future options and maximizes count due to fixed upper bound (26).",
        "state_progression": "Maintain a set of used starting characters; traverse left to right, initiate new substring upon first encounter of unused character."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "alphabet size",
            "values": [
              "26",
              "k (generalized)"
            ],
            "impact": "changes upper bound on answer"
          },
          {
            "name": "input type",
            "values": [
              "1D string",
              "circular string",
              "array of tokens"
            ]
          },
          {
            "name": "objective variation",
            "values": [
              "maximize count",
              "minimize count under constraint",
              "count valid partitions"
            ]
          },
          {
            "name": "constraint variation",
            "values": [
              "distinct first character",
              "distinct last character",
              "distinct character set per substring"
            ]
          },
          {
            "name": "data mode",
            "values": [
              "offline batch input",
              "online streaming input"
            ]
          },
          {
            "name": "output requirement",
            "values": [
              "return maximum count",
              "return actual partition",
              "return lexicographically smallest split"
            ]
          },
          {
            "name": "repetition policy",
            "values": [
              "no repeated start char",
              "at most k repeats allowed"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Largest Prime from Consecutive Prime Sum",
    "slug": "largest-prime-from-consecutive-prime-sum",
    "schema": {
      "Input Structure": "整数 n，表示上界；1 <= n <= 5 * 10^5",
      "Core Constraint": "目标质数必须同时满足两个条件：(1) 是质数；(2) 可表示为从 2 开始的连续质数序列之和（即形如 2, 2+3, 2+3+5, ...）",
      "Objective Function": "在所有满足条件的质数中，返回小于或等于 n 的最大值；若不存在则返回 0",
      "Algorithmic Invariant": "连续质数和序列具有单调递增性；一旦当前累加和超过 n，则后续和必然也超过 n，可终止生成；质数判定可通过预筛法（埃拉托斯特尼筛）保证高效性与一致性",
      "Transformable Parameters": [
        "n 的数量级（当前为 5e5，可调整至更高或更低）",
        "是否要求输出所有符合条件的质数（而非仅最大值）",
        "连续质数是否必须从 2 开始（可改为任意起始位置）",
        "是否允许重复使用质数（本题不允许，可设为可变约束）",
        "输入形式：单组数据 → 多组查询（离线/在线）",
        "是否将‘连续质数和’替换为‘连续合数和’或其他数列（如斐波那契质数等）作为变形"
      ]
    }
  },
  {
    "title": "Maximize Sum of Squares of Digits",
    "slug": "maximize-sum-of-squares-of-digits",
    "schema": {
      "Input Structure": [
        "正整数 num：表示目标整数的位数（1 <= num <= 2 * 10^5）",
        "正整数 sum：表示各位数字之和（1 <= sum <= 2 * 10^6）",
        "输入为两个标量参数，构造一个长度为 num 的数字序列 D[1..num]，其中 D[i] ∈ {0,1,...,9}，且 D[1] ≠ 0（首位非零）"
      ],
      "Core Constraint": [
        "总位数必须恰好为 num",
        "各位数字之和必须恰好等于 sum",
        "每位数字在 0 到 9 之间，且首位不能为 0",
        "在满足上述约束的前提下，需最大化数字的字典序与分数（平方和）"
      ],
      "Objective Function": [
        "最大化好整数的分数：即 ∑(D[i]^2)",
        "若存在多个相同最大分数的好整数，返回字典序最大的那个",
        "若无解，返回空字符串"
      ],
      "Algorithmic Invariant": [
        "贪心结构：为了最大化平方和，应优先将较大的数字（如 9）放在高位（左端），因为高位可同时提升字典序和平方和贡献",
        "平方函数 f(x)=x² 是凸函数，因此在固定和的情况下，数值越集中（即尽可能使用 9 和 8 等大数），平方和越大",
        "构造过程可从前到后逐位确定：每一步尝试填入当前允许的最大数字 d（从 9 到 0 枚举），使得剩余位数能用 [0,9] 填满并满足剩余数字和约束",
        "剩余可行性判断不变量：对于第 i 位，若剩余 k = num - i + 1 位，剩余和 s，则必须满足 0 <= s <= 9 * k，且当 i=1 时，d >= 1"
      ],
      "Transformable Parameters": [
        "num 的数量级：可扩展至 10^6 或更高（影响是否可用 DP）",
        "sum 的值域范围：是否可能超出 9*num 或小于 1（决定是否存在解）",
        "数字基底：是否十进制 → 可变为 b 进制（如二进制、十六进制）",
        "是否允许前导零：当前不允许，可设为可变参数",
        "目标函数变化：改为最小化分数、或最小化字典序、或计数可行解个数",
        "输出形式：返回字符串 / 返回模意义下的数值 / 返回方案数",
        "多组数据输入：是否处理 T 组测试用例",
        "在线约束：动态修改 num 或 sum，要求快速响应",
        "加入额外约束：如相邻位差值限制、不能出现某数字等"
      ]
    }
  },
  {
    "title": "Stable Subarrays With Equal Boundary and Interior Sum",
    "slug": "stable-subarrays-with-equal-boundary-and-interior-sum",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": [
          3,
          100000
        ],
        "value_range": [
          -1000000000,
          1000000000
        ],
        "description": "一维整数数组 capacity[1..n]，表示元素值可正可负"
      },
      "Core Constraint": {
        "length_constraint": "子数组长度至少为 3",
        "equality_constraint": "首元素 == 尾元素 == 中间所有元素之和",
        "structure_dependency": "对于子数组 capacity[l..r]，需满足 capacity[l] = capacity[r] = sum(capacity[l+1:r])",
        "implication": "中间段的和必须等于两端点值，且两端点相等"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计满足条件的稳定子数组的数量",
        "output_type": "integer",
        "note": "同一个子数组若满足条件仅计一次，不重复计数"
      },
      "Algorithmic Invariant": {
        "invariant_1": "固定左端点 l 后，枚举右端点 r，维护从 l+1 到 r-1 的累加和",
        "invariant_2": "若当前累加和 s 等于 capacity[l] 且 capacity[l] == capacity[r]，则构成一个稳定子数组",
        "invariant_3": "累加和可在移动右指针时增量更新，无需重复计算",
        "optimization_potential": "可通过哈希表预处理相同值的位置或前缀和加速，但暴力枚举在约束下仍可行"
      },
      "Transformable Parameters": {
        "n_magnitude": "1e5 可支持 O(n^2) 解法；若增大至 1e6 则需 O(n) 或 O(n log n) 解法",
        "value_domain": "是否允许负数（本题允许），影响前缀和单调性",
        "array_order": "是否有序（本题无序）",
        "circular": false,
        "online_queries": false,
        "multiple_test_cases": true,
        "output_detail": "是否要求输出每个稳定子数组的区间而非仅计数",
        "relax_length_constraint": "最小长度可变为 k（如 k=4）作为变体",
        "constraint_transformation": "将‘首尾相等’改为‘首尾和等于中间和’等逻辑变形"
      }
    }
  },
  {
    "title": "Maximum Transactions Without Negative Balance",
    "slug": "maximum-transactions-without-negative-balance",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；左右边界约束独立但需全局一致以确定局部容量",
      "Objective Function": "计算所有位置可接雨水的总量（求和）",
      "Algorithmic Invariant": "维护双指针 L 和 R，分别从左右两端向内收缩；维护 left_max 和 right_max 表示当前遍历过的最大高度；若 left_max ≤ right_max，则左指针当前位置的积水高度可确定为 left_max - H[L]，且移动左指针不影响已确定区域的正确性；反之亦然",
      "Transformable Parameters": [
        "n 的数量级：1e3 / 1e5 / 1e7（影响解法选择）",
        "H[i] 是否允许负值（变形题中可能表示凹陷地形）",
        "是否扩展到二维矩阵（2D 接雨水问题）",
        "是否环形排列（首尾相连的容器）",
        "是否支持在线更新（加入、删除或修改高度）",
        "是否要求输出每个位置的具体积水量而非总和",
        "是否多组测试数据输入",
        "输入是否有序（如按高度排序后处理）"
      ]
    }
  },
  {
    "title": "Smallest Missing Multiple of K",
    "slug": "smallest-missing-multiple-of-k",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element": "integer",
        "dimension": 1,
        "domain": "positive integers",
        "size": "n",
        "constraints": [
          "1 <= nums.length <= 100",
          "1 <= nums[i] <= 100",
          "nums is a list of positive integers, possibly unsorted and with duplicates"
        ],
        "auxiliary_input": {
          "k": {
            "type": "integer",
            "range": "1 <= k <= 100"
          }
        }
      },
      "Core Constraint": {
        "description": "The set of k-multiples forms an arithmetic sequence: k, 2k, 3k, ...; the problem reduces to finding the smallest such multiple not present in the given array.",
        "key_insight": "Membership testing in a finite set allows early termination; since values are bounded, the search space for missing multiples is effectively bounded.",
        "structural_property": "The k-multiples are totally ordered and sparse relative to the value range; presence in nums breaks continuity."
      },
      "Objective Function": {
        "goal": "find",
        "target": "minimum",
        "output_type": "positive integer",
        "condition": "smallest positive multiple of k that is not present in nums"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "For any m >= 1, if all multiples k, 2k, ..., mk are in nums, then the answer must be greater than mk.",
          "Once a multiple mk is found such that mk ∉ nums, and all smaller multiples have been checked, mk is the minimal missing multiple."
        ],
        "monotonicity": "The sequence of k-multiples is strictly increasing, enabling sequential checking until first absence.",
        "optimality_condition": "Earliest absent multiple in the ordered sequence of k-multiples is globally optimal."
      },
      "Transformable Parameters": {
        "n_range": [
          "1..100"
        ],
        "value_domain": [
          "1..100"
        ],
        "k_range": [
          "1..100"
        ],
        "array_properties": {
          "sorted": "optional",
          "distinct_elements": "no",
          "negative_values": "not allowed"
        },
        "input_mode": "offline, single instance",
        "query_type": "static existence check",
        "extensions": [
          "online version: support insert/delete operations on nums",
          "multi-query: answer for multiple k values over same nums",
          "bounded search: return missing multiple within threshold T",
          "counting variant: count how many multiples of k <= T are missing",
          "higher dimension: 2D grid of integers, find missing k-multiple in flattened form",
          "relaxed constraint: allow negative k (symmetric multiples)"
        ]
      }
    }
  },
  {
    "title": "Maximum Alternating Sum of Squares",
    "slug": "maximum-alternating-sum-of-squares",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element": "integer",
        "size": "n",
        "range": [
          -40000,
          40000
        ],
        "order": "arbitrary",
        "rearrangeable": true,
        "length_constraint": "1 <= n <= 1e5"
      },
      "Core Constraint": {
        "alternating_pattern": "even indices contribute positively, odd indices negatively",
        "objective_dependence": "square values dominate contribution; sign of original number does not matter due to squaring",
        "key_insight": "to maximize score, large squared values should be placed at even indices (positive contribution), small or negative-effect squared values at odd indices",
        "parity_separation": "optimal arrangement separates largest |values| into even positions, next into odd"
      },
      "Objective Function": {
        "goal": "maximization",
        "output_type": "integer",
        "computed_as": "sum_{i=0}^{n-1} (-1)^i * (arr[i])^2"
      },
      "Algorithmic Invariant": {
        "invariant_description": "greedy assignment: sort absolute values in descending order and assign alternately to maximize positive contributions",
        "proof_condition": "since x^2 >= y^2 implies placing x at an even index maximizes gain (or minimizes loss if forced to odd), sorting enables optimal greedy construction",
        "decision_monotonicity": "once sorted by magnitude, no swap between higher and lower magnitude elements can improve the total score",
        "rearrangement_optimality": "there exists an optimal permutation where the sequence of |arr[i]| is non-increasing when grouped by parity of index"
      },
      "Transformable Parameters": {
        "n_magnitude": [
          "small (≤20)",
          "large (≤1e5)"
        ],
        "value_domain": [
          "integers",
          "possibly negative",
          "bounded range"
        ],
        "ordering_constraint": [
          "unsorted input",
          "can be fully rearranged"
        ],
        "significance_of_sign": "no — because of squaring",
        "target_function_variants": [
          "minimize alternating sum",
          "count number of optimal arrangements",
          "achieve target score modulo M"
        ],
        "index_parity_weighting": [
          "+ - + - ...",
          "- + - + ...",
          "generalized: w_i ∈ {+1, -1}"
        ],
        "input_structure_extensions": [
          "fixed elements at certain positions",
          "multiple arrays with cross-alternation",
          "online version: insert/delete/query max alternating score"
        ],
        "algebraic_modifications": [
          "use |x| instead of x^2",
          "use x^k for even k",
          "non-quadratic convex functions"
        ]
      }
    }
  },
  {
    "title": "Lexicographically Smallest Negated Permutation that Sums to Target",
    "slug": "lexicographically-smallest-negated-permutation-that-sums-to-target",
    "schema": {
      "Input Structure": [
        "正整数 n，表示数组长度",
        "整数 target，表示目标和",
        "n 的取值范围：1 <= n <= 10^5",
        "target 的取值范围：-10^10 <= target <= 10^10"
      ],
      "Core Constraint": [
        "数组元素的绝对值必须构成一个大小为 n 的排列（即 |a_i| 是 1 到 n 的重排）",
        "数组元素之和必须等于 target",
        "在满足上述约束的前提下，要求构造字典序最小的数组",
        "每个整数 1..n 恰好作为某个元素的绝对值出现一次"
      ],
      "Objective Function": [
        "构造一个长度为 n 的整数数组",
        "使其元素和等于 target",
        "其绝对值是 1 到 n 的排列",
        "且该数组在所有合法解中字典序最小",
        "若无解，返回空数组"
      ],
      "Algorithmic Invariant": [
        "贪心构造：从左到右逐位确定元素符号（正或负），以保证字典序最小",
        "优先尝试将当前最大可调整幅度留给后续位置（通过控制负数分配）",
        "已确定前缀的字典序最优性不被后续选择破坏",
        "总和偏差可通过剩余未分配数字的最大/最小调整能力进行可行性剪枝"
      ],
      "Transformable Parameters": [
        "n 的数量级（当前为 1e5，可扩展至更高）",
        "target 值域（当前为 -1e10 ~ 1e10，可设更紧或更松）",
        "是否允许重复绝对值（原题不允许，变形可开放）",
        "目标函数变化：求字典序最大 / 计数可行解个数 / 判定是否存在",
        "输入形式变化：多组测试数据 / 在线查询 n 和 target",
        "附加约束：限制负数个数 / 要求连续段和性质",
        "输出形式：仅判断存在性 / 输出任意解 / 输出字典序第 k 小"
      ]
    }
  },
  {
    "title": "Count Subarrays With Majority Element II",
    "slug": "count-subarrays-with-majority-element-ii",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "非空且连续",
        "元素为正整数，值域范围 [1, 10^9]",
        "给定目标整数 target ∈ [1, 10^9]",
        "n ∈ [1, 10^5]"
      ],
      "Core Constraint": [
        "主要元素定义：在子数组中出现次数 > 子数组长度的一半",
        "仅关心 target 是否为主要元素，而非任意主要元素",
        "子数组必须非空且连续",
        "局部计数依赖于 target 的相对频次与区间长度的关系"
      ],
      "Objective Function": "计数 —— 统计以 target 为主要元素的子数组的总数",
      "Algorithmic Invariant": [
        "将问题转化为：对每个位置，维护 target 出现次数与其他元素净贡献的差值（如：遇 target 加1，否则减1）",
        "若某区间 [l, r] 上前缀差值满足 diff[r] > diff[l-1]，则该区间中 target 满足主要元素条件",
        "利用前缀和思想 + 哈希表统计满足 diff[i] < diff[j] (i < j) 的有序对数量",
        "状态单调性体现在：只需记录先前更小的前缀差值出现次数即可正确累计答案"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e1",
            "1e3",
            "1e5",
            "1e6"
          ],
          "值域": "[1, 1e9]"
        },
        "输入形式": {
          "是否有序": false,
          "是否可重复": true,
          "target 是否存在于数组中": [
            "可能不存在"
          ]
        },
        "约束条件": {
          "主要元素判定阈值": [
            "严格大于长度一半（> ⌊L/2⌋）",
            "≥ ⌊L/2⌋ + k（可变偏移）",
            "等于众数且唯一"
          ],
          "关注对象": [
            "固定 target",
            "任意主要元素",
            "多个指定 target"
          ]
        },
        "输出形式": [
          "仅计数",
          "输出所有满足条件的子数组区间",
          "输出最长/最短满足条件的子数组"
        ],
        "数据流模式": [
          "离线批量处理",
          "在线查询（动态添加元素）",
          "支持修改操作（如点更新）"
        ],
        "扩展维度": [
          "二维矩阵中的连续行/列子段",
          "环形数组",
          "允许空子数组"
        ]
      }
    }
  },
  {
    "title": "Count Subarrays With Majority Element I",
    "slug": "count-subarrays-with-majority-element-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "nums: array of integers with length n (1 <= n <= 1000)",
          "nums[i] in range [1, 10^9]",
          "target: integer in range [1, 10^9]",
          "subarray must be contiguous and non-empty"
        ]
      },
      "Core Constraint": {
        "description": "A subarray has 'target' as its majority element if the frequency of target is strictly greater than half the length of the subarray.",
        "mathematical_form": "count(target in subarray) > floor(len(subarray) / 2)",
        "implication": "Local contribution depends on balance between occurrences of target and other elements; prefix-based transformation (e.g., +1 for target, -1 for others) enables cumulative analysis."
      },
      "Objective Function": {
        "type": "counting",
        "goal": "Count the number of contiguous non-empty subarrays where target is the majority element."
      },
      "Algorithmic Invariant": {
        "invariant_description": "Using a prefix-sum-like transformation: map each element to +1 if equal to target, else -1. A subarray [i..j] has target as majority iff prefix[j+1] > prefix[i].",
        "key_insight": "For transformed array T, subarray from i to j is valid iff sum(T[i..j]) > 0 → equivalent to prefix[j+1] > prefix[i].",
        "data_structure_support": "Use hash map to count how many times each prefix sum has occurred, enabling O(n) traversal with order preservation.",
        "monotonicity_or_order": "The relative order of prefix sums determines valid pairs; no need to sort, but cumulative counts maintain invariant."
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 1000 (can be increased for harder variants)",
        "value_domain": "nums[i], target ∈ [1, 10^9] (can be constrained to small set or made negative)",
        "target_existence": "target may or may not appear in nums",
        "majority_threshold": [
          "strictly greater than half → can be changed to >= (at least half), or k-th fraction",
          "generalized to: count > len/k"
        ],
        "input_form": [
          "offline batch input → online streaming queries",
          "single target → multiple targets or any-majority-element (unknown)"
        ],
        "output_form": [
          "count only → list all such subarrays",
          "boolean decision:是否存在至少一个"
        ],
        "array_properties": [
          "non-circular → circular array extension",
          "static → dynamic with updates"
        ],
        "additional_constraints": [
          "minimum/maximum subarray length",
          "only odd-length subarrays considered"
        ]
      }
    }
  },
  {
    "title": "Lexicographically Smallest String After Reverse",
    "slug": "lexicographically-smallest-string-after-reverse",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n",
        "constraints": [
          "1 <= n <= 1000",
          "s consists of lowercase English letters"
        ]
      },
      "Core Constraint": {
        "operation_constraint": "exactly one operation allowed",
        "operation_type": "reverse either the first k characters or the last k characters",
        "k_range": "1 <= k <= n",
        "feasible_actions": [
          "reverse_prefix(k)",
          "reverse_suffix(k)"
        ],
        "decision_dependency": "the lexicographical outcome depends on both k and reversal direction"
      },
      "Objective Function": "find the lexicographically smallest string achievable after exactly one valid operation",
      "Algorithmic Invariant": {
        "invariant_1": "for prefix reversals: reversing s[0:k] places the largest early character (from initial segment) to front if it's beneficial",
        "invariant_2": "for suffix reversals: reversing s[n-k:n] brings a potentially small character from end to front, but only affects tail alignment",
        "invariant_3": "optimal solution must be among O(n) candidates — one for each k in [1, n] and two choices per k",
        "invariant_4": "no greedy shortcut across all k; brute-force enumeration is feasible due to n <= 1000",
        "invariant_5": "comparing strings under lexicographic order is monotonic: first difference determines result"
      },
      "Transformable Parameters": {
        "n_magnitude": "1 <= n <= 1000 (allows O(n^2) simulation)",
        "alphabet_type": "lowercase English letters (fixed)",
        "string_order": "arbitrary (not necessarily sorted or monotonic)",
        "operation_count": "fixed to exactly one reversal",
        "reversible_segment": [
          "prefix [0:k]",
          "suffix [n-k:n]"
        ],
        "input_form": "single string, offline input",
        "output_form": "lexicographically minimal string (constructive)",
        "online_query": false,
        "multiple_test_cases": false,
        "extension_potential": [
          "allow multiple operations → dynamic programming state",
          "allow any substring reversal → more complex search space",
          "minimize k as secondary objective",
          "generalize to circular string",
          "add cost function on k"
        ]
      }
    }
  },
  {
    "title": "Maximum Distance Between Unequal Words in Array II",
    "slug": "maximum-distance-between-unequal-words-in-array-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "properties": [
          "one-dimensional array H[1..n]",
          "H[i] >= 0, represents bar height at position i"
        ]
      },
      "Core Constraint": {
        "description": "The water trapped at each position is determined by the minimum of the maximum heights to its left and right, minus the current height.",
        "key_conditions": [
          "Water trapping depends on global left and right maxima",
          "Left and right boundary constraints are independent but must be jointly considered",
          "No overflow between non-adjacent bars; only local minima in elevation trap water"
        ]
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total amount of trapped rainwater",
        "output": "single integer representing cumulative capacity over all positions"
      },
      "Algorithmic Invariant": {
        "description": "Two-pointer technique maintains correctness of trapped water calculation for processed regions.",
        "invariants": [
          "Maintain left pointer L and right pointer R, with maxLeft and maxRight tracking left/right maxima",
          "If maxLeft <= maxRight, then the trapped water at L is fully determined by maxLeft - H[L]",
          "Similarly, if maxRight < maxLeft, then trapped water at R is determined",
          "Moving the smaller side pointer preserves optimality and completeness"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative integers",
              "integers (with negative allowed)",
              "real numbers"
            ],
            "impact": "Negative values may disable trapping or require reinterpretation"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D (grid)",
              "circular array"
            ],
            "impact": "Changes spatial neighborhood and boundary conditions"
          },
          {
            "name": "data_streaming",
            "options": [
              "offline batch input",
              "online queries",
              "dynamic updates (insert/delete/update)"
            ],
            "impact": "Determines need for persistent data structures or incremental algorithms"
          },
          {
            "name": "output_granularity",
            "options": [
              "total sum",
              "per-position values",
              "maximum single container"
            ],
            "impact": "Alters objective function and potentially algorithm design"
          },
          {
            "name": "constraint_modification",
            "options": [
              "standard trapping",
              "bounded container (e.g., no external walls)",
              "flow dynamics (time-evolving)"
            ],
            "impact": "May shift problem to simulation or DP"
          },
          {
            "name": "input_properties",
            "options": [
              "unsorted",
              "sorted",
              "partially monotonic",
              "random order"
            ],
            "impact": "Affects feasibility of greedy strategies"
          },
          {
            "name": "multiple_test_cases",
            "type": "boolean",
            "impact": "Requires resettable state or amortized efficiency"
          }
        ]
      }
    }
  },
  {
    "title": "Count Ways to Choose Coprime Integers from Rows",
    "slug": "count-ways-to-choose-coprime-integers-from-rows",
    "schema": {
      "Input Structure": "二维矩阵 mat[1..m][1..n]，其中每个元素为正整数；m 表示行数（每行对应一组可选数字），n 表示列数（每行中可选的整数个数）；1 <= m, n, mat[i][j] <= 150",
      "Core Constraint": "必须从每一行恰好选择一个整数，形成一个长度为 m 的序列；目标是使该序列所有元素的最大公约数（GCD）等于 1；GCD 具有全局依赖性：整个序列的 GCD 由所有选中数共同决定，且 gcd(a, b, c) = gcd(gcd(a, b), c)",
      "Objective Function": "计数 —— 统计满足条件的选择方案数量（即选出的 m 个数的 GCD 恰好为 1），结果对 10^9 + 7 取模",
      "Algorithmic Invariant": "利用容斥原理或状态压缩动态规划维护当前已选数字集合的 GCD 状态；若当前前缀的 GCD 为 g，则后续加入的数只会使 GCD 缩小（单调非增）；所有路径最终收敛到某个 g，只需统计最终 g == 1 的路径总数",
      "Transformable Parameters": [
        "m 和 n 的数量级（当前 ≤150，可扩展至支持更大规模或稀疏结构）",
        "mat[i][j] 的值域范围（当前 ≤150，可调整以改变 GCD 状态空间大小）",
        "是否允许重复行 / 是否要求去重方案",
        "目标函数变换：求 GCD ≥ k 的方案数 / 求最大可能 GCD / 判定是否存在 GCD=1 的方案",
        "约束变化：改为每行选多个数 / 至少一行选特定数",
        "模数变化：是否固定模 1e9+7 或参数化",
        "输入形式：是否离线批量处理 / 是否在线逐行添加矩阵行",
        "附加限制：要求所选数字乘积最小等复合优化目标"
      ]
    }
  },
  {
    "title": "Sum of Elements With Frequency Divisible by K",
    "slug": "sum-of-elements-with-frequency-divisible-by-k",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          1,
          100
        ],
        "constraints": [
          "nums.length >= 1",
          "nums[i] >= 1",
          "k >= 1"
        ]
      },
      "Core Constraint": {
        "description": "一个元素只有在其在整个数组中的总出现次数能被 k 整除时，才被计入总和",
        "dependency": "全局频次统计：每个元素的决策依赖于其在整个数组中出现的总次数",
        "independence": "不同元素之间相互独立，可分别判断是否满足条件"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute_total_sum",
        "condition": "sum over all elements x, each repeated count(x) times, if count(x) % k == 0",
        "edge_case": "if no element satisfies the condition, return 0"
      },
      "Algorithmic Invariant": {
        "invariant": "元素的贡献仅由其全局出现次数模 k 的结果决定",
        "properties": [
          "一旦统计完所有元素频次，每个元素是否参与求和即确定",
          "频次统计过程支持线性扫描与哈希计数，且无后效性",
          "加法操作满足结合律，累加顺序不影响结果"
        ],
        "optimal_substructure": "问题可分解为：对每个元素独立判断是否满足整除条件，若满足则将其所有出现值相加"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "k_mod_condition",
            "type": "constraint",
            "values": [
              "== 0",
              "!= 0",
              "<= threshold",
              ">= threshold"
            ],
            "description": "改变整除条件，如改为 count(x) % k != 0 或 count(x) >= k"
          },
          {
            "name": "frequency_transformation",
            "type": "objective",
            "values": [
              "sum",
              "count_elements",
              "count_occurrences",
              "product",
              "maximum",
              "minimum"
            ],
            "description": "目标函数变换：从‘满足条件的元素总和’变为其他聚合形式"
          },
          {
            "name": "input_structure",
            "type": "structure",
            "values": [
              "1D array",
              "2D grid",
              "tree traversal sequence",
              "streaming data"
            ],
            "description": "输入结构扩展，如在树中统计节点值频次"
          },
          {
            "name": "data_scale",
            "type": "complexity",
            "values": {
              "small": "n <= 100",
              "medium": "n <= 1e5",
              "large": "n <= 1e6"
            },
            "implication": "小规模可用哈希表直接计数；大规模需考虑离线/在线处理"
          },
          {
            "name": "online_query",
            "type": "mode",
            "values": [
              "offline",
              "online"
            ],
            "description": "是否支持动态插入/删除元素并实时查询满足条件的和"
          },
          {
            "name": "multiplicity_handling",
            "type": "semantics",
            "values": [
              "include_all_occurrences_if_condition_met",
              "include_once_per_element",
              "weight_by_frequency"
            ],
            "description": "控制满足条件的元素如何计入答案：全部重复计入、只计一次、或加权计入"
          }
        ]
      }
    }
  },
  {
    "title": "Maximum Distance Between Unequal Words in Array I",
    "slug": "maximum-distance-between-unequal-words-in-array-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at that index."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the minimum of their heights and the distance between them.",
        "key_insight": "To maximize area, a greedy strategy can be applied: moving the shorter pointer may lead to a larger area, while keeping the taller one fixed preserves potential for future gains.",
        "dependency": "The optimal solution must consider both spatial separation and height balance; local decisions affect global feasibility."
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "the amount of water that can contain between two lines",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "invariant": "At each step, the currently smaller height determines the maximum possible area for all configurations involving that boundary.",
        "pointer_movement_rule": "Move the pointer with the smaller height inward, as extending from the taller side cannot increase the bounding height.",
        "state_preservation": "The maximal area seen so far is always tracked, and the search space is reduced without missing the global optimum."
      },
      "Transformable Parameters": {
        "n_range": [
          2,
          100000
        ],
        "value_range": [
          0,
          10000
        ],
        "input_variants": [
          "sorted array (ascending/descending)",
          "circular arrangement (last connects to first)",
          "2D version (matrix of heights)",
          "online queries (dynamic addition of lines)"
        ],
        "output_variants": [
          "return indices of the optimal pair",
          "count the number of pairs achieving maximum area",
          "report all pairs within 90% of maximum"
        ],
        "operation_support": [
          "point updates (modify one height)",
          "range queries (find best pair in subarray)"
        ],
        "additional_constraints": [
          "minimum distance between selected lines",
          "selected lines must satisfy parity condition on indices"
        ]
      }
    }
  },
  {
    "title": "Minimum Deletions to Make Alternating Substring",
    "slug": "minimum-deletions-to-make-alternating-substring",
    "schema": {
      "Input Structure": [
        "字符串 s[0..n-1]，其中每个字符为 'A' 或 'B'",
        "长度 n 满足 1 <= n <= 1e5",
        "二维整数数组 queries，长度 q (1 <= q <= 1e5)",
        "queries[i] 为 [1, j] 表示单点更新：反转 s[j]",
        "queries[i] 为 [2, l, r] 表示区间查询：子串 s[l..r] 上的最小删除数使成为交替字符串"
      ],
      "Core Constraint": [
        "交替字符串定义：任意相邻两个字符不相等（即无连续 'AA' 或 'BB'）",
        "删除操作是唯一允许的操作（不能替换或插入）",
        "每次删除可移除一个字符，目标是使剩余子序列是交替的",
        "单点修改会影响后续所有查询，具有时序依赖性",
        "问题本质是动态维护字符串并支持区间结构化查询"
      ],
      "Objective Function": [
        "对于每个类型为 [2, l, r] 的查询，求最小删除字符数",
        "等价于：最大化可保留的最长交替子序列长度，然后计算 (r - l + 1) - max_length",
        "目标函数为计数型（最小删除数），非判定、非构造"
      ],
      "Algorithmic Invariant": [
        "在任意区间 [l, r] 中，最优保留的交替子序列必为两种模式之一：以 'A' 开头或以 'B' 开头",
        "对固定模式（如 ABAB... 或 BABA...），可在 O(1) 时间内通过预处理前缀和计算匹配字符数",
        "维护两个前缀数组：count_A_start[i] 表示从位置 0 到 i 匹配 ABAB... 模式的字符个数",
        "count_B_start[i] 表示匹配 BABA... 模式的字符个数",
        "使用线段树或树状数组支持单点修改与区间查询（因有更新操作）",
        "每次更新只影响一个位置的两个模式匹配状态，可增量更新数据结构"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 <= n <= 1e5",
          "q": "1 <= q <= 1e5",
          "是否可扩展至 1e6（强制在线段树/树状数组）": true
        },
        "字符串性质": {
          "字符集大小": "二元（仅 A/B），可推广至 k 元交替",
          "是否允许其他字符": false,
          "初始字符串是否有序/随机": "任意"
        },
        "操作类型": {
          "是否支持批量更新": false,
          "是否支持区间反转": false,
          "是否支持插入/删除字符（变长字符串）": false
        },
        "查询形式": {
          "是否离线": false,
          "是否在线（依赖前面修改）": true,
          "是否要求输出方案而非数值": false
        },
        "目标函数变形": [
          "改为求最长交替子序列长度",
          "改为判定是否已是交替字符串",
          "改为计数满足条件的子区间数量（静态版本）"
        ],
        "输入维度扩展": [
          "一维字符串 → 二维字符网格上的路径交替约束",
          "线性序列 → 环形字符串"
        ],
        "隐藏条件变化": [
          "显式给出模式 → 隐式推断最优起始字符",
          "固定字符集 → 字符带权删除成本"
        ]
      }
    }
  },
  {
    "title": "Count Distinct Subarrays Divisible by K in Sorted Array",
    "slug": "count-distinct-subarrays-divisible-by-k-in-sorted-array",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "非降序排列（单调不减）",
        "nums[i] ≥ 1，整数",
        "正整数 k ≥ 1"
      ],
      "Core Constraint": [
        "子数组为连续非空序列",
        "良好子数组定义为：元素和可被 k 整除",
        "利用前缀和性质：若 (prefix[j] - prefix[i]) % k == 0，则 prefix[j] % k == prefix[i] % k",
        "相同余数的前缀和下标之间构成的子数组和能被 k 整除"
      ],
      "Objective Function": "计数：统计满足条件的不同良好子数组的数量",
      "Algorithmic Invariant": [
        "前缀和模 k 的同余类中，任意两个下标 i < j 可形成一个良好子数组 nums[i+1..j]",
        "使用哈希表记录每个 prefix_sum % k 余数首次出现后持续累加频次",
        "遍历时维护当前前缀和模 k 的值，并累加该余数历史出现次数以更新答案",
        "非降序性质虽存在但未被最优解法直接使用，核心不变量依赖模意义下的前缀和重复"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5 → 可扩展至 1e6（要求 O(n) 或 O(n log n)）",
        "值域范围": "nums[i] ∈ [1, 1e9], k ∈ [1, 1e9] → 可支持负数、零或更大模数",
        "数组有序性": "当前为非降序 → 可改为无序（不影响主解法）、或强制利用单调性进行优化变体",
        "是否多组输入": "单组输入 → 可改造为多组测试用例",
        "是否在线": "离线处理 → 可设计为流式输入下的动态查询问题",
        "模运算形式": "可变换为 ≡ r (mod k)（r≠0），或 ≥K 而非整除",
        "输出形式": "仅计数 → 可改为输出所有起止位置、最长/最短良好子数组等"
      }
    }
  },
  {
    "title": "Library Late Fee Calculator",
    "slug": "library-late-fee-calculator",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given a 1D array H[1..n], where each element H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The water trapped at any position depends on the maximum heights to its left and right; specifically, the effective boundary is determined by the minimum of the two global maxima from either side.",
        "key_insight": "Left and right boundaries evolve monotonically; local decisions can be made based on comparative knowledge of left_max and right_max."
      },
      "Objective Function": {
        "goal": "sum",
        "description": "Compute the total amount of rainwater that can be trapped between the bars after raining."
      },
      "Algorithmic Invariant": {
        "invariant": [
          "Two pointers (L, R) start from both ends and move toward each other.",
          "At each step, if max_left <= max_right, then the water at L is solely constrained by max_left (since there exists a >= barrier on the right), so we can safely compute contribution at L.",
          "Similarly, if max_right < max_left, the water at R is bounded by max_right.",
          "Updating max_left and max_right as we go preserves correctness of future decisions.",
          "Movement of pointers does not compromise optimality of already-processed regions."
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative_heights"
            ],
            "note": "Negative values change physical meaning; may require reinterpretation."
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D"
            ],
            "note": "Extends to 2D 'trapping rain water II' with heap + BFS."
          },
          {
            "name": "input_type",
            "options": [
              "offline_batch",
              "online_streaming"
            ],
            "note": "In online version, queries come incrementally; requires persistent data structures."
          },
          {
            "name": "output_granularity",
            "options": [
              "total_sum",
              "per_position_contribution"
            ],
            "note": "Can ask for detailed breakdown instead of just total."
          },
          {
            "name": "dynamic_operations",
            "options": [
              "static",
              "supports_update_delete"
            ],
            "note": "Support for point updates or deletions leads to segment tree / sqrt decomposition variants."
          },
          {
            "name": "data_order",
            "options": [
              "arbitrary",
              "sorted"
            ],
            "note": "If sorted, alternative O(n) two-pointer or stack methods still apply but structure changes."
          },
          {
            "name": "multiple_test_cases",
            "type": "boolean",
            "default": false
          }
        ]
      }
    }
  },
  {
    "title": "Design Exam Scores Tracker",
    "slug": "design-exam-scores-tracker",
    "schema": {
      "Input Structure": [
        "有序的考试记录序列 (time_i, score_i), 其中 i = 1..n",
        "time_i ∈ [1, 1e9], 严格递增",
        "score_i ∈ [1, 1e9]",
        "支持动态追加记录",
        "查询基于时间区间 [startTime, endTime] 的聚合信息"
      ],
      "Core Constraint": [
        "record 操作按 time 严格递增顺序进行，保证数据流为离线且有序",
        "totalScore 查询满足 startTime <= endTime <= 最近 record 时间，无需处理未来数据",
        "查询仅依赖历史已知数据，无回滚或修改操作",
        "输入规模较大（最多 1e5 次操作），要求高效查询"
      ],
      "Objective Function": [
        "在给定时间区间 [startTime, endTime] 内，计算所有 record 记录的 score 总和",
        "若区间内无记录，返回 0",
        "目标函数为区间求和（计数类聚合）"
      ],
      "Algorithmic Invariant": [
        "维护一个按时间排序的记录列表，其 time 序列单调递增，支持二分查找边界",
        "前缀和数组可构造于 sorted times 上，使得任意区间和可在 O(log n) 时间内完成查询",
        "每次 record 操作后，前缀和结构可通过追加更新，保持单调性与完整性",
        "查询时通过 lower_bound 和 upper_bound 定位有效索引范围，再利用前缀和差分求解"
      ],
      "Transformable Parameters": {
        "数据规模": "n ≤ 1e5，允许使用 O(n log n) 预处理 + O(log n) 查询",
        "时间维度是否离散化": "原始 time 值大但稀疏，可考虑离散化坐标",
        "score 值域变化": "score 可扩展为负数，目标函数仍为代数和",
        "聚合函数类型": "可改为最大值、最小值、计数、平均值等（非线性聚合需不同处理）",
        "输入模式": "当前为离线有序流；可变更为在线乱序输入（需平衡树或线段树）",
        "是否支持删除/修改操作": "当前仅追加；可扩展为支持撤销或更新历史记录",
        "多组数据": "单实例对象，但可改造为支持多个独立 ExamTracker 实例",
        "输出精度": "score 总和可能超过 int，使用 long long，反映数值稳定性需求"
      }
    }
  },
  {
    "title": "Compute Alternating Sum",
    "slug": "compute-alternating-sum",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n >= 1，nums[i] ∈ [1, 100]",
      "Core Constraint": "交替和的计算规则由下标奇偶性决定：偶数下标加，奇数下标减；每个位置的符号固定且仅依赖其下标位置",
      "Objective Function": "计算并返回数组的交替和（即：nums[0] - nums[1] + nums[2] - nums[3] + ...）",
      "Algorithmic Invariant": "遍历过程中，当前累计值始终保持为已处理前缀子数组的交替和；符号按索引顺序交替变化，且该模式在整个序列中保持一致",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 100",
        "值域": "nums[i] ∈ [1, 100]",
        "是否有序": "可变（题目未要求有序）",
        "是否循环": "否（线性结构）",
        "是否多组输入": "否（单次输入）",
        "是否在线": "否（离线处理）",
        "符号模式可变性": "可改编为任意周期性符号序列（如 ++--++--...）、随机符号、或由外部函数生成",
        "下标定义方式": "可改为从1开始计数，或使用模k分类",
        "输出形式": "可要求输出每一步的部分和，或最大前缀交替和"
      }
    }
  },
  {
    "title": "Total Waviness of Numbers in Range I",
    "slug": "total-waviness-of-numbers-in-range-i",
    "schema": {
      "Input Structure": [
        "两个整数 num1 和 num2，表示一个闭区间 [num1, num2]",
        "每个数字被视为其十进制数位序列 d[0..k-1]，其中 k 为位数",
        "所有数字范围在 [1, 10^5] 内，即最多 6 位十进制数"
      ],
      "Core Constraint": [
        "波动值由数位序列中的局部极值（峰或谷）决定",
        "峰定义：d[i] > d[i-1] 且 d[i] > d[i+1]",
        "谷定义：d[i] < d[i-1] 且 d[i] < d[i+1]",
        "首尾数位不能成为峰或谷",
        "少于 3 位的数字无有效中间位，波动值为 0",
        "问题本质是遍历多个数字的数位结构并统计满足局部极值条件的位置"
      ],
      "Objective Function": "计数 - 计算区间 [num1, num2] 内所有数字的波动值之和",
      "Algorithmic Invariant": [
        "对于任意数字，其波动值可通过逐位扫描其数位序列独立计算",
        "每一位是否为峰或谷仅依赖于其相邻三位，具有局部可判定性",
        "不同数字之间的波动值可加，总和可分解为个体贡献之和",
        "数位间比较不改变原数字值，状态可逆且无副作用"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "num1, num2 的范围": "可扩展至 10^9 或更高（要求数位 DP）",
          "当前约束": "1 <= num1 <= num2 <= 1e5，允许暴力枚举"
        },
        "输入形式": {
          "是否单组数据": true,
          "是否多组查询": false,
          "是否在线输入区间": false
        },
        "波动定义变体": {
          "峰/谷是否包含等于情况": "当前为严格大于/小于，可改为非严格",
          "是否允许首尾为峰谷": "当前不允许，可作为参数放开"
        },
        "目标函数变体": [
          "求最大波动值的数字",
          "求波动值等于某值的数字个数",
          "判断是否存在波动值 >= k 的数字"
        ],
        "数字表示扩展": {
          "是否考虑前导零": false,
          "是否扩展到其他进制": false
        },
        "计算模式": {
          "当前解法": "暴力枚举每个数字并拆位判断",
          "潜在优化路径": "当数据范围增大时，需使用数位动态规划（Digit DP）进行状态压缩"
        }
      }
    }
  },
  {
    "title": "Longest Balanced Substring II",
    "slug": "longest-balanced-substring-ii",
    "schema": {
      "Input Structure": [
        "长度为 n 的字符串 s，其中 n ∈ [1, 10^5]",
        "字符集限定为 { 'a', 'b', 'c' }",
        "s 是非空连续字符序列"
      ],
      "Core Constraint": [
        "平衡子串要求：该子串中所有不同字符的出现次数完全相同",
        "字符种类数最多为 3，因此可能的平衡模式为：每种出现字符频次相等（如 k 次）",
        "子串必须连续且非空"
      ],
      "Objective Function": "求最长满足平衡条件的子串的长度（最大化）",
      "Algorithmic Invariant": [
        "对于固定字符种类数 t（1 ≤ t ≤ 3），若存在一个平衡子串，则其长度必为 t × k（k 为每个字符出现次数）",
        "枚举 t 和 k，可在 O(n) 或 O(n × max_k) 内验证是否存在对应平衡子串",
        "使用前缀频次差（或状态哈希）可将相同相对频次的状态映射，从而在一次遍历中检测平衡性",
        "当仅考虑某几种字符时，其余字符的存在会中断合法区间，需分情况处理或跳过"
      ],
      "Transformable Parameters": {
        "字符集大小": {
          "当前值": 3,
          "可变范围": "2 → 26（扩展到小写字母全集）"
        },
        "字符串长度 n": {
          "当前值": "1e5",
          "可变范围": "1e3（离线暴力）→ 1e7（需要线性解法）"
        },
        "字符是否可重复任意次": true,
        "是否允许其他字符": false,
        "目标函数形式": {
          "当前": "最大长度",
          "可变换为": [
            "计数平衡子串个数",
            "判定是否存在长度 ≥ K 的平衡子串",
            "构造最长平衡子串"
          ]
        },
        "是否在线输入": false,
        "是否多组数据": false,
        "子串是否可为空": false,
        "平衡定义是否可变": {
          "当前": "所有出现字符频次相等",
          "可变形为": [
            "频次成等差",
            "频次成比例",
            "最多相差 1",
            "某种字符频次是其他两倍"
          ]
        }
      }
    }
  },
  {
    "title": "Longest Balanced Substring I",
    "slug": "longest-balanced-substring-i",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length_range": [
          1,
          1000
        ],
        "description": "一维字符序列 s[1..n]，由小写英文字母组成"
      },
      "Core Constraint": {
        "constraint": "在子串中，所有不同字符的出现次数必须完全相同",
        "implication": "若子串包含 k 个不同字符，且总长度为 L，则每个字符必须恰好出现 L/k 次（即 L 能被 k 整除）",
        "key_insight": "平衡性依赖于字符频次的全局一致性；局部频次变化需同步调整以维持相等"
      },
      "Objective Function": {
        "goal": "最大化满足平衡条件的子串长度",
        "type": "optimization (maximization)",
        "output": "最长平衡子串的长度（整数）"
      },
      "Algorithmic Invariant": {
        "invariant": "枚举不同字符数量 k（1 到 26），对每个 k 使用滑动窗口维护恰好含 k 种字符且频次相等的子串",
        "technique": "固定字符种类数下的双指针滑动窗口 + 频次统计",
        "monotonicity": "当右端点扩展时，频次分布单调增加；通过调节左右指针保持候选解的合法性",
        "optimality_preservation": "对于给定 k，遍历所有可能的起始位置或使用双指针推进，确保不遗漏最长合法子串"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "character_set",
            "values": [
              "lowercase",
              "uppercase",
              "alphanumeric",
              "general ASCII"
            ],
            "default": "lowercase"
          },
          {
            "name": "string_dimension",
            "values": [
              "1D",
              "2D grid",
              "circular string"
            ],
            "default": "1D"
          },
          {
            "name": "balance_definition",
            "values": [
              "all distinct chars have equal frequency",
              "frequencies differ by at most 1",
              "mode - min_freq <= threshold"
            ],
            "default": "equal frequency"
          },
          {
            "name": "objective",
            "values": [
              "maximize length",
              "count balanced substrings",
              "find shortest balanced substring",
              "check existence"
            ],
            "default": "maximize length"
          },
          {
            "name": "input_mode",
            "values": [
              "offline",
              "online queries",
              "dynamic updates (insert/delete)"
            ],
            "default": "offline"
          },
          {
            "name": "data_scale",
            "n_range": [
              1,
              1000,
              10000,
              100000
            ],
            "default": [
              1,
              1000
            ]
          },
          {
            "name": "output_detail",
            "values": [
              "length only",
              "one optimal substring",
              "all optimal substrings",
              "position indices"
            ],
            "default": "length only"
          }
        ]
      }
    }
  },
  {
    "title": "Count Distinct Integers After Removing Zeros",
    "slug": "count-distinct-integers-after-removing-zeros",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "range": "1 <= n <= 1e15",
        "description": "一个正整数 n，表示从 1 到 n 的连续整数序列作为处理对象"
      },
      "Core Constraint": {
        "constraint": "每个整数 x ∈ [1, n] 需经过‘移除所有十进制表示中的零’操作，得到新整数；该操作是确定性映射，但多个不同 x 可能映射到相同结果",
        "key_insight": "前导零不出现，但中间和末尾的 '0' 被完全删除，导致数值压缩；例如 101 → 11，100 → 1",
        "structural_property": "去零后的整数与原整数之间不存在单调一一对应关系，但去零操作具有字符串投影性质"
      },
      "Objective Function": {
        "goal": "计数",
        "target": "统计所有去零后得到的不同整数的个数",
        "output_type": "integer (distinct count)"
      },
      "Algorithmic Invariant": {
        "invariant": "去零后的数值仅依赖于原数的非零数字序列，与其位置无关（即忽略所有 '0' 字符后的剩余数字串）",
        "optimization_principle": "无需显式遍历 1 到 n 的每一个数，可通过构造所有可能的非零数字串（即不含 '0' 的十进制数）并判断其是否 ≤ n（在插入任意数量的 '0' 后）来反向枚举有效源数",
        "search_space_reduction": "合法的去零结果只能由数字 1-9 构成；因此可枚举所有不含 '0' 的正整数 k，并检查是否存在某个整数 x ≤ n，使得 removeZeros(x) == k"
      },
      "Transformable Parameters": {
        "n_magnitude": "1 <= n <= 1e15 (支持大范围，暗示需 O(poly(log n)) 解法)",
        "digit_removal_rule": "可变：移除 '0' → 移除某特定数字 d / 移除重复数字 / 保留唯一出现等",
        "base_system": "可扩展至其他进制（如二进制去 0）",
        "online_query": "是否多组 n 查询 → 支持预处理打表或数位 DP 批量处理",
        "output_detail": "返回数量 vs 返回所有不同整数的列表",
        "transformation_composition": "去零后是否再做反转、取模、加权等操作",
        "input_structure_variation": "n 是上界 → 给定区间 [L, R]；或输入为数组而非范围"
      }
    }
  },
  {
    "title": "Majority Frequency Characters",
    "slug": "majority-frequency-characters",
    "schema": {
      "Input Structure": {
        "type": "string",
        "content": "s: 由小写英文字母组成的字符串",
        "length_constraint": "1 <= n <= 100",
        "element_type": "char in 'a'..'z'",
        "properties": [
          "finite",
          "unordered",
          "with repetition"
        ]
      },
      "Core Constraint": {
        "frequency_group_definition": "对于频率 k，频率组是 s 中恰好出现 k 次的所有字符的集合",
        "uniqueness": "每个字符仅属于一个频率组（由其全局频次决定）",
        "total_partition": "所有字符被唯一划分到某个频率组中",
        "comparison_rule": "若多个频率组有相同大小（不同字符数），则选择频率 k 更大的那个组作为众数频率组"
      },
      "Objective Function": {
        "goal": "返回众数频率组中的所有字符",
        "output_type": "string",
        "order_sensitive": false,
        "selection_criterion": "先最大化频率组的大小（即包含的不同字符数量），若有并列，则选择频率 k 更大的组"
      },
      "Algorithmic Invariant": {
        "invariant_1": "字符频次统计完成后，每个字符的归属频率组是确定且唯一的",
        "invariant_2": "频率组按 k 分组后，组大小为该组内非空字符集合的基数（|{c : freq(c) = k}|）",
        "invariant_3": "最优性比较具有全序性：优先比较组大小，其次比较 k 值，因此存在唯一解",
        "invariant_4": "无需动态维护：离线统计即可完成全部决策，无前后依赖或状态演化"
      },
      "Transformable Parameters": {
        "n_range": "[1, 100]",
        "character_set": {
          "base": "lowercase English letters",
          "possible_extensions": [
            "uppercase",
            "digits",
            "arbitrary symbols"
          ]
        },
        "frequency_condition": {
          "current": "exactly k occurrences",
          "transformable_to": [
            "at least k",
            "at most k",
            "within range [k1,k2]"
          ]
        },
        "tie_breaking_rule": {
          "current": "choose group with larger k",
          "alternatives": [
            "choose smaller k",
            "choose lexicographically smallest characters",
            "merge all tied groups"
          ]
        },
        "output_form": {
          "current": "concatenated string, order irrelevant",
          "variants": [
            "sorted order",
            "each char repeated k times",
            "return k value only",
            "return size only"
          ]
        },
        "input_dynamics": {
          "current": "static offline input",
          "extensions": [
            "online character stream",
            "support updates (insert/delete)"
          ]
        },
        "multiplicity": {
          "current": "single test case",
          "extension": "multiple queries over same string or different k values"
        }
      }
    }
  },
  {
    "title": "Equal Score Substrings",
    "slug": "equal-score-substrings",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n (2 <= n <= 100)",
        "representation": "s[0..n-1], each character c maps to value: 'a'=1, 'b'=2, ..., 'z'=26"
      },
      "Core Constraint": {
        "description": "The string must be split into two non-empty contiguous substrings at some index i (0 <= i < n-1), and the sum of character values in both parts must be equal.",
        "split_condition": "Left substring s[0..i] and right substring s[i+1..n-1] are non-empty and their scores are compared.",
        "global_dependency": "Total score is fixed; left score = total - right score. Equality implies left score = total / 2."
      },
      "Objective Function": {
        "type": "decision problem",
        "goal": "Determine whether there exists an index i ∈ [0, n-2] such that the score of s[0..i] equals the score of s[i+1..n-1]"
      },
      "Algorithmic Invariant": {
        "prefix_sum_monotonicity": "The prefix sum increases monotonically as we iterate from left to right.",
        "early_termination": "If prefix sum exceeds half of total score, no further index can satisfy the condition (since all values are positive).",
        "balance_condition": "At any index i, check if prefix_sum[i] == total_sum - prefix_sum[i] → i.e., 2 * prefix_sum[i] == total_sum"
      },
      "Transformable Parameters": {
        "n_range": "2 <= n <= 100",
        "character_set": "lowercase English letters only",
        "value_mapping": "a=1, b=2, ..., z=26 (can be generalized)",
        "score_equality": "exact equality of two substring scores",
        "number_of_splits": "single split point (one cut)",
        "output_type": "boolean (true/false)",
        "input_form": "single static string",
        "online_processing": "offline (whole string given)",
        "variants": [
          "Allow uppercase or other alphabets",
          "Change scoring function (e.g., a=0, or custom weights)",
          "Count number of valid splits instead of existence",
          "Allow more than two parts",
          "Minimize |left_score - right_score| instead of exact equality",
          "Extend to circular strings"
        ]
      }
    }
  },
  {
    "title": "Remove Zeros in Decimal Representation",
    "slug": "remove-zeros-in-decimal-representation",
    "schema": {
      "Input Structure": [
        "正整数 n",
        "1 <= n <= 10^15",
        "十进制数字序列 D[1..k], k = floor(log10(n)) + 1",
        "D[i] ∈ {0,1,...,9}, D[1] ≠ 0"
      ],
      "Core Constraint": [
        "零的移除操作不改变非零数字的相对顺序",
        "结果必须保持原始数字中非零位的从左到右顺序",
        "不允许前导零（由于输入为正整数且输出为整数，天然无前导零）"
      ],
      "Objective Function": "构造一个新整数，其十进制表示由原数字中所有非零位按原顺序拼接而成",
      "Algorithmic Invariant": [
        "遍历过程中维护当前构造结果 res = res * 10 + digit（仅当 digit != 0）",
        "每一步处理后，res 始终是已处理部分去掉所有零后的正确整数表示",
        "数值构建过程满足顺序不变性和累积性"
      ],
      "Transformable Parameters": {
        "值域范围": "1 <= n <= 10^15",
        "是否包含负数": false,
        "是否允许前导零输入": false,
        "目标进制": "十进制",
        "移除的数字": [
          "0",
          "可推广至移除任意特定数字 d"
        ],
        "操作类型": [
          "移除",
          "替换",
          "统计"
        ],
        "输出形式": [
          "整数结果",
          "字符串结果",
          "每位数字列表"
        ],
        "是否多组数据": false,
        "是否在线处理": false,
        "是否要求逆序恢复": false,
        "扩展变形": [
          "移除所有偶数位",
          "保留单调递增子序列",
          "在二进制表示中移除 0",
          "流式输入下的即时转换"
        ]
      }
    }
  },
  {
    "title": "Minimum Index Sum of Common Elements",
    "slug": "minimum-index-sum-of-common-elements",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置 i 能存储的水量由其左侧最大高度和右侧最大高度中的较小值决定，且该约束具有局部独立性与全局依赖性",
      "Objective Function": "计算整个数组能接住的雨水总量（求和型目标函数）",
      "Algorithmic Invariant": "维护两个指针 L 和 R 分别从左右两端向内移动，同时记录 left_max 和 right_max；若 left_max ≤ right_max，则左指针当前位置的蓄水量可确定，且移动左指针不破坏已计算部分的最优性；反之亦然",
      "Transformable Parameters": {
        "数据规模 n": "1 ≤ n ≤ 10^5（可调整为更小或支持在线流式输入）",
        "值域范围": "H[i] ∈ [0, 10^4]（可扩展至负数或高精度场景）",
        "数组有序性": "无序输入（可变体：近似单调、双峰分布等）",
        "维度扩展": "可推广至二维矩阵（2D 接雨水问题）",
        "操作类型": "静态一次性输入（可变体：支持单点修改、删除、插入）",
        "输出形式": "仅求总量（可变体：输出每个位置的存水量、最大连续积水段等）",
        "输入模式": "单组数据（可变体：多组测试用例、在线查询）"
      }
    }
  },
  {
    "title": "Count No-Zero Pairs That Sum to N",
    "slug": "count-no-zero-pairs-that-sum-to-n",
    "schema": {
      "Input Structure": [
        "整数 n，满足 2 <= n <= 10^15",
        "定义‘无零整数’为十进制表示中不包含数字 '0' 的正整数"
      ],
      "Core Constraint": [
        "a 和 b 必须均为无零整数",
        "a + b = n",
        "数对 (a, b) 中 a 和 b 的顺序不同视为不同的数对（即有序）"
      ],
      "Objective Function": "计数：统计满足条件的有序数对 (a, b) 的数量",
      "Algorithmic Invariant": [
        "对于任意 a ∈ [1, n-1]，b = n - a 可唯一确定",
        "只需判断 a 和 b 是否均为无零整数",
        "无零判断可通过逐位检查十进制表示完成，且该判断具有可分离性和独立性",
        "遍历过程中的合法性校验不依赖历史状态，具备独立子问题性质"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 10^15（可调整为更小或支持更大范围）",
        "是否允许前导零": "否（隐含在无零定义中，可变形为允许但不计数）",
        "无零定义是否扩展到其他进制": "当前为十进制，可变更为 k 进制",
        "数对是否有序": "当前为有序（即 (a,b) ≠ (b,a) 当 a≠b），可改为无序以改变计数逻辑",
        "是否多组数据": "单组输入，可扩展为 T 组查询",
        "是否在线输入": "离线处理，可改造为在线流式 n 输入",
        "目标函数变化": [
          "改为判定是否存在至少一对",
          "构造所有合法数对",
          "求 a 的最大值等优化目标"
        ],
        "约束条件变化": [
          "要求 a <= b 或 a < b 以去重",
          "加入 a 和 b 位数相同的限制",
          "引入数字频率限制（如每位最多出现一次）"
        ]
      }
    }
  },
  {
    "title": "Minimum Time to Complete All Deliveries",
    "slug": "minimum-time-to-complete-all-deliveries",
    "schema": {
      "Input Structure": {
        "d": "整数数组 [d1, d2], 表示两架无人机各自需要完成的送货次数",
        "r": "整数数组 [r1, r2], 表示两架无人机各自的充电周期（每 ri 小时必须在 ri 的倍数时刻充电）",
        "约束条件": [
          "1 <= d1, d2 <= 1e9",
          "2 <= r1, r2 <= 3e4",
          "每次送货耗时恰好1小时",
          "任意时刻最多只有一架无人机可以送货",
          "充电发生在 r_i 的倍数小时，该小时内不能送货"
        ]
      },
      "Core Constraint": {
        "时间线结构": "离散小时序列 t = 1, 2, 3, ..., T",
        "资源互斥": "同一小时内仅允许一个事件（送货或充电）发生，且充电为强制占用",
        "周期性禁用": "对于无人机 i，所有满足 t % ri == 0 的时间点 t 均不可用于其送货",
        "任务完整性": "无人机 i 必须在非充电时间中安排 di 次送货"
      },
      "Objective Function": "最小化总时间 T（即最后一项送货完成的时间），使得两架无人机都能在其允许的时间内完成全部 di 次送货，且无时间冲突",
      "Algorithmic Invariant": {
        "贪心构造不变量": "若当前最早可用时间未被占用且不违反充电周期，则优先安排任务",
        "双机调度独立性": "每架无人机的可行送货时间集合是固定的（非倍数小时）",
        "时间单调推进": "一旦确定某时间点被使用（送货），后续决策不影响之前安排的合法性",
        "最优子结构性质": "整体最小完成时间由两个无人机的任务排布与资源竞争共同决定，可通过二分答案结合可行性验证进行求解"
      },
      "Transformable Parameters": {
        "数据规模": [
          "di 的范围：可扩展至 1e12（支持大数场景）",
          "ri 的范围：可缩小至 1（退化为无充电）或增大至环形调度模型"
        ],
        "输入维度": [
          "从 2 架无人机推广到 k 架（k >= 2）",
          "是否允许部分共享充电时间槽"
        ],
        "约束形式": [
          "充电周期从 '必须在倍数时间充电' 改为 '每连续运行 ri-1 小时后需休息1小时'",
          "改为滑动窗口式约束（任意连续 ri 小时最多送货 ri-1 次）"
        ],
        "目标函数变换": [
          "从最小化最大完成时间 → 最小化总空闲时间",
          "改为判定问题：给定 T，是否能完成所有任务？",
          "计数问题：有多少种合法调度方案？"
        ],
        "数据流模式": [
          "离线批量输入 → 在线动态增加送货需求",
          "加入删除操作：临时取消某次任务"
        ],
        "是否多组数据": true,
        "是否循环时间轴": false,
        "是否要求输出具体方案": false
      }
    }
  },
  {
    "title": "Longest Balanced Subarray II",
    "slug": "longest-balanced-subarray-ii",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 1 <= n <= 10^5，nums[i] ∈ [1, 10^5]，元素可重复，子数组为连续非空序列",
      "Core Constraint": "平衡子数组要求：子数组中不同偶数的个数等于不同奇数的个数；该约束依赖于集合的大小而非频率或顺序",
      "Objective Function": "最大化满足平衡条件的子数组长度（即求最长平衡子数组的长度）",
      "Algorithmic Invariant": "使用状态压缩与前缀哈希映射：将‘不同偶数个数 - 不同奇数个数’的差值作为状态，相同状态首次出现的位置与当前位置构成的子数组具有平衡潜力；若两个位置间的状态差为0，则其间子数组可能平衡；利用哈希表记录每个状态首次出现的索引以支持 O(1) 查询",
      "Transformable Parameters": {
        "数据规模": "n 的范围可在 1e3 → 1e5 → 1e6 变化，影响是否允许 O(n^2) 或必须 O(n)",
        "值域特性": "nums[i] 是否有界、是否可负、是否密集影响哈希或计数方式",
        "奇偶定义扩展": "可替换为模 k 同余类计数平衡（如 mod 3 余 0/1/2 的数量相等）",
        "目标函数变换": "从‘最长’变为‘最短’、‘计数’或‘是否存在长度 ≥ K 的平衡子数组’",
        "输入形式": "单组输入 → 多组测试数据；离线处理 → 在线流式添加元素",
        "子数组变体": "是否允许空子数组；是否考虑环形数组（首尾相连）",
        "平衡条件变形": "从‘不同数值个数相等’变为加权平衡、或引入阈值容忍（如 |#even - #odd| <= K）"
      }
    }
  },
  {
    "title": "Longest Balanced Subarray I",
    "slug": "longest-balanced-subarray-i",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中每个元素为整数，满足 1 <= nums[i] <= 10^5；数组长度 n 满足 1 <= n <= 1500",
      "Core Constraint": "平衡子数组要求其内部不同偶数的个数等于不同奇数的个数；由于只关心‘不同’数值，且值域较小（<=10^5），可用状态压缩或哈希记录奇偶数出现情况；连续性约束使得必须在子数组上维护动态集合",
      "Objective Function": "最大化满足‘不同偶数个数 == 不同奇数个数’的连续非空子数组的长度",
      "Algorithmic Invariant": "使用前缀状态差思想：将偶数视为+1变化，奇数视为-1变化（或反之），但因需计数‘不同’值，不能直接累加；改为维护从左到右遍历中，已出现的不同偶数与不同奇数的集合差状态；当两个位置的状态差（即 (distinct_odd_count - distinct_even_count)）相同时，中间区间为平衡；利用哈希表记录最早出现某状态差的位置以最大化长度",
      "Transformable Parameters": {
        "数据规模": "n 的范围可调整（当前 1 <= n <= 1500），支持 O(n^2) 或优化至 O(n × C) 解法",
        "值域范围": "nums[i] 的值域可变（当前 <= 10^5），若进一步缩小（如 <= 20）可启用位掩码优化",
        "是否允许重复扩展": "可改为要求‘不同质数/合数’、‘模k余偶/余奇’等语义变形",
        "目标函数形式": "可变换为：计数平衡子数组数量、判定是否存在长度 >= K 的平衡子数组",
        "输入形式": "可改为多组测试数据、在线流式输入（要求近似或滑动窗口处理）",
        "结构维度": "可推广至二维矩阵中的最大平衡子矩阵问题"
      }
    }
  },
  {
    "title": "Find Zombie Sessions",
    "slug": "find-zombie-sessions",
    "schema": {
      "Input Structure": [
        "表 app_events",
        "包含字段：event_id (int, 主键), user_id (int), event_timestamp (datetime), event_type (varchar), session_id (varchar), event_value (int)",
        "event_type ∈ {app_open, click, scroll, purchase, app_close}",
        "session_id 将同一用户会话的事件分组",
        "event_value 含义依赖于 event_type：purchase 表金额（美元），scroll 表滚动像素数，其余为 NULL"
      ],
      "Core Constraint": [
        "会话行为由其内部事件序列唯一确定",
        "会话时长由最早与最晚 event_timestamp 决定",
        "滚动次数、点击次数、购买存在性等统计量可从事件流中聚合得出",
        "点击滚动比率 = 点击次数 / 滚动次数（当滚动次数 > 0；否则视为无穷大或未定义）",
        "所有判定条件必须基于单个 session_id 内部数据独立计算"
      ],
      "Objective Function": [
        "识别满足以下全部条件的会话（僵尸会话）：",
        "- 会话时长 > 30 分钟",
        "- 至少有 5 次 scroll 事件",
        "- 点击滚动比率 < 0.20",
        "- 无任何 purchase 事件",
        "输出每个符合条件的会话的：session_id, user_id, 会话时长（分钟）, 滚动次数",
        "结果按 scroll_count 降序，再按 session_id 升序排序"
      ],
      "Algorithmic Invariant": [
        "每个 session_id 可独立处理，无跨会话依赖",
        "时间跨度可通过 MIN(event_timestamp) 和 MAX(event_timestamp) 正确计算",
        "事件计数（如 scroll、click、purchase）可通过 GROUP BY session_id 的聚合操作保持一致性",
        "ratio 计算在分母（scroll_count）固定后具有单调性：增加 click 会使 ratio 上升，不利于满足 <0.20 条件",
        "过滤顺序可优化：先筛出足够长且有足够 scroll 的会话，再检查 ratio 和 purchase 更高效"
      ],
      "Transformable Parameters": {
        "n": "事件总数，可变范围：10^3 ~ 10^7",
        "session_count": "会话数量，可变范围：10^2 ~ 10^5",
        "time_threshold_minutes": 30,
        "min_scroll_count": 5,
        "max_click_to_scroll_ratio": 0.2,
        "must_have_purchase": false,
        "output_fields": [
          "session_id",
          "user_id",
          "session_duration_minutes",
          "scroll_count"
        ],
        "ordering": [
          "scroll_count DESC",
          "session_id ASC"
        ],
        "event_types": [
          "app_open",
          "click",
          "scroll",
          "purchase",
          "app_close"
        ],
        "is_multi_user": true,
        "is_online_streaming": false,
        "allows_null_event_value": true,
        "requires_real_time_detection": false,
        "add_constraints": []
      }
    }
  },
  {
    "title": "Minimum Operations to Transform Array",
    "slug": "minimum-operations-to-transform-array",
    "schema": {
      "Input Structure": [
        "一维数组 nums1[1..n]",
        "一维数组 nums2[1..n+1]",
        "nums1[i], nums2[i] ∈ [1, 10^5]",
        "整数类型，非负"
      ],
      "Core Constraint": [
        "操作包括：对任意位置 i 的 nums1[i] 增加1、减少1，或将其值追加到 nums1 末尾",
        "追加操作会扩展 nums1 长度，最终需使 nums1 完全等于 nums2（长度 n+1）",
        "每个操作独立计数，目标是最小化总操作次数",
        "只能使用已有元素进行追加，不能插入任意值"
      ],
      "Objective Function": "最小化将 nums1 转换为 nums2 所需的操作次数（增加、减少、追加三类操作之和）",
      "Algorithmic Invariant": [
        "追加的元素必须来自当前 nums1 中某个下标 i 的当前值",
        "一旦某元素被修改用于匹配目标，其后续变化不影响已确定位置的最优性",
        "最优策略中，追加操作应尽早执行以提供新元素参与后续调整",
        "状态空间可建模为动态规划：dp[i][j] 表示 nums1 前 i 个元素匹配 nums2 前 j 个位置的最小代价",
        "可通过枚举追加位置与匹配顺序实现子问题划分"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1 <= n <= 10^5",
            "可变至 10^3 或 10^6"
          ],
          "值域范围": [
            "[1, 10^5]",
            "可扩展为 [-10^5, 10^5] 或更大"
          ]
        },
        "输入形式": {
          "是否有序": false,
          "是否允许重复": true,
          "数组长度关系": "nums2.length = nums1.length + 1（固定偏移）"
        },
        "操作类型": {
          "可追加操作": true,
          "可删除元素": false,
          "可插入任意值": false,
          "是否允许多次追加同一元素": true
        },
        "输出要求": {
          "仅返回最小操作次数": true,
          "是否要求构造方案": false
        },
        "多组数据": false,
        "在线/离线": "离线处理"
      }
    }
  },
  {
    "title": "Climbing Stairs II",
    "slug": "climbing-stairs-ii",
    "schema": {
      "Input Structure": {
        "description": "一维数组 cost[1..n]，下标从 1 开始，表示第 i 级台阶的成本；总台阶数为 n+1（编号 0 到 n）；从位置 0 出发，目标是到达位置 n",
        "type": "Array",
        "size": "n",
        "indexing": "1-based for costs, 0-based for positions",
        "values": "costs[i] ≥ 1, integer",
        "constraints_on_n": "1 <= n <= 1e5"
      },
      "Core Constraint": {
        "movement_rule": "从位置 i 只能跳到 i+1, i+2, 或 i+3",
        "transition_cost_formula": "从 i 跳到 j 的成本为：costs[j] + (j - i) * (j - i)",
        "dependency_structure": "当前状态仅依赖于前三个可达位置的最优解",
        "optimal_substructure": true,
        "no_cycle": true,
        "directed_path": true
      },
      "Objective Function": {
        "goal": "最小化从位置 0 到位置 n 的总跳跃成本",
        "objective_type": "minimization",
        "output_single_value": true
      },
      "Algorithmic Invariant": {
        "dp_invariant": "dp[i] = 到达位置 i 所需的最小总成本（i >= 1）",
        "recurrence_relation": "dp[i] = min_{j ∈ {i-3,i-2,i-1}}(dp[j] + costs[i] + (i - j)*(i - j))，其中 j >= 0",
        "base_condition": "dp[0] = 0",
        "monotonicity": false,
        "irreversibility": true,
        "local_decision_global_optimality": true
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 1e5",
        "cost_value_range": "1 <= costs[i] <= 1e4",
        "jump_span": "可变：k=1,2,3 → 可推广至任意固定 k",
        "cost_function_form": [
          "二次代价: (j-i)^2",
          "线性代价: |j-i|",
          "常数跳跃成本",
          "自定义函数 f(j-i)"
        ],
        "start_positions": "单起点（0）→ 多起点（如从 0,1,2 中任选）",
        "end_positions": "单一终点（n）→ 多终点（如任意 >= n-k）",
        "input_type": "静态数组 → 在线流式输入（逐步给出 costs[i]）",
        "modification_support": "是否支持更新操作（如修改某级台阶成本）",
        "output_detail": "仅输出最小成本 → 输出路径方案",
        "multiple_queries": false,
        "is_circular": false
      }
    }
  },
  {
    "title": "Compute Decimal Representation",
    "slug": "compute-decimal-representation",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "value": "n",
        "domain": "positive integer",
        "range": "1 <= n <= 10^9",
        "representation": "decimal digit decomposition"
      },
      "Core Constraint": {
        "definition": "A 'decimal component' is a positive integer that can be expressed as the product of a single digit (1-9) and a non-negative power of 10.",
        "implication": "Each digit in the decimal representation of n contributes independently to a unique set of decimal components, one per non-zero digit.",
        "uniqueness": "The minimal decomposition corresponds directly to the non-zero digits in each power-of-10 place."
      },
      "Objective Function": {
        "goal": "minimize the number of decimal components",
        "output_form": "return a list of decimal components",
        "ordering": "in descending order by value"
      },
      "Algorithmic Invariant": {
        "decomposition_rule": "Each non-zero digit d at position k (from right, 0-indexed) generates exactly one term: d * 10^k.",
        "optimality_condition": "No two digits can be combined into fewer terms without violating the definition of a decimal component.",
        "greedy_property": "Greedy selection of one term per non-zero digit yields globally optimal solution.",
        "independence": "Digits in different decimal places are independent; no carry or interaction affects minimality."
      },
      "Transformable Parameters": {
        "n_magnitude": "1 <= n <= 10^9",
        "digit_set": {
          "base": 10,
          "allowed_digits": "1-9",
          "exponent_range": "non-negative integers up to floor(log10(n))"
        },
        "input_form": "single integer",
        "output_form": "list of integers, sorted in descending order",
        "multi_query": false,
        "online_input": false,
        "base_generalization": {
          "possible": true,
          "example": "change base from 10 to b, redefine decimal component accordingly"
        },
        "component_constraints": {
          "allow_digit_zero": false,
          "allow_negative_powers": false,
          "restrict_component_count": false
        },
        "variant_objectives": [
          "count only the number of components",
          "find lexicographically smallest sequence",
          "represent using maximum component first (same as original)",
          "allow reuse of components under additional constraints"
        ]
      }
    }
  },
  {
    "title": "Lexicographically Smallest Palindromic Permutation Greater Than Target",
    "slug": "lexicographically-smallest-palindromic-permutation-greater-than-target",
    "schema": {
      "Input Structure": [
        "长度为 n 的字符串 s，由小写英文字母组成",
        "长度为 n 的目标字符串 target，由小写英文字母组成",
        "1 <= n <= 300"
      ],
      "Core Constraint": [
        "回文排列存在的充要条件是：至多一个字符的出现次数为奇数（其余均为偶数）",
        "字典序严格大于 target 的候选解必须基于 s 中字符的重排",
        "目标是在所有合法回文排列中寻找字典序最小的、且满足 > target 的字符串"
      ],
      "Objective Function": "构造字典序最小的字符串，该字符串既是 s 的回文排列，又在字典序上严格大于 target；若不存在则返回空字符串",
      "Algorithmic Invariant": [
        "回文结构对称性：前半部分确定后，后半部分唯一确定",
        "字符频次可构造回文 ↔ 奇数频次字符个数 ≤ 1",
        "字典序比较具有前缀单调性：从高位向低位尝试最小可行字符，可贪心构造候选解",
        "一旦构造出一个回文排列 > target，后续更小字典序的排列无需考虑（因要求最小且 > target）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "n <= 300（当前），可扩展至 n <= 1e5（需优化构造方式）",
        "字符类型": "当前为小写英文字母，可推广至大写字母或数字",
        "是否允许无解": "是，当无回文排列或所有回文排列 ≤ target 时返回空串",
        "目标函数变形": [
          "改为求字典序最大的 < target 的回文排列",
          "改为计数：有多少个回文排列 > target",
          "改为判定：是否存在一个回文排列 > target"
        ],
        "输入形式变化": [
          "s 和 target 是否有序",
          "是否多组查询（固定 s，多个 target）",
          "是否在线输入字符流"
        ],
        "约束隐式化": [
          "不直接给出 s，而是给出字符频次表",
          "target 不显式给出，而是以某种规则生成"
        ],
        "回文结构变形": [
          "要求是回文子序列而非排列",
          "允许最多 k 个字符修改以构造近似回文"
        ]
      }
    }
  },
  {
    "title": "Sum of Weighted Modes in Subarrays",
    "slug": "sum-of-weighted-modes-in-subarrays",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱子高度",
      "Core Constraint": "每个位置 i 能存储的水量由其左侧最大高度 maxLeft 和右侧最大高度 maxRight 的较小值决定，且仅当该最小值大于 H[i] 时才能储水",
      "Objective Function": "计算整个数组能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针 L 和 R 分别从左右两端向中间移动，维护 maxLeft 和 maxRight；若 maxLeft ≤ maxRight，则左指针所在位置的可接雨水量可立即确定并累加，反之亦然；指针推进过程中不会破坏已计算区域的正确性",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许负数（如沟壑模型）",
        "维度扩展": "是否推广到二维矩阵（2D接雨水）",
        "输入模式": "是否在线输入或支持动态修改（加入更新操作）",
        "输出要求": "是否需要输出每个位置的具体储水量而非总和",
        "结构变形": "是否为环形数组（首尾相连）",
        "数据规模": "n 的数量级（如 1e3 / 1e5 / 1e7，影响解法选择）",
        "多组数据": "是否处理多组测试用例"
      }
    }
  },
  {
    "title": "Maximum Partition Factor",
    "slug": "maximum-partition-factor",
    "schema": {
      "Input Structure": "二维整数数组 points[1..n]，其中 points[i] = [x_i, y_i] 表示笛卡尔平面上的点，-10^8 <= x_i, y_i <= 10^8，2 <= n <= 500",
      "Core Constraint": "划分必须将 n 个点分为恰好两个非空组；划分因子定义为各组内所有无序点对曼哈顿距离的最小值中的最大可能值；单点组不产生组内距离，不影响最小值（视为忽略）",
      "Objective Function": "最大化所有有效划分中，各组内部点对间最小曼哈顿距离的下界（即：max over min{组1内最小距离, 组2内最小距离}），若某组无点对则仅取另一组的最小距离",
      "Algorithmic Invariant": "最优解对应的划分因子 d 具有单调性：若存在一种划分使得每组内任意点对距离 ≥ d，则 d 可行；可通过二分枚举 d，并用图论建模（补图连通性）或枚举分割方式验证可行性；点之间曼哈顿距离的局部结构支持基于聚类或连通分量的剪枝",
      "Transformable Parameters": [
        "n 的数量级：[2, 500] → 可扩展至 10^3 或更高以要求更优算法",
        "坐标值域：[-10^8, 10^8] → 可压缩或离散化",
        "距离度量：曼哈顿距离 → 欧几里得距离 / 切比雪夫距离",
        "分组数量：2 组 → k 组（多组划分）",
        "是否允许空组：否 → 是（需重新定义目标函数）",
        "是否在线输入点集：否 → 是（流式点加入）",
        "是否要求构造最优划分方案：否 → 是",
        "目标函数变换：最大划分因子 → 最小划分因子 / 计数满足条件的划分数量"
      ]
    }
  },
  {
    "title": "Longest Subsequence With Non-Zero Bitwise XOR",
    "slug": "longest-subsequence-with-non-zero-bitwise-xor",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 1 <= n <= 10^5，0 <= nums[i] <= 10^9",
      "Core Constraint": "子序列的异或结果非零；空子序列不合法，子序列必须保持原顺序但可任意删除元素",
      "Objective Function": "求异或结果非零的最长子序列的长度；若不存在则返回 0",
      "Algorithmic Invariant": "全局最优解具有贪心性质：若整个数组异或结果非零，则整个数组即为所求；否则，最优子序列必为整个数组删除一个元素后的前缀或后缀（使得剩余部分异或非零）；可通过前缀异或与后缀异或的组合判断局部最优",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^5（可改为更小或更大以控制复杂度）",
        "值域范围": "0 <= nums[i] <= 10^9（可扩展至负数或更高位）",
        "是否有序": "数组无序，顺序不可变（可考虑排序后是否影响问题结构）",
        "是否循环": "线性结构，非循环（可变形为环形数组）",
        "是否多组输入": "单组输入（可扩展为多组测试用例）",
        "是否在线": "离线输入（可设计为流式数据，在线查询最长非零异或子序列）",
        "目标函数变化": "可改为：计数非零异或子序列个数、求最短长度、判定是否存在长度 >= k 的子序列等",
        "操作类型扩展": "加入单点修改或区间查询，变为支持动态更新的数据结构题"
      }
    }
  },
  {
    "title": "Maximize Cyclic Partition Score",
    "slug": "maximize-cyclic-partition-score",
    "schema": {
      "Input Structure": "循环数组 nums[1..n]，其中 n >= 1；每个元素 nums[i] ∈ [1, 10^9]；允许子数组跨越数组末尾与起点（环形结构）",
      "Core Constraint": "划分至多 k 个连续非空子数组（可环绕），每个子数组的得分是其最大值与最小值之差；目标函数具有可加性且局部极值依赖全局最值分布；由于环形特性，起始点不固定，需考虑所有可能断环位置",
      "Objective Function": "最大化所有子数组范围（最大值 - 最小值）的总和",
      "Algorithmic Invariant": "最优解中，每个子数组的贡献独立累加；若将整个数组视为环，则存在一个断开位置使得线性化后的最优划分仍保持原环形最优性；可通过枚举断点转化为线性问题，并利用动态规划维护：dp[i][j] 表示前 i 个元素划分为 j 段的最大得分，转移时维护每段的 min 和 max",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1000（适合 O(n²k) 或优化后 O(nk log n) 解法）",
        "值域范围": "nums[i] ∈ [1, 10^9]，支持离散化或直接比较",
        "是否有序": "无序输入，但可通过排序辅助分析极值分布（注意破坏连续性）",
        "是否循环": "是，关键特征，可变形成非循环版本作为变形题",
        "是否多组输入": "单组输入，可扩展为多组测试用例",
        "是否在线": "离线处理，可扩展为在线查询不同 k 值下的答案",
        "子数组数量限制": "最多 k 个，不要求恰好 k 个，可变参数包括 '必须恰好 k 段' 或 '至少 k 段'",
        "目标函数形式": "求最大得分，可变换为最小化得分、判定是否存在得分 ≥ S 的方案、计数达到最大得分的方案数"
      }
    }
  },
  {
    "title": "Sort Array By Absolute Value",
    "slug": "sort-array-by-absolute-value",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定",
        "properties": [
          "左右边界约束独立但需联合判定",
          "局部可确定性：当某一侧的最大值小于等于另一侧时，当前指针位置的接水量仅由该侧最大值决定"
        ]
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组所有位置能够接到的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示左指针左侧历史最大值，maxRight 表示右指针右侧历史最大值",
          "若 maxLeft ≤ maxRight，则左指针当前位置的接水量仅由 maxLeft 决定，L 可安全右移",
          "若 maxRight < maxLeft，则右指针当前位置的接水量仅由 maxRight 决定，R 可安全左移",
          "已确定区域的贡献值在指针移动过程中保持不变且正确"
        ],
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "n_range": "1 ≤ n ≤ 10^5",
        "value_range": "0 ≤ H[i] ≤ 10^4",
        "ordered": false,
        "circular": false,
        "negative_allowed": false,
        "online_queries": false,
        "mutable": false,
        "output_detail": "total sum only",
        "dimensions": 1,
        "multiple_test_cases": false,
        "transformations": [
          "输入维度变换：1D → 2D（二维接雨水）",
          "目标变换：求总和 → 求最大单区间容量（如‘盛最多水的容器’）",
          "约束反转：非负高度 → 允许负值（地形凹陷建模）",
          "数据流化：静态数组 → 支持更新或在线插入",
          "隐藏条件：显式数组 → 隐式生成高度（如函数或坐标流）"
        ]
      }
    }
  },
  {
    "title": "Number of Stable Subsequences",
    "slug": "number-of-stable-subsequences",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n >= 1，nums[i] >= 1，元素顺序固定，用于生成非空子序列",
      "Core Constraint": "子序列中任意连续三个元素不能具有相同的奇偶性；约束仅依赖于子序列内部的相对位置和奇偶模式，不涉及数值大小或全局结构",
      "Objective Function": "计数所有满足‘稳定子序列’定义的非空子序列数量，并对结果取模 (10^9 + 7)",
      "Algorithmic Invariant": "动态规划状态可基于末尾连续相同奇偶性的长度（0、1 或 2）进行转移：\n- 状态 dp[i][parity][count] 表示考虑前 i 个元素，以奇偶性 parity 结尾且末尾有 count 个连续相同奇偶性的稳定子序列数量\n- 添加新元素时，根据其奇偶性更新状态，若会导致三个连续相同奇偶性则禁止转移\n- 每一步转移保持‘无三连同奇偶’的合法性",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^5，支持线性或近线性解法",
        "值域": "nums[i] ∈ [1, 10^5]，但实际只关心奇偶性，故可压缩为布尔属性",
        "是否有序": "输入数组顺序重要（子序列需保持原序），不可重排",
        "是否循环": "否，子序列按线性顺序构建",
        "是否多组输入": "可扩展为多组测试用例",
        "是否在线": "当前为离线一次性输入，可改造为流式添加元素的在线版本",
        "奇偶约束强度": "可调整为不允许两个连续相同奇偶（更严格），或允许最多 k 个连续（泛化）",
        "目标函数形式": "可改为求最长稳定子序列长度（最优化）、判断是否存在不稳定子序列（判定问题）等"
      }
    }
  },
  {
    "title": "Find Loyal Customers",
    "slug": "find-loyal-customers",
    "schema": {
      "Input Structure": [
        "Table: customer_transactions",
        "Columns: transaction_id (int, primary key), customer_id (int), transaction_date (date), amount (decimal), transaction_type (varchar)",
        "transaction_type ∈ {'purchase', 'refund'}",
        "One-dimensional sequence of transactions per customer"
      ],
      "Core Constraint": [
        "Customer must have at least 3 purchase transactions",
        "Customer's activity span (difference between max and min transaction_date) ≥ 30 days",
        "Refund rate = count(refund) / (count(purchase) + count(refund)) < 0.2",
        "Constraints are independent per customer and aggregatable by customer_id"
      ],
      "Objective Function": [
        "Filter and return customer_ids satisfying all three loyalty conditions",
        "Output is a list of customer_id in ascending order",
        "Binary classification per customer: loyal or not"
      ],
      "Algorithmic Invariant": [
        "Grouping by customer_id preserves independence across customers",
        "Aggregation functions (count, date diff, ratio) are separable and monotonic under partitioning",
        "Local computation per customer ensures global correctness",
        "Order of processing transactions does not affect final aggregation result"
      ],
      "Transformable Parameters": {
        "Purchase threshold": "Minimum number of purchases (e.g., 3 → 5)",
        "Activity duration threshold": "Minimum active days (e.g., 30 → 60)",
        "Refund rate threshold": "Maximum allowed refund ratio (e.g., 20% → 10% or 25%)",
        "Transaction types": "Extend to more types (e.g., 'exchange', 'chargeback')",
        "Time window": "Add constraint on recency (e.g., within last 6 months)",
        "Value-based conditions": "Replace count with amount sum (e.g., total purchase amount > X)",
        "Output format": "Return additional metrics (e.g., refund rate, active days) or full records",
        "Data scale": "Single table → distributed tables / sharded databases",
        "Input mode": "Static batch input → streaming transaction events (online variant)",
        "Sorting requirement": "customer_id ascending → descending / no sort / by activity length"
      }
    }
  },
  {
    "title": "Count Binary Palindromic Numbers",
    "slug": "count-binary-palindromic-numbers",
    "schema": {
      "Input Structure": "非负整数 n，表示上界；目标是枚举所有 k ∈ [0, n] 的整数，并检查其二进制表示（无前导零）是否为回文",
      "Core Constraint": "一个非负整数的二进制字符串正读和反读相同；由于二进制表示唯一且不含前导零，判断回文仅依赖于位序列的对称性；关键观察：回文串的长度决定了其构造方式（奇偶长度可分类），且较小位数的所有回文数一定小于较大位数的回文数",
      "Objective Function": "计数：统计满足 0 <= k <= n 且 k 的二进制表示为回文数的整数个数",
      "Algorithmic Invariant": "可以通过生成所有可能的二进制回文数（按位长递增顺序）并判断是否 ≤ n 来避免遍历整个区间 [0, n]；生成过程保持单调递增性，一旦生成的回文数超过 n 可提前终止；每个回文数由前半段确定，后半段镜像得到，保证不重复也不遗漏",
      "Transformable Parameters": {
        "n 的数量级": "0 <= n <= 1e15，意味着不能暴力遍历，但二进制位数最多约 50 位，支持按位构造",
        "值域": "输入为单个非负整数 n，输出为计数结果",
        "是否有序": "k 自然有序，但解法不依赖排序而是构造",
        "是否循环": "否",
        "是否多组输入": "可扩展为多组测试数据",
        "是否在线": "当前为离线输入，可改造为在线查询多个 n 的情形",
        "回文定义变化": "可改为带前导零判断、或要求必须奇数长度等变体",
        "进制扩展": "可推广至 b 进制下的回文数计数问题"
      }
    }
  },
  {
    "title": "Minimum Operations to Equalize Subarrays",
    "slug": "minimum-operations-to-equalize-subarrays",
    "schema": {
      "Input Structure": {
        "nums": "一维整数数组 A[1..n], 其中 n >= 1, A[i] ∈ [1, 10^9]",
        "k": "正整数，表示每次操作可加减的固定值，k ∈ [1, 10^9]",
        "queries": "二维整数数组 Q[1..m], 每个查询为 [l_i, r_i], 表示子数组区间, m >= 1, l_i <= r_i, 索引从0开始"
      },
      "Core Constraint": {
        "operation_rule": "每次操作只能将某个元素增加或减少恰好 k",
        "target_condition": "子数组内所有元素必须变为相等值",
        "feasibility_condition": "当且仅当所有元素模 k 同余时，才可能通过若干次操作使它们相等",
        "invariance_under_op": "每个数在模 k 下的余数在操作中保持不变"
      },
      "Objective Function": {
        "goal": "对每个查询 [l_i, r_i]，求将 nums[l_i..r_i] 所有元素变为相等所需的最小操作次数",
        "output_type": "若可行则输出最小操作次数；否则输出 -1",
        "aggregation": "返回一个长度等于 queries.length 的答案数组 ans"
      },
      "Algorithmic Invariant": {
        "modular_consistency": "子数组能被统一当且仅当所有元素 ≡ r (mod k) 对某个 r 成立",
        "median_optimality": "在模 k 可行的前提下，选择目标值为排序后序列的中位数（或附近）可最小化总操作次数",
        "prefix_preprocessing": "可通过预处理前缀和与模类分组实现快速区间查询",
        "monotonicity_in_ops": "操作次数关于目标值呈凸性，中位数处取最小"
      },
      "Transformable Parameters": {
        "value_range": "nums[i] 和 k 的范围可调整（如负数、更大值域）",
        "array_dimension": "可扩展为二维数组上的子矩阵查询",
        "operation_type": "从‘增减恰好k’变为‘最多增减k’或‘乘除k’等变形",
        "mod_constraint": "从固定k到多个k_i或动态模数",
        "query_mode": [
          "单次查询",
          "多组批量查询",
          "在线查询（需支持修改）"
        ],
        "data_update": "是否允许 nums 支持点更新或区间修改",
        "output_detail": [
          "仅输出最小操作数",
          "输出目标值",
          "输出具体操作方案"
        ],
        "feasibility_relaxation": "允许近似相等（如误差≤ε）而非严格相等",
        "cost_function": "从计数操作次数变为加权代价（如代价 = |delta|/k 或其他函数）"
      }
    }
  },
  {
    "title": "Distinct Points Reachable After Substring Removal",
    "slug": "distinct-points-reachable-after-substring-removal",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，字符集为 {'U', 'D', 'L', 'R'}",
        "正整数 k（1 <= k <= n）",
        "移动规则：U: (x, y) → (x, y+1), D: (x, y) → (x, y-1), L: (x, y) → (x-1, y), R: (x, y) → (x+1, y)",
        "起始位置为 (0, 0)"
      ],
      "Core Constraint": [
        "必须恰好移除一个长度为 k 的连续子串",
        "剩余部分按原顺序执行移动",
        "最终坐标由整体位移向量决定（可叠加性）",
        "不同移除位置可能导致相同剩余路径，需去重"
      ],
      "Objective Function": "计数 —— 返回所有可能移除方案下，可到达的不同最终坐标的数量",
      "Algorithmic Invariant": [
        "总位移具有前缀和性质：整个路径的位移 = 前缀位移 + 后缀位移（跳过长度为k的段）",
        "使用前后缀分解：pre[i] 表示前 i 步的位移，suf[i] 表示从第 i 步到末尾的位移",
        "对于每个合法的删除区间 [i, i+k-1]，最终位移 = pre[i] + suf[i+k]",
        "利用哈希集合维护不同坐标，保证计数唯一性",
        "滑动窗口式枚举所有长度为k的子串删除位置，O(n) 枚举 + O(1) 位移更新"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5（要求线性或近线性解法）",
        "k 的取值范围": "1 <= k <= n，可等于 n（全删）或 1（微调）",
        "是否多组数据": "可扩展为多组输入测试",
        "是否在线": "当前为离线输入；可变形为动态修改 s 或 k 的在线版本",
        "输入形式变化": [
          "移动指令由字符串变为数组或流式输入",
          "增加新方向（如对角线）→ 扩展到8邻域",
          "允许移除多个不相交子串（组合复杂度上升）"
        ],
        "目标函数变化": [
          "求最大曼哈顿距离",
          "判定能否回到原点",
          "最小化不同终点数（对抗性删除）"
        ],
        "约束变化": [
          "移除任意子序列而非连续子串 → 复杂度升高",
          "k 不固定，选择任意长度 → 需枚举 k",
          "保留部分必须连通且非空 → 边界处理"
        ],
        "结构维度扩展": [
          "3D 移动（增加 Z 轴操作）",
          "环形网格或模意义下的坐标",
          "加入障碍物或禁止区域（路径合法性判定）"
        ]
      }
    }
  },
  {
    "title": "Lexicographically Smallest Permutation Greater Than Target",
    "slug": "lexicographically-smallest-permutation-greater-than-target",
    "schema": {
      "Input Structure": [
        "长度为 n 的两个字符串 s 和 target",
        "s 和 target 均由小写英文字母组成",
        "1 <= n <= 300"
      ],
      "Core Constraint": [
        "目标是构造 s 的一个排列，使其字典序严格大于 target",
        "必须使用 s 中所有字符（即为全排列）",
        "若存在多个满足条件的排列，必须选择字典序最小的一个",
        "字典序比较基于首次不同字符的位置"
      ],
      "Objective Function": "构造并返回 s 的字典序最小的排列，要求该排列严格大于 target；若不存在则返回空字符串",
      "Algorithmic Invariant": [
        "贪心构造：从左到右逐位确定结果字符串的字符",
        "在每一位上尝试填入未使用的最小可行字符（即能保证后续仍可构造出 > target 的字符串）",
        "可通过预处理字符频次与后缀最大/最小排列来判断剩余字符能否构成足够大的后缀",
        "状态单调性：一旦某位选择了大于 target 对应位的字符，则后续可贪心取最小排列；否则必须继续受限于 target 的前缀"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题 n ≤ 300，可调整为更小（暴力枚举）或更大（需优化贪心）",
        "字符集类型": "当前为小写字母，可扩展为大写、数字或自定义排序",
        "是否允许重复字符": "当前允许，若禁止则退化为集合排列问题",
        "输入形式": "当前为离线双字符串，可改为在线流式输入字符",
        "目标函数变体": [
          "求字典序最小的 ≥ target 的排列（非严格大于）",
          "求第 k 小的 > target 的排列",
          "计数问题：统计有多少个排列 > target"
        ],
        "是否多组数据": "当前单组，可扩展为多组测试用例",
        "约束反转": "改为求严格小于 target 的最大排列",
        "隐藏条件": "不直接给出 target，而是通过某种规则生成"
      }
    }
  },
  {
    "title": "Remove K-Balanced Substrings",
    "slug": "remove-k-balanced-substrings",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，仅由 '(' 和 ')' 组成",
        "整数 k，表示 k-平衡子串的参数",
        "s.length ∈ [2, 1e5], k ∈ [1, floor(n/2)]"
      ],
      "Core Constraint": [
        "k-平衡子串定义为 '(' 重复 k 次后紧跟 ')' 重复 k 次，即 '('*k + ')'*k",
        "移除操作必须重复进行，每次移除所有不重叠的 k-平衡子串",
        "移除后剩余部分拼接，形成新字符串继续处理",
        "过程持续到无法找到任何 k-平衡子串为止"
      ],
      "Objective Function": "返回经过所有可能移除操作后的最终字符串",
      "Algorithmic Invariant": [
        "使用栈结构模拟匹配过程：每当栈顶连续出现 k 个 ')' 时，检查其前是否恰好有连续 k 个 '('（或等价状态）",
        "可通过计数字符段（run-length encoding）维护当前未匹配的括号序列",
        "每次扫描可识别并删除所有不重叠的 k-平衡子串，且删除操作不影响更外层结构的合法性判断",
        "若采用迭代扫描+替换，每轮删除保持剩余字符相对顺序不变，且不会遗漏后续可生成的 k-平衡子串"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5 → 可扩展至 1e6（要求线性解法）",
        "字符集": "仅 '(' 和 ')' → 可推广至多种括号类型（如 '[', ']'）",
        "k 的性质": "固定常数 k → 可变为变量数组或随位置变化",
        "是否在线": "一次性输入 → 支持动态添加/删除字符的在线版本",
        "移除策略": "不重叠且贪心移除 → 可改为最大覆盖、可重叠限制等变体",
        "输出形式": "返回最终字符串 → 可改为返回移除次数、最长残留段等",
        "多组数据": "单组输入 → 多组测试用例批量处理",
        "k-平衡定义": "严格连续 k 个 '(' 后跟 k 个 ')' → 可放松为嵌套深度 k 或其他结构"
      }
    }
  },
  {
    "title": "Minimum Moves to Balance Circular Array",
    "slug": "minimum-moves-to-balance-circular-array",
    "schema": {
      "Input Structure": [
        "环形一维数组 balance[0..n-1]",
        "n >= 1, n <= 10^5",
        "balance[i] ∈ ℤ, -10^9 <= balance[i] <= 10^9",
        "数组表示每个人的净余额",
        "初始时至多有一个元素为负"
      ],
      "Core Constraint": [
        "每次移动只能将恰好 1 单位余额转移给相邻邻居（左或右）",
        "目标是使所有 balance[i] >= 0",
        "总余额守恒：sum(balance) 不变",
        "若 sum(balance) < 0，则无解（无法全非负）",
        "由于至多一个负值，问题可转化为从该负值点出发的‘债务消除’过程",
        "环形结构意味着索引按模 n 连接"
      ],
      "Objective Function": [
        "最小化移动次数",
        "若无法使所有人非负，返回 -1"
      ],
      "Algorithmic Invariant": [
        "最优策略中，每个单位的‘债务偿还’路径是唯一的：从负值位置向其左右传递亏空",
        "可以将问题转化为前缀和形式：设累计不平衡量 prefix[i] 表示从起点到 i 的净流出需求",
        "最小移动次数等于所有位置到‘累积流’的绝对偏差之和的某种变形",
        "利用环形结构的对称性，枚举断点或使用数学推导消去环形影响",
        "存在贪心不变量：局部最优转移不会增加全局代价",
        "可通过拆环为链 + 枚举起始点 或 数学中位数建模求解"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n_range": [
            1,
            100000
          ],
          "value_range": [
            -1000000000.0,
            1000000000.0
          ]
        },
        "输入形式": {
          "是否环形": true,
          "是否有序": false,
          "负值数量约束": "至多一个初始负值"
        },
        "目标函数变体": [
          "改为最大化可保留人数",
          "改为判定是否存在方案",
          "改为计数可行转移序列数（模意义下）"
        ],
        "操作模式扩展": [
          "允许跨邻居跳跃传输（带权边）",
          "允许多单位同时转移",
          "引入转移成本（如距离加权）"
        ],
        "数据流模式": [
          "离线处理（默认）",
          "在线查询：动态修改 balance 值并询问当前最小移动次数"
        ],
        "约束松弛": [
          "允许多个负值",
          "限制只能单向转移（仅左传或仅右传）",
          "加入容量上限：每个节点最多持有 M 单位"
        ]
      }
    }
  },
  {
    "title": "Filter Characters by Frequency",
    "slug": "filter-characters-by-frequency",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "description": "Given a 1D array H[1..n], where each H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The water trapped at any position depends on the minimum of the maximum heights to its left and right, minus its own height.",
        "properties": [
          "Left and right boundaries are independent but must be globally consistent",
          "Local information (current height) is insufficient without global context (max left/right)"
        ]
      },
      "Objective Function": {
        "goal": "sum",
        "description": "Compute the total amount of rainwater that can be trapped after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two-pointer traversal maintains sufficient state to determine contribution of current end with lower max boundary",
        "rules": [
          "Maintain two pointers L and R starting from both ends",
          "Track maxLeft = max(H[0..L]) and maxRight = max(H[R..n-1])",
          "If maxLeft ≤ maxRight, then the trapped water at L is determined solely by maxLeft - H[L]",
          "Move the pointer on the side with smaller max boundary",
          "The decision at each step preserves optimality and does not affect future feasibility"
        ]
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 3 * 10^4",
          "small: n <= 100",
          "large: n up to 1e5+"
        ],
        "value_domain": [
          "H[i] >= 0",
          "allow_negative_heights: false",
          "extended: H[i] in [-1e4, 1e4]"
        ],
        "array_property": [
          "unordered",
          "sorted",
          "circular_array: false",
          "dynamic_updates: false"
        ],
        "input_mode": [
          "single_batch",
          "online_queries",
          "sliding_window_input"
        ],
        "output_type": [
          "total_sum",
          "per_position_contribution",
          "maximum_single_valley",
          "construction_of_water_profile"
        ],
        "data_variants": [
          "2D version: matrix of heights",
          "3D version: volumetric trapping",
          "with_obstacles_or_permeable_blocks",
          "time-evolving_heights"
        ],
        "query_type": [
          "static",
          "update-supported (e.g., point update)",
          "range-query_supported"
        ]
      }
    }
  },
  {
    "title": "Split Array With Minimum Difference",
    "slug": "split-array-with-minimum-difference",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "integer",
        "constraints": [
          "length n where 2 <= n <= 1e5",
          "each element satisfies 1 <= nums[i] <= 1e5",
          "non-circular",
          "contiguous subarrays only"
        ],
        "description": "一维整数数组 nums，用于分割为两个连续非空子数组"
      },
      "Core Constraint": {
        "left_condition": "子数组 left 必须严格递增（即对所有 i ∈ [1, len(left)-1]，有 left[i] > left[i-1]）",
        "right_condition": "子数组 right 必须严格递减（即对所有 i ∈ [1, len(right)-1]，有 right[i] < right[i-1]）",
        "partition_rule": "恰好在位置 i 分割，left = nums[0..i], right = nums[i+1..n-1]，其中 0 <= i <= n-2",
        "global_dependency": "分割点的选择必须同时满足左右两段的单调性约束，且局部判断可提前剪枝"
      },
      "Objective Function": {
        "goal": "minimize absolute difference between sum(left) and sum(right)",
        "output_type": "integer",
        "failure_value": -1,
        "description": "求所有有效分割方案中，左右子数组元素和的绝对差值的最小值；若无有效方案，返回 -1"
      },
      "Algorithmic Invariant": {
        "precomputation": {
          "prefix_increasing": "从左向右预处理每个位置 i 是否满足 nums[0..i] 严格递增",
          "suffix_decreasing": "从右向左预处理每个位置 i 是否满足 nums[i..n-1] 严格递减"
        },
        "invariance": [
          "若 prefix_increasing[i] 为真，则 left = nums[0..i] 是合法的",
          "若 suffix_decreasing[i+1] 为真，则 right = nums[i+1..n-1] 是合法的",
          "对于每个分割点 i ∈ [0, n-2]，可通过 O(1) 查表判断合法性",
          "总和可通过前缀和快速计算：sum_left = prefix_sum[i+1], sum_right = total_sum - sum_left",
          "一旦确定所有候选分割点，最优解可在 O(n) 内完成枚举"
        ],
        "optimality_preservation": "预处理保证了状态独立性和可复用性，枚举过程不破坏最优性"
      },
      "Transformable Parameters": {
        "n_range": [
          "small: n <= 20 → 可暴力枚举所有分割",
          "medium: n <= 1e5 → 需线性或近线性解法"
        ],
        "value_domain": {
          "nums[i] range": "positive integers (default),可扩展至包含负数或零"
        },
        "order_constraints": {
          "left_monotonicity": "strictly increasing (default), 可改为 non-decreasing",
          "right_monotony": "strictly decreasing (default), 可改为 non-increasing 或 unimodal"
        },
        "input_form": {
          "single_array": true,
          "multi_test_cases": false,
          "online_queries": false
        },
        "output_requirements": {
          "return_type": "minimal absolute difference (default), 可改为返回分割位置或所有可行方案数量",
          "constructive_output": false
        },
        "structural_variants": {
          "circular_array": false,
          "2D_extension": "matrix row-wise / column-wise split with monotonic constraints",
          "k_partitions": "split into k > 2 monotonic segments"
        },
        "operation_support": {
          "dynamic_updates": false,
          "support_modification": false
        }
      }
    }
  },
  {
    "title": "Earliest Time to Finish One Task",
    "slug": "earliest-time-to-finish-one-task",
    "schema": {
      "Input Structure": {
        "type": "2D integer array",
        "description": "tasks[i] = [s_i, t_i], where s_i is the start time and t_i is the duration of the task",
        "constraints": {
          "length": "1 <= tasks.length <= 100",
          "values": "1 <= s_i, t_i <= 100",
          "element_type": "non-negative integers"
        }
      },
      "Core Constraint": {
        "description": "Each task starts at s_i and ends at s_i + t_i. Tasks can overlap in time, but each runs independently without preemption or concurrency constraints.",
        "key_property": "Completion time of a task is determined solely by its start time and duration; no resource contention or scheduling order affects execution."
      },
      "Objective Function": {
        "goal": "minimize",
        "target": "earliest completion time among all tasks",
        "output_type": "integer (single value)"
      },
      "Algorithmic Invariant": {
        "invariant": "The minimum completion time is invariant under permutation of tasks, since each task's end time depends only on its own parameters and not on others.",
        "proof_condition": "For any task i, end_time[i] = s_i + t_i; thus min(end_time) can be computed directly without considering execution order or dependencies.",
        "optimality_preservation": "No greedy choice or ordering improves upon the direct evaluation of all end times."
      },
      "Transformable Parameters": {
        "n_magnitude": "small scale (n ≤ 100), suitable for O(n) or O(n log n)",
        "value_range": "s_i, t_i ∈ [1, 100]",
        "input_form": "offline batch input",
        "multiple_test_cases": false,
        "online_input": false,
        "data_modification": false,
        "ordering_requirement": false,
        "additional_constraints": [
          "Could be extended to: earliest time to complete k tasks",
          "With non-overlapping constraint → becomes interval scheduling",
          "Add processing priority or deadlines → transforms into deadline-aware scheduling",
          "Allow preemption or multitasking → changes core structure"
        ]
      }
    }
  },
  {
    "title": "Smallest Absent Positive Greater Than Average",
    "slug": "smallest-absent-positive-greater-than-average",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 100",
        "value_range": "-100 <= nums[i] <= 100",
        "description": "一维整数数组 nums，长度为 n"
      },
      "Core Constraint": {
        "constraint": "目标值必须同时满足两个条件：(1) 严格大于数组元素的平均值；(2) 是未在数组中出现的最小正整数。",
        "implication": "由于平均值可能非整数，且数组包含负数和重复元素，需分离‘数值大小约束’与‘存在性约束’。问题本质是结合了数值计算与集合缺失正整数判定的复合判断。"
      },
      "Objective Function": {
        "type": "construction",
        "goal": "返回严格大于数组平均值的、未出现在数组中的最小正整数"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "平均值 avg 可预先计算，作为阈值下界（target > avg）",
          "从候选值 floor(avg) + 1 开始向上枚举，第一个不在 nums 中的正整数即为答案",
          "由于值域和数组长度有限，枚举上界可控（最多到约 200）",
          "集合查找使用哈希集可保证 O(1) 查询，整体复杂度不变"
        ],
        "optimality_proof": "因目标函数要求‘最小’且‘未出现’，从小于等于 avg 的下一个整数开始递增搜索，首次命中即最优解，贪心策略成立"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "数据规模",
            "slot": "n",
            "range": "1 <= n <= 100",
            "possible_transform": "扩大至 1e5（需优化输入处理）或缩小至极小规模用于教学"
          },
          {
            "name": "值域范围",
            "slot": "nums[i]",
            "range": "-100 <= nums[i] <= 100",
            "possible_transform": "扩展至更大范围或加入浮点数（若允许）"
          },
          {
            "name": "输入类型",
            "slot": "data_type",
            "type": "integer",
            "possible_transform": "改为浮点数组（改变平均值精度处理方式）"
          },
          {
            "name": "是否多组数据",
            "slot": "multi_case",
            "default": false,
            "possible_transform": "支持多组测试用例批量处理"
          },
          {
            "name": "是否在线",
            "slot": "online_input",
            "default": false,
            "possible_transform": "设计为流式输入，动态维护平均值与缺失正整数"
          },
          {
            "name": "目标函数变体",
            "slot": "objective",
            "possible_transforms": [
              "求小于平均值的最大未出现负整数",
              "求大于等于平均值的最小未出现正整数",
              "计数：有多少个介于 [avg, k] 的未出现正整数"
            ]
          },
          {
            "name": "约束反转",
            "slot": "condition",
            "possible_transform": "将 '严格大于' 改为 '大于等于' 或 '严格小于'"
          }
        ]
      }
    }
  },
  {
    "title": "Maximize Alternating Sum Using Swaps",
    "slug": "maximize-alternating-sum-using-swaps",
    "schema": {
      "Input Structure": {
        "nums": "一维整数数组 A[0..n-1], 其中 n >= 2, A[i] ∈ [1, 10^9]",
        "swaps": "二维整数数组 S, 每个元素为 [p_i, q_i], 表示允许交换的索引对, 0 <= p_i < q_i <= n-1, 无重复对"
      },
      "Core Constraint": {
        "index_connectivity": "通过 swaps 中的交换操作，可以形成若干连通的索引集合（由交换关系构成无向图的连通分量）",
        "free_rearrangement": "在每个连通分量内部，可以通过任意次交换实现元素的任意排列",
        "parity_preservation": "元素的位置奇偶性（下标模2）会影响其在交替和中的符号：偶数下标为正，奇数下标为负"
      },
      "Objective Function": "最大化交替和：Σ (-1)^i * nums[i] = nums[0] - nums[1] + nums[2] - nums[3] + ...",
      "Algorithmic Invariant": {
        "component_independence": "不同连通分量之间无法交互元素，因此可独立优化",
        "greedy_assignment": "在每个连通分量内，最优策略是将较大的数值尽可能分配到偶数下标位置，较小的数值分配到奇数下标位置",
        "bipartite_view": "将所有下标按奇偶分为两个集合（偶数位：正贡献；奇数位：负贡献），问题转化为在连通约束下对值进行二部赋值以最大化总收益"
      },
      "Transformable Parameters": {
        "n_range": "n ∈ [2, 10^5]",
        "value_range": "nums[i] ∈ [1, 10^9]",
        "swap_list_properties": {
          "length": "swaps.length ∈ [0, 10^5]",
          "duplicate_allowed": false,
          "ordered_pairs": true
        },
        "connectivity_structure": [
          "完全不连通（swaps为空）",
          "部分连通（多个小连通块）",
          "全局连通（整个数组可重排）"
        ],
        "input_form": {
          "static_offline": true,
          "online_swaps": false,
          "dynamic_updates": false
        },
        "objective_variants": [
          "最小化交替和",
          "计数最大交替和的方案数",
          "构造最优排列",
          "带权重的交替系数"
        ],
        "structural_extensions": [
          "三维及以上交替模式（如 + - + - + ... 扩展为周期k）",
          "树形结构上的节点赋值与路径交替和"
        ]
      }
    }
  },
  {
    "title": "Bitwise OR of Even Numbers in an Array",
    "slug": "bitwise-or-of-even-numbers-in-an-array",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "每个元素为正整数：nums[i] ∈ [1, 100]",
        "数组长度 n ∈ [1, 100]"
      ],
      "Core Constraint": [
        "偶数的判定基于最低位为0（即 nums[i] & 1 == 0）",
        "按位或运算具有幂等性、结合律和单调性：添加更多偶数不会使结果变小，且顺序无关"
      ],
      "Objective Function": [
        "计算数组中所有偶数元素的按位或（bitwise OR）结果",
        "若无偶数，返回0"
      ],
      "Algorithmic Invariant": [
        "已累积的按位或结果 r 满足：r = r | x 对任意后续偶数 x 成立",
        "中间状态 r 的每一位一旦被置为1，则在整个运算过程中保持为1（单调上升性）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": "1e2",
          "值域范围": "[1, 100]"
        },
        "输入形式": {
          "是否有序": false,
          "是否可重复": true,
          "是否包含负数": false
        },
        "偶数定义变形": false,
        "位运算类型可变": [
          "OR → AND → XOR",
          "支持子集组合类目标（如最大/最小结果）"
        ],
        "输出形式": {
          "是否仅返回最终结果": true,
          "是否要求路径记录": false
        },
        "多组数据": false,
        "在线查询": false,
        "操作扩展": [
          "支持单点修改",
          "支持区间查询（转化为线段树问题）"
        ]
      }
    }
  },
  {
    "title": "Restore Finishing Order",
    "slug": "restore-finishing-order",
    "schema": {
      "Input Structure": {
        "order": "一维整数数组 order[1..n]",
        "friends": "一维整数数组 friends[1..m]",
        "constraints": [
          "order 是 [1, n] 的一个排列（每个整数恰好出现一次）",
          "friends 是严格递增的子序列，且每个元素 ∈ order",
          "1 <= n <= 100",
          "1 <= m <= min(8, n)"
        ]
      },
      "Core Constraint": {
        "description": "friends 中的 ID 在 order 中的位置决定了其完成顺序；需保持 order 中首次出现的相对顺序",
        "key_point": "输出顺序由 order 的遍历顺序决定，而非 friends 的初始顺序"
      },
      "Objective Function": {
        "type": "构造方案",
        "goal": "返回 friends 中所有 ID 按照它们在 order 数组中出现的先后顺序组成的数组"
      },
      "Algorithmic Invariant": {
        "invariant_1": "一旦某个 friend 的 ID 在 order 中被访问到，则应立即加入结果序列",
        "invariant_2": "由于 friends 已排序但不按完成时间排序，不能直接利用其顺序进行跳转",
        "invariant_3": "可以通过预处理建立 ID → order_index 的映射，使查找朋友位置为 O(1)，保证整体顺序可线性重构"
      },
      "Transformable Parameters": {
        "data_scale": {
          "n_range": "1 to 100",
          "friends_length_upper_bound": "min(8, n)"
        },
        "ordering": {
          "order_sortedness": "任意排列（无序，但含全排列信息）",
          "friends_sortedness": "严格递增（值域有序，非时间有序）"
        },
        "input_form": {
          "multi_case_input": false,
          "online_query": false
        },
        "modifications": [
          "friends 是否仍保持有序输入？若打乱如何处理？",
          "是否支持动态添加 friend 或 streaming order？",
          "是否要求返回排名而非 ID 序列？",
          "是否扩展至二维比赛（如多赛道）？",
          "是否存在并列完成时间（重复值）？当前为无重复"
        ]
      }
    }
  },
  {
    "title": "Maximum Total Subarray Value II",
    "slug": "maximum-total-subarray-value-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "integer",
        "size": "n",
        "value_range": "[0, 10^9]",
        "constraints": [
          "nums.length == n",
          "1 <= n <= 5 * 10^4",
          "k is integer, 1 <= k <= min(10^5, n * (n + 1) / 2)"
        ]
      },
      "Core Constraint": {
        "subarray_definition": "nums[l..r] is a contiguous non-empty subsequence",
        "selection_rule": "exactly k distinct subarrays must be selected",
        "uniqueness": "no two selected subarrays can have identical (l, r)",
        "overlap_allowed": true,
        "value_definition": "value of subarray = max(nums[l..r]) - min(nums[l..r])",
        "global_dependency": "total value depends on contribution of each subarray's range"
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "sum of values of exactly k selected distinct subarrays",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "greedy_selection_invariant": "larger subarray ranges tend to yield higher values when they span global extremes",
        "monotonic_contribution_potential": "a subarray containing both global maximum and minimum has maximum possible single value",
        "local_optimality_mergeable": "if top-k highest-value subarrays are disjoint in selection space, selecting them greedily is optimal",
        "dual_extremes_importance": "subarrays covering elements near global max or min contribute more; contributions additive only if non-redundant",
        "priority_queue_feasibility": "can use heap to extract candidates by value, but need deduplication on (l, r)"
      },
      "Transformable Parameters": {
        "n_magnitude": [
          "small (<= 20)",
          "medium (<= 1000)",
          "large (<= 5e4)"
        ],
        "k_magnitude": [
          "k = 1",
          "k small (<= 100)",
          "k large (close to min(10^5, n*(n+1)/2))"
        ],
        "array_properties": {
          "sorted": [
            "unsorted",
            "ascending",
            "descending",
            "nearly_sorted"
          ],
          "distinctness": [
            "all distinct",
            "many duplicates"
          ]
        },
        "input_form": {
          "single_instance": true,
          "multiple_test_cases": false,
          "online_queries": false
        },
        "operation_support": {
          "dynamic_updates": false,
          "point_update": false,
          "range_query": false
        },
        "output_form": {
          "return_total_sum_only": true,
          "require_construct_solution": false,
          "return_selected_intervals": false
        },
        "value_function_variation": {
          "alternative_objectives": [
            "minimize total value",
            "count number of ways to achieve maximum value",
            "constrained selection (e.g., non-overlapping only)"
          ]
        },
        "constraint_modifications": [
          "require non-overlapping subarrays",
          "limit subarray length",
          "fix subarray length",
          "allow reuse of same l-r pair up to m times"
        ],
        "dimension_extension": {
          "2D_array": false,
          "circular_array": false
        }
      }
    }
  },
  {
    "title": "Determine if a Simple Graph Exists",
    "slug": "determine-if-a-simple-graph-exists",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "description": "Given an array H[1..n] where each H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The water trapped at any position depends on the maximum height to its left and right; specifically, the effective boundary is determined by the minimum of the two side maxima.",
        "global_dependency": true,
        "local_insufficiency": true,
        "symmetry": "left-right dual constraint structure"
      },
      "Objective Function": {
        "goal": "sum",
        "type": "aggregation",
        "description": "Compute the total amount of rainwater that can be trapped between the bars after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers (L, R) maintain the current leftmost and rightmost boundaries; maxLeft and maxRight track the highest bar encountered so far from each side. If maxLeft ≤ maxRight, then the water at L is solely constrained by maxLeft (and vice versa for R), allowing safe advancement without missing optimal contributions.",
        "pointer_movement_rule": "Move the pointer corresponding to the smaller max-side inward.",
        "optimality_preservation": true,
        "state_encapsulation": [
          "maxLeft",
          "maxRight",
          "L",
          "R"
        ]
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          100000
        ],
        "value_range": [
          0,
          10000
        ],
        "negative_values_allowed": false,
        "is_sorted": false,
        "is_circular": false,
        "multi_query": false,
        "online_updates": false,
        "output_detail_level": "total sum only",
        "supports_modification": false,
        "dimension_extension": "1D → 2D (e.g., elevation map)",
        "objective_variation": [
          "maximum single container",
          "counting valid trapping positions"
        ],
        "input_streaming": false
      }
    }
  },
  {
    "title": "Maximum Total Subarray Value I",
    "slug": "maximum-total-subarray-value-i",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "n ∈ [1, 5×10⁴]",
        "nums[i] ∈ [0, 10⁹]",
        "整数 k ∈ [1, 10⁵]"
      ],
      "Core Constraint": [
        "每个被选子数组的值由其区间内的最大值与最小值之差决定",
        "可以重复选择相同区间的子数组（允许重叠与重复）",
        "必须恰好选择 k 个非空连续子数组",
        "目标函数具有可加性：总值 = Σ(max - min)"
      ],
      "Objective Function": "最大化所选 k 个子数组的值之和（即总值）",
      "Algorithmic Invariant": [
        "最优解中，每个子数组的贡献独立且可叠加",
        "存在贪心结构：极值（max - min）较大的子数组应被优先或多次选用",
        "全局最大可能单个值为 max(nums) - min(nums)，该值可通过包含整个数组的子数组实现",
        "若某个子数组达到全局极差，则重复选择它是最优策略之一（当 k 允许时）",
        "问题可转化为：是否能通过若干子数组的选择组合，逼近 k × (全局极差)"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1e4",
            "5e4",
            "可扩展至 1e5"
          ],
          "k 的范围": [
            "1 ≤ k ≤ n",
            "k > n",
            "k 可非常大（如在线场景）"
          ]
        },
        "数组性质": [
          "是否有序",
          "是否允许负数",
          "是否所有元素相等（退化情况）",
          "是否单调"
        ],
        "子数组约束": [
          "是否允许空子数组（否，题设非空）",
          "是否禁止重复选择同一区间",
          "是否要求子数组互不重叠"
        ],
        "目标函数变形": [
          "求最小总值",
          "求平均值最大",
          "计数满足总值 ≥ T 的方案数"
        ],
        "输入形式": [
          "单组数据",
          "多组测试用例",
          "在线查询（动态添加元素或修改 k）"
        ],
        "操作扩展": [
          "支持点更新（变为动态数组）",
          "支持区间修改",
          "离线批量处理多个 k 查询"
        ]
      }
    }
  },
  {
    "title": "Longest Fibonacci Subarray",
    "slug": "longest-fibonacci-subarray",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "positive_integer",
        "description": "一维数组 nums[1..n]，其中每个元素为正整数，表示数值序列",
        "constraints": {
          "length_range": [
            3,
            100000
          ],
          "value_range": [
            1,
            1000000000
          ]
        }
      },
      "Core Constraint": {
        "description": "斐波那契子数组要求从第三项开始，每一项等于前两项之和；即对于子数组 A[i..j]（j-i+1 ≥ 3），有 A[k] = A[k-1] + A[k-2] 对所有 k ∈ [i+2, j] 成立",
        "implication": "局部三项满足加法关系是全局扩展的基础，且该性质具有方向性和传递性"
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "length",
        "description": "求最长的连续子数组的长度，使其构成斐波那契数组；长度为1或2的子数组默认满足条件"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "若已知两个起始值 (a, b)，则后续斐波那契序列唯一确定，可线性生成并匹配",
          "对任意位置 i，枚举可能的起始对 (nums[i], nums[j])，通过哈希表快速查找下一个期望值是否存在",
          "使用动态规划状态 dp[i][j] 表示以 nums[i] 和 nums[j] 作为前两项的斐波那契子序列的最大长度，状态转移仅在 nums[k] == nums[i] + nums[j] 时发生",
          "指针移动过程中，已处理的位置对不会影响后续更优解的存在性"
        ],
        "key_mechanism": "基于哈希加速的三元组推进机制与双层循环下的DP状态扩展"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "array_order",
            "values": [
              "ordered",
              "unordered"
            ],
            "default": "ordered",
            "note": "原题为顺序数组，可变形为乱序下求最长斐波那契子序列（非连续）"
          },
          {
            "name": "subarray_vs_subsequence",
            "values": [
              "contiguous_subarray",
              "discrete_subsequence"
            ],
            "default": "contiguous_subarray",
            "note": "本题为子数组（连续），可改编为子序列版本"
          },
          {
            "name": "data_scale",
            "values": {
              "n": "up_to_1e5",
              "value_domain": "up_to_1e9"
            },
            "note": "支持大规模输入，需避免 O(n^3) 暴力"
          },
          {
            "name": "online_query",
            "values": [
              "offline",
              "online"
            ],
            "default": "offline",
            "note": "当前为静态输入，可扩展为支持在线添加元素后查询最长斐波那契子数组"
          },
          {
            "name": "output_form",
            "values": [
              "length_only",
              "reconstruct_sequence",
              "count_all_fib_segments"
            ],
            "default": "length_only",
            "note": "可改为输出所有最大长度段、或计数满足条件的子数组个数"
          },
          {
            "name": "numeric_constraint",
            "values": [
              "positive_integers",
              "non_negative",
              "with_negatives"
            ],
            "default": "positive_integers",
            "note": "负数引入可能导致多解路径，改变搜索结构"
          },
          {
            "name": "dimensionality",
            "values": [
              "1D",
              "2D_grid"
            ],
            "default": "1D",
            "note": "可推广至二维网格中寻找斐波那契路径"
          }
        ]
      }
    }
  },
  {
    "title": "Count Bowl Subarrays",
    "slug": "count-bowl-subarrays",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "length n, where 3 <= n <= 1e5",
          "all elements are distinct",
          "values in range [1, 1e9]",
          "unsorted"
        ],
        "description": "一维整数数组 nums[1..n]，元素互不相同"
      },
      "Core Constraint": {
        "condition": "对于子数组 nums[l...r]，满足 min(nums[l], nums[r]) > max(nums[l+1 ... r-1])",
        "structural_requirement": "子数组长度至少为 3 (r - l + 1 >= 3)",
        "implication": "两端点的较小值必须严格大于中间部分的最大值，形成‘凹陷’结构",
        "dependency": "局部极小值在两端，中间存在相对极大区域"
      },
      "Objective Function": {
        "type": "counting",
        "target": "统计满足条件的‘碗’子数组的数量",
        "output": "非负整数：符合条件的连续子数组个数"
      },
      "Algorithmic Invariant": {
        "monotonicity": "固定一端时，另一端扩展过程中中间段最大值单调不减",
        "expandability": "若某个区间 [l, r] 不构成碗，则任何包含它的更大区间 [l', r']（保持同侧端点）不一定继承性质，但可利用中间最大值剪枝",
        "decomposition": "每个碗由左右边界和中间最大值共同决定；可通过枚举中心/边界结合单调栈维护候选端点",
        "optimality_preservation": "使用单调栈可维护潜在的左/右边界，使得当新元素加入时能快速判断是否形成新碗"
      },
      "Transformable Parameters": {
        "data_scale": {
          "n_range": "[3, 1e5]",
          "value_range": "[1, 1e9]"
        },
        "uniqueness": "elements are distinct (can be relaxed to allow duplicates)",
        "ordering": "array is unsorted (can impose sorted or partially ordered variants)",
        "dimensionality": "1D → could generalize to 2D grid submatrices with boundary vs interior constraints",
        "online_processing": "current: offline batch input; can transform to streaming model with incremental counting",
        "query_type": "single query → multiple queries on dynamic array (with updates)",
        "output_detail": "return count only → return all bowls / longest bowl / shortest bowl",
        "constraint_variation": [
          "change comparison: ≥ instead of >",
          "relax length constraint: allow length=2",
          "reverse condition: min(mid) > max(endpoints)",
          "hidden monotonicity: e.g., only given that array has single peak"
        ]
      }
    }
  },
  {
    "title": "Minimum Operations to Transform String",
    "slug": "minimum-operations-to-transform-string",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n",
        "s 仅由小写英文字母组成",
        "1 <= n <= 5 * 10^5"
      ],
      "Core Constraint": [
        "每个字符 c 可被替换为其在字母表中的下一个字符（循环：'z' -> 'a'）",
        "操作可对所有相同字符同时执行（即一次操作将所有 'c' 变为 'c+1'）",
        "目标是使整个字符串变为全 'a'",
        "字符变换具有循环性与单调推进性（按字母顺序向前走）"
      ],
      "Objective Function": "最小化操作次数，使得字符串 s 转换为全由 'a' 组成的字符串",
      "Algorithmic Invariant": [
        "每个字符到 'a' 的距离可以逆向计算（从后往前考虑哪些字符需要经过多少轮变化才能归零）",
        "若多个字符处于同一变换路径上（如 'y' -> 'z' -> 'a'），它们的操作可合并处理",
        "最优策略中，每一轮操作应尽可能推动多个尚未到位的字符向前一步",
        "贪心不变量：优先处理非-'a'字符中字典序最大的，因为其变化不会干扰更小字符的状态"
      ],
      "Transformable Parameters": {
        "字符串长度规模": "n ∈ [1, 5*10^5]",
        "字符集范围": "是否扩展至大写字母或自定义字符环",
        "操作规则变化": [
          "是否允许单个位置独立操作（而非全局同字符统一操作）",
          "是否支持多字符并行升级（如一次升两个级别）"
        ],
        "目标状态变化": [
          "是否改为转换为其他固定字符（如全 'b'）",
          "是否要求最终为回文串或其他结构"
        ],
        "是否在线输入": false,
        "是否多组数据": true,
        "字母表循环性": "可取消循环（'z' 无法再变）作为变形"
      }
    }
  },
  {
    "title": "Minimum Operations to Equalize Array",
    "slug": "minimum-operations-to-equalize-array",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1]",
        "n >= 1, n <= 100",
        "nums[i] ∈ [1, 10^5]"
      ],
      "Core Constraint": [
        "操作作用于任意连续子数组 nums[l..r]",
        "子数组中所有元素被替换为该子数组的按位与（bitwise AND）结果",
        "AND 运算具有单调不增性：对任意集合 S，S 的子集的 AND 值 ≥ S 的 AND 值",
        "一旦某段区间被操作，其值变为一个固定常量（即该区间的 AND 结果），后续无法通过相同方式还原"
      ],
      "Objective Function": "最小化使整个数组所有元素相等所需的操作次数",
      "Algorithmic Invariant": [
        "最终相等的值一定是原数组某个子数组的按位与结果",
        "最优解中，最后一次操作一定覆盖整个数组或使其全部等于某个公共值",
        "若数组已全等，则操作数为 0；否则至少需要 1 次",
        "可以通过动态规划或 BFS 枚举状态转移：每个状态是当前数组的压缩表示（但由于 n≤100，直接状态搜索不可行）",
        "关键观察：操作不会引入新值，所有可能值均为原数组某子数组的 AND 值，总数有限（最多 O(n²) 个不同 AND 值）",
        "可构建图模型：节点为数组的‘等价类’（如值序列的分段常量形式），边为一次合法操作；目标是最短路径到全等状态"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": [
            "小规模 (n ≤ 100)",
            "中等规模 (n ≤ 1000)",
            "大规模 (n ≤ 1e5)"
          ],
          "值域范围": [
            "[1, 1e5]",
            "扩展至负数",
            "二进制位宽限制"
          ]
        },
        "输入形式": [
          "单组输入",
          "多组测试用例",
          "在线查询：逐步添加元素并询问当前最小操作数"
        ],
        "操作规则变形": [
          "改为按位或（OR）操作",
          "改为按位异或（XOR）操作",
          "允许多种操作混合使用",
          "限制只能操作长度 ≥ k 的子数组"
        ],
        "目标函数变换": [
          "最小操作次数（原题）",
          "判断是否可在 ≤ K 次内完成",
          "计数达成全等的不同方案数",
          "构造最优操作序列"
        ],
        "结构扩展": [
          "从 1D 数组 → 环形数组",
          "从数组 → 树链上的路径操作",
          "二维网格上子矩阵 AND 赋值"
        ],
        "约束变化": [
          "要求最终值等于特定目标值",
          "不允许修改某些位置",
          "每次操作代价为子数组长度，求最小总代价"
        ]
      }
    }
  },
  {
    "title": "Maximize Sum of At Most K Distinct Elements",
    "slug": "maximize-sum-of-at-most-k-distinct-elements",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums[i] 为正整数，值域范围 [1, 10^9]",
        "数组长度 n 满足 1 <= n <= 100",
        "元素可重复"
      ],
      "Core Constraint": [
        "最多选择 k 个元素",
        "所选元素必须互不相同（即每个数值至多选一次）",
        "目标是在满足唯一性约束的前提下最大化元素和"
      ],
      "Objective Function": [
        "构造一个严格递减的数组",
        "使得数组中元素之和最大",
        "输出该数组（非仅返回和值）"
      ],
      "Algorithmic Invariant": [
        "贪心选择不变性：优先选择较大的不同数值可保证局部最优解能扩展为全局最优解",
        "排序后处理不变性：将所有不同数值按降序排列后贪心选取前 min(k, distinct_count) 个，不会破坏最优性",
        "唯一性维护不变性：对每个数值只取一次，确保满足互不相同约束"
      ],
      "Transformable Parameters": {
        "k 的取值范围": "1 <= k <= nums.length，可调整为固定/动态限制",
        "是否允许重复选取同一数值": "可改为允许重复 / 限制最多选 m 次",
        "输入形式": [
          "单组数据",
          "可扩展为多组测试用例"
        ],
        "值域范围": "当前为 [1, 10^9]，可缩小或扩大以影响算法设计（如支持负数）",
        "输出要求": [
          "当前要求输出严格递减排列的数组",
          "可变体：仅返回最大和 / 返回所有方案 / 要求字典序最小"
        ],
        "在线处理": "当前为离线输入，可改造为流式数据下的在线选择问题",
        "唯一性约束强度": "可推广为‘最多选 t 个相同元素’（t ≥ 1），t=1 即本题"
      }
    }
  },
  {
    "title": "Find Books with Polarized Opinions",
    "slug": "find-books-with-polarized-opinions",
    "schema": {
      "Input Structure": [
        "表 books: 包含字段 (book_id: int, title: varchar, author: varchar, genre: varchar, pages: int), book_id 为主键",
        "表 reading_sessions: 包含字段 (session_id: int, book_id: int, reader_name: varchar, pages_read: int, session_rating: int), session_id 为主键",
        "两表通过 book_id 进行关联",
        "session_rating ∈ [1,5] 的整数",
        "每本书对应多条阅读记录"
      ],
      "Core Constraint": [
        "一本书必须至少有 5 次阅读事件才被考虑",
        "极化定义为：同时存在 ≥4 的高评分和 ≤2 的低评分",
        "极化得分 = 极端评分次数 / 总阅读次数，其中极端评分为 ≤2 或 ≥4",
        "只有当极化得分 ≥ 0.6 时，该书才被纳入结果集",
        "rating_spread = 最高评分 - 最低评分"
      ],
      "Objective Function": [
        "筛选满足条件的书籍：阅读次数 ≥5，存在高低极端评分，极化得分 ≥0.6",
        "对每本入选书籍计算两个指标：rating_spread 和 polarization_score",
        "返回完整书籍信息及上述两个指标",
        "结果按 polarization_score 降序排序，若相同则按 title 降序排序"
      ],
      "Algorithmic Invariant": [
        "对每本书的评分集合进行聚合统计时，可独立处理各 book_id 的数据（分组不变性）",
        "极化得分的计算具有可加性：极端评分计数可在遍历中累加而不影响最终比例",
        "最大/最小评分的维护满足单调性：max_rating 随新评分非减，min_rating 非增",
        "一旦确定某书不满足最低阅读次数或缺失某一类极端评分，可提前剪枝"
      ],
      "Transformable Parameters": {
        "minimum_sessions": {
          "type": "int",
          "default": 5,
          "description": "纳入考虑所需的最小阅读次数，可调整为其他阈值"
        },
        "high_rating_threshold": {
          "type": "int",
          "default": 4,
          "description": "定义‘高评分’的最小值，可改为 ≥3 或 ≥5"
        },
        "low_rating_threshold": {
          "type": "int",
          "default": 2,
          "description": "定义‘低评分’的最大值，可改为 ≤1 或 ≤3"
        },
        "polarization_score_threshold": {
          "type": "float",
          "default": 0.6,
          "description": "极化得分的过滤阈值，可调整为 0.5 或 0.7"
        },
        "rating_scale": {
          "type": "range",
          "default": "[1,5]",
          "description": "评分系统是否可变（如 [0,10] 或连续值）"
        },
        "sort_order": {
          "type": "list",
          "default": [
            "polarization_score DESC",
            "title DESC"
          ],
          "description": "输出排序规则可调换主次或改变升降序"
        },
        "output_fields": {
          "type": "set",
          "default": [
            "book_id",
            "title",
            "author",
            "genre",
            "pages",
            "rating_spread",
            "polarization_score"
          ],
          "description": "可选择性增加或减少输出列"
        },
        "data_mode": {
          "type": "enum",
          "default": "offline",
          "options": [
            "offline",
            "online_streaming"
          ],
          "description": "是否从流式会话中实时计算极化得分"
        },
        "grouping_key": {
          "type": "field",
          "default": "book_id",
          "description": "可改为按作者、类型或读者群体分组分析极化现象"
        }
      }
    }
  },
  {
    "title": "GCD of Odd and Even Sums",
    "slug": "gcd-of-odd-and-even-sums",
    "schema": {
      "Input Structure": "一个正整数 n（1 <= n <= 1000）",
      "Core Constraint": "前 n 个奇数构成等差数列，首项为 1，公差为 2；前 n 个偶数构成等差数列，首项为 2，公差为 2。两个和均可由闭式公式直接计算：sumOdd = n²，sumEven = n(n + 1)",
      "Objective Function": "计算 sumOdd 与 sumEven 的最大公约数（GCD）",
      "Algorithmic Invariant": "sumOdd 恒为完全平方数（n²），sumEven 恒为 n 与 (n+1) 的乘积，二者互质部分仅取决于 n 与 n+1 的性质；gcd(n², n(n+1)) = n * gcd(n, n+1) = n * gcd(n, 1) = n（当 n 为奇数时）或进一步约简（需考虑公共因子）——实际可推导出 gcd(sumOdd, sumEven) = gcd(n², n(n+1)) = n * gcd(n, n+1) = n（因 gcd(n, n+1)=1），但结合数值规律可得最终结果为 n 当 n 为奇数，否则为 n/2？需验证：\n- 实际观察示例：n=4 → gcd(16,20)=4；n=5 → gcd(25,30)=5\n- 推导：gcd(n², n(n+1)) = n * gcd(n, n+1) = n * 1 = n 不成立？因为 gcd(16,20)=4≠4×gcd(4,5)=4×1=4 ✅；gcd(25,30)=5=5×1 ✅\n→ 实际恒有：gcd(sumOdd, sumEven) = n\n但验证：n=1: gcd(1,2)=1 ✅；n=2: sumOdd=1+3=4, sumEven=2+4=6, gcd(4,6)=2 ✅；n=3: sumOdd=9, sumEven=12, gcd(9,12)=3 ✅ → 观察得结果恒等于 n\n因此存在数学不变量：gcd(n², n(n+1)) = n",
      "Transformable Parameters": [
        "n 的数量级（当前 1<=n<=1000，可扩展至大数场景，要求模意义下输出）",
        "是否改为最小公倍数 LCM(sumOdd, sumEven)",
        "是否将奇偶数序列替换为其他等差数列（如前 n 个 3k+1 数之和等）",
        "是否多组输入（T 组 n 值）",
        "是否在线查询（动态增加 n 并实时返回 GCD）",
        "是否隐藏公式（不提示使用等差数列求和，考察暴力模拟与优化路径）"
      ]
    }
  },
  {
    "title": "Find The Least Frequent Digit",
    "slug": "find-the-least-frequent-digit",
    "schema": {
      "Input Structure": [
        "整数 n（1 <= n <= 2^31 - 1）",
        "n 的十进制表示中各位数字构成一个可重复的有限序列",
        "输入为单个正整数，无前导零（除 n=0 外）"
      ],
      "Core Constraint": [
        "数字频率由其在十进制表示中的出现次数决定",
        "所有候选数字仅限于 0-9 十个阿拉伯数字",
        "频率最小化优先，其次在平局时取数值最小的数字"
      ],
      "Objective Function": [
        "找出出现频率最低的数字",
        "若多个数字具有相同最低频率，则返回其中数值最小者",
        "输出为单一整数（0-9 范围内）"
      ],
      "Algorithmic Invariant": [
        "频率统计过程与遍历顺序无关（可交换性）",
        "最终结果仅依赖于频次直方图和数字值的双重比较规则",
        "一旦完成频次计数，最优解可通过一次确定性扫描得到"
      ],
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 2^31 - 1]，最多 10 位数字",
        "值域": "数字集合固定为 {0,1,...,9}，但可扩展至其他进制（如二进制、十六进制）",
        "是否有序": "输入数字序列隐式有序（从高位到低位），但算法不依赖此序",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "可变目标函数": [
          "改为求频率最高的数字",
          "返回所有最低频率数字的列表",
          "要求按出现位置首次出现顺序返回"
        ],
        "约束变形": [
          "排除 0 作为候选（如不允许前导零参与选择）",
          "限定只考虑奇数/偶数数字",
          "加入权重：加权频率最小化"
        ]
      }
    }
  },
  {
    "title": "Longest Semi-Repeating Subarray",
    "slug": "longest-semi-repeating-subarray",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的非负整数数组 H[1..n]，表示每个位置上的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能存储的水量由其左侧最大值和右侧最大值中的较小者决定，且仅当该值大于 H[i] 时才能蓄水",
        "independence": "左右侧最大值可独立维护，但需满足全局一致性以确定局部容量"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组所有位置上能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示 H[0..L] 的最大值，maxRight 表示 H[R..n-1] 的最大值",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水高度由 maxLeft 决定，可直接计算并右移 L",
          "反之，若 maxRight < maxLeft，则位置 R 处的积水高度由 maxRight 决定，可左移 R",
          "指针移动过程中已计算区域的解保持不变，且不会破坏后续最优性"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "description": "H[i] 是否允许为负数（影响蓄水模型）"
          },
          {
            "name": "dimension",
            "options": [
              "1D",
              "2D",
              "circular"
            ],
            "description": "输入从一维扩展到二维或环形结构"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online"
            ],
            "description": "是否支持在线数据流式输入或动态更新"
          },
          {
            "name": "output_form",
            "options": [
              "total_sum",
              "per_position",
              "construction"
            ],
            "description": "输出是总和、每个位置的贡献，还是具体构造方案"
          },
          {
            "name": "data_update",
            "options": [
              "static",
              "dynamic_with_updates"
            ],
            "description": "是否支持单点修改、插入或删除操作"
          },
          {
            "name": "multiple_queries",
            "options": [
              "single",
              "multiple"
            ],
            "description": "是否处理多组测试用例或区间查询"
          }
        ]
      }
    }
  },
  {
    "title": "Generate Schedule",
    "slug": "generate-schedule",
    "schema": {
      "Input Structure": "整数 n，表示 n 支队伍（编号 0 到 n-1）；需构造一个连续天数的二维数组 schedule，其中每场赛事为 [home, away]，满足 home ≠ away",
      "Core Constraint": "1. 每对队伍 (i, j)（i ≠ j）必须恰好比赛两次：一次 i 主场 vs j，一次 j 主场 vs i；\n2. 每天仅进行一场比赛；\n3. 任意队伍不能在连续两天参赛（无论主场或客场）",
      "Objective Function": "构造一个合法的完整赛程表（2D 整数数组），使得所有队伍完成双循环对决且无连续参赛；若不存在则返回空数组",
      "Algorithmic Invariant": "1. 赛程安排过程中，每个队伍的上一次出场时间被跟踪，确保下一次出场至少间隔一天；\n2. 所有比赛对 (i,j) 和 (j,i) 均被显式枚举并待调度；\n3. 使用贪心构造策略：按天推进，每天选择一对可比赛且不违反连续约束的队伍；\n4. 状态单调性：已安排的比赛不会回退，未安排的比赛集合逐步缩小",
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 50（当前范围）；可扩展至更大规模以测试构造效率",
        "是否有序": "输入 n 无需排序，但输出 schedule 是时间序列，顺序敏感",
        "是否循环": "否；但可变体可要求‘循环赛制+轮空’或‘每周一轮’等周期结构",
        "是否多组输入": "当前单组；可改为多组 n 的在线查询",
        "是否在线": "否；离线一次性生成；可改造为动态增删比赛的在线版本",
        "目标函数变化": "从构造任意解 → 最小化总天数（固定约束下最优压缩）→ 引入休息均衡性计数目标",
        "约束反转": "将‘不能连续参赛’改为‘必须至少连续两天参赛’或‘最多连续一场后必须轮休 k 天’",
        "数据流化": "从静态全部比赛生成 → 逐步输出每一天的比赛（流式生成）",
        "隐藏条件": "显式给出 n；可隐式通过比赛对列表反推 n 并验证完整性"
      }
    }
  },
  {
    "title": "Maximum XOR of Subsequences",
    "slug": "maximum-xor-of-subsequences",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "size": "n",
        "range": "[0, 1e9]",
        "constraints": [
          "2 <= n <= 1e5",
          "elements are non-negative integers",
          "order of elements must be preserved in subsequences"
        ]
      },
      "Core Constraint": {
        "subsequence_property": "subsequences preserve original order, can be empty, and may overlap",
        "xor_property": "XOR is associative, commutative, and self-inverse (a XOR a = 0)",
        "decomposition_insight": "X XOR Y = (A) XOR (B), where A and B are XORs of two subsequences; equivalently, X XOR Y = (A XOR B) if we consider symmetric difference in contribution under linearity of XOR in GF(2)"
      },
      "Objective Function": {
        "goal": "maximize",
        "target_expression": "X XOR Y",
        "components": [
          "X = XOR of first subsequence",
          "Y = XOR of second subsequence"
        ],
        "note": "This is not minimizing or counting — it's a maximization over all pairs of subsequences."
      },
      "Algorithmic Invariant": {
        "key_insight": "Let T = X XOR Y. Since any element can appear in zero, one, or both subsequences, its effective contribution to T is: 0 if in neither or in both (cancels due to XOR), or nums[i] if in exactly one. Thus, T is the XOR of a subset of nums (those appearing in exactly one of the two subsequences). Hence, maximizing X XOR Y is equivalent to finding the maximum XOR over all subsets of nums.",
        "reduction_to_known_problem": "Maximum XOR of any subset of nums → equivalent to finding maximum XOR value achievable from linear combinations (over GF(2)) of the numbers → solvable via Gaussian elimination on binary representation or using a trie-based greedy method.",
        "invariant": "The set of achievable XOR values forms a linear space; the maximum value in this space can be found using bit-wise greedy strategy with a binary trie or row-echelon basis."
      },
      "Transformable Parameters": {
        "n_magnitude": [
          "[2, 1e3]",
          "[2, 1e5]"
        ],
        "value_domain": [
          "non-negative integers",
          "allow negative",
          "bounded bit-width (e.g., 30-bit)"
        ],
        "input_form": [
          "single array",
          "multiple test cases",
          "online queries (dynamic addition of elements)"
        ],
        "subsequence_constraints": [
          "overlap allowed (default)",
          "disjoint subsequences required",
          "non-empty subsequences only"
        ],
        "objective_variants": [
          "maximize X XOR Y",
          "minimize |X - Y|",
          "count number of distinct X XOR Y values",
          "determine if a target value is achievable"
        ],
        "data_updates": [
          "static input",
          "support for insertions/deletions",
          "streaming input"
        ],
        "output_requirements": [
          "return maximum value",
          "return pair of subsequences achieving max",
          "return modulo a prime (for counting variants)"
        ]
      }
    }
  },
  {
    "title": "Sum of Beautiful Subsequences",
    "slug": "sum-of-beautiful-subsequences",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length": "n",
        "constraints": [
          "n == nums.length, 1 <= n <= 10^4",
          "nums[i] is positive integer, 1 <= nums[i] <= 7 * 10^4",
          "array is unordered and may contain duplicates"
        ],
        "derived_objects": [
          "set of all non-empty strictly increasing subsequences",
          "GCD value for each subsequence"
        ]
      },
      "Core Constraint": {
        "constraint_logic": "The GCD of a subsequence determines its contribution group; multiple different subsequences can have the same GCD.",
        "key_observation": "For a fixed g, only subsequences with gcd exactly equal to g contribute to g's beauty value.",
        "dependency_structure": "Subsequence must be strictly increasing in index and value order; GCD computation depends on all elements in the subsequence.",
        "combinatorial_bottleneck": "Direct enumeration of all subsequences is infeasible (2^n), requiring number-theoretic aggregation via multiples."
      },
      "Objective Function": {
        "goal": "sum over all positive integers g of (g * count_of_subsequences_with_gcd_exactly_g)",
        "objective_type": "aggregation",
        "output_form": "single integer: sum modulo 1e9+7",
        "scope": "global over all possible g (g >= 1)"
      },
      "Algorithmic Invariant": {
        "invariant_principle": "Mobius inversion or divisor-based DP: count sequences with gcd divisible by d, then use inclusion-exclusion to get exact-gcd counts.",
        "monotonicity": "If a subsequence has gcd = k, then it also has gcd divisible by every divisor of k.",
        "state_preservation": "For each d from max_value down to 1, maintain dp[d] = number of strictly increasing subsequences such that gcd is divisible by d.",
        "update_rule": "For each num in nums, update dp[gcd(d, num)] += dp[d] for all existing d | num, plus singleton [num].",
        "optimality_condition": "Ordering traversal by value ensures no duplicate counting; using multiples allows reversal via Möbius function."
      },
      "Transformable Parameters": {
        "n_magnitude": "1 <= n <= 10^4",
        "value_range": "1 <= nums[i] <= 7 * 10^4",
        "ordering_requirement": "strictly increasing (by index and value)",
        "gcd_definition": "standard mathematical GCD over integers",
        "modular_arithmetic": "required: result mod 1e9+7",
        "input_variations": [
          "allow non-strictly increasing?",
          "change target function: maximize beauty instead of sum?",
          "restrict g to prime numbers only?",
          "online version: process nums one by one with queries on current total?",
          "multi-dimensional nums? (e.g., pairs (a_i, b_i))",
          "support updates (add/remove element)?"
        ],
        "data_form": "single batch input, offline processing assumed",
        "output_detail": "scalar sum, not per-g breakdown unless requested"
      }
    }
  },
  {
    "title": "Maximum Weight in Two Bags",
    "slug": "maximum-weight-in-two-bags",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 height，height[i] 表示第 i 根柱子的高度。"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左右两侧最高柱子的较小值决定。",
        "independence": "左侧最大值和右侧最大值可以独立维护。",
        "global_dependency": "局部积水依赖于全局极值信息，无法仅通过邻域确定。"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算在下雨后整个数组所能接住的雨水总量。"
      },
      "Algorithmic Invariant": {
        "technique": "two_pointers",
        "invariants": [
          "维护左指针 L 和右指针 R，以及从左侧到 L 的最大值 maxLeft，从右侧到 R 的最大值 maxRight。",
          "若 maxLeft ≤ maxRight，则 L 处的积水可由 maxLeft - height[L] 确定，因为右侧存在足够高的阻挡（maxRight ≥ maxLeft）。",
          "同理，若 maxRight < maxLeft，则 R 处的积水可由 maxRight - height[R] 确定。",
          "每次移动较小一侧的指针，保证已计算区域的贡献正确且不遗漏。"
        ],
        "optimality_preservation": "指针移动过程中，已确定区域的积水计算不会被后续操作推翻。"
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          "0",
          "10^5"
        ],
        "is_sorted": false,
        "is_circular": false,
        "multiple_test_cases": false,
        "online_queries": false,
        "modifications_allowed": false,
        "output_detail": "only total amount",
        "variations": [
          "允许负高度值（需重新定义物理意义）",
          "扩展至二维网格（2D 接雨水问题）",
          "动态更新：支持单点修改后的快速再计算",
          "输出每个位置的具体积水量",
          "在线输入流模式下的滑动窗口接雨水"
        ]
      }
    }
  },
  {
    "title": "Maximum Path Score in a Grid",
    "slug": "maximum-path-score-in-a-grid",
    "schema": "{\n  \"Input Structure\": [\n    \"二维网格 grid[0..m-1][0..n-1], 其中 m, n ∈ [1, 200]\",\n    \"每个单元格值 ∈ {0, 1, 2}\",\n    \"整数 k 表示最大允许花费，k ∈ [0, 1000]\",\n    \"起点为 (0, 0)，终点为 (m-1, n-1)\",\n    \"只能向右或向下移动\"\n  ],\n  \"Core Constraint\": [\n    \"路径的总花费是经过的单元格的花费之和：值为 0 的单元格花费 0；值为 1 或 2 的单元格花费 1\",\n    \"路径必须从左上角到右下角，仅支持右/下移动，形成单调路径\",\n    \"目标是在满足总花费 ≤ k 的前提下最大化分数（单元格值之和）\",\n    \"状态空间由位置 (i, j) 和当前累计花费 c 共同决定，c ≤ k\"\n  ],\n  \"Objective Function\": [\n    \"最大化路径上的总分数（即 grid[i][j] 值之和）\",\n    \"约束条件下判定是否存在有效路径，若无则返回 -1\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"动态规划状态 dp[i][j][c] 表示到达 (i, j) 且累计花费恰好为 c 时的最大分数\",\n    \"状态转移仅来自上方 (i-1, j) 或左方 (i, j-1)\",\n    \"对于每个 (i, j)，所有可能的花费 c ∈ [0, k] 构成独立子问题\",\n    \"花费维度具有单调非减性：后续状态不会减少已用花费\",\n    \"最优子结构：局部最优路径扩展后仍可能构成全局最优\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"m, n 的范围\": \"[1, 200]\",\n      \"k 的范围\": \"[0, 1000]\",\n      \"是否可扩展至更大规模（如 1e5）以要求更优复杂度\"\n    },\n    \"值域变化\": [\n      \"grid[i][j] 是否可取负值或更大整数\",\n      \"花费规则是否可变（如值为 v 的单元格花费 f(v)）\"\n    ],\n    \"移动方向\": [\n      \"是否允许四个方向 → 引入环与状态重复访问问题\",\n      \"是否允许对角线移动\"\n    ],\n    \"输入形式\": [\n      \"是否多组测试数据\",\n      \"是否在线构造网格（流式输入）\"\n    ],\n    \"约束条件\": [\n      \"花费限制由 ≤k 变为 ≥k（最小花费达标问题）\",\n      \"增加最多经过 x 个类型2单元格等复合约束\"\n    ],\n    \"目标函数变形\": [\n      \"求最小花费下最大分数 → 多目标优化\",\n      \"计数类问题：有多少条路径满足花费≤k且得分≥s\",\n      \"判定问题：是否存在路径使得得分≥s且花费≤k\"\n    ],\n    \"状态维度扩展\": [\n      \"加入时间戳或步数限制\",\n      \"三维网格或分层图结构\"\n    ],\n    \"特殊条件隐藏\": [\n      \"花费信息不显式给出，需根据某种规律推断（隐式花费）\"\n    ]\n  }\n}"
  },
  {
    "title": "Minimum Operations to Equalize Binary String",
    "slug": "minimum-operations-to-equalize-binary-string",
    "schema": {
      "Input Structure": [
        "二进制字符串 s，长度为 n（1 <= n <= 10^5）",
        "每个字符 s[i] ∈ {'0', '1'}",
        "整数 k（1 <= k <= n）",
        "输入为一次性离线数据"
      ],
      "Core Constraint": [
        "每次操作必须恰好翻转 k 个不同下标上的位",
        "翻转是异或操作：'0'→'1'，'1'→'0'",
        "目标状态是全 '1' 字符串",
        "一个位置可能被多次翻转，但每次操作必须选恰好 k 个下标",
        "问题的可行性取决于初始 '0' 的数量与 k 的奇偶性及可覆盖性关系"
      ],
      "Objective Function": [
        "求使字符串变为全 '1' 所需的最少操作次数",
        "若不可能实现，返回 -1",
        "目标函数类型：最小化 + 判定存在性"
      ],
      "Algorithmic Invariant": [
        "贪心推进不变量：从左到右处理，一旦遇到 '0' 必须在其所在的操作窗口中翻转",
        "局部决策唯一性：若当前位置为 '0'，则必须以该位置为起点发起一次翻转（否则无法再修正）",
        "差分标记不变量：使用差分数组或事件标记来维护当前累计翻转次数的奇偶性",
        "单调性：翻转操作不可逆，且越早处理左侧 '0' 越优",
        "状态压缩可行性：实际只需维护当前翻转影响的奇偶态，而非完整历史"
      ],
      "Transformable Parameters": {
        "n 的数量级": [
          "1e5（当前）",
          "可扩展至支持在线流式输入"
        ],
        "k 的性质": [
          "固定整数",
          "可变为变量数组（每步 k 不同）",
          "可允许 k > n 或 k = 0 的边界情况"
        ],
        "翻转规则": [
          "必须恰好 k 个下标（当前）",
          "可改为 ≤k 或 ≥k 个下标",
          "可允许重复下标（非法，但可用于构造陷阱题）"
        ],
        "目标状态": [
          "全 '1'（当前）",
          "可改为全 '0'",
          "可改为交替模式或其他模式"
        ],
        "是否多组数据": [
          "单组（当前）",
          "可扩展为 T 组测试用例"
        ],
        "是否在线": [
          "否（当前为离线）",
          "可设计为动态字符串支持修改查询"
        ],
        "字符串结构": [
          "线性一维（当前）",
          "可扩展为环形字符串",
          "可推广至二维二进制矩阵，每次翻转 k×k 子块"
        ],
        "操作限制": [
          "无重叠限制（当前）",
          "可加入‘任意两个操作集合不能完全相同’等约束"
        ]
      }
    }
  },
  {
    "title": "Maximum Walls Destroyed by Robots",
    "slug": "maximum-walls-destroyed-by-robots",
    "schema": {
      "Input Structure": {
        "robots": "一维整数数组 robots[1..n]，表示每个机器人的位置，互不相同",
        "distance": "一维整数数组 distance[1..n]，distance[i] 表示第 i 个机器人子弹的最大射程",
        "walls": "一维整数数组 walls[1..m]，表示每堵墙的位置，互不相同",
        "constraints": {
          "n": "1 <= n <= 1e5",
          "m": "1 <= m <= 1e5",
          "position_range": "1 <= robots[i], walls[j] <= 1e9",
          "distance_range": "1 <= distance[i] <= 1e5"
        }
      },
      "Core Constraint": {
        "bullet_path": "子弹沿直线向左或向右发射，最远可飞行 distance[i] 米",
        "obstacle_blocking": "机器人是固定障碍物；若子弹在击中墙前遇到其他机器人，则立即停止",
        "wall_destruction": "子弹可摧毁路径上所有位于其行进范围内的墙",
        "same_position": "若机器人与墙在同一位置，该墙可被该机器人摧毁（视为射程内）",
        "one_shot_per_robot": "每个机器人只能发射一颗子弹，方向可选（左或右）"
      },
      "Objective Function": "最大化可被摧毁的墙壁总数（计数型优化问题）",
      "Algorithmic Invariant": {
        "greedy_choice_independence": "每个机器人的射击方向选择独立影响其能摧毁的墙集合，但受其他机器人位置阻挡约束",
        "spatial_monotonicity": "对于某一方向的射击，能摧毁的墙具有位置单调性：越靠近机器人的墙更可能被覆盖",
        "blocking_condition": "若某机器人 A 在机器人 B 向某方向的路径上，且 |pos[A] - pos[B]| <= distance[B]，则 A 可能阻挡 B 的子弹",
        "directional_coverage_precomputation": "对每个机器人预处理左右两个方向在无阻挡下可覆盖的墙集合，再根据实际阻挡关系剪枝"
      },
      "Transformable Parameters": {
        "n_value": "robots 数组长度，可在 [1, 1e5] 范围内调整",
        "m_value": "walls 数组长度，可在 [1, 1e5] 范围内调整",
        "coordinate_scale": "位置值域可扩展至更大范围（如 1e12），测试离散化需求",
        "distance_distribution": "distance[i] 分布可设为均匀、集中或极端（如全为 1 或极大）",
        "ordering": "robots 和 walls 是否预先排序",
        "duplicate_positions": "是否允许机器人与墙同位置（当前允许）、多个墙/机器人同位置（当前不允许）",
        "multi_shot": "每个机器人是否允许多颗子弹（当前为单颗）",
        "shooting_constraint": "是否强制所有子弹必须同向（新增约束）",
        "online_query": "墙壁是否动态增删，在线查询最大摧毁数",
        "output_type": "仅输出最大数量 / 输出每个机器人的射击方向方案",
        "environment_structure": "从一维直线 → 环形轨道（变形输入结构）"
      }
    }
  },
  {
    "title": "Jump Game IX",
    "slug": "jump-game-ix",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "constraints": [
          "1 <= n <= 1e5",
          "1 <= nums[i] <= 1e9",
          "array values are positive integers"
        ],
        "indexing": "0-based",
        "order": "unordered",
        "variable_name": "grexolanta"
      },
      "Core Constraint": {
        "jump_rules": [
          "From index i, can jump to j > i only if nums[j] < nums[i]",
          "From index i, can jump to j < i only if nums[j] > nums[i]"
        ],
        "connectivity": "Directed reachability based on value and position: movement direction depends on relative value; forward jumps require decreasing values, backward jumps require increasing values",
        "component_structure": "Reachable components are formed through alternating upward and downward transitions; global maximum is a sink state"
      },
      "Objective Function": {
        "goal": "For each starting index i, compute the maximum value reachable via any sequence of valid jumps",
        "output_type": "array",
        "output_form": "ans[i] = maximum value reachable from index i",
        "computation_type": "per-index maximization over reachable set"
      },
      "Algorithmic Invariant": {
        "invariant_description": "The global maximum in the array is always reachable from any index that can connect to it through a chain of valid jumps. Once a higher value is reached (via backward jump), lower values can be traversed forward freely.",
        "monotonicity": "Value progression along paths has alternating monotonic segments: descending when moving right, ascending when moving left.",
        "state_propagation": "If an index i can reach a value v, and another index j can reach i, then j can also reach at least v. Thus, answers propagate from high-value indices to their predecessors.",
        "optimal_substructure": "Dynamic programming or reverse traversal from maxima allows propagation of best reachable values under jump constraints."
      },
      "Transformable Parameters": {
        "data_size": [
          "n ~ 1e5",
          "feasible for O(n log n) or O(n) solutions"
        ],
        "value_range": "nums[i] in [1, 1e9]",
        "ordering": [
          "original array is unsorted",
          "can be modified to sorted or partially ordered variants"
        ],
        "direction_constraints": [
          "asymmetric jump rules based on direction and comparison",
          "modifiable to symmetric rules or single-direction only"
        ],
        "objective_variants": [
          "max reachable value (current)",
          "min reachable value",
          "count of distinct reachable values",
          "longest path length"
        ],
        "input_dynamics": [
          "static offline input (current)",
          "potential extension to online updates (insert/delete)"
        ],
        "graph_representation": [
          "implicit DAG construction possible",
          "can transform into functional graph or dependency graph"
        ],
        "multi_query": "Can be extended to support multiple queries on subarrays or with modifications"
      }
    }
  },
  {
    "title": "Best Time to Buy and Sell Stock using Strategy",
    "slug": "best-time-to-buy-and-sell-stock-using-strategy",
    "schema": {
      "Input Structure": [
        "一维数组 prices[1..n]，表示第 i 天的股票价格，prices[i] ≥ 1",
        "一维数组 strategy[1..n]，表示原始交易策略，strategy[i] ∈ {-1, 0, 1}",
        "偶数整数 k，满足 2 ≤ k ≤ n"
      ],
      "Core Constraint": [
        "只能进行最多一次修改操作",
        "修改操作必须作用于 strategy 中恰好 k 个连续元素",
        "修改后前 k/2 个元素变为 0（持有），后 k/2 个元素变为 1（卖出）",
        "利润由逐日贡献累加：sum(strategy[i] * prices[i])，且无持仓限制，所有操作均可行"
      ],
      "Objective Function": "最大化总利润（即 strategy[i] * prices[i] 的总和）",
      "Algorithmic Invariant": [
        "原策略的利润是固定的基线，修改仅影响一个长度为 k 的连续子数组",
        "对每个可能的修改位置，其带来的利润变化 = 新策略片段的收益 - 原策略对应片段的收益",
        "由于修改规则固定（前半为0，后半为1），每个位置的增益可预计算，从而支持滑动窗口枚举",
        "最优解必然出现在某一个长度为 k 的连续子数组被修改时，因此只需枚举所有起始位置"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 1e5，适合 O(n) 或 O(n log n) 解法",
        "值域范围": "prices[i] 在 [1, 1e5]，strategy[i] ∈ {-1,0,1}，k 为偶数且 ≥2",
        "是否有序": "prices 和 strategy 均无序，依赖索引顺序",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "修改次数限制": "最多一次修改（可选择不修改）",
        "修改结构约束": "必须是连续 k 元素，且前 k/2 设为 0，后 k/2 设为 1",
        "目标函数变体": "可改为最小化亏损、判定是否可达某利润、或计数最优方案数",
        "数据流化扩展": "可设计为在线输入 prices 和 strategy，要求动态维护最大可获利润"
      }
    }
  },
  {
    "title": "Partition Array Into K-Distinct Groups",
    "slug": "partition-array-into-k-distinct-groups",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "元素为正整数，1 <= nums[i] <= 10^5",
        "1 <= n <= 10^5",
        "允许重复元素"
      ],
      "Core Constraint": [
        "每个组必须恰好包含 k 个元素",
        "每组内元素互不相同（即组内无重复）",
        "所有元素必须被恰好使用一次",
        "分组数量为 n / k，因此 n 必须能被 k 整除"
      ],
      "Objective Function": "判定是否存在一种合法的分组方案，使得满足上述所有条件",
      "Algorithmic Invariant": [
        "若存在某个元素 x 的出现次数超过总组数（n / k），则无法分配（因为每个组最多放一个 x）",
        "最频繁元素的频次不能超过总组数，是充要条件之一",
        "贪心构造不变性：按频次从高到低分配元素到各组，每个组依次填充不同元素，不会破坏可行性",
        "问题可转化为：能否将元素按频率分配到 n/k 个桶中，每个桶大小为 k，且桶内无重复"
      ],
      "Transformable Parameters": {
        "k 的取值范围": [
          "k = 2（固定小值）",
          "k 可变，支持查询多个 k",
          "k > n 或 k 不整除 n 的情况需特判"
        ],
        "数据规模": [
          "n <= 10^5（当前）",
          "扩展至 n <= 10^6（在线处理需求）"
        ],
        "输入形式": [
          "单组数据",
          "多组测试用例",
          "在线流式输入元素（动态判断是否仍可分组）"
        ],
        "元素类型变化": [
          "非负整数 → 负数也允许（不影响频次统计）",
          "字符串或对象代替整数（需哈希支持）"
        ],
        "约束变形": [
          "组内元素可以重复 → 改变问题本质",
          "每组至少 k 个不同元素 → 最小化而非精确匹配",
          "允许剩余元素 → 由判定变为最大化分组数"
        ],
        "目标函数变换": [
          "判定是否存在分组（当前）",
          "求最多能分成多少个满足条件的组（构造类）",
          "计数合法分组方案数（组合数学）"
        ],
        "是否有序": "无关（仅依赖频次分布，与顺序无关）",
        "是否循环结构": false,
        "是否支持修改操作": [
          "静态数组（当前）",
          "支持添加/删除元素后重新判断（动态版本）"
        ]
      }
    }
  },
  {
    "title": "XOR After Range Multiplication Queries II",
    "slug": "xor-after-range-multiplication-queries-ii",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1], 其中 n >= 1",
        "二维整数数组 queries, 每个 query = [l_i, r_i, k_i, v_i]",
        "nums[i] ∈ [1, 10^9]",
        "queries.length == q ∈ [1, 10^5]",
        "每个查询参数满足: 0 <= l_i <= r_i < n, 1 <= k_i <= n, 1 <= v_i <= 10^5"
      ],
      "Core Constraint": [
        "每次查询在子序列 {l_i, l_i + k_i, l_i + 2*k_i, ...} ∩ [l_i, r_i] 上执行更新操作",
        "更新具有累积性：多个查询可能作用于同一位置，且顺序执行",
        "模运算保持数值稳定性：(nums[idx] * v_i) % (10^9 + 7)",
        "异或操作不具备线性可分性，最终结果依赖所有元素的完整终值"
      ],
      "Objective Function": "返回处理完所有查询后，nums 数组所有元素的按位异或结果",
      "Algorithmic Invariant": [
        "每个位置的最终值由其初始值和所有覆盖该位置的查询中 v_i 的乘积（模意义下）决定",
        "异或不可拆分为独立区间合并，必须维护完整的终态数组或等价信息",
        "查询之间顺序执行，存在显式依赖关系：后一个查询看到的是前一个查询修改后的数组",
        "单个查询的更新步长 k_i 决定了稀疏访问模式，但总更新次数最坏可达 O(n*q)，需考虑优化策略"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e5",
            "可扩展至 1e6（在线段树/差分优化语境下）"
          ],
          "q": [
            "1e5",
            "可设为离线批量处理或多轮询问"
          ]
        },
        "值域": {
          "nums[i]": "正整数，可扩展到非负或含零",
          "v_i": "可允许 v_i = 0（导致清零），或 v_i 可逆（模意义下）以支持撤销操作",
          "模数": "固定为 10^9+7，可改为一般模数或无模"
        },
        "输入形式": [
          "是否离线：当前为顺序执行，可变更为离线重排查询以优化",
          "是否在线：后续查询依赖前面结果，目前是天然在线模式"
        ],
        "操作类型": [
          "乘法更新 → 可改为加法、幂运算、置换等",
          "步长 k_i 固定 per query → 可变为动态或自适应步长"
        ],
        "输出目标": [
          "异或 → 可改为求和、最大值、乘积（模下）、众数等",
          "全局统计 → 可改为区间异或查询"
        ],
        "结构变形": [
          "一维数组 → 环形数组（idx += k_i 自动取模）",
          "单点跳步更新 → 区间块更新（如 k_i 整除时用分块加速）"
        ],
        "附加约束": [
          "是否允许并行执行查询（需去冲突）",
          "是否加入撤销操作（回滚版本控制）"
        ]
      }
    }
  },
  {
    "title": "XOR After Range Multiplication Queries I",
    "slug": "xor-after-range-multiplication-queries-i",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1], 其中 n >= 1",
        "二维查询数组 queries, 每个 query = [l_i, r_i, k_i, v_i]",
        "nums[i] ∈ [1, 10^9]",
        "queries 长度 q ∈ [1, 10^3]",
        "每个查询参数满足: 0 <= l_i <= r_i < n, 1 <= k_i <= n, 1 <= v_i <= 10^5"
      ],
      "Core Constraint": [
        "每次更新操作在等差下标序列上进行：idx = l_i, l_i + k_i, l_i + 2*k_i, ... <= r_i",
        "每个位置的更新是乘法模 (10^9 + 7) 的累积操作",
        "多个查询可能重复修改同一位置，顺序敏感",
        "异或运算不满足分配律，不能直接合并乘法因子"
      ],
      "Objective Function": "返回最终数组所有元素的按位异或结果（XOR）",
      "Algorithmic Invariant": [
        "模意义下的乘法可逐次应用：新值 = (旧值 * v_i) % MOD",
        "每个查询独立遍历其等差下标序列，无状态依赖跨查询",
        "异或操作具有交换律和结合律，允许最后统一计算",
        "无需回滚或逆操作，过程为单向状态演化"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e3",
            "1e5",
            "1e7"
          ],
          "q": [
            "1e3",
            "1e5"
          ],
          "值域": [
            "nums[i] up to 1e9",
            "v_i up to 1e5",
            "MOD = 10^9+7"
          ]
        },
        "输入形式": [
          "单组数据 / 多组测试用例",
          "queries 是否离线给出 / 在线生成"
        ],
        "操作类型扩展": [
          "加法代替乘法",
          "支持撤销操作（如带时间戳）",
          "支持区间连续更新而非跳跃更新"
        ],
        "更新模式变化": [
          "k_i 固定为 1 → 任意 k_i",
          "改为质数模数 / 无模数（高精度）",
          "v_i 变为与 idx 相关的函数"
        ],
        "输出目标变换": [
          "求和 instead of XOR",
          "求最大值",
          "要求输出每个位置的历史修改次数"
        ],
        "结构变形": [
          "从一维数组 → 环形数组（idx %= n）",
          "从静态 queries → 动态插入查询"
        ]
      }
    }
  },
  {
    "title": "Flip Square Submatrix Vertically",
    "slug": "flip-square-submatrix-vertically",
    "schema": {
      "Input Structure": [
        "二维整数矩阵 grid[1..m][1..n]",
        "三个整数 x, y, k",
        "grid[i][j] ≥ 1",
        "x 表示子矩阵左上角行索引，y 表示列索引，k 表示正方形边长"
      ],
      "Core Constraint": [
        "操作对象是一个从 (x, y) 开始的 k×k 正方形子矩阵",
        "仅对该子矩阵进行垂直翻转（即按行上下翻转）",
        "原地修改或构造新矩阵不影响问题本质",
        "翻转操作不改变元素值，只改变行顺序：第 i 行与第 (2*x + k - 1 - i) 行交换"
      ],
      "Objective Function": "返回经过垂直翻转后的完整矩阵",
      "Algorithmic Invariant": [
        "子矩阵外的元素保持不变",
        "子矩阵内部的行满足对称交换关系：row[i] ↔ row[2*x + k - 1 - i] for i in [x, x + k)",
        "每对行交换一次且仅一次，避免重复翻转",
        "翻转过程可独立于其他区域进行，无状态依赖"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": [
            "小规模",
            "1 <= m, n <= 50"
          ],
          "值域范围": "1 <= grid[i][j] <= 100"
        },
        "子矩阵参数": {
          "是否正方形": true,
          "k 是否可为 1": true,
          "k 是否动态输入": true
        },
        "翻转类型": [
          "垂直翻转（行翻转）",
          "可替换为水平翻转（列翻转）",
          "双向翻转（180度旋转）"
        ],
        "操作形式": [
          "单次操作",
          "多组连续操作（可叠加）",
          "是否支持撤销 / 历史记录"
        ],
        "输入输出形式": [
          "一次性输入并输出整个矩阵",
          "是否允许原地修改"
        ],
        "扩展维度": [
          "是否推广到非正方形子矩阵",
          "是否推广到三维立方体切片翻转",
          "是否支持任意形状区域的反射变换"
        ],
        "在线性": "离线处理，固定输入"
      }
    }
  },
  {
    "title": "Find Stores with Inventory Imbalance",
    "slug": "find-stores-with-inventory-imbalance",
    "schema": {
      "Input Structure": [
        "Two relational tables: 'stores' and 'inventory'",
        "stores(store_id: int, store_name: varchar, location: varchar), where store_id is primary key",
        "inventory(inventory_id: int, store_id: int, product_name: varchar, quantity: int, price: decimal), where inventory_id is primary key",
        "Each row in inventory corresponds to a product in a specific store",
        "Finite, static data; offline batch input"
      ],
      "Core Constraint": [
        "Per-store aggregation is required due to analysis scope being defined at store level",
        "The most expensive and cheapest products are determined by max(price) and min(price) within each store",
        "Tie-breaking rule: among products with same extreme price, select the one with highest quantity",
        "Only stores with at least 3 distinct products are considered (cardinality constraint on product diversity)",
        "Imbalance condition depends on comparing quantities of two derived items per store"
      ],
      "Objective Function": [
        "Identify stores with inventory imbalance: quantity(most_expensive_product) < quantity(cheapest_product)",
        "Compute imbalance_ratio = quantity(cheapest_product) / quantity(most_expensive_product), rounded to 2 decimal places",
        "Output detailed result including store metadata, names of extreme products, and ratio",
        "Return results sorted by imbalance_ratio descending, then by store_name ascending"
      ],
      "Algorithmic Invariant": [
        "Per-store extremal product selection is independent and can be processed in isolation (no cross-store dependencies)",
        "Max and min price queries over finite sets maintain monotonicity under insertion (if extended to dynamic setting)",
        "Tie-breaking by quantity ensures deterministic selection given fixed input",
        "Grouping by store_id preserves functional dependency between store and its inventory items",
        "Aggregation pipeline (filter → group → reduce → compare → compute) maintains correctness under relational algebra"
      ],
      "Transformable Parameters": {
        "Minimum distinct products threshold": {
          "current": 3,
          "possible_values": [
            2,
            3,
            4,
            "log(n)",
            "dynamic expression"
          ]
        },
        "Imbalance condition": {
          "current": "quantity_most_expensive < quantity_cheapest",
          "possible_transforms": [
            "≤",
            ">",
            "≥",
            "abs_diff > K",
            "ratio > K"
          ]
        },
        "Objective variation": {
          "current": "compute and sort by imbalance_ratio",
          "alternatives": [
            "boolean flag only",
            "count such stores",
            "minimize/maximize ratio",
            "return top-k"
          ]
        },
        "Tie-breaking rules": {
          "current": "highest quantity among same-price items",
          "alternatives": [
            "lexicographically smallest product_name",
            "lowest inventory_id",
            "arbitrary choice"
          ]
        },
        "Sorting criteria": {
          "current": "imbalance_ratio DESC, store_name ASC",
          "alternatives": [
            "store_id",
            "location",
            "quantity difference",
            "custom weight"
          ]
        },
        "Data dynamics": {
          "current": "static offline tables",
          "extensions": [
            "online updates to inventory",
            "streaming input",
            "support for deletes/modifications"
          ]
        },
        "Output form": {
          "current": "full structured table with multiple columns",
          "variants": [
            "only store_id and ratio",
            "JSON-formatted rows",
            "aggregated statistics"
          ]
        },
        "Price/quantity types": {
          "current": "price: decimal, quantity: int",
          "possible_changes": [
            "negative prices allowed?",
            "zero/negative quantities?"
          ]
        }
      }
    }
  },
  {
    "title": "Sort Threats by Severity and Exploitability",
    "slug": "sort-threats-by-severity-and-exploitability",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at that index."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the distance between their indices and the minimum of their heights.",
        "key_insight": "For any two lines at indices i and j (i < j), the area they form is (j - i) * min(height[i], height[j]).",
        "structural_property": "No three lines can jointly increase the area beyond pairwise consideration; optimal solution lies in selecting two lines."
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "the amount of water that can be contained between two vertical lines",
        "output_type": "integer representing maximum area"
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariant": [
          "At each step, moving the pointer with smaller height does not risk losing the optimal pair.",
          "The wider container has potential for larger area, so starting from widest and narrowing is safe.",
          "If height[left] < height[right], then all containers using left with an inner right pointer are dominated by current or future candidates."
        ],
        "proof_basis": "Monotonicity of min function and linear scan with pruning based on dominance."
      },
      "Transformable Parameters": {
        "n_range": [
          2,
          100000
        ],
        "value_range": [
          0,
          10000
        ],
        "input_variants": [
          "2D version: matrix of heights, find rectangular container",
          "Circular array: indices wrap around",
          "Online queries: dynamically add/remove lines",
          "Output mode: return indices instead of area",
          "Constraint modification: require at least k distance between lines",
          "Generalization: maximize volume in 3D elevation map",
          "Data update support: support point updates to height array",
          "Multiple queries: preprocess for repeated queries"
        ],
        "additional_conditions": [
          "Array may be sorted or unsorted",
          "Negative values allowed (if reinterpreted as depth below ground)",
          "Weighted distances or non-uniform spacing between lines"
        ]
      }
    }
  },
  {
    "title": "Earliest Finish Time for Land and Water Rides II",
    "slug": "earliest-finish-time-for-land-and-water-rides-ii",
    "schema": {
      "Input Structure": [
        "一维数组 landStartTime[1..n]，表示每个陆地游乐设施最早可开始时间",
        "一维数组 landDuration[1..n]，表示每个陆地游乐设施持续时间",
        "一维数组 waterStartTime[1..m]，表示每个水上游乐设施最早可开始时间",
        "一维数组 waterDuration[1..m]，表示每个水上游乐设施持续时间",
        "n, m ≥ 1，且值域为 [1, 1e5]",
        "所有输入均为正整数"
      ],
      "Core Constraint": [
        "游客必须从陆地和水上游乐设施中各选一个，顺序不限",
        "每个项目可在其 startTime 或之后任意时间开始",
        "完成一个项目后可立即开始另一个（若已开放），否则需等待至其开放时间",
        "两个项目之间无冷却或转移时间"
      ],
      "Objective Function": "最小化 完成两个游乐设施的总结束时间（即第二个项目结束的时间点）",
      "Algorithmic Invariant": [
        "对于固定顺序（陆→水 或 水→陆），某一类别的最优选择具有单调性：在另一类别固定起点下，越早结束的项目更优",
        "可通过预处理每类项目的最早可能结束时间，并结合另一类的开放时间进行贪心匹配",
        "枚举顺序 + 对每类项目按开始时间排序后使用双指针或二分查找，可保证不漏最优解",
        "最终答案是两种顺序下的最小结束时间的最小值"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 数量级": [
            "1e4",
            "5e4"
          ],
          "时间值域": "[1, 1e5]"
        },
        "输入形式": [
          "是否有序（landStartTime / waterStartTime 是否已排序）",
          "是否多组测试数据"
        ],
        "是否在线": false,
        "约束变化": [
          "是否允许选择多个项目（计数扩展）",
          "是否加入项目间转移时间",
          "是否限制总游玩时长",
          "是否要求输出方案路径而不仅是时间"
        ],
        "目标函数变形": [
          "改为最大化最晚结束时间（对抗型）",
          "改为计数满足结束时间≤T的方案数",
          "改为判定是否存在方案在时间T前完成"
        ],
        "结构扩展": [
          "增加第三种类别（如空中项目），形成三阶段序列",
          "变为环形顺序（必须回到起点状态）"
        ]
      }
    }
  },
  {
    "title": "Minimum Sum After Divisible Sum Deletions",
    "slug": "minimum-sum-after-divisible-sum-deletions",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "每个元素 nums[i] ≥ 1",
        "给定整数 k ≥ 1",
        "数组长度 n 满足 1 ≤ n ≤ 10^5",
        "值域：nums[i] ∈ [1, 10^6], k ∈ [1, 10^5]"
      ],
      "Core Constraint": [
        "可多次删除任意连续子数组，只要其元素和 ≡ 0 (mod k)",
        "删除后剩余元素拼接成新数组，操作可重复直至无法进一步优化",
        "问题本质等价于：通过模 k 同余的前缀和差分来识别可消去区间",
        "最终剩余部分不能包含任何子数组其和 ≡ 0 (mod k)，除非牺牲更优解"
      ],
      "Objective Function": "最小化最终剩余数组的所有元素之和",
      "Algorithmic Invariant": [
        "前缀和模 k 的同余性质：若 prefix[i] ≡ prefix[j] (mod k)，则子数组 nums[i..j-1] 和可被 k 整除",
        "贪心不变性：尽可能多地移除模 k 为 0 的子数组，等价于保留最短不可再删的前缀序列",
        "动态规划状态可定义为 dp[i] = 前 i 个元素中能保留的最小和，且结尾前缀和模 k 状态可传递",
        "利用哈希表记录最早出现的同余类，以支持最大区间删除（即最小保留）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e1",
            "1e3",
            "1e5"
          ],
          "值域范围": "[1, 1e6]",
          "k 范围": "[1, 1e5]"
        },
        "输入形式": {
          "是否有序": false,
          "是否允许负数": true,
          "是否允许零": true
        },
        "操作模式": {
          "是否只能删除一次": false,
          "是否限制删除次数": false,
          "是否要求构造方案": false
        },
        "目标函数变体": [
          "改为最小化剩余长度",
          "改为判断是否能全删完",
          "改为计数最多可删除多少次"
        ],
        "约束变换": [
          "子数组必须长度 ≥ L",
          "子数组必须长度 ≤ L",
          "只允许删除至多 m 次"
        ],
        "流式处理": {
          "是否在线输入": false,
          "是否支持修改操作": false
        },
        "维度扩展": [
          "二维矩阵中删除子矩阵其和 ≡ 0 (mod k)"
        ],
        "模数特性": [
          "k 是否为质数",
          "是否多个不同 k 共同约束"
        ]
      }
    }
  },
  {
    "title": "Earliest Finish Time for Land and Water Rides I",
    "slug": "earliest-finish-time-for-land-and-water-rides-i",
    "schema": {
      "Input Structure": [
        "两个类别的一维数组对：",
        "(landStartTime[1..n], landDuration[1..n]) 表示 n 个陆地游乐设施的最早开始时间和持续时间",
        "(waterStartTime[1..m], waterDuration[1..m]) 表示 m 个水上游乐设施的最早开始时间和持续时间",
        "所有时间为正整数，且满足 1 <= landStartTime[i], landDuration[i], waterStartTime[j], waterDuration[j] <= 1000",
        "n, m >= 1 且 <= 100"
      ],
      "Core Constraint": [
        "游客必须从每个类别中选择恰好一个项目",
        "顺序不限（可先陆地后水上，或先水上后陆地）",
        "每个项目可在其 startTime 或之后任意时间开始",
        "完成一个项目后可立即开始另一个（若已开放），否则需等待至其开放时间",
        "项目的实际开始时间 = max(完成前一项的时间, 目标项目的 startTime)"
      ],
      "Objective Function": "最小化 完成两个项目后的总结束时间（即第二项结束的时间）",
      "Algorithmic Invariant": [
        "对于任意选定的 (i, j) 组合（陆地 i + 水上 j），两种顺序的结束时间可以独立计算：",
        "  - 顺序 A（陆 → 水）：end_time = max(landStartTime[i] + landDuration[i], waterStartTime[j]) + waterDuration[j]",
        "  - 顺序 B（水 → 陆）：end_time = max(waterStartTime[j] + waterDuration[j], landStartTime[i]) + landDuration[i]",
        "最优解必然是在所有 i ∈ [0,n), j ∈ [0,m) 和两种顺序中取全局最小结束时间",
        "枚举所有组合不会破坏最优性，因为选择相互独立且状态空间小"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 的数量级": [
            "小规模 (≤100)",
            "可扩展为 ≤1e5（需优化解法）"
          ],
          "值域范围": [
            "时间 ≤1000",
            "可放大至 1e9"
          ]
        },
        "输入形式": [
          "是否分开展示 startTime 和 duration 数组",
          "是否合并为事件对象列表",
          "是否支持多类别（>2 类）项目"
        ],
        "顺序约束": [
          "是否强制顺序（如必须先陆后水）",
          "是否允许跳过某些项目（改为选择至少一个）"
        ],
        "目标函数变形": [
          "求最早完成时间（当前）",
          "改为求方案数、是否存在可行解、最小等待时间总和等"
        ],
        "在线性": [
          "是否支持动态添加/删除游乐设施（在线更新）",
          "是否支持查询多次不同组合"
        ],
        "隐藏条件": [
          "startTime 是否有序（可排序预处理）",
          "是否存在隐式单调性可用于剪枝"
        ]
      }
    }
  },
  {
    "title": "Number of ZigZag Arrays II",
    "slug": "number-of-zigzag-arrays-ii",
    "schema": {
      "Input Structure": {
        "description": "三个整数 n, l, r",
        "n": "数组长度，满足 3 <= n <= 10^9",
        "l": "取值下界，满足 1 <= l < r",
        "r": "取值上界，满足 l < r <= 75",
        "array_elements": "数组每个元素 ∈ [l, r]"
      },
      "Core Constraint": {
        "adjacent_unequal": "任意两个相邻元素不相等",
        "no_three_consecutive_monotonic": "任意三个连续元素不能构成严格递增或严格递减序列",
        "implication": "第 i+2 个元素的大小关系必须与前两者的趋势相反（即必须‘锯齿’）"
      },
      "Objective Function": {
        "goal": "计数",
        "target": "满足条件的长度为 n 的锯齿形数组总数",
        "output_mod": "结果对 10^9 + 7 取模"
      },
      "Algorithmic Invariant": {
        "state_dependency": "当前状态仅依赖于前两个元素的相对大小（上升或下降）",
        "transition_symmetry": "状态转移具有对称性：上升后必须下降，下降后必须上升",
        "dp_state_form": "令 dp[i][up] 表示以第 i 位结尾且最后一步是上升（或下降）的合法方案数",
        "recurrence_linearity": "转移方程是线性的，且转移系数只与值域 [l, r] 的宽度有关",
        "matrix_exponentiation_possible": "由于 n 极大而 r-l 很小，可用矩阵快速幂优化线性递推"
      },
      "Transformable Parameters": {
        "n_range": "n ∈ [3, 10^9] → 可改为较小范围以禁用矩阵快速幂",
        "value_range": "[l, r] 宽度 w = r - l + 1 ≤ 75 → 可扩展至更大以改变复杂度边界",
        "modular_arithmetic": "是否取模、模数是否为 1e9+7",
        "initial_conditions": "是否固定首元素 / 前两个元素",
        "output_type": "仅总数 vs. 输出所有方案 vs. 判断是否存在",
        "constraint_variation": [
          "允许相邻相等 → 改变状态定义",
          "禁止更多长度单调子序列（如4项）→ 提高状态维度",
          "加入全局约束（如总和限制）→ 引入额外DP维"
        ],
        "online_query": "多组 (n, l, r) 查询 → 预处理转移矩阵族",
        "circular_array": "将数组视为环形 → 要求首尾也满足锯齿条件"
      }
    }
  },
  {
    "title": "Number of Perfect Pairs",
    "slug": "number-of-perfect-pairs",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中 n >= 2；元素为整数，值域范围 [-10^9, 10^9]；允许负数、零和正数；无序；可重复",
      "Core Constraint": "一对下标 (i, j) 满足 i < j，且对于 a = nums[i], b = nums[j]，必须同时满足：\n1. min(|a - b|, |a + b|) <= min(|a|, |b|)\n2. max(|a - b|, |a + b|) >= max(|a|, |b|)\n该约束具有对称性但依赖于绝对值组合的几何性质，不可通过简单排序消除冗余比较",
      "Objective Function": "计数：统计满足条件的不同的下标对 (i, j) 的数量（即完美对的总数）",
      "Algorithmic Invariant": "无指针类单调推进结构；但由于判断条件仅依赖于数值的绝对值及其和差的绝对值，可通过数学变换将条件转化为符号无关的形式。关键不变量是：\n- 对任意 a, b，有 |\n- 判断逻辑仅依赖于 |a|, |b| 和 |a ± b| 的相对大小关系，不依赖原始符号或顺序\n- 可通过对数值按绝对值分组或哈希优化重复计算，但无法避免 O(n²) 最坏情况下的两两比对（除非引入数论结构假设）",
      "Transformable Parameters": [
        "n 的数量级：从 O(10^2) 到 O(10^5)，决定是否需要亚二次解法",
        "是否允许重复元素：影响计数时是否去重",
        "数组是否有序：若输入有序则可能设计双指针扩展变体",
        "值域范围：如限制在小范围内（如 [-1000,1000]），可启用桶计数或频次数组优化",
        "是否在线查询：动态添加元素并实时返回当前完美对数量",
        "是否要求构造所有完美对的具体下标（而非仅计数）",
        "是否加入模数取余（如结果对 1e9+7 取模）",
        "是否扩展到三元组 (i,j,k) 形式"
      ]
    }
  },
  {
    "title": "Number of ZigZag Arrays I",
    "slug": "number-of-zigzag-arrays-i",
    "schema": {
      "Input Structure": {
        "type": "integer_sequence",
        "length": "n",
        "value_domain": "[l, r]",
        "constraints": [
          "n ∈ [3, 2000]",
          "l, r ∈ [1, 2000], l < r",
          "each element is integer in [l, r]"
        ]
      },
      "Core Constraint": {
        "adjacent_unequal": "任意两个相邻元素不相等",
        "no_three_consecutive_monotonic": "任意三个连续元素不能构成严格递增或严格递减序列",
        "implication": "局部三元组结构约束导致状态转移必须依赖前两步的相对大小关系"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "计算满足条件的长度为 n 的锯齿形数组总数",
        "output_mod": "1000000007"
      },
      "Algorithmic Invariant": {
        "state_dependency": "当前合法序列的扩展仅依赖于最后两个元素的大小关系（上升或下降）",
        "dp_state_structure": "使用动态规划，状态定义为 dp[i][last][rising] 表示前 i 个位置、最后一个值为 last、最后一步趋势为上升/下降的方案数",
        "transition_invariance": "在固定前两个元素后，后续每一步的选择只受‘避免三连单调’这一不变量限制，可通过状态分离（上升/下降）实现无后效性转移",
        "symmetry_optimization": "由于转移仅依赖相对大小而非绝对值，可优化为按排名压缩状态，利用前缀和加速转移"
      },
      "Transformable Parameters": {
        "n_range": "[3, 2000]",
        "value_range": "[l, r] with l < r, up to 2000",
        "mod_enabled": true,
        "input_type": "single instance",
        "online_queries": false,
        "extension_possibilities": [
          "改为构造一个合法序列（构造型目标）",
          "加入更多全局约束（如总和限制）",
          "允许非整数或高维推广（向量序列）",
          "将‘三连单调’检测变为滑动窗口式在线判定",
          "将值域扩大并要求离散化预处理",
          "改为最小化/最大化某类子序列数量的目标函数"
        ],
        "structural_variants": [
          "环形锯齿数组（首尾相连形成三元组）",
          "更高阶禁止单调：禁止四连单调",
          "允许多重跳跃模式下的广义锯齿"
        ]
      }
    }
  },
  {
    "title": "Find Students with Study Spiral Pattern",
    "slug": "find-students-with-study-spiral-pattern",
    "schema": {
      "Input Structure": [
        "表 students: (student_id: int, student_name: varchar, major: varchar), student_id 为主键",
        "表 study_sessions: (session_id: int, student_id: int, subject: varchar, session_date: date, hours_studied: decimal), session_id 为主键",
        "每个学生有多个学习记录，按日期排序",
        "subject 为分类变量（学科名称）",
        "session_date 为连续时间戳，精度为天"
      ],
      "Core Constraint": [
        "螺旋学习模式要求：至少3个不同学科构成一个循环序列",
        "该序列必须重复至少2个完整周期（即至少6条连续记录）",
        "相邻学习记录的日期间隔 ≤ 2天，且整体呈时间递增顺序",
        "模式中的学科顺序必须严格重复（即周期性序列）",
        "每个周期内学科种类和顺序完全一致"
      ],
      "Objective Function": [
        "识别满足螺旋学习模式的学生",
        "对每位符合条件的学生：",
        "  - 计算循环长度（即模式中不同学科的数量）",
        "  - 计算总学习时长（该模式下所有记录的 hours_studied 之和）",
        "返回字段：student_id, student_name, major, cycle_length, total_study_hours",
        "结果按 cycle_length 降序排序；相同时按 total_study_hours 降序排序"
      ],
      "Algorithmic Invariant": [
        "对于每个学生，其学习记录可按 session_date 排序形成时间序列 S[1..m]",
        "若存在周期 p ≥ 3 和起始位置 i，使得子序列 S[i:i+2p] 满足：",
        "  - 前 p 个 subject 构成基础周期 T",
        "  - 后 p 个 subject 与 T 完全相同",
        "  - 所有相邻记录日期差 ≤ 2",
        "则该学生符合螺旋模式，且 cycle_length = |set(T)|",
        "一旦找到最长合法周期，其总时长可通过累加对应记录得到",
        "周期检测具有单调推进性质：若从某起点无法匹配，则无需回溯至中间位置"
      ],
      "Transformable Parameters": {
        "cycle_length_threshold": "最小循环长度，默认为3，可调整为k≥2",
        "min_complete_cycles": "最小完整周期数，默认为2，可改为c≥1",
        "max_date_gap": "连续学习允许的最大间隔天数，默认为2，可设为g≥0",
        "min_total_sessions": "触发检查的最小会话数阈值（如6条），可参数化",
        "subject_similarity": "是否支持模糊匹配学科名（如'Algebra I' ≈ 'Algebra II'），默认精确匹配",
        "overlap_allowed": "周期之间是否允许重叠（本题不允许跨周期干扰）",
        "output_fields": [
          "可选输出每周期平均时长、首次/末次学习时间等"
        ],
        "input_mode": "离线批量处理；可扩展为在线流式检测模式",
        "data_grouping": "按 student_id 分组独立处理，支持并行化",
        "ordering_requirement": "结果排序规则可变：如按总时长优先或按学生ID排序"
      }
    }
  },
  {
    "title": "Number of Student Replacements",
    "slug": "number-of-student-replacements",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组中能够接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max；当 left_max ≤ right_max 时，左指针当前位置的蓄水量仅由 left_max 决定，右指针同理；移动较小一侧指针可保证局部贡献正确且不破坏全局最优性",
      "Transformable Parameters": {
        "数据规模 n": "1 ≤ n ≤ 10^5（可调整为更小或支持在线流式输入）",
        "值域范围": "H[i] ∈ [0, 10^4]（可扩展至负数以考察边界处理）",
        "数组性质": "无序、允许重复元素（可变体：有序、环形数组）",
        "维度扩展": "可推广至二维矩阵（2D接雨水）、三维空间",
        "操作类型": "静态一次性输入（可变体：支持单点更新、删除、插入的动态版本）",
        "输出形式": "仅求总量（可变体：输出每列蓄水量、最大连续蓄水区间等）",
        "输入模式": "单组数据（可变体：多组测试用例、在线查询模式）"
      }
    }
  },
  {
    "title": "Maximum Total from Optimal Activation Order",
    "slug": "maximum-total-from-optimal-activation-order",
    "schema": {
      "Input Structure": [
        "两个长度为 n 的整数数组 value[1..n] 和 limit[1..n]",
        "value[i] ≥ 1, limit[i] ∈ [1, n]",
        "n ∈ [1, 10^5]"
      ],
      "Core Constraint": [
        "激活元素 i 时，当前活跃元素数量必须严格小于 limit[i]",
        "每次激活后，所有满足 limit[j] ≤ 当前活跃元素总数的元素 j（无论是否已激活）将永久变为非活跃",
        "一旦元素变为非活跃，不能再被激活或贡献 value"
      ],
      "Objective Function": "最大化可获得的总 value 和（即所有成功激活元素的 value[i] 之和）",
      "Algorithmic Invariant": [
        "按 limit 分组处理：limit 值小的元素更容易导致大规模失效，应优先考虑其激活时机",
        "贪心策略成立条件：若某元素在某个激活序列中能安全加入且不引发高价值元素失效，则应尽可能延迟低收益高风险元素的激活",
        "状态单调性：活跃集合只增（临时）或减（永久），不可逆；全局活跃数随操作非递减（仅看激活后瞬间）",
        "最优子结构：对于固定最终激活数量 k，最优解可通过选择 limit > k 且 value 最大的元素构成"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e1",
            "1e3",
            "1e5"
          ],
          "value[i] 范围": "[1, 1e5]",
          "limit[i] 范围": "[1, n]"
        },
        "输入形式": [
          "单组输入",
          "多组测试用例",
          "在线查询（动态添加元素）"
        ],
        "约束变形": [
          "limit 条件由 ≤ 改为 ≥ 导致反向失效机制",
          "允许重复激活",
          "引入 cooldown 时间而非永久失效",
          "改为区间型 limit（如 [a_i, b_i] 内才有效）"
        ],
        "目标函数变体": [
          "求最大总和（原题）",
          "求最多激活次数",
          "判定是否存在方案达到某阈值",
          "构造字典序最小的激活顺序"
        ],
        "结构扩展": [
          "二维情形：元素位于网格中，limit 与邻域有关",
          "图结构依赖：激活一个节点影响其邻居的 limit 效力",
          "环形激活链：最后一个激活影响第一个的状态"
        ],
        "隐藏单调性": [
          "显式给出 limit 数组 → 隐式通过其他规则生成 limit（如排序后赋值）",
          "value 与 limit 相关（如 value[i] = f(limit[i])）引入权衡"
        ]
      }
    }
  },
  {
    "title": "Minimum Removals to Balance Array",
    "slug": "minimum-removals-to-balance-array",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "nums.length ∈ [1, 1e5]",
          "nums[i] ∈ [1, 1e9]",
          "k ∈ [1, 1e5]",
          "non-empty array after removal"
        ],
        "sorted": false,
        "distinctness": "duplicates allowed"
      },
      "Core Constraint": {
        "balance_condition": "max(remaining) <= min(remaining) * k",
        "structural_insight": "if we fix the minimum and maximum of the remaining subsequence, then all elements between them (in value) can be kept as long as they lie within [min_val, min_val * k]",
        "monotonicity_in_values": "after sorting, valid remaining elements form a contiguous segment in sorted order that satisfies the balance condition"
      },
      "Objective Function": {
        "goal": "minimize number of removed elements",
        "equivalent_form": "maximize size of remaining balanced subsequence",
        "output_type": "integer (minimum removals)"
      },
      "Algorithmic Invariant": {
        "invariant_description": "when the array is sorted, the optimal remaining subsequence lies in a contiguous interval [i, j] such that nums[j] <= nums[i] * k",
        "two_pointer_movement": "for increasing left index i, the maximal right index j satisfying nums[j] <= nums[i] * k is non-increasing in reverse scan or can be scanned forward with monotonic growth",
        "optimality_preservation": "expanding j for fixed i greedily captures maximum retainable elements; no benefit from skipping values inside [nums[i], nums[i]*k]"
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          100000
        ],
        "value_domain": [
          1,
          1000000000
        ],
        "k_range": [
          1,
          100000
        ],
        "sorting_required": true,
        "circular_array": false,
        "online_queries": false,
        "batch_input": false,
        "allow_empty_result": false,
        "output_detail_level": "single integer (min removals)",
        "variant_targets": [
          "count number of balanced subsequences",
          "return one optimal solution array",
          "require minimal sum/maximal product instead of maximal length",
          "2D version: matrix rows must each be balanced",
          "dynamic updates: add/remove elements online"
        ],
        "constraint_transforms": [
          "change condition to max >= min * k (unbalanced focus)",
          "replace multiplication with addition: max <= min + k",
          "introduce weights on elements: minimize total weight removed"
        ]
      }
    }
  },
  {
    "title": "Sum of Perfect Square Ancestors",
    "slug": "sum-of-perfect-square-ancestors",
    "schema": {
      "Input Structure": {
        "Tree": "An undirected tree with n nodes (0-indexed), rooted at node 0",
        "Edges": "A 2D array edges of length n - 1, where edges[i] = [u_i, v_i] represents an undirected edge",
        "Values": "An integer array nums of length n, where nums[i] is a positive integer assigned to node i",
        "Constraints": {
          "n": "1 <= n <= 1e5",
          "nums_value_range": "1 <= nums[i] <= 1e5"
        }
      },
      "Core Constraint": {
        "Ancestor Path": "For each node i (i != 0), ancestors are all nodes on the unique path from i to root 0, excluding i itself",
        "Square Condition": "The product nums[i] * nums[ancestor] must be a perfect square",
        "Multiplicative Property": "A product is a perfect square iff the combined exponent of every prime in its factorization is even"
      },
      "Objective Function": "Sum over all non-root nodes i (from 1 to n-1) of t_i, where t_i is the count of ancestors of i for which nums[i] * nums[ancestor] is a perfect square",
      "Algorithmic Invariant": {
        "Factorization Canonical Form": "Each number can be reduced to its 'square-free kernel' by removing all squared factors; two numbers form a perfect square product iff their kernels are equal",
        "Path Monotonicity": "During DFS from root to leaves, maintain a frequency map of square-free kernels along the current path",
        "State Inheritance": "When traversing down, add current node's kernel to the map before visiting children, remove after",
        "Count Efficiency": "For node i with kernel k, the number of valid ancestors is the current count of k in the path map (excluding self)"
      },
      "Transformable Parameters": {
        "Data Range": {
          "n": [
            "1e3",
            "1e5"
          ],
          "nums[i]": [
            "[1, 100]",
            "[1, 1e5]"
          ]
        },
        "Tree Type": [
          "Rooted tree",
          "Unrooted tree (re-rooting required)",
          "Forest"
        ],
        "Query Type": [
          "Offline static",
          "Online queries with updates"
        ],
        "Operation Support": [
          "Static input",
          "Support for node value updates",
          "Edge insertion/deletion (dynamic tree)"
        ],
        "Output Variation": [
          "Sum of t_i",
          "Maximum t_i",
          "List all valid ancestor pairs",
          "Count modulo 1e9+7"
        ],
        "Mathematical Variant": [
          "Perfect cube instead of square",
          "Product is power of K",
          "GCD/LCM condition instead"
        ],
        "Kernel Definition": [
          "Square-free kernel",
          "Cube-free kernel",
          "Modular equivalence class"
        ],
        "Input Form": [
          "Explicit tree edges",
          "Parent array",
          "Euler Tour + values"
        ]
      }
    }
  },
  {
    "title": "Trionic Array II",
    "slug": "trionic-array-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "4 <= n <= 1e5",
        "value_range": "-1e9 <= nums[i] <= 1e9",
        "description": "长度为 n 的整数数组 nums，表示可正可负的数值序列"
      },
      "Core Constraint": {
        "structure": "三段式连续子数组",
        "segments": [
          {
            "name": "第一段",
            "condition": "严格递增",
            "range": "nums[l...p], 其中 l < p"
          },
          {
            "name": "第二段",
            "condition": "严格递减",
            "range": "nums[p...q], 其中 p < q"
          },
          {
            "name": "第三段",
            "condition": "严格递增",
            "range": "nums[q...r], 其中 q < r"
          }
        ],
        "index_constraint": "l < p < q < r, 所有下标在 [0, n) 范围内",
        "continuity": "整个子数组 nums[l...r] 是连续的",
        "explanation": "结构上要求存在两个内部转折点 p 和 q，使得序列呈现 '升-降-升' 的三段模式，且每段长度至少为2（因严格单调需至少两个元素）"
      },
      "Objective Function": {
        "type": "maximization",
        "target": "sum of subarray",
        "goal": "在所有满足三段式结构的连续子数组中，找出元素和最大的那个，并返回其最大和"
      },
      "Algorithmic Invariant": {
        "main_paradigm": "dynamic programming with state decomposition",
        "invariants": [
          "对于每个位置 i，可以预处理出以 i 结尾的最长严格递增前缀的和（或最大和贡献）",
          "对于每个位置 i，可以预处理出以 i 开头的最长严格递减后缀的局部信息",
          "中间段的极值点 p 和 q 构成状态转移的关键节点，可通过枚举 q 并结合左右信息合并答案",
          "最优子结构：全局最大和三段式子数组，其第一段必是以某个 p 结尾的最大递增段，第三段必是以某个 q 开头的最大递增段",
          "可用 left_increasing[i] 表示从左侧某起点到 i 的最大递增子段和（以 i 结尾），right_increasing[i] 表示从 i 到右侧某终点的最大递增子段和（以 i 开头）",
          "利用中间递减段连接左右递增段时，可通过枚举递减段两端点 p 和 q，组合 left_increasing[p] + decreasing_sum(p,q) + right_increasing[q]"
        ],
        "monotonicity": "无直接单调性，但可通过 DP 维护局部最优性",
        "state_separation": "前后段独立于中间段，可通过预处理分离依赖"
      },
      "Transformable Parameters": {
        "n_scale": [
          "1e3",
          "1e5"
        ],
        "value_domain": [
          "negative allowed",
          "non-negative only",
          "positive only"
        ],
        "order_constraint": [
          "strictly increasing/decreasing required",
          "non-decreasing/non-increasing allowed"
        ],
        "input_form": "single array, offline",
        "multi_query": false,
        "online_update": false,
        "circular_array": false,
        "output_form": [
          "return maximum sum",
          "return indices (l,p,q,r)",
          "count number of valid triple-segment subarrays"
        ],
        "objective_variation": [
          "maximize sum",
          "minimize sum",
          "maximize length",
          "count valid configurations"
        ],
        "structural_variation": [
          "改为 '降-升-降' 模式",
          "允许更多段（如五段式）",
          "仅要求整体形状符合趋势，不要求严格连续单调"
        ],
        "constraint_variation": [
          "允许平台（相等元素）",
          "固定中间段长度",
          "加入和的上下界约束"
        ]
      }
    }
  },
  {
    "title": "Threshold Majority Queries",
    "slug": "threshold-majority-queries",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n], 其中 n >= 1",
        "元素值域: nums[i] ∈ [1, 10^9]",
        "查询数组 queries, 每个 query = [l_i, r_i, threshold_i]",
        "子数组范围满足 0 <= l_i <= r_i < n",
        "threshold_i 至少为 1，至多为子数组长度"
      ],
      "Core Constraint": [
        "每个查询独立作用于一个连续子数组 nums[l_i..r_i]",
        "需在子数组内统计各元素频次",
        "仅考虑频次 ≥ threshold_i 的候选元素",
        "若多个元素满足条件，则选择频率最高者；频率相同时选数值最小者",
        "若无元素满足 threshold_i 要求，则返回 -1"
      ],
      "Objective Function": [
        "对每个查询，构造一个答案值 ans[i]",
        "ans[i] = 满足频次 ≥ threshold_i 的元素中，频率最高（优先）、数值最小（次优先）的元素",
        "若不存在则 ans[i] = -1",
        "目标类型：构造性查询响应（逐查询输出最优元素）"
      ],
      "Algorithmic Invariant": [
        "对于任意子数组，元素频率可通过哈希映射精确统计",
        "频率比较具有全序性（先按频次降序，再按值升序）",
        "每个查询的答案仅依赖其对应区间的局部信息，与其他查询无关",
        "无指针推进或状态转移依赖，但可利用离线排序优化多查询处理（如 Mo's Algorithm 在特定参数下的可行性）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 <= n <= 10^4",
          "queries.length": "1 <= q <= 5 * 10^4",
          "threshold_i": "1 <= threshold_i <= (r_i - l_i + 1)"
        },
        "值域变化": [
          "nums[i] 是否允许负数",
          "nums[i] 值域是否压缩至小范围（如 [1, n]，支持桶计数）"
        ],
        "输入形式": [
          "单次批量输入 → 在线流式查询",
          "是否允许多轮修改操作（加入点更新）"
        ],
        "查询模式": [
          "是否支持离线重排（用于莫队算法优化）",
          "是否所有查询区间长度相近（影响分块策略）"
        ],
        "输出要求": [
          "仅返回答案数组 → 同时返回频次分布",
          "是否要求稳定输出（相同频率时固定取最小）"
        ],
        "约束变形": [
          "threshold 条件由 ≥ 改为 ≤ 或 ==（变为精确频次匹配）",
          "目标函数由 '最高频且最小值' 变为 '最频繁的所有元素列表'"
        ]
      }
    }
  },
  {
    "title": "Maximum Balanced Shipments",
    "slug": "maximum-balanced-shipments",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "constraints": [
          "n ∈ [2, 10^5]",
          "weight[i] ∈ [1, 10^9]",
          "array is one-dimensional and ordered by index"
        ]
      },
      "Core Constraint": {
        "definition": "A contiguous subarray (shipment) is balanced if the last element is strictly less than the maximum element in that subarray.",
        "implication": "Single-element shipments cannot be balanced. The feasibility of a segment depends on local maxima and endpoint comparison."
      },
      "Objective Function": {
        "type": "maximization",
        "goal": "maximum number of non-overlapping balanced shipments",
        "coverage": "each element can appear in at most one shipment; some elements may be left out"
      },
      "Algorithmic Invariant": {
        "principle": "Greedy selection with DP or greedy scanning: once a valid balanced segment ending at position i is found, we can consider it as a candidate for inclusion if it does not conflict with prior segments.",
        "monotonicity": "Extending a segment does not reduce its maximum; thus, the condition 'last < max' becomes harder to satisfy as segments grow.",
        "optimal_substructure": "If optimal solution includes a shipment ending at i, then the prefix before this shipment must also be optimally packed.",
        "greedy_choice": "Prefer shorter valid segments when they enable more total segments (subject to validation via dynamic programming)."
      },
      "Transformable Parameters": {
        "n_scale": [
          "10^3",
          "10^5",
          "online streaming"
        ],
        "value_domain": {
          "allow_negative": false,
          "duplicate_values": true,
          "sortedness": "arbitrary order"
        },
        "structural_variants": [
          "2D grid of weights → find non-overlapping rectangular shipments",
          "circular array (last connects to first)",
          "overlapping allowed with penalty"
        ],
        "input_mode": [
          "offline batch input",
          "online queries (add/remove elements)"
        ],
        "output_variants": [
          "return maximum count",
          "return actual partitioning",
          "count all possible balanced subarrays (preprocessing step)"
        ],
        "constraint_modifications": [
          "change 'strictly less' to 'less than or equal'",
          "require first element instead of last to be small",
          "balance condition based on average or median",
          "multiple balance conditions combined"
        ]
      }
    }
  },
  {
    "title": " Minimum Discards to Balance Inventory",
    "slug": "minimum-discards-to-balance-inventory",
    "schema": {
      "Input Structure": [
        "一维数组 arrivals[1..n]，表示每天到达的物品类型",
        "两个整数 w 和 m",
        "arrivals[i] ∈ [1, 10^5]",
        "n = len(arrivals) ∈ [1, 10^5]",
        "天数从 1 开始编号"
      ],
      "Core Constraint": [
        "每个物品只能在到达当天决定保留或丢弃",
        "对于任意一天 i，考虑时间窗口 [max(1, i - w + 1), i]（最近 w 天）",
        "在该窗口内，每种物品类型的保留数量不得超过 m 次",
        "若保留当前物品会导致其类型在当前窗口中超过 m 次，则必须丢弃"
      ],
      "Objective Function": "最小化需要丢弃的物品总数",
      "Algorithmic Invariant": [
        "使用滑动窗口维护最近 w 天内的物品类型频次计数",
        "从前向后逐天处理，决策具有不可逆性：一旦丢弃无法恢复",
        "保留策略是贪心的：只要不违反约束就保留（因为目标是最小化丢弃）",
        "窗口左端点随时间单调右移，支持用队列或双指针维护有效区间",
        "频次统计仅依赖当前窗口内数据，历史超出窗口的数据可安全移除"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5 → 可扩展至 1e6（要求 O(n) 或 O(n log n) 解法）",
        "值域": "arrivals[i] 范围可变（如小范围 [1,K] 支持数组计数；大范围支持哈希表）",
        "是否有序": "arrivals 无序，但时间序列天然有序",
        "窗口类型": "固定宽度滑动窗口 → 可变为可变宽度、环形窗口等",
        "约束方向": "最多 m 次 → 可改为至少 m 次（目标函数相应变化）",
        "是否多组输入": "单组 → 可扩展为多组测试用例",
        "是否在线": "离线输入 → 可设计为在线流式到达，要求实时决策",
        "操作类型扩展": "加入修改/延迟丢弃机制 → 增加复杂度",
        "输出形式变化": "返回最少丢弃数 → 可改为构造具体保留方案或判断可行性"
      }
    }
  },
  {
    "title": "Trionic Array I",
    "slug": "trionic-array-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "constraints": [
          "3 <= n <= 100",
          "-1000 <= nums[i] <= 1000"
        ],
        "order": "arbitrary",
        "repetition": true
      },
      "Core Constraint": {
        "description": "数组可被划分为三个连续子数组，分别满足：严格递增 → 严格递减 → 严格递增，且分割点 p 和 q 满足 0 < p < q < n - 1",
        "structural_requirements": [
          "存在索引 p 和 q 将数组划分为三段",
          "第一段 [0...p] 严格递增",
          "第二段 [p...q] 严格递减",
          "第三段 [q...n-1] 严格递增"
        ],
        "boundary_conditions": [
          "p > 0",
          "q < n - 1"
        ]
      },
      "Objective Function": {
        "type": "decision",
        "goal": "判断是否存在合法的分割点 p 和 q，使得数组构成三段式结构",
        "output": "boolean (true if trionic, else false)"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "前缀单调性：可以预处理最长严格递增前缀，用于快速验证第一段",
          "后缀单调性：可以预处理最长严格递增后缀，用于验证第三段",
          "中间段的极大递减区间可以从每个可能的峰值向两侧扩展判定",
          "枚举所有可能的 p 和 q 时，利用已计算的递增/递减信息避免重复比较"
        ],
        "optimization_principle": "通过预处理 left_increasing[i] 表示从 0 到 i 是否严格递增，right_increasing[i] 表示从 i 到末尾是否严格递增，以及构建递减段的合法性检查表，可在 O(n²) 内完成判定；进一步优化可至 O(n) 枚举候选峰谷位置结合双指针推进规则"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n_size",
            "values": [
              "small: [3, 100]",
              "medium: [1e3]",
              "large: [1e5]"
            ],
            "impact": "决定是否允许 O(n^2) 或必须 O(n)"
          },
          {
            "name": "monotonicity_strength",
            "values": [
              "strict",
              "non-strict"
            ],
            "impact": "改变比较条件为 ≥ / ≤"
          },
          {
            "name": "segment_count",
            "values": [
              "3",
              "k"
            ],
            "impact": "推广为 k 段交替增减模式（如增-减-增-...）"
          },
          {
            "name": "input_dimension",
            "values": [
              "1D",
              "2D (matrix row-wise or spiral)"
            ],
            "impact": "在二维网格中寻找路径形成三段式序列"
          },
          {
            "name": "objective_type",
            "values": [
              "decision",
              "counting",
              "construction",
              "longest_trionic_subarray"
            ],
            "impact": "改为求最长三段式子数组长度，或统计所有合法 (p,q) 对"
          },
          {
            "name": "data_streaming",
            "values": [
              "offline",
              "online (streaming elements)"
            ],
            "impact": "是否支持动态添加元素并实时判断"
          },
          {
            "name": "constraint_visibility",
            "values": [
              "explicit indices p,q",
              "hidden structure (only decide existence)"
            ],
            "impact": "是否要求输出 p,q 或仅判断"
          }
        ]
      }
    }
  },
  {
    "title": "Next Special Palindrome Number",
    "slug": "next-special-palindrome-number",
    "schema": {
      "Input Structure": "一个整数 n，满足 0 <= n <= 10^15",
      "Core Constraint": "特殊数必须同时满足两个条件：(1) 是回文数；(2) 每个数字 k 在该数中恰好出现 k 次（即数字 1 出现 1 次，数字 2 出现 2 次，……，数字 9 出现 9 次；数字 0 可以出现任意次但若出现则也需满足其自身约束）",
      "Objective Function": "求严格大于 n 的最小特殊数",
      "Algorithmic Invariant": "1. 构造的数为回文结构，由前半部分唯一确定；\n2. 数字使用频率满足 f(k) = k 或 f(k) = 0；\n3. 所有可能的合法数字组合是有限且可枚举的，因总位数上限受限于 Σk×k = 1×1 + 2×2 + ... + 9×9 = 285，实际更小；\n4. 可按长度递增、数值递增顺序生成候选回文数，确保首次找到的大于 n 的解即为最优解",
      "Transformable Parameters": [
        "n 的数量级（当前为 10^15，可调整至更高或更低）",
        "是否允许前导零",
        "是否要求输出所有特殊数在 [L, R] 范围内（计数型变体）",
        "是否改为小于 n 的最大特殊数（目标方向变换）",
        "是否放宽约束为 '每个数字 k 至多/至少出现 k 次'（约束松弛）",
        "是否允许多组查询（离线或多组数据输入）",
        "是否在线构造（流式输入模式）",
        "是否加入其他数学性质约束（如质数、平方数等复合条件）"
      ]
    }
  },
  {
    "title": "Maximum K to Sort a Permutation",
    "slug": "maximum-k-to-sort-a-permutation",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1]",
        "n ∈ [1, 1e5]",
        "nums 是 [0, n-1] 的一个排列",
        "每个元素为非负整数且唯一"
      ],
      "Core Constraint": [
        "仅当 nums[i] & nums[j] == k 时，允许交换下标 i 和 j 的元素",
        "k 是固定的非负整数（待最大化）",
        "可进行任意次合法交换",
        "交换操作具有传递性和对称性，形成连通分量结构",
        "最终目标是使数组变为非递减顺序（即 [0,1,...,n-1]）"
      ],
      "Objective Function": "最大化满足条件的 k 值，使得在所有满足 (nums[i] & nums[j]) >= k 的位置之间可间接交换的前提下，能够将数组重排为非递减序列",
      "Algorithmic Invariant": [
        "对于固定的 k，若两个下标 i 和 j 满足 nums[i] & nums[j] >= k，则它们可以通过一系列中间节点实现元素互通（连通性）",
        "使用并查集维护在当前 k 下可通过交换连通的位置集合",
        "若每个连通块内的值集合与目标位置上的期望值集合一致，则该 k 可行",
        "k 具有单调性：若 k 可行，则所有 k' < k 也可行 → 可二分答案"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5（支持 O(n log n) 或 O(n log max_val)）",
        "值域范围": "[0, n-1]，且为排列",
        "是否有序": "初始无序，目标为有序",
        "k 的约束形式": "可改为 ≤k、≥k、恰好等于 k 等变形",
        "操作类型扩展": "加入删除/插入操作 → 动态版本",
        "输入形式": "单组输入；可拓展为多组测试数据",
        "在线性": "目前离线；可设计成在线询问不同 k 的可行性",
        "位运算变化": "AND → OR / XOR，改变连通规则",
        "图结构隐式构建方式": "从位运算关系中构建隐式图，可替换为其他边生成逻辑"
      }
    }
  },
  {
    "title": "Minimum Number of Primes to Sum to Target",
    "slug": "minimum-number-of-primes-to-sum-to-target",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度的最小值决定，即 min(maxLeft[i], maxRight[i]) - H[i]（若为正）",
      "Objective Function": "计算整个数组中所有位置可接雨水的总量（求和型）",
      "Algorithmic Invariant": "使用双指针 L 和 R 分别从左右两端向内收缩；维护 maxLeft 和 maxRight 表示当前遍历到的左右侧最高值；若 maxLeft ≤ maxRight，则左指针当前位置的蓄水量可确定并累加，且移动左指针；反之则处理右指针；已计算区域不会被后续操作影响",
      "Transformable Parameters": {
        "H 是否允许负值": false,
        "维度扩展": "可扩展至二维矩阵（如 2D 接雨水问题）",
        "输入形式": "支持离线一次性输入或在线流式更新（带修改操作的版本）",
        "输出要求": [
          "仅求总量",
          "输出每个位置的具体储水量",
          "构造最优储水方案"
        ],
        "数据规模 n": "1 ≤ n ≤ 10^5（标准竞赛规模）",
        "是否多组数据": false,
        "是否循环数组": false
      }
    }
  },
  {
    "title": "Maximum Number of Subsequences After One Inserting",
    "slug": "maximum-number-of-subsequences-after-one-inserting",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "uppercase English letters",
        "length_range": "1 <= n <= 1e5",
        "order_significance": true,
        "modifiability": "at most one insertion of a single uppercase letter at any position"
      },
      "Core Constraint": {
        "subsequence_pattern": "LCT",
        "insertion_limit": 1,
        "insertion_position": "anywhere (beginning, middle, end)",
        "character_set": "only uppercase letters",
        "non_deletion": true,
        "alphabet_independence": "inserted character can be chosen optimally from 'A'-'Z'"
      },
      "Objective Function": "maximize the number of distinct occurrences of subsequence 'LCT' after at most one character insertion",
      "Algorithmic Invariant": {
        "precomputation_invariance": [
          "Count of 'L' prefixes: number of 'L' up to index i",
          "Count of 'LC' subsequences ending before index i",
          "Count of 'CT' or 'T' suffixes starting after index i"
        ],
        "contribution_separation": "The total 'LCT' count after inserting char c at position k is: sum over all ways to form 'LC' in s[0:k] × (if c == 'C' then 1 else 0) × count of 'T' in s[k:] + adjustments for original and new paths",
        "optimal_choice_separation": "Best inserted character is either 'L', 'C', or 'T', depending on where it maximizes bridging between existing partial subsequences",
        "monotonic_accumulation": "Number of 'LC' pairs increases left-to-right; number of 'T' decreases right-to-left — enabling precomputed arrays"
      },
      "Transformable Parameters": {
        "pattern_length": 3,
        "target_subsequence": "configurable (e.g., 'ABC', 'LOV')",
        "insertion_count": "1 (can be generalized to K insertions)",
        "insertion_type": "single-character only, fixed length gain",
        "input_dimensionality": "1D string (can extend to 2D grid of characters)",
        "online_queries": false,
        "data_updates": "static input",
        "alphabet_size": 26,
        "case_sensitivity": "uppercase only, but can be relaxed",
        "output_requirement": "maximum count only (could require construction or location tracking)",
        "multi_query": false,
        "constraints_on_inserted_char": "currently free choice; could restrict to given set"
      }
    }
  },
  {
    "title": "Balanced K-Factor Decomposition",
    "slug": "balanced-k-factor-decomposition",
    "schema": {
      "Input Structure": [
        "整数 n（4 <= n <= 1e5）",
        "整数 k（2 <= k <= 5）",
        "要求将 n 分割为恰好 k 个正整数，其乘积等于 n"
      ],
      "Core Constraint": [
        "分割的 k 个正整数必须满足乘积等于 n",
        "k 严格小于 n 的正因数总数，保证存在多种分解方式",
        "所有数均为正整数且个数固定为 k",
        "因子分解的组合空间受限于 n 的因数结构"
      ],
      "Objective Function": "最小化这 k 个数中的最大值与最小值之差（max - min）",
      "Algorithmic Invariant": [
        "最优解中，数值应尽可能接近几何平均（n^(1/k)）以缩小极差",
        "若将因子按非降序排列，则局部调整不会破坏全局最优性：即更均匀的分布对应更小极差",
        "可通过枚举因数分解 + 剪枝搜索或递归生成所有合法 k 元组，并比较极差",
        "贪心构造：优先使用接近 n^(1/k) 的因数进行分解，保持剩余部分仍可拆分为 k-1 个因数"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": "可扩展至 1e7 或更高（影响因数枚举复杂度）",
          "k 的范围": "当前较小（≤5），可推广至更大的 k（如 k ≤ 20），改变搜索策略需求"
        },
        "输入形式": [
          "单组输入 → 多组测试数据",
          "是否在线输入 n 和 k"
        ],
        "约束条件": [
          "是否允许重复数字（当前允许）",
          "是否要求输出所有最优方案",
          "是否要求字典序最小的输出"
        ],
        "目标函数变形": [
          "最小化极差 → 最大化最小值 / 最小化最大值",
          "改为最小化方差或最大化乘积熵（信息熵）",
          "计数问题：有多少种分割方案使极差最小"
        ],
        "分解限制": [
          "是否要求严格递增/不重复",
          "是否限定质因数分解",
          "是否允许 1 出现（当前允许）"
        ],
        "输出形式": [
          "返回任意一个最优方案 → 返回所有最优方案",
          "返回极差值而非具体数组"
        ]
      }
    }
  },
  {
    "title": "Find Maximum Balanced XOR Subarray Length",
    "slug": "find-maximum-balanced-xor-subarray-length",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length_range": [
          1,
          100000
        ],
        "value_range": [
          0,
          1000000000
        ],
        "properties": [
          "non-empty",
          "continuous subarray allowed"
        ]
      },
      "Core Constraint": {
        "constraint_1": "子数组的按位异或（XOR）结果必须为 0",
        "constraint_2": "子数组中偶数个数与奇数个数相等",
        "structural_insight": "两个条件均可通过前缀信息进行压缩表示：使用 (prefix_xor, diff_count) 二元组作为状态键，其中 diff_count = 偶数个数 - 奇数个数（或反之）"
      },
      "Objective Function": {
        "goal": "最大化满足约束的子数组长度",
        "return_type": "integer",
        "fallback": 0
      },
      "Algorithmic Invariant": {
        "invariant_1": "若两个位置 i 和 j 的前缀 XOR 值相同，且前缀偶奇数量差也相同，则区间 (i, j] 的 XOR 为 0 且偶奇数量相等",
        "invariant_2": "利用哈希表记录最早出现的 (prefix_xor, balance) 状态，后续相同状态可扩展更长合法子数组",
        "invariant_3": "状态转移具有前缀可加性和可合并性，支持 O(1) 扩展"
      },
      "Transformable Parameters": {
        "n_scale": "1e5",
        "value_domain": "non-negative integers up to 1e9",
        "ordered_input": false,
        "circular_array": false,
        "online_queries": false,
        "multiple_test_cases": true,
        "output_detail": "length only",
        "relax_constraints": [
          "xor_k instead of xor_0",
          "allow odd-even difference <= K",
          "require exact count of even/odd",
          "extend to 2D grid paths"
        ],
        "additional_operations": [
          "point updates",
          "range queries",
          "dynamic insertion/deletion"
        ]
      }
    }
  },
  {
    "title": "Minimum Sensors to Cover Grid",
    "slug": "minimum-sensors-to-cover-grid",
    "schema": {
      "Input Structure": [
        "二维网格 G[0..n-1][0..m-1], 其中 n, m ∈ [1, 10^3]",
        "整数 k ≥ 0，表示传感器的切比雪夫距离覆盖半径",
        "每个传感器放置在某个单元格 (r, c)，其覆盖所有满足 max(|r - r'|, |c - c'|) ≤ k 的单元格 (r', c')"
      ],
      "Core Constraint": [
        "单个传感器的覆盖区域是以其为中心、边长为 2k+1 的正方形（若不越界）",
        "覆盖区域具有对称性和空间连续性",
        "多个传感器的覆盖范围可以重叠，但需联合覆盖整个网格",
        "问题本质是集合覆盖的几何特例，利用规则形状和网格结构可避免暴力搜索"
      ],
      "Objective Function": "最小化所需传感器的数量，使得整个 n×m 网格被完全覆盖（即每个单元格至少被一个传感器覆盖）",
      "Algorithmic Invariant": [
        "贪心覆盖不变性：从左上角开始，每次选择能最远向右下扩展未覆盖区域的传感器位置",
        "行优先填充时，当前最左上未覆盖点必须被某个传感器覆盖，且最优策略中该传感器应尽可能向右下延伸",
        "每个新传感器的位置可固定于当前未覆盖区域的‘锚点’附近（如偏移 k 步），以最大化覆盖效率",
        "由于覆盖形状为正方形且规则排列，可通过分块或周期性布局逼近最优解"
      ],
      "Transformable Parameters": {
        "n": "1 <= n <= 10^3（可扩展至 10^5 若允许近似算法）",
        "m": "1 <= m <= 10^3（同上）",
        "k": "0 <= k <= 10^3（关键参数，决定单个传感器覆盖能力）",
        "grid_shape": "是否为矩形 / 是否环形拓扑（如 torus 网格）",
        "distance_metric": "切比雪夫距离 → 曼哈顿距离 → 欧几里得距离（变换度量空间）",
        "coverage_shape": "正方形覆盖 → 十字形 → 圆形近似",
        "sensor_placement_constraint": "可在任意格点放置 → 只能在边界/特定行放置",
        "output_type": "仅求最小数量 → 输出具体部署方案 → 在线增量覆盖查询",
        "dynamic_operations": "静态一次性部署 → 支持添加/删除传感器 → 动态 k 变化",
        "multi_objective": "最小数量 → 最小最大负载（每个传感器负担的格子数）"
      }
    }
  },
  {
    "title": "Minimum Time to Activate String",
    "slug": "minimum-time-to-activate-string",
    "schema": {
      "Input Structure": [
        "长度为 n 的字符串 s，其中 s[i] ∈ {'a'..'z'}",
        "长度为 n 的整数数组 order，是 [0, n-1] 的一个排列",
        "整数 k（目标阈值）",
        "n ∈ [1, 1e5]"
      ],
      "Core Constraint": [
        "在时间 t，下标为 order[0], order[1], ..., order[t] 的字符被替换为 '*'",
        "一个子字符串有效当且仅当它包含至少一个 '*'",
        "所有子字符串总数为 n*(n+1)/2，但只有含 '*' 的才被计入",
        "有效子字符串数量随 '*' 增加而单调不减"
      ],
      "Objective Function": "求最小时间 t（从 0 开始），使得当前字符串中有效子字符串的总数 ≥ k；若无法满足则返回 -1",
      "Algorithmic Invariant": [
        "有效子字符串总数 = 所有包含至少一个 '*' 的连续子串个数",
        "等价于：总子串数 - 所有完全不包含 '*' 的极大连续段的子串数之和",
        "即：total_valid = n*(n+1)/2 - Σ(len_i * (len_i + 1) / 2)，其中 len_i 是第 i 个全字母段的长度",
        "随着 '*' 增加，全字母段被不断分割，其贡献单调递减",
        "使用并查集或双向链表维护连续段，在删除点（插入 '*'）时动态合并相邻段的信息",
        "可在 O(1) 或 O(log n) 时间内更新有效子串数"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可变范围：[1, 1e3] / [1, 1e5] / [1, 1e6]",
        "字符串字符类型": "小写字母 / 大写字母 / 数字 / 任意 ASCII",
        "替换字符": "'*' 或其他特定标记符",
        "order 是否为排列": "是 / 否（允许重复或越界）",
        "是否允许多次操作同一位置": "否（因是排列），可改为允许 → 影响去重逻辑",
        "k 的范围": "1 <= k <= 1e9（可能超过最大有效子串数）",
        "是否在线处理": "离线（已知整个 order）→ 可二分；可改为在线流式输入 order 元素",
        "目标函数变形": "最小时间 → 最大时间 / 判定是否存在某个时刻 / 计数满足条件的时刻数",
        "输入结构维度扩展": "一维字符串 → 二维字符网格，'*'扩散后统计含 '*' 的子矩阵数",
        "约束反转": "≥k → ≤k → 恰好等于 k",
        "隐藏单调性": "显式给出 order → 隐式生成 order（如按哈希规则）"
      }
    }
  },
  {
    "title": "Find Overbooked Employees",
    "slug": "find-overbooked-employees",
    "schema": {
      "Input Structure": [
        "employees: table with schema (employee_id: int, employee_name: varchar, department: varchar), primary key = employee_id",
        "meetings: table with schema (meeting_id: int, employee_id: int, meeting_date: date, meeting_type: varchar, duration_hours: decimal), primary key = meeting_id",
        "Each row in meetings represents one meeting participation by an employee",
        "meeting_type ∈ {'Team', 'Client', 'Training'}",
        "Standard workweek = 40 hours → threshold = 20 hours (50%)"
      ],
      "Core Constraint": [
        "Weekly aggregation is defined on calendar weeks (Monday to Sunday)",
        "An employee's weekly meeting time is the sum of duration_hours for all meetings in that week",
        "A 'meeting-heavy week' occurs when total weekly meeting hours > 20",
        "Only employees with ≥2 such weeks are included in final output",
        "Dependencies across time and grouping require temporal alignment and per-user accumulation"
      ],
      "Objective Function": [
        "Count the number of meeting-heavy weeks per employee",
        "Filter employees having at least 2 meeting-heavy weeks",
        "Output: employee_id, employee_name, department, meeting_heavy_weeks",
        "Sort order: descending by meeting_heavy_weeks, ascending by employee_name"
      ],
      "Algorithmic Invariant": [
        "Week boundaries are fixed (ISO week: Monday–Sunday), enabling deterministic partitioning of dates",
        "Aggregation can be performed independently per (employee_id, week) without interference",
        "After computing weekly totals, comparison against threshold (20h) is monotonic and local",
        "Final filtering (≥2 weeks) and sorting depend only on aggregated counts, not raw data",
        "Grouping → Aggregation → Filtering → Sorting pipeline preserves correctness under relational algebra"
      ],
      "Transformable Parameters": {
        "Temporal Granularity": [
          "weekly",
          "daily",
          "biweekly",
          "monthly"
        ],
        "Workweek Threshold": {
          "base_hours": [
            40,
            32,
            48
          ],
          "threshold_percentage": [
            0.5,
            0.6,
            0.75
          ],
          "absolute_threshold_hours": null
        },
        "Meeting Type Filter": [
          "all types",
          "only specific types (e.g., exclude 'Training')",
          "weighted contribution by type"
        ],
        "Minimum Weeks Requirement": [
          2,
          1,
          3,
          "parameterizable K"
        ],
        "Output Sorting Criteria": [
          "by count desc, name asc",
          "by total meeting hours",
          "by department then count"
        ],
        "Data Dynamics": [
          "static batch input",
          "online streaming meetings (real-time update of counts)",
          "support for meeting updates/deletions"
        ],
        "Input Scope": [
          "single company dataset",
          "multi-tenant with organization_id filter",
          "multiple departments or roles"
        ],
        "Date Range": [
          "unbounded historical data",
          "last N weeks only",
          "specific month/year"
        ]
      }
    }
  },
  {
    "title": "Find Drivers with Improved Fuel Efficiency",
    "slug": "find-drivers-with-improved-fuel-efficiency",
    "schema": {
      "Input Structure": [
        "表 drivers: 包含 driver_id (int, 主键), driver_name (varchar)",
        "表 trips: 包含 trip_id (int, 主键), driver_id (int, 外键), trip_date (date), distance_km (decimal), fuel_consumed (decimal)",
        "数据关系：trips.driver_id → drivers.driver_id",
        "时间范围隐含为完整日历年（1-12月）"
      ],
      "Core Constraint": [
        "仅考虑在上半年（1-6月）和下半年（7-12月）均有至少一次行程的司机",
        "燃油效率按每次行程独立计算：efficiency = distance_km / fuel_consumed",
        "上下半年划分基于 trip_date 的月份，不跨年处理",
        "必须通过聚合（平均值）比较两个时间段的整体表现"
      ],
      "Objective Function": [
        "对每个符合条件的司机：",
        "1. 计算上半年平均燃油效率（first_half_avg）",
        "2. 计算下半年平均燃油效率（second_half_avg）",
        "3. 计算效率提升值：second_half_avg - first_half_avg",
        "4. 返回 driver_id, driver_name, first_half_avg, second_half_avg, efficiency_improvement",
        "5. 所有浮点结果四舍五入至小数点后两位",
        "排序规则：先按 efficiency_improvement 降序，再按 driver_name 升序"
      ],
      "Algorithmic Invariant": [
        "时间区间可静态划分（上/下半年），无需滑动或动态判断",
        "每位司机的上下半年数据可通过分组和条件聚合分离",
        "平均值的计算满足可加性与可分性：avg = sum(efficiency) / count",
        "双阶段聚合不变量：先按 trip 聚合效率，再按 driver 分别统计两时段均值",
        "筛选条件（两时段均有行程）可在分组后通过计数约束保证"
      ],
      "Transformable Parameters": {
        "时间切分方式": [
          "上半年/下半年",
          "季度对比",
          "前k天 vs 后k天",
          "季节性窗口",
          "自定义日期范围"
        ],
        "效率计算方式": [
          "distance / fuel",
          "distance^2 / fuel",
          "加权平均（按距离）",
          "中位数代替平均"
        ],
        "目标变换": [
          "最大化提升",
          "最小化退步",
          "计数类：有多少司机效率提升",
          "判定类：是否提升超过阈值"
        ],
        "约束变化": [
          "允许单侧缺失（补0）",
          "要求连续多期增长",
          "排除异常行程（如fuel=0）"
        ],
        "输出形式": [
          "返回全部字段",
          "仅返回driver_id和improvement",
          "增加排名字段"
        ],
        "数据规模": [
          "司机数量：1e3~1e6",
          "行程数量：稀疏/密集",
          "是否需要索引优化"
        ],
        "是否多组数据": [
          "支持多年份并行分析",
          "按年分组输出"
        ],
        "是否在线": [
          "实时流式trip输入",
          "增量更新平均值",
          "使用滑动时间窗"
        ]
      }
    }
  },
  {
    "title": "Number of Integers With Popcount-Depth Equal to K II",
    "slug": "number-of-integers-with-popcount-depth-equal-to-k-ii",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n], 其中 n <= 1e5, nums[i] ∈ [1, 1e15]",
        "二维查询数组 queries, 每个 query 要么是 [1, l, r, k]（查询），要么是 [2, idx, val]（单点更新）",
        "所有数值均为正整数，popcount-depth 的值域极小（k ≤ 5）"
      ],
      "Core Constraint": [
        "popcount-depth 是一个仅依赖于数值本身的静态函数：每个 x 的深度 d(x) 可预先计算",
        "d(x) 的演化路径由 popcount 迭代决定，且收敛极快（最多约 5 步到 1）",
        "查询与更新交替进行，要求支持动态修改数组并快速回答区间内满足 d(nums[j]) == k 的元素个数"
      ],
      "Objective Function": [
        "对类型 1 查询：计数 —— 统计区间 [l, r] 中满足 popcount-depth 等于 k 的下标 j 的数量",
        "对类型 2 查询：更新 —— 将 nums[idx] 修改为 val",
        "最终输出所有类型 1 查询的结果构成的数组"
      ],
      "Algorithmic Invariant": [
        "popcount-depth 函数具有静态不变性：d(x) 不随上下文变化，可预处理打表",
        "由于 k 很小（≤5），且 d(x) 值域有限（0~5），可以按 depth 分组维护数据结构",
        "支持单点更新和区间查询的数据结构（如线段树、树状数组、分块）保持正确性：每次更新只影响一个位置的 depth 值，可通过先删后增维护计数"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1e5, 支持 O(n log n) 或 O(n √n) 解法",
          "queries_length": "1e5, 强制在线处理"
        },
        "值域": {
          "nums[i]_range": "[1, 1e15], 足够大以防止暴力遍历二进制位",
          "k_range": "[0, 5], 极小，可用于桶分类"
        },
        "是否有序": false,
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": true,
        "操作类型": [
          "区间查询（按条件计数）",
          "单点更新"
        ],
        "可变设计方向": [
          "改为离线查询 → 可用莫队算法",
          "增加区间更新 → 需懒标记线段树",
          "depth 条件变为 ≥k 或 ≤k → 可前缀和优化",
          "扩展到二维数组 → 二维树状数组",
          "popcount 规则变换 → 如 popcount 替换为 digit sum in base 3"
        ]
      }
    }
  },
  {
    "title": "Process String with Special Operations II",
    "slug": "process-string-with-special-operations-ii",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，由小写英文字母和特殊字符 {'*', '#', '%'} 组成",
        "整数 k，表示查询位置（下标从 0 开始）",
        "n ∈ [1, 1e5]",
        "result 字符串最终长度可达 1e15"
      ],
      "Core Constraint": [
        "操作具有顺序依赖性：每个字符的操作基于当前 result 的状态",
        "特殊字符的行为是非局部的：'#' 导致长度翻倍，'%' 改变顺序结构，'*' 删除末尾",
        "不能显式构造完整 result（因长度可能达 1e15），必须避免模拟全过程",
        "仅需返回第 k 个字符，允许惰性计算或逆向追踪"
      ],
      "Objective Function": [
        "查询最终 result 字符串中第 k 个字符",
        "若 k 超出范围，返回 '.'",
        "目标函数是单点查询（Point Query），非构造整个字符串"
      ],
      "Algorithmic Invariant": [
        "可以逆向遍历操作序列，追踪 k 在历史字符串中的来源位置",
        "定义状态 (pos, idx)：在第 pos 个操作后，目标字符对应于当前字符串的 idx 位置",
        "逆向推理时，根据 s[pos] 的类型反向映射 idx 到前一状态的位置",
        "当遇到字母添加：若 idx == len-1，则来自此次添加；否则递归前段",
        "当遇到 '#'：若 idx >= len/2，则来自复制后的副本，映射到 idx - len/2",
        "当遇到 '%'：位置反转，idx 映射为 len-1-idx",
        "当遇到 '*'：若原字符串非空，则当前字符串是删去末尾得到，故目标位置若 < len，则来自前一状态同位置",
        "使用栈或递归记录每一步的长度和操作类型，支持逆向定位"
      ],
      "Transformable Parameters": [
        "s 的长度范围：[1, 1e5] → 可调整至 [1, 1e6] 或支持在线输入",
        "k 的范围：[0, 1e15] → 可扩展为多组 k 查询",
        "是否允许多次查询（如多个 k 值）→ 引入缓存或预处理结构",
        "特殊字符集合可变：例如增加 '~' 表示去重、'@' 表示子串复制等",
        "是否允许嵌套结构更深的操作语义（如递归反转）",
        "输入形式：单次离线处理 → 流式在线处理字符",
        "输出目标变化：第 k 字符 → 最长回文子串长度 / 是否包含某模式等"
      ]
    }
  },
  {
    "title": "Twisted Mirror Path Count",
    "slug": "twisted-mirror-path-count",
    "schema": {
      "Input Structure": {
        "type": "2D grid",
        "dimensions": "m x n",
        "element_type": "binary",
        "values": {
          "0": "empty cell",
          "1": "mirror"
        },
        "start_position": [
          0,
          0
        ],
        "end_position": [
          "m-1",
          "n-1"
        ],
        "movement_restriction": "only right or down",
        "initial_conditions": "grid[0][0] == 0 and grid[m-1][n-1] == 0"
      },
      "Core Constraint": {
        "reflection_rule": {
          "attempt_right_into_mirror": "redirect downward to (i+1, j)",
          "attempt_down_into_mirror": "redirect rightward to (i, j+1)"
        },
        "chained_reflection": "if reflection lands in another mirror, immediate re-reflection occurs following the same rule",
        "boundary_constraint": "any move (including post-reflection) that goes out of bounds invalidates the entire path",
        "deterministic_path": "robot's movement is fully determined by grid layout and initial direction choices; no branching at mirrors"
      },
      "Objective Function": "count the number of distinct valid paths from (0, 0) to (m-1, n-1), modulo 10^9 + 7",
      "Algorithmic Invariant": {
        "state_representation": "dp[i][j][dir] can be used where dir indicates incoming direction (though not needed due to deterministic propagation)",
        "path_independence": "once a cell is reached via a valid sequence, all paths to it are additive modulo arithmetic",
        "no_cycle_in_grid": "due to only right/down moves and reflections preserving progress toward bottom-right, no cycles possible",
        "monotonic_progress": "each move (original or reflected) strictly increases either row or column index over time",
        "dynamic_programming_feasibility": "subproblem: number of ways to reach (i, j); transitions consider both direct entry and indirect via reflection chains"
      },
      "Transformable Parameters": {
        "grid_dimensions": {
          "m_range": "2 <= m <= 500",
          "n_range": "2 <= n <= 500"
        },
        "value_domain": "binary {0, 1}",
        "modular_arithmetic": "required: output mod 1e9+7",
        "multi_query": false,
        "online_input": false,
        "mutation_operations": "could support updates (mirror added/removed)",
        "dimension_extension": "could generalize to 3D or toroidal (wrap-around) grids",
        "movement_rules_variation": [
          "support diagonal moves",
          "allow up/left movements",
          "add different mirror types (e.g., \\ or / reflecting differently)"
        ],
        "reflection_behavior": {
          "chained_reflections": true,
          "bounded_reflection_depth": false
        },
        "output_form": "single integer count (could change to list paths, check existence, minimize/maximize something)"
      }
    }
  },
  {
    "title": "Number of Integers With Popcount-Depth Equal to K I",
    "slug": "number-of-integers-with-popcount-depth-equal-to-k-i",
    "schema": {
      "Input Structure": [
        "正整数 n，表示查询范围 [1, n]",
        "非负整数 k，表示目标 popcount-depth",
        "函数 popcount(x) 定义为 x 的二进制表示中 1 的个数",
        "序列定义：p₀ = x, pᵢ₊₁ = popcount(pᵢ)，直到 p_d = 1",
        "popcount-depth 是最小 d ≥ 0 使得 p_d = 1"
      ],
      "Core Constraint": [
        "每个整数 x 的 popcount-depth 仅依赖于其迭代 popcount 的路径长度",
        "popcount 操作使数值迅速减小（logarithmic 收敛）",
        "所有足够大的数在几次 popcount 后进入小值域（≤ 5 位）",
        "depth 值域极小（k ≤ 5），可预处理所有可能 depth 的分布"
      ],
      "Objective Function": "计数：统计区间 [1, n] 中 popcount-depth 恰好等于 k 的整数个数",
      "Algorithmic Invariant": [
        "popcount-depth 具有函数不变性：depth(x) = 1 + depth(popcount(x))（除非 x == 1）",
        "对于 x > 1，depth 可递归计算；base case: depth(1) = 0",
        "由于 popcount(x) << x，状态空间极小，可打表所有 depth ≤ 5 的数值模式",
        "数位 DP 可用于高效统计满足 depth(x) = k 的 x ∈ [1, n]"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1e15，支持大范围查询",
        "k 的取值范围": "0 <= k <= 5，极小且有限",
        "是否多组数据": "可扩展为多组 (n, k) 查询",
        "是否在线": "可设计为在线查询，预处理 depth 映射后支持 O(1) 或 O(log n) 查询",
        "输入形式变化": [
          "改为输出最小/最大满足条件的 x",
          "改为判定是否存在满足 depth(x) = k 的 x",
          "改为求所有满足条件的 x 的和"
        ],
        "约束变化": [
          "将 popcount 替换为其他位运算函数（如 parity, clz）",
          "将 depth 定义改为首次达到某固定值（如 2 或 3）",
          "加入前导零限制或位长约束"
        ],
        "结构扩展": [
          "从一维整数范围扩展到二维矩阵中元素的 depth 分布",
          "引入动态修改 n 或 k 的流式场景"
        ]
      }
    }
  },
  {
    "title": "Split Array by Prime Indices",
    "slug": "split-array-by-prime-indices",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length_range": [
          1,
          100000
        ],
        "value_range": [
          -1000000000,
          1000000000
        ],
        "index_base": 0,
        "description": "一维整数数组 nums，长度为 n，下标从 0 开始"
      },
      "Core Constraint": {
        "partition_rule": "所有位于质数下标的元素必须分配到数组 A，其余元素分配到数组 B",
        "prime_definition": "质数是大于 1 且仅有两个因子（1 和自身）的自然数",
        "index_dependent": true,
        "constraint_type": "静态划分规则依赖于数组下标是否为质数"
      },
      "Objective Function": {
        "goal": "计算两个子数组和的绝对差值",
        "function": "abs(sum(A) - sum(B))",
        "output_type": "integer",
        "objective_type": "数值计算（绝对差值）"
      },
      "Algorithmic Invariant": {
        "invariant_description": "一旦确定某一下标是否为质数，则其归属（A 或 B）即固定不变",
        "sum_separation": "总和可分解为：sum(A) = 所有质数下标处元素之和，sum(B) = 非质数下标处元素之和",
        "global_partition_independence": "每个元素的归属仅取决于其下标是否为质数，彼此独立，无顺序依赖",
        "computation_optimization": "可通过预处理筛法快速判断多个下标的质数性，实现线性时间内完成划分"
      },
      "Transformable Parameters": {
        "n_value": "1 <= n <= 1e5",
        "value_domain": "nums[i] 可为负数、零或正数",
        "primality_condition": "可变体包括：使用斐波那契下标、回文下标、偶数下标等替代质数下标",
        "objective_variation": [
          "改为求 sum(A) / sum(B) 的比值（需处理 sum(B)=0）",
          "改为判定 |sum(A) - sum(B)| >= K",
          "改为最小化差值的构造问题（允许重排？）"
        ],
        "input_structure_variation": [
          "二维数组中按质数行列下标选取",
          "环形数组下标映射后判断质数性"
        ],
        "data_flow_mode": "当前为离线一次性输入；可扩展为在线流式输入并动态更新差值",
        "output_requirement": "当前仅输出最终差值；可要求输出 A 和 B 的具体构成"
      }
    }
  },
  {
    "title": "Once Twice",
    "slug": "once-twice",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组所能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针 L 和 R 分别从左右两端向内收缩；维护 maxLeft 表示 H[0..L] 的最大值，maxRight 表示 H[R..n-1] 的最大值；若 maxLeft ≤ maxRight，则左指针位置的蓄水量仅由 maxLeft 决定，且可安全更新并右移 L；反之则处理 R；移动过程中已确定区域的解不变",
      "Transformable Parameters": [
        "n 的数量级：1e3 / 1e5 / 1e7（影响是否可用 O(n) 算法）",
        "H[i] 是否允许负数（变形为‘地形坑洼’或非法输入）",
        "是否扩展到二维矩阵（2D 接雨水问题）",
        "是否支持在线查询或动态修改（加入单点更新、区间查询）",
        "是否要求输出每个位置的具体蓄水量而非总和",
        "是否为环形数组（首尾相连）",
        "是否有多组测试数据",
        "输入是否有序（如按高度排序后重构问题）"
      ]
    }
  },
  {
    "title": "Coupon Code Validator",
    "slug": "coupon-code-validator",
    "schema": {
      "Input Structure": [
        "三个长度为 n 的数组：code[1..n]（字符串），businessLine[1..n]（字符串），isActive[1..n]（布尔值）",
        "n >= 1 且 <= 100",
        "code[i] 和 businessLine[i] 由可打印 ASCII 字符组成，长度在 [0, 100] 范围内"
      ],
      "Core Constraint": [
        "一个优惠券有效的条件是三者同时满足：",
        "- code[i] 非空，且每个字符属于 [a-z][A-Z][0-9] 或 '_'",
        "- businessLine[i] ∈ {\"electronics\", \"grocery\", \"pharmacy\", \"restaurant\"}",
        "- isActive[i] == true",
        "有效性判断仅依赖于单个索引 i 的三元组 (code[i], businessLine[i], isActive[i])，无跨位置依赖"
      ],
      "Objective Function": [
        "筛选出所有有效优惠券的 code[i]",
        "返回结果数组，按以下规则排序：",
        "1. 主序：businessLine[i] 按固定类别顺序排序 —— \"electronics\" < \"grocery\" < \"pharmacy\" < \"restaurant\"",
        "2. 次序：在同一 businessLine 内，按 code[i] 的字典升序排列"
      ],
      "Algorithmic Invariant": [
        "过滤操作保持原始索引对应关系不变",
        "排序过程具有稳定偏序结构：主键为有限枚举类型，可映射为整数优先级；次键为字典序，支持自然比较",
        "最终顺序可通过自定义比较器或两轮排序（先按次键，再稳定排序主键）保证正确性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 100（当前小规模，可扩展至 1e5 引入性能约束）",
        "code 字符限制": "当前限定字母数字和下划线，可变形为正则模式匹配或黑名单字符",
        "businessLine 枚举集合": "当前固定四个类别，可参数化为输入给定的有效类别列表",
        "isActive 含义": "当前为布尔值，可改为状态码字段（如整数状态）",
        "排序规则": "businessLine 的优先级顺序可作为输入参数，或要求逆序输出",
        "输出形式": "可变更为计数、最大字典序、分组输出等",
        "是否多组数据": "当前单组输入，可扩展为多测试用例",
        "是否在线": "当前离线处理，可设计为流式优惠券注册与实时查询有效集"
      }
    }
  },
  {
    "title": "Minimum Jumps to Reach End via Prime Teleportation",
    "slug": "minimum-jumps-to-reach-end-via-prime-teleportation",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "index_range": "[0, n-1]",
        "value_domain": "positive integers, 1 <= nums[i] <= 1e6",
        "start_position": 0,
        "target_position": "n - 1"
      },
      "Core Constraint": {
        "movement_rules": [
          "can move to adjacent indices (i-1 or i+1) if within bounds",
          "if nums[i] is a prime p, can teleport to any j != i such that nums[j] % p == 0"
        ],
        "prime_definition": "a natural number > 1 with exactly two divisors: 1 and itself",
        "constraint_type": "hybrid graph expansion: local adjacency + global divisibility-based teleportation from prime values"
      },
      "Objective Function": "minimize the number of jumps (steps) required to reach index n - 1 from index 0",
      "Algorithmic Invariant": {
        "search_strategy": "BFS in implicit graph",
        "state_independence": "once a node is visited with minimal steps, no shorter path exists to it",
        "teleport_optimality": "all teleportations from a prime p can be precomputed and broadcast to all indices j where nums[j] % p == 0",
        "monotonicity": "step count increases monotonically; BFS ensures first arrival is optimal",
        "pruning_rule": "each index needs to be processed at most once per relevant prime broadcast group"
      },
      "Transformable Parameters": {
        "n_value": "up to 1e5",
        "nums_value_range": "up to 1e6",
        "prime_condition": [
          "change to composite-triggered teleport",
          "reverse condition: jump if nums[j] % p != 0",
          "require p divides nums[j] exactly k times"
        ],
        "teleport_scope": [
          "only forward teleport",
          "limit teleport distance",
          "allow only one teleport per prime value"
        ],
        "movement_options": [
          "remove adjacent moves",
          "allow jump to i+2 only",
          "add cost to teleport"
        ],
        "input_form": [
          "multiple queries / online version",
          "dynamic array updates (insert/delete)",
          "circular array"
        ],
        "output_variation": [
          "count number of shortest paths",
          "construct the path",
          "determine if reachable at all"
        ],
        "number_theory_extension": [
          "use perfect numbers, primes, or square-free numbers as trigger",
          "require gcd(nums[i], nums[j]) > 1 instead of prime modulus"
        ]
      }
    }
  },
  {
    "title": "Find COVID Recovery Patients",
    "slug": "find-covid-recovery-patients",
    "schema": {
      "Input Structure": [
        "表 patients: (patient_id: int, patient_name: varchar, age: int), patient_id 为主键",
        "表 covid_tests: (test_id: int, patient_id: int, test_date: date, result: varchar), test_id 为主键",
        "每个患者的多次检测记录通过 patient_id 关联",
        "test_date 为日期类型，支持日期差计算",
        "result 取值为 'Positive', 'Negative', 'Inconclusive'"
      ],
      "Core Constraint": [
        "康复定义为：患者必须有至少一次 'Positive' 检测，且在该次阳性之后（严格日期后）有至少一次 'Negative' 检测",
        "仅考虑首次阳性检测与该阳性之后的首次阴性检测",
        "'Inconclusive' 结果被忽略，不影响康复判断",
        "必须同时具备有效阳性与有效阴性记录才计入输出"
      ],
      "Objective Function": [
        "对每个符合条件的患者：",
        "  - 提取首次阳性检测日期（min(test_date) where result = 'Positive'）",
        "  - 提取首次在该阳性之后的阴性检测日期（min(test_date) > first_positive_date and result = 'Negative'）",
        "  - 计算两者之间的天数差作为 recovery_time",
        "返回字段：patient_id, patient_name, age, recovery_time",
        "排序规则：按 recovery_time 升序，然后按 patient_name 升序"
      ],
      "Algorithmic Invariant": [
        "每位患者的检测序列可按 test_date 排序后线性扫描",
        "首次阳性日期具有单调性：一旦确定，后续更晚的阳性不影响‘首次’定义",
        "首次后续阴性日期可通过遍历排序后的记录，在首个满足 test_date > first_positive_date 且 result = 'Negative' 时确定",
        "结果独立性：不同 patient_id 之间无依赖，可分组独立处理"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n_patients": "1e5 数量级以内",
          "n_tests_per_patient": "可变，稀疏或密集检测"
        },
        "时间约束": {
          "test_date 范围": "可设定为固定区间（如 2020-2023），或相对时间",
          "是否允许未来日期": "可设为约束"
        },
        "结果类型": {
          "是否忽略 Inconclusive": "可改为计入某种状态转移",
          "是否引入新状态（如 'Recovered'）": "可扩展语义"
        },
        "输入形式": {
          "是否多组数据": "支持批量病例分析",
          "是否在线流式输入": "可设计为实时监测系统",
          "是否要求实时更新 recovery_time": "可变为动态查询"
        },
        "目标函数变化": [
          "求平均康复时间",
          "求最长/最短 recovery_time",
          "统计康复率",
          "输出所有中间检测点路径（构造型）"
        ],
        "约束变形": [
          "要求连续两次阴性才算康复",
          "阳性后需间隔 K 天阴性",
          "引入免疫有效期窗口"
        ]
      }
    }
  },
  {
    "title": "Process String with Special Operations I",
    "slug": "process-string-with-special-operations-i",
    "schema": {
      "Input Structure": "字符串 s[1..n]，其中每个字符为小写英文字母或特殊字符 {'*', '#', '%'}；n ∈ [1, 20]",
      "Core Constraint": "操作具有顺序依赖性：当前 result 的状态直接影响后续操作的行为（如删除、复制、反转）；所有操作均基于当前构建的字符串进行原地变换",
      "Objective Function": "构造并返回经过完整规则处理后的最终字符串 result",
      "Algorithmic Invariant": "result 字符串的状态在每一步操作后保持唯一且确定；特殊字符的操作规则是无歧义且可顺序执行的：\n- '*' 删除末尾字符（若存在）\n- '#' 将当前整个字符串复制并追加\n- '%' 反转当前字符串\n- 字母直接追加\n该过程不可逆但具有确定性状态转移",
      "Transformable Parameters": [
        "s 的长度范围（当前为 1–20，可扩展至 1e5 并要求高效算法）",
        "是否引入嵌套控制符（如括号分组操作）",
        "是否支持撤销操作（如 '!' 表示回退上一操作）",
        "是否允许多次反转叠加或优化（如偶数次反转抵消）",
        "是否将 result 存储结构改为 deque 或其他双端数据结构以支持高效反转模拟",
        "是否在线处理字符流（逐字符输入，实时输出中间结果）",
        "是否加入新控制符（如 '^' 表示清空，'@' 表示去重等）",
        "输出形式是否要求记录每步中间状态"
      ]
    }
  },
  {
    "title": "Longest Palindromic Path in Graph",
    "slug": "longest-palindromic-path-in-graph",
    "schema": {
      "Input Structure": {
        "graph_type": "undirected graph",
        "node_count": "n (1 <= n <= 14)",
        "nodes": "labeled from 0 to n-1",
        "edges": "2D array edges[i] = [u_i, v_i], representing an undirected edge between nodes u_i and v_i",
        "labels": "string label of length n, where label[i] is the character associated with node i",
        "constraints": [
          "no duplicate edges",
          "graph is connected or disconnected",
          "each node has a single lowercase letter label"
        ]
      },
      "Core Constraint": {
        "path_constraint": "simple path only (each node visited at most once)",
        "movement_rule": "can start at any node, move to adjacent nodes via edges",
        "label_sequence": "the sequence of characters along the path forms a string",
        "palindrome_condition": "a valid result requires the string formed by node labels on the path to be a palindrome"
      },
      "Objective Function": {
        "goal": "maximize the length of the palindromic string",
        "output_type": "integer: maximum possible length of a palindromic path"
      },
      "Algorithmic Invariant": {
        "state_representation": "use bitmask or set to represent visited nodes due to small n (≤14)",
        "search_strategy": "DFS with memoization over subsets of visited nodes and current position",
        "symmetry_exploitation": "for palindrome, consider symmetry in character frequency: at most one character can have odd count in the path",
        "state_monotonicity": "extending a path maintains prefix/suffix structure; backtracking preserves correctness",
        "invariant_under_extension": "if a partial path cannot extend to a longer palindrome, it can be pruned"
      },
      "Transformable Parameters": {
        "n_value_range": "1 <= n <= 14 → can be increased for approximation/heuristic variants",
        "graph_density": "from tree-like (n-1 edges) to dense (up to complete graph)",
        "label_alphabet": "currently lowercase letters; could generalize to larger alphabet or numeric labels",
        "path_type": "simple path only; could allow cycles if constraints change",
        "objective_variation": [
          "count number of distinct palindromic paths",
          "find lexicographically smallest longest palindrome",
          "require palindrome to be of even/odd length only"
        ],
        "input_form": [
          "offline static graph",
          "could become dynamic (edge insertions/deletions)"
        ],
        "query_mode": "single query; could support multiple queries on same graph with different labels",
        "output_detail": "return length only; could require reconstructing the actual path"
      }
    }
  },
  {
    "title": "Subarrays with XOR at Least K",
    "slug": "subarrays-with-xor-at-least-k",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "notation": "H[1..n]",
        "properties": [
          "one-dimensional",
          "ordered by index",
          "values represent heights"
        ]
      },
      "Core Constraint": {
        "description": "The water trapped at each position is determined by the minimum of the maximum height to the left and the maximum height to the right, minus the current height.",
        "key_conditions": [
          "local contribution depends on global left and right maxima",
          "left and right boundaries are independent but must be consistent",
          "no trapping if current height equals or exceeds both sides"
        ]
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total amount of trapped rainwater",
        "output": "single integer representing cumulative capacity"
      },
      "Algorithmic Invariant": {
        "invariant_description": "At each step, the lower boundary (left or right) determines that the current side's contribution can be safely calculated.",
        "rules": [
          "maintain two pointers L=0, R=n-1 from both ends",
          "track maxLeft and maxRight as running maximums",
          "if maxLeft <= maxRight, then H[L] is bounded by maxLeft, so add maxLeft - H[L] to result and move L forward",
          "else, H[R] is bounded by maxRight, so add maxRight - H[R] to result and move R backward",
          "pointer movement preserves correctness of already computed regions"
        ],
        "proof_basis": "monotonicity of boundary maxima ensures no future height will increase the bottleneck on the smaller side"
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4",
          "up to 1e5 for extended versions"
        ],
        "value_domain": [
          "non-negative integers",
          "can be generalized to allow negative values (with reinterpretation)"
        ],
        "array_ordering": [
          "arbitrary order",
          "can be sorted or partially ordered in variants"
        ],
        "dimensionality": [
          "1D base case",
          "adaptable to 2D grid for 'trapping rainwater II'"
        ],
        "input_mode": [
          "offline batch input",
          "online streaming queries possible"
        ],
        "operation_support": [
          "static array",
          "dynamic updates (update height at index)"
        ],
        "output_granularity": [
          "total sum",
          "per-position breakdown required"
        ],
        "constraints_modification": [
          "capacity defined under different rules (e.g., only count contiguous pools)",
          "add physical constraints like gravity flow or leakage"
        ],
        "multi_query": false,
        "circular_array": false
      }
    }
  },
  {
    "title": "Split and Merge Array Transformation",
    "slug": "split-and-merge-array-transformation",
    "schema": {
      "Input Structure": {
        "type": "two_arrays",
        "description": "两个长度为 n 的整数数组 nums1 和 nums2，其中 nums2 是 nums1 的一个排列",
        "constraints": [
          "n ∈ [2, 6]",
          "nums1[i], nums2[i] ∈ [-10^5, 10^5]",
          "数组元素可重复"
        ]
      },
      "Core Constraint": {
        "description": "拆分合并操作允许将任意连续子数组从原数组中移除，并插入到剩余部分的任意位置；该操作保持子数组内部顺序不变，仅改变其在整体中的相对位置",
        "key_observations": [
          "每次操作可以重排一个连续块的位置",
          "目标是通过最少的操作次数使 nums1 变为 nums2",
          "问题本质是分析 nums1 中已有序匹配于 nums2 的最长连续结构（即：无需被打散的段）"
        ]
      },
      "Objective Function": {
        "type": "minimization",
        "goal": "求将 nums1 转换为 nums2 所需的最少拆分合并操作次数"
      },
      "Algorithmic Invariant": {
        "invariant": "最大可保留的连续匹配段数决定了最小操作次数：若在最终序列中存在 k 个在 nums1 中以相同顺序出现的连续元素段，则这些段之间需要被至少 k-1 次操作分离和重组",
        "insight": "最少操作次数 = (总元素数 - 最长在 nums2 中保持连续且在 nums1 中按序出现的子序列长度) 的某种变形；更准确地说，等价于将 nums1 划分为最少数量的连续子数组，使得它们可以通过重排拼接成 nums2 —— 这对应于寻找最多能保留的、在 nums2 中也连续出现的子数组块",
        "alternative_view": "反向思考：找出最大的一组不相交连续块，这些块在 nums1 中连续，在 nums2 中也连续且顺序一致；则操作次数 = 块数 - 1"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n",
            "range": "small: [2, 6]; extended: up to 1e3 or 1e5",
            "note": "当前题目中 n 很小，适合暴力或状态压缩 DP；增大后需设计更高效算法"
          },
          {
            "name": "array_dimension",
            "values": [
              "1D → 2D"
            ],
            "note": "是否扩展到二维矩阵的块移动问题"
          },
          {
            "name": "operation_type",
            "values": [
              "split-merge",
              "reverse-only",
              "swap-subarrays"
            ],
            "note": "替换为其他类型的重排操作"
          },
          {
            "name": "input_form",
            "values": [
              "offline",
              "online_streaming"
            ],
            "note": "是否支持动态更新数组"
          },
          {
            "name": "output_requirement",
            "values": [
              "min_operations",
              "construction_path",
              "number_of_ways"
            ],
            "note": "输出最小步数 vs 输出方案数 vs 构造具体操作序列"
          },
          {
            "name": "constraint_on_blocks",
            "values": [
              "must_be_contiguous",
              "can_overlap",
              "with_cost_model"
            ],
            "note": "加入对移动块大小或频率的限制"
          },
          {
            "name": "data_property",
            "values": [
              "distinct_elements",
              "with_duplicates",
              "ordered_input"
            ],
            "note": "是否所有元素互异，影响匹配策略"
          },
          {
            "name": "multi_query",
            "value": false,
            "note": "是否多组目标数组查询同一源数组"
          }
        ]
      }
    }
  },
  {
    "title": "Minimum Cost Path with Alternating Directions II",
    "slug": "minimum-cost-path-with-alternating-directions-ii",
    "schema": {
      "Input Structure": {
        "type": "2D grid",
        "dimensions": "m x n, where m >= 1, n >= 1",
        "entry_cost_function": "(i + 1) * (j + 1) for cell (i, j)",
        "wait_cost_matrix": "waitCost[i][j], an integer matrix of size m x n",
        "movement_rules": {
          "odd_seconds": "move right or down to adjacent cell",
          "even_seconds": "wait in current cell for 1 second"
        },
        "start_point": "(0, 0)",
        "end_point": "(m - 1, n - 1)",
        "initial_action": "enter (0, 0) at time 1 with entry cost"
      },
      "Core Constraint": {
        "temporal_action_dependency": "action at each second depends on parity of time step",
        "alternating_behavior": "strict alternation between movement (odd) and waiting (even)",
        "path_continuity": "movement only allowed to adjacent cells (right/down), forming a monotonic path in grid",
        "state_dependence": "total cost depends on both position and time modulo 2"
      },
      "Objective Function": "minimize total cost to reach (m - 1, n - 1), including all entry costs and wait costs along the path",
      "Algorithmic Invariant": {
        "state_representation": "DP state: (i, j, t_mod_2) representing minimum cost to reach (i, j) at odd/even second",
        "optimal_substructure": "minimum cost to (i, j) can be derived from its top and left neighbors",
        "time_parity_preservation": "each move changes time parity; waiting preserves position but flips parity",
        "monotonic_progression": "only right/down moves ensure no cycles, enabling DP ordering by i + j",
        "cost_separation": "entry cost paid once per cell upon first entry; wait cost paid per even-second wait"
      },
      "Transformable Parameters": {
        "grid_size": "m, n ∈ [1, 1e5], with 2 <= m*n <= 1e5",
        "wait_cost_range": "0 <= waitCost[i][j] <= 1e5",
        "movement_directions": [
          "original: right/down only",
          "variant: add left/up under constraints"
        ],
        "time_pattern": [
          "original: odd=move, even=wait",
          "reversed: odd=wait, even=move",
          "k-periodic: every k-th second requires wait"
        ],
        "entry_cost_formula": [
          "original: (i+1)*(j+1)",
          "parametric: f(i,j) = a*i^2 + b*j + c"
        ],
        "waiting_duration": [
          "original: exactly 1 second per even tick",
          "variable: wait multiple seconds with cumulative cost"
        ],
        "output_form": [
          "minimum total cost",
          "also return optimal path sequence",
          "count number of optimal paths"
        ],
        "input_mode": [
          "offline: full waitCost given",
          "online: waitCost revealed dynamically"
        ],
        "cell_revisiting": [
          "not allowed (implied by monotonic movement)",
          "allowed in variants — introduces cycles"
        ]
      }
    }
  },
  {
    "title": "Minimum Cost Path with Alternating Directions I",
    "slug": "minimum-cost-path-with-alternating-directions-i",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示柱状图中每个位置的高度",
      "Core Constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度中的较小值决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组所能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max：当 left_max ≤ right_max 时，左指针位置的蓄水量仅由 left_max 决定，右指针同理；移动较短侧指针可保证未访问区域不会影响已确定位置的贡献",
      "Transformable Parameters": [
        "n 的数量级：可变范围 [1, 10^4] 或扩展至 [1, 10^6]（影响解法选择）",
        "H[i] 值域：非负整数 → 可推广至实数或允许负值（需重新定义物理意义）",
        "是否有序：原题无序，可构造单调序列变体",
        "维度扩展：1D → 2D（二维接雨水问题）",
        "输入形式：单次离线输入 → 支持动态修改/删除/插入操作（在线版本）",
        "输出要求：总蓄水量 → 每个位置的具体蓄水量分布",
        "边界条件：线性结构 → 环形数组（首尾相连）"
      ]
    }
  },
  {
    "title": "Count Odd Letters from Number",
    "slug": "count-odd-letters-from-number",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示柱状图中每个位置的高度",
      "Core Constraint": "每个位置能接雨水的量由其左侧最大高度和右侧最大高度中的较小值决定；若当前高度低于该值，则可蓄水，否则不能",
      "Objective Function": "计算整个数组所能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max：当 left_max ≤ right_max 时，左指针位置的蓄水量仅受限于 left_max，可直接计算并右移左指针；反之亦然。指针移动过程中不破坏已确定区域的最优性",
      "Transformable Parameters": {
        "数据范围": "n 的数量级可设为 1e4、1e5 或更大，影响解法选择（如是否可用 O(n) 空间）",
        "值域限制": "H[i] 是否非负（允许负值则需重新定义物理意义）",
        "维度扩展": "可推广至二维矩阵（2D接雨水问题）",
        "输入形式": "支持离线批量处理或在线流式输入（动态添加柱子）",
        "操作类型": "支持单点修改、区间更新等操作（转为数据结构题）",
        "输出要求": "可要求输出总容量、每列容量、最大连续蓄水区间等",
        "结构变形": "数组是否环形连接（首尾相连形成环形地貌）"
      }
    }
  },
  {
    "title": "Minimum Moves to Reach Target in Grid",
    "slug": "minimum-moves-to-reach-target-in-grid",
    "schema": {
      "Input Structure": [
        "二维整数坐标起点 (sx, sy) 和终点 (tx, ty)",
        "满足 0 <= sx <= tx <= 1e9",
        "0 <= sy <= ty <= 1e9",
        "定义操作：在任意点 (x, y)，令 m = max(x, y)，可移动至 (x + m, y) 或 (x, y + m)"
      ],
      "Core Constraint": [
        "每一步的移动步长由当前坐标的最大值决定，即 m = max(x, y)",
        "只能增加坐标，不能减少，路径具有单向性",
        "从 (sx, sy) 出发只能向右或向上扩展，且每次扩展至少为 max(x, y)",
        "若目标点 (tx, ty) 不在任何合法转移路径上，则不可达"
      ],
      "Objective Function": [
        "求从 (sx, sy) 到 (tx, ty) 的最小移动次数",
        "若无法到达，返回 -1",
        "目标函数类型：最小化（minimization）与可达性判定（decision）结合"
      ],
      "Algorithmic Invariant": [
        "反向搜索不变性：从 (tx, ty) 反推前驱状态是唯一的（在多数情况下）",
        "若 tx > ty，则最后一步必然是从 (tx - max_val, ty) 而来，其中 max_val >= ty，故 max_val = tx - prev_x = tx（因 tx > ty）=> 前一步为 (tx % ty, ty) 类似辗转相除",
        "状态演化具有类欧几里得结构：通过取模快速跳过多步相同方向移动",
        "正向贪心不可行，但反向还原路径具有单调递减和唯一前驱候选的性质",
        "每轮缩小较大坐标，保持 sx <= tx, sy <= ty 的约束下逼近起点"
      ],
      "Transformable Parameters": [
        "数据规模：sx, sy, tx, ty 的范围（当前为 1e9，支持大数）",
        "是否允许负坐标（当前不允许）",
        "移动规则变化：m = min(x, y) 或 m = x + y",
        "操作种类变化：增加 (x - m, y) 或 (x, y - m)（引入回退机制）",
        "目标函数变换：求方案数 / 判断是否存在路径 / 输出路径序列",
        "是否多组查询：给定多对 (tx, ty)，固定起点 (sx, sy)，在线回答",
        "维度扩展：3D 版本，允许 (x+m,y,z), (x,y+m,z), (x,y,z+m)"
      ]
    }
  },
  {
    "title": "Find Consistently Improving Employees",
    "slug": "find-consistently-improving-employees",
    "schema": {
      "Input Structure": [
        "employees: table with schema (employee_id: int, name: varchar), employee_id is primary key",
        "performance_reviews: table with schema (review_id: int, employee_id: int, review_date: date, rating: int), review_id is primary key",
        "rating ∈ [1,5], integer",
        "Each employee can have multiple performance reviews over time"
      ],
      "Core Constraint": [
        "Only employees with at least 3 performance reviews are considered",
        "For each employee, the last 3 reviews must be selected by review_date in descending order",
        "The ratings of these 3 most recent reviews must form a strictly increasing sequence: rating₁ < rating₂ < rating₃",
        "Temporal ordering matters: analysis is based on chronological sequence of reviews"
      ],
      "Objective Function": [
        "Filter and identify employees satisfying strict monotonic improvement in last 3 reviews",
        "Compute improvement_score = last_rating - first_rating among the last 3 reviews",
        "Return employee_id, name, and improvement_score",
        "Sort by improvement_score in descending order, then by name in ascending order"
      ],
      "Algorithmic Invariant": [
        "For each employee, sorting reviews by review_date ensures correct temporal window",
        "Window size fixed to 3 most recent entries; older entries do not affect result once window is extracted",
        "Strictly increasing condition is local to the 3-element subsequence and verifiable in O(1) after sorting",
        "Improvement score computation depends only on endpoints of valid triple, invariant under intermediate values as long as monotonicity holds"
      ],
      "Transformable Parameters": {
        "Minimum review count": "3 (can be parameterized: k reviews required)",
        "Rating range": "[1,5] (can vary, e.g. [0,10] or float scores)",
        "Monotonicity type": "strictly increasing (can change to non-decreasing, decreasing, etc.)",
        "Time window selection": "last 3 reviews by date (can become sliding time window: e.g. last 12 months)",
        "Improvement metric": "difference between first and last (alternatives: sum of increments, average slope)",
        "Sorting criteria": "improvement_score DESC, name ASC (can include employee_id, rating trend stability, etc.)",
        "Data frequency": "multiple reviews per time unit allowed (can impose constraints like one review per quarter)",
        "Online processing": "batch input now; could extend to stream of reviews with real-time updates",
        "Output granularity": "only top performers (can return all with flag, or include near-misses)"
      }
    }
  },
  {
    "title": "Minimum Stability Factor of Array",
    "slug": "minimum-stability-factor-of-array",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "nums: array of integers with length n, where 1 <= n <= 10^5",
          "1 <= nums[i] <= 10^9",
          "maxC: integer representing maximum number of allowed modifications, 0 <= maxC <= n"
        ],
        "properties": [
          "subarray is contiguous",
          "HCF of a single element x is x itself"
        ]
      },
      "Core Constraint": {
        "definition": "A subarray is stable if the HCF (GCD) of all its elements >= 2.",
        "key_insight": "HCF of a set is monotonic under inclusion: adding more elements can only decrease or maintain the HCF.",
        "dependency_structure": "Stability of a subarray depends on global divisibility properties; breaking long divisible sequences requires strategic modifications.",
        "constraint_logic": "The problem reduces to preventing long contiguous intervals from having a common divisor >= 2, using at most maxC changes."
      },
      "Objective Function": {
        "goal": "minimize",
        "target": "the stability factor, defined as the length of the longest stable subarray after at most maxC modifications",
        "fallback": "return 0 if no stable subarray exists (though in practice minimum is 1 if any element >=2 remains)"
      },
      "Algorithmic Invariant": {
        "invariant_type": "sliding window with feasibility check under budget constraint",
        "core_invariant": "For a fixed target stability factor L, we can verify whether it's possible to eliminate all stable subarrays of length > L using <= maxC modifications.",
        "monotonicity": "If stability factor L is achievable, then L+1 is also achievable; thus binary search on answer is valid.",
        "greedy_feasibility": "Within a feasibility check for max_length = L, use sliding window to detect maximal intervals where HCF >= 2 and length > L; cover them optimally with minimal replacements (greedy interval covering).",
        "decoupling": "Answer structure allows decoupling: outer binary search on result, inner O(n) or O(n log(max_value)) checks via segment tree / sparse table for range GCD and two-pointer scanning."
      },
      "Transformable Parameters": {
        "n_scale": "1 <= n <= 10^5 → can be reduced to 1e3 for educational version or increased with efficient data structures",
        "value_domain": "nums[i] up to 1e9 → could be bounded to small values (e.g., <= 100) to allow factorization-based preprocessing",
        "order_property": "array is unordered; variant can assume structured input (e.g., sorted, periodic)",
        "modification_model": [
          "maxC modifications allowed → can become exact k modifications",
          "cost-weighted modifications (each index has cost)",
          "only allow specific values after modification (e.g., must be prime)"
        ],
        "online_queries": "static array → dynamic version with updates and queries on stability factor",
        "output_form": [
          "return minimum stability factor → return configuration achieving it",
          "count number of optimal solutions"
        ],
        "structural_variation": [
          "1D array → 2D grid, find largest stable submatrix",
          "circular array → wrap-around subarrays considered"
        ],
        "constraint_transformation": [
          "change threshold from >=2 to >=K",
          "define stability by LCM instead of HCF",
          "require HCF == 1 (opposite condition)"
        ]
      }
    }
  },
  {
    "title": "Network Recovery Pathways",
    "slug": "network-recovery-pathways",
    "schema": {
      "Input Structure": [
        "有向无环图（DAG），节点数为 n，编号从 0 到 n-1",
        "边集 edges，长度为 m，每条边为 [u_i, v_i, cost_i]，表示从 u_i 到 v_i 的有向边，恢复成本为 cost_i",
        "布尔数组 online[0..n-1]，online[i] 表示节点 i 是否在线",
        "起点为 0，终点为 n-1，二者始终在线",
        "约束：2 <= n <= 5 * 10^4, 0 <= m <= min(10^5, n*(n-1)/2), 0 <= cost_i <= 10^9, 0 <= k <= 5 * 10^13"
      ],
      "Core Constraint": [
        "路径必须从节点 0 到节点 n-1",
        "路径上的所有中间节点必须满足 online[i] == true",
        "路径的总边成本 ≤ k",
        "目标不是最短路，而是最大化路径上的最小边成本（即瓶颈边）",
        "由于是 DAG，存在拓扑序，可用于动态规划或按序松弛"
      ],
      "Objective Function": "在所有满足约束的有效路径中，求最大化的路径分数，其中路径分数定义为该路径上所有边成本的最小值；若无有效路径，返回 -1",
      "Algorithmic Invariant": [
        "可以使用二分答案 + 可达性验证：假设最大可行的最小边成本为 x，则只保留边权 ≥ x 的边，并检查是否存在一条从 0 到 n-1 的路径，其总成本 ≤ k 且仅经过在线节点",
        "随着 x 增大，可走的边减少，可达性单调递减 → 满足二分性质",
        "在固定 x 下的图遍历中，使用 DAG 上的动态规划或拓扑排序进行状态转移，状态 dp[u] 表示到达节点 u 的最小总成本",
        "状态转移满足：若边 (u,v,cost) 满足 cost >= x 且 online[v] 为真，则可用 dp[u] + cost 更新 dp[v]"
      ],
      "Transformable Parameters": [
        "图结构：DAG → 一般有向图（引入环后需处理负环或 SCC 缩点）",
        "目标函数变换：最大最小边 → 最小最大边 → 总成本最小化 → 计数类（有多少条满足条件的路径）",
        "约束变化：k 改为 ≥K（反向约束）→ 路径必须恰好等于 k",
        "数据流化：边在线添加 → 支持动态插入边的查询",
        "节点状态变化：online 数组变为动态可变（支持开关操作）",
        "输入形式：多组测试用例 / 单组输入",
        "是否要求输出具体路径方案",
        "边权类型：非负整数 → 可为负数（影响二分和 DP 正确性）",
        "图维度扩展：单层 DAG → 分层图或多维状态图"
      ]
    }
  },
  {
    "title": "Check Divisibility by Digit Sum and Product",
    "slug": "check-divisibility-by-digit-sum-and-product",
    "schema": {
      "Input Structure": [
        "正整数 n",
        "1 <= n <= 10^6",
        "n 的位数最多为 7 位（因 10^6 有 7 位）",
        "数字和：各位数字之和",
        "数字积：各位数字之积（注意：若含 0，则积为 0）"
      ],
      "Core Constraint": [
        "数字和与数字积的计算依赖于 n 的十进制表示的每一位",
        "数字积在包含数字 0 时为 0，此时两值之和即为数字和",
        "判定条件完全由 n 的数位分解结果决定，无需外部状态",
        "问题具有可分离性：只需遍历 n 的每一位即可完成全部计算"
      ],
      "Objective Function": [
        "判定：n 是否能被 (digit_sum + digit_product) 整除",
        "返回布尔值：true 或 false"
      ],
      "Algorithmic Invariant": [
        "数位分解过程是确定性的：从个位到高位逐位取模或字符串遍历均可正确提取每位数字",
        "数字和与数字积的计算满足累加/累乘不变性：顺序不影响结果",
        "整除判断不变性：(n % (digit_sum + digit_product)) == 0 是最终判定依据，且仅当分母非零时有效"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^k，k 可调整（当前 k=6）",
        "是否允许前导零": "否（n 是正整数）",
        "是否包含零位": "是，影响数字积（可引入边界情况）",
        "输入形式": "单个整数 n（可改为数组批量处理或多组测试数据）",
        "输出形式": "布尔值（可扩展为列出所有满足条件的 n）",
        "是否在线": "否（一次性输入），可改造为流式输入各位数字",
        "数字操作变换": [
          "目标函数变化：改为能否被 digit_sum 整除？或 digit_product？",
          "约束反转：要求 digit_sum + digit_product 能被 n 整除？",
          "计数类变形：[1, N] 内有多少个 n 满足该性质？",
          "进制变换：改为二进制、十六进制下的数字和与积？"
        ],
        "异常处理参数": "当 digit_sum + digit_product == 0 时如何处理（实际不会发生，因 n >= 1，至少有一位非零）"
      }
    }
  },
  {
    "title": "Minimum Time to Reach Destination in Directed Graph",
    "slug": "minimum-time-to-reach-destination-in-directed-graph",
    "schema": {
      "Input Structure": [
        "有向图 G = (V, E), 其中 V = {0, 1, ..., n-1}, |V| = n",
        "边集 edges 表示为二维数组，edges[i] = [u_i, v_i, start_i, end_i]",
        "每条边 e ∈ E 是一个四元组 (u, v, s, t)，表示从 u 到 v 的有向边，在时间区间 [s, t] 内可用",
        "整数 n 表示节点数量，1 <= n <= 1e5",
        "时间域为整数，且 0 <= start_i <= end_i <= 1e9"
      ],
      "Core Constraint": [
        "边只能在指定时间窗口 [start_i, end_i] 内被使用",
        "每个时间单位可选择：停留原地 或 沿着当前可用的出边移动",
        "路径的时间是逐步递增的，不允许时间倒流",
        "转移依赖于当前时间与边的时间约束的交集"
      ],
      "Objective Function": "最小化从节点 0 出发到达节点 n-1 的时间；若不可达则返回 -1",
      "Algorithmic Invariant": [
        "使用 Dijkstra 算法框架维护到达各节点的最早时间 dist[v]",
        "状态定义为 (node, earliest_arrival_time)，按时间从小到大扩展",
        "一旦某个节点 v 被以时间 T 首次访问，则后续不会通过更小时间到达该节点",
        "对于每条边 (u, v, s, e)，只有当当前时间 t >= s 时才可考虑使用；实际出发时间为 max(t, s)，到达时间为 max(t, s) + 1",
        "贪心选择不变性：优先处理时间最小的状态，确保首次到达目标节点的时间最优"
      ],
      "Transformable Parameters": [
        "n 的数量级：1e3 / 1e5（影响是否可用朴素或堆优化）",
        "边的数量：稀疏图 vs 稠密图",
        "时间范围：[0, 1e9] 是否支持离散化或在线查询",
        "是否允许多次经过同一节点（本题允许）",
        "是否支持动态加边（离线 vs 在线）",
        "目标函数变换：从‘最小时间’变为‘是否存在路径’、‘最大时间限制下可达性’",
        "约束反转：改为必须在时间窗口外使用边",
        "输入维度扩展：二维时间窗（如周期性可用）、多资源约束",
        "是否要求输出路径方案而非仅时间",
        "是否加入等待代价限制（最多连续等待 k 时间）"
      ]
    }
  },
  {
    "title": "Maximum Product of Two Integers With No Common Bits",
    "slug": "maximum-product-of-two-integers-with-no-common-bits",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "整数类型，满足 2 <= n <= 10^5",
        "每个元素满足 1 <= nums[i] <= 10^6",
        "无序，可重复"
      ],
      "Core Constraint": [
        "两个数 nums[i] 和 nums[j] 的二进制表示中不能有任何公共置位（即 (nums[i] & nums[j]) == 0）",
        "i ≠ j",
        "按位与为零的数对才合法"
      ],
      "Objective Function": [
        "最大化乘积 nums[i] * nums[j]",
        "若不存在满足条件的数对，返回 0"
      ],
      "Algorithmic Invariant": [
        "对于任意两个数 a 和 b，若 a & b == 0，则它们可以构成候选答案",
        "最大乘积未必来自全局最大的两个数，但若最大两数无公共位，则其乘积为最优",
        "可以通过枚举数值范围内的互补掩码（complement mask）来加速查找合法配对",
        "状态空间具有子集单调性：若 a & b == 0，则 b 是 a 的按位取反的子集"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "10^2",
            "10^3",
            "10^5"
          ],
          "值域范围": [
            "1 <= nums[i] <= 10^6",
            "扩展至 1 <= nums[i] <= 2^20"
          ]
        },
        "输入形式": [
          "单组输入",
          "多组测试用例"
        ],
        "是否在线": false,
        "约束变化": [
          "从 '无公共置位' 改为 '至少有一个公共置位'",
          "改为求最小乘积",
          "改为计数满足条件的数对个数",
          "增加下标顺序约束（如 i < j）"
        ],
        "结构扩展": [
          "从一维数组扩展到两个数组，求跨数组无公共位的最大乘积",
          "从两数乘积扩展到三元组乘积且三者两两无公共位"
        ],
        "输出形式": [
          "仅返回最大乘积",
          "返回具体下标 i, j",
          "返回所有最优方案"
        ]
      }
    }
  },
  {
    "title": "Check if Any Element Has Prime Frequency",
    "slug": "check-if-any-element-has-prime-frequency",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "n ∈ [1, 100]",
        "nums[i] ∈ [0, 100]",
        "允许重复元素"
      ],
      "Core Constraint": [
        "元素频次定义为其在数组中出现的次数",
        "质数定义为大于1且因数仅为1和自身的自然数",
        "频次与值本身无关，仅依赖于全局计数"
      ],
      "Objective Function": "判定是否存在至少一个元素，其频次为质数（存在性判断）",
      "Algorithmic Invariant": [
        "频次统计具有可加性和独立性：每个元素的频次可单独计算而不影响其他元素",
        "质数集合在小范围内（≤100）可预计算，具有静态不变性",
        "一旦完成频次统计，判定过程是逐项独立、可并行的"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": "1 <= n <= 100",
          "值域范围": "0 <= nums[i] <= 100"
        },
        "频次性质": {
          "目标函数变换": [
            "判定存在质数频次",
            "要求最大/最小质数频次",
            "计数具有质数频次的元素个数"
          ],
          "约束反转": [
            "频次是否为合数",
            "频次是否为偶数/奇数"
          ]
        },
        "输入形式": {
          "是否有序": false,
          "是否多组数据": true,
          "是否在线输入": false
        },
        "扩展变形": [
          "二维数组中元素频次判定",
          "字符串中字符频次是否为质数",
          "动态插入删除下的频次质数查询（支持更新操作）",
          "要求连续子数组中某元素频次为质数（引入区间约束）"
        ]
      }
    }
  },
  {
    "title": "Partition Array to Minimize XOR",
    "slug": "partition-array-to-minimize-xor",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non_negative_integers",
        "constraints": [
          "nums: integer array of length n, where 1 <= n <= 250",
          "each element satisfies 1 <= nums[i] <= 1e9",
          "k: integer partition count, 1 <= k <= n"
        ],
        "properties": [
          "values are positive integers",
          "subarrays must be contiguous and non-empty",
          "exactly k subarrays required"
        ]
      },
      "Core Constraint": {
        "description": "The value of each subarray is defined by the XOR of its elements. The goal is to minimize the maximum XOR across all k partitions. The optimal solution requires balancing partition boundaries such that no single segment has excessively high XOR, leveraging the fact that XOR is associative and prefix-computable.",
        "key_insight": "Prefix XOR allows O(1) range XOR computation; dynamic programming state depends on previous cuts and accumulated XOR values.",
        "dependency_structure": "Partition decisions are sequential and affect future feasible splits; local choices influence global max-min objective."
      },
      "Objective Function": {
        "type": "minimax",
        "goal": "minimize the maximum XOR value among k contiguous subarrays",
        "output_type": "integer",
        "semantic": "Find the smallest possible value of the largest XOR over all valid k-partitions."
      },
      "Algorithmic Invariant": {
        "primary_invariant": "For any prefix ending at index i split into j parts, the DP state dp[i][j] represents the minimal possible value of the maximum XOR in such a configuration.",
        "recurrence_property": "dp[i][j] = min_{m < i} { max(dp[m][j-1], xor(m+1, i)) }, where xor(l, r) can be computed via prefix XOR array.",
        "monotonicity": "Increasing k never increases the answer (more splits allow finer control), but decreasing k may force higher XOR segments.",
        "optimality_preservation": "Once a cut is made with a certain max-XOR bound, further extensions do not invalidate prior feasibility under relaxation."
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          250
        ],
        "value_domain": [
          1,
          1000000000
        ],
        "k_range": "1 <= k <= n",
        "array_order": "ordered, contiguous segments only",
        "data_modification": "static input (offline)",
        "input_form": "single test case or multiple test cases (can be extended)",
        "online_query": false,
        "cyclic_array": false,
        "allow_empty_subarrays": false,
        "xor_operation_variants": [
          "replace XOR with sum → becomes 'Split Array Largest Sum' (LeetCode 410)",
          "replace objective: maximize minimum XOR → different greedy structure",
          "add constraint: each subarray length >= L"
        ],
        "extensions": [
          "support updates (dynamic array)",
          "query for number of optimal schemes (counting variant)",
          "return actual partition indices (construction variant)"
        ]
      }
    }
  },
  {
    "title": "Hexadecimal and Hexatrigesimal Conversion",
    "slug": "hexadecimal-and-hexatrigesimal-conversion",
    "schema": {
      "Input Structure": "整数 n，其中 1 <= n <= 1000",
      "Core Constraint": "需要分别计算 n² 的十六进制表示和 n³ 的三十六进制表示，并将两个字符串拼接；进制转换规则固定：十六进制使用 0–9 和 A–F（基16），三十六进制使用 0–9 和 A–Z（基36）",
      "Objective Function": "构造并返回一个字符串，为 n² 的十六进制表示与 n³ 的三十六进制表示的拼接结果",
      "Algorithmic Invariant": "进制转换过程可通过不断除以基数取余数逆序构造字符串；对于非负整数 x 和基数 b，其 b 进制表示是唯一的；拼接顺序固定为先十六进制后三十六进制",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1000",
        "值域": "n 为正整数，n² 最大为 1e6，n³ 最大为 1e9，均在标准整型范围内",
        "是否有序": "输入为单个整数，无序结构",
        "是否循环": "否",
        "是否多组输入": "可扩展为多组测试数据",
        "是否在线": "当前为离线单次输入，可改造为在线批量处理",
        "进制基数": "可变参数：十六进制（16）和三十六进制（36）可泛化为任意进制对 (b1, b2)",
        "输出形式": "可要求仅返回某一部分、或加入分隔符、或反转拼接顺序",
        "字符集映射": "可修改为小写字母、自定义符号表等"
      }
    }
  },
  {
    "title": "Find the Shortest Superstring II",
    "slug": "find-the-shortest-superstring-ii",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度中的较小值决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组所能接住的雨水总量（求和）",
      "Algorithmic Invariant": "维护两个指针 L 和 R 分别从左右两端向中间移动，同时记录 left_max 和 right_max；当 left_max ≤ right_max 时，L 处的积水可以确定（反之亦然），指针移动过程中不破坏已计算区域的正确性",
      "Transformable Parameters": {
        "数值范围": "H[i] 是否允许负数（如沟壑模型）",
        "维度扩展": "是否推广到二维矩阵（2D 接雨水问题）",
        "输入模式": "是否在线输入或支持动态更新（如单点修改后重新查询）",
        "输出要求": "是否需要输出每个位置的具体蓄水量而非总和",
        "操作类型": "是否支持插入、删除、区间查询等操作（转化为数据结构题）",
        "数据规模": "n 的数量级（例如 1e3 / 1e5 / 1e7，影响解法选择）",
        "数组性质": "是否有序、是否循环（环形地形接雨水）"
      }
    }
  },
  {
    "title": "Find Books with No Available Copies",
    "slug": "find-books-with-no-available-copies",
    "schema": {
      "Input Structure": [
        "Two relational tables: library_books and borrowing_records",
        "library_books(book_id: int, title: varchar, author: varchar, genre: varchar, publication_year: int, total_copies: int)",
        "borrowing_records(record_id: int, book_id: int, borrower_name: varchar, borrow_date: date, return_date: date)",
        "book_id is foreign key linking both tables",
        "return_date is NULL if the book is currently borrowed"
      ],
      "Core Constraint": [
        "A book is considered currently borrowed if there exists a record with return_date = NULL",
        "The number of currently borrowed copies for a book = count of records in borrowing_records with matching book_id and return_date IS NULL",
        "Available copies = total_copies - current_borrowers",
        "Only books with current_borrowers > 0 AND available_copies <= 0 are selected"
      ],
      "Objective Function": [
        "Filter and output books that are currently borrowed and have no available copies (i.e., all copies are checked out)",
        "Compute current_borrowers as an aggregated count per book",
        "Return full book details along with current_borrowers",
        "Sort by current_borrowers in descending order, then by title in ascending order"
      ],
      "Algorithmic Invariant": [
        "Aggregation on borrowing_records by book_id preserves one-to-many relationship between books and borrow records",
        "Counting only non-returned records (return_date IS NULL) correctly reflects current demand",
        "Joining after aggregation ensures correctness when filtering on availability constraint",
        "Sorting is stable and deterministic given secondary sort on title"
      ],
      "Transformable Parameters": {
        "Data Scale": {
          "n_books": "1e3 to 1e6",
          "n_records": "1e4 to 1e7"
        },
        "Constraints": [
          "Whether multiple simultaneous borrows per user are allowed",
          "Whether a user can borrow multiple copies of the same book"
        ],
        "Input Variants": [
          "Single table input with denormalized schema",
          "Time-range queries (e.g., during peak season)",
          "Partial index on return_date IS NULL"
        ],
        "Output Requirements": [
          "Include borrower names as array/list",
          "Return only book_id and current_borrowers",
          "Add pagination or top-K limit"
        ],
        "Query Mode": [
          "Offline batch query",
          "Online real-time lookup per book_id",
          "Continuous monitoring (streaming updates)"
        ],
        "Extension Possibilities": [
          "Dynamic total_copies (with new acquisitions or losses)",
          "Reservation system: users waiting despite no copies",
          "Due-date proximity warning for high-demand books"
        ]
      }
    }
  },
  {
    "title": "Minimum Increments to Equalize Leaf Paths",
    "slug": "minimum-increments-to-equalize-leaf-paths",
    "schema": {
      "Input Structure": [
        "n: 整数，表示树的节点数量",
        "edges: 二维数组，长度为 n - 1，edges[i] = [u_i, v_i] 表示无向边",
        "cost: 一维整数数组，长度为 n，cost[i] 表示节点 i 的初始成本",
        "树以节点 0 为根，构成一棵合法的无向树（无环连通图）"
      ],
      "Core Constraint": [
        "所有从根节点（0）到叶子节点的路径必须具有相同的总得分（路径上节点成本之和）",
        "只能通过增加节点成本（非负增量）来调整路径得分，不能减少",
        "增加操作不改变节点存在性或树结构，仅影响成本值",
        "目标是最小化被修改的节点数量，而非最小化总增加量"
      ],
      "Objective Function": "最小化需要增加成本的节点数量，使得所有根到叶子的路径得分相等",
      "Algorithmic Invariant": [
        "在树形结构中，任意子树内所有根到其叶子的路径得分应被统一为该子树的最大原始路径得分（贪心不变量）",
        "若某节点的所有子树已调整至各自最大路径得分一致，则该节点只需一次性补偿差额（通过提升其自身成本），即可使这些路径对齐",
        "一旦某个节点被选择增加成本，其上游路径将继承这一统一后的路径得分，且后续决策不会回溯修改其相对关系",
        "最优策略下，每个节点最多被修改一次，且修改值等于其子树间最大路径得分差值"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 1e5",
        "cost 值域": "1 <= cost[i] <= 1e9",
        "树形态": [
          "链状（退化为线性结构）",
          "星型（根连接多个叶子）",
          "完全二叉树结构"
        ],
        "是否有序": "树结构由 edges 给出，输入顺序无关",
        "是否循环": false,
        "是否多组输入": true,
        "是否在线": false,
        "修改操作类型": [
          "仅允许增加值",
          "可扩展为允许删减（需重新设计贪心策略）",
          "可支持区间修改或批量更新（用于衍生题）"
        ],
        "输出形式变化": [
          "返回最小修改节点数（当前题）",
          "改为返回最小总增加成本（不同目标函数）",
          "返回方案构造（哪些节点增加了多少）"
        ],
        "约束条件变化": [
          "要求最终路径得分为特定目标值 T",
          "限制最多修改 k 个节点，求可达的最小方差",
          "允许多次动态更新 edges 或 cost"
        ]
      }
    }
  },
  {
    "title": "Minimum Time for K Connected Components",
    "slug": "minimum-time-for-k-connected-components",
    "schema": {
      "Input Structure": [
        "整数 n，表示无向图的节点数量（节点编号从 0 到 n-1）",
        "二维数组 edges，其中每个元素为 [u_i, v_i, time_i]，表示连接节点 u_i 和 v_i 的无向边，将在时间 time_i 被移除",
        "整数 k，表示目标连通分量数量",
        "图初始时由所有边构成，边按 time_i 递增顺序在对应时间被移除",
        "1 <= n <= 10^5, 0 <= |edges| <= 10^5, 1 <= time_i <= 10^9"
      ],
      "Core Constraint": [
        "边仅在特定时间点被永久移除（离线移除）",
        "连通性随时间单调递减：一旦断开，不会恢复",
        "连通分量数量随时间单调不减",
        "问题具有时间可序性和状态演化可逆性：可通过逆序加边模拟连通性变化",
        "最终状态为所有边均被移除，最多有 n 个连通分量"
      ],
      "Objective Function": "求最小时间 t，使得在移除所有满足 time <= t 的边后，图中连通分量数量 ≥ k",
      "Algorithmic Invariant": [
        "使用并查集（Union-Find）维护连通分量数量",
        "时间上二分答案：若在时间 t 后连通分量数 ≥ k，则答案 ≤ t；否则 > t",
        "或采用逆序处理（从大到小加入边）：从全断开状态开始，按 time 降序加边，直到连通分量数 ≤ n - (已加边数)，当首次满足 comp_count <= n - added_edges 且 comp_count < k 时，前一时刻即为答案",
        "连通分量数的变化是单调的，支持二分或扫描线",
        "每次加边最多减少一个连通分量（合并两个集合）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5 → 可扩展至 1e6（要求 O(n log n) 解法）",
        "边的数量": "稀疏图 → 可变为完全图形式（稠密图）",
        "time_i 值域": "1~1e9 → 可压缩至 1~n（离散化需求变化）",
        "是否在线": "当前为离线输入 → 可改为动态删除边的在线查询",
        "是否多组数据": "单次查询 → 多组 k 或多组 t 查询",
        "目标函数变换": "≥k 个连通分量 → 恰好 k 个 / 最大 t 使得 <k 个",
        "操作类型反转": "删边 → 加边（给定添加时间，求最早达到 k 连通块的时间）",
        "图结构维度": "一维链式结构 → 网格图上的边删除",
        "连通性定义": "普通连通 → 强连通（转为有向图版本）"
      }
    }
  },
  {
    "title": "Count Prime-Gap Balanced Subarrays",
    "slug": "count-prime-gap-balanced-subarrays",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 5 * 10^4",
        "value_range": "1 <= nums[i] <= 5 * 10^4",
        "properties": [
          "一维整数数组 nums[1..n]",
          "元素为自然数",
          "子数组定义为连续非空序列"
        ]
      },
      "Core Constraint": {
        "prime_definition": "质数是大于1且仅有因数1和自身的自然数",
        "subarray_condition": "子数组中至少包含两个质数",
        "balance_condition": "子数组内最大质数与最小质数之差 ≤ k",
        "dependency_structure": "局部信息依赖于子数组内的质数分布，但整体约束由极值差驱动"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计满足‘质数间隔平衡’条件的子数组数量",
        "output_type": "非负整数"
      },
      "Algorithmic Invariant": {
        "invariant_type": "双指针推进 + 滑动窗口扩展",
        "monotonicity": "随着右端点右移，新加入的质数可能更新当前窗口的最大/最小质数；左端点收缩时可维护有效状态",
        "valid_state_preservation": "在固定左端点下，若某右端点形成合法平衡子数组，则所有中间扩展均已被枚举或可剪枝",
        "greedy_movable": "可在遍历过程中动态维护当前窗口内的质数集合及其极值，利用极值单调性减少重复计算"
      },
      "Transformable Parameters": {
        "constraints": [
          {
            "parameter": "k",
            "range": "0 <= k <= 5 * 10^4",
            "transformations": [
              "目标变换：从计数 → 判定（是否存在）",
              "约束反转：≤k → ≥k → 等于k",
              "阈值离散化：k为固定常量或变量"
            ]
          },
          {
            "parameter": "prime_requirement",
            "options": [
              "至少两个质数 → 至少一个 / 至少m个",
              "替换为其他数字性质（如奇偶、平方数等）"
            ]
          },
          {
            "parameter": "array_dimension",
            "options": [
              "1D → 2D网格上的连通区域",
              "线性数组 → 环形数组"
            ]
          },
          {
            "parameter": "data_mode",
            "options": [
              "离线批量输入 → 在线流式查询",
              "静态数组 → 支持单点修改"
            ]
          },
          {
            "parameter": "output_form",
            "options": [
              "仅数量 → 输出所有符合条件的子数组",
              "构造方案 → 返回最长/最短者"
            ]
          },
          {
            "parameter": "number_property",
            "options": [
              "质数 → 合数 / 斐波那契数 / 模意义下同余类"
            ]
          }
        ],
        "complexity_boundary": {
          "expected_time_complexity": "O(n^2) 可接受，但可通过优化至 O(n log n) 或均摊 O(n)",
          "space_complexity": "O(π(max_value)) 预处理质数表，额外空间用于记录位置"
        }
      }
    }
  },
  {
    "title": "Kth Smallest Path XOR Sum",
    "slug": "kth-smallest-path-xor-sum",
    "schema": {
      "Input Structure": [
        "一棵以节点 0 为根的无向树，包含 n 个节点（编号 0 到 n-1）",
        "每个节点 i 有一个整数值 vals[i] ≥ 0",
        "父节点数组 par，其中 par[0] = -1，其余 par[i] 表示节点 i 的父节点",
        "一个二维整数数组 queries，其中 queries[j] = [u_j, k_j]"
      ],
      "Core Constraint": [
        "路径异或和定义为从根节点 0 到节点 u 的路径上所有节点 vals[i] 的按位异或（包括 u）",
        "子树定义为以某节点 u 为根的所有后代节点及其自身",
        "每个查询要求在指定子树中统计所有**不同**的路径异或和",
        "路径异或和具有前缀异或性质：xor_path[u] = xor_path[parent[u]] ^ vals[u]",
        "子树内信息不可通过全局预处理直接索引，需支持局部聚合"
      ],
      "Objective Function": [
        "对每个查询 [u_j, k_j]，求以 u_j 为根的子树中，第 k_j 小的不同路径异或和",
        "若不同异或值数量 < k_j，则返回 -1",
        "目标函数类型：子树范围内的有序选择（第 k 小元素）+ 去重"
      ],
      "Algorithmic Invariant": [
        "DFS 过程中维护当前路径异或值，可 O(1) 更新子节点异或值",
        "利用欧拉序（DFS 序）将子树查询转化为区间查询",
        "使用 Mo's Algorithm 或 DSU on Tree（启发式合并）维护子树内异或值频次与有序集合",
        "异或值域有限（≤ 2^17），可使用桶或权值树状数组进行快速第 k 小查询",
        "合并子树时，较小集合向较大集合合并（DSU on Tree 不变量）保证复杂度 O(n log n)"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 5 * 10^4",
        "vals 值域": "0 <= vals[i] <= 10^5",
        "异或值域": "最大约 2^17，适合桶或 Trie 维护",
        "queries 长度": "1 <= queries.length <= 5 * 10^4",
        "是否多组数据": "否（单棵树）",
        "是否在线": "可改造为在线（如持久化数据结构）或离线（Mo's / DSU on Tree）",
        "输入形式": "父数组建树，非邻接表直接给出",
        "是否要求去重": "是（不同路径异或和）",
        "k_j 范围": "1 <= k_j <= n，但实际受限于不同值数量",
        "是否支持修改操作": "原始题为静态，可扩展为支持点权修改（需用线段树/平衡树）"
      }
    }
  },
  {
    "title": "Partition String ",
    "slug": "partition-string",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "s[1..n]",
        "constraints": [
          "n >= 1 and n <= 1e5",
          "s contains only lowercase English letters"
        ],
        "formal": "一维字符串 s[1..n], 字符集为 {a-z}"
      },
      "Core Constraint": {
        "rules": [
          "段必须从左到右连续构建",
          "当前段在被加入结果前必须是此前未出现过的（全局唯一性）",
          "一旦当前扩展导致段重复，则停止扩展并重置当前段为单个新字符",
          "已生成的段集合构成状态记忆，影响后续决策"
        ],
        "inherent_property": "局部扩展受全局历史段集合约束"
      },
      "Objective Function": {
        "type": "construction",
        "goal": "构造一个字符串数组 segments",
        "requirements": [
          "segments 中每个元素为非空字符串",
          "segments 按照分割顺序排列",
          "所有段互不相同",
          "覆盖整个原字符串且无重叠"
        ]
      },
      "Algorithmic Invariant": {
        "invariants": [
          "已确定的段列表始终保持互异性",
          "当前段的构建遵循贪心规则：尽可能短地满足唯一性",
          "指针推进与哈希集合更新同步：每完成一段，立即插入集合并重置临时段",
          "不存在回溯：每段一旦确认，其边界不可更改"
        ],
        "proof_condition": "若某段 S 在首次达到唯一时未被截断，则更长的扩展必然包含 S 作为前缀，而后续唯一性判断仍依赖全局历史，因此贪心截断最优"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "string_length",
            "range": "1 <= n <= 1e5",
            "can_scale": true,
            "impact": "影响哈希表性能与算法常数"
          },
          {
            "name": "character_set",
            "values": "lowercase / uppercase / digit / mixed",
            "default": "lowercase",
            "can_vary": true
          },
          {
            "name": "uniqueness_definition",
            "options": [
              "exact_string_match",
              "case_insensitive",
              "anagram-equivalent (变位词)",
              "substring-free_inclusion"
            ],
            "current": "exact_string_match"
          },
          {
            "name": "input_mode",
            "type": "offline_online",
            "options": [
              "offline",
              "online_streaming"
            ],
            "description": "是否支持字符流式输入"
          },
          {
            "name": "output_requirement",
            "options": [
              "segments_list",
              "number_of_segments",
              "maximum_segment_length",
              "lexicographically_smallest_partition"
            ],
            "current": "segments_list"
          },
          {
            "name": "segment_constraint",
            "options": [
              "no_reuse",
              "at_most_k_occurrences",
              "length_bounded"
            ],
            "description": "可推广为多重现限制"
          },
          {
            "name": "data_structure_interface",
            "options": [
              "static_input",
              "support_modify_character",
              "support_insert_delete"
            ],
            "description": "是否支持动态修改字符串"
          }
        ]
      }
    }
  },
  {
    "title": "Minimum Adjacent Swaps to Alternate Parity",
    "slug": "minimum-adjacent-swaps-to-alternate-parity",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "distinct integers",
        "constraints": [
          "nums.length ∈ [1, 10^5]",
          "nums[i] ∈ [1, 10^9]",
          "all elements are unique"
        ]
      },
      "Core Constraint": {
        "valid_permutation_condition": "adjacent elements must alternate in parity (odd-even or even-odd)",
        "operation_restriction": "only adjacent swaps allowed",
        "structural_feasibility": "a valid arrangement exists only if the counts of odd and even numbers satisfy |count_odd - count_even| ≤ 1"
      },
      "Objective Function": {
        "goal": "minimize the number of adjacent swaps",
        "output": "integer: minimum swap count to reach any valid alternating parity permutation, or -1 if impossible"
      },
      "Algorithmic Invariant": {
        "invariant_1": "parity alternation defines two possible target patterns: starts with even (E-O-E-O...) or starts with odd (O-E-O-E...)",
        "invariant_2": "for each feasible pattern, relative order of original odd/even elements can be exploited to compute minimum adjacent swaps via inversion counting",
        "invariant_3": "minimum adjacent swaps to form a target sequence equals the number of inversions when mapping current positions to desired positions",
        "invariant_4": "since only adjacent swaps are allowed, optimal strategy is to independently evaluate both feasible templates and take minimum"
      },
      "Transformable Parameters": {
        "n_magnitude": "1e5 → allows O(n log n) solutions",
        "element_uniqueness": "required; duplicates would break inversion-based reasoning",
        "ordering_requirement": "alternating parity — can be generalized to k-parity cycles or modular conditions",
        "swap_type": "adjacent only — could extend to arbitrary swaps (then becomes cycle decomposition)",
        "input_streaming": "currently offline; can become online with incremental inversion count",
        "output_variant": [
          "return -1 on impossibility",
          "could require construction of final array",
          "could ask for number of distinct optimal ways"
        ],
        "feasibility_condition": "depends on |count_odd - count_even| ≤ 1; reversing this yields always-impossible variants",
        "pattern_constraint": "free choice of starting parity; could fix it as additional input"
      }
    }
  },
  {
    "title": "Inverse Coin Change",
    "slug": "inverse-coin-change",
    "schema": "{\n  \"Input Structure\": [\n    \"一维数组 numWays[1..n]，从索引 1 开始计数\",\n    \"numWays[i] 表示凑出总金额 i 的方法数（非负整数）\",\n    \"每种硬币面值为正整数，且面值 ≤ n\"\n  ],\n  \"Core Constraint\": [\n    \"numWays 数组是由某个未知的硬币面值集合 S 通过无限背包方案数生成的\",\n    \"即：numWays 是完全背包计数问题的输出结果，递推关系为：\",\n    \"numWays[0] = 1（隐式基础情况），对每个金额 i ≥ 1，有\",\n    \"numWays[i] = Σ_{s ∈ S, s ≤ i} numWays[i - s]\",\n    \"面值集合 S 必须满足该递推关系在整个数组上成立\",\n    \"面值只能是 1 到 n 之间的整数\"\n  ],\n  \"Objective Function\": [\n    \"还原所有可能的唯一硬币面值集合 S\",\n    \"返回按升序排列的面值列表\",\n    \"若无解则返回空数组\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"面值必须从小到大依次验证：若金额 i 的方法数不能由已知面值和当前候选面值解释，则 i 不可作为新面值\",\n    \"对于每个金额 i ≥ 1，若 numWays[i] > 当前基于已有面值得到的方案数，则 i 必须是一个新的硬币面值\",\n    \"一旦确定一个面值 s，它将影响所有 j ≥ s 的 numWays[j]，可通过动态规划反向验证其贡献\",\n    \"贪心构造 + 动态验证：从小到大遍历金额，维护当前可用面值下的理论方案数，与实际比较以决定是否引入新面值\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n = numWays.length，范围 [1, 100]\"\n    },\n    \"值域\": {\n      \"numWays[i] ∈ [0, 2e8]\"\n    },\n    \"是否有序\": true,\n    \"是否从1开始计数\": true,\n    \"是否允许负值\": false,\n    \"是否多组输入\": false,\n    \"是否在线\": false,\n    \"硬币使用限制\": \"无限次使用（完全背包）\",\n    \"面值约束\": \"必须是正整数，且 ≤ n\",\n    \"输出要求\": \"唯一、升序排列的面值集合，若不存在则返回空数组\"\n  }\n}"
  },
  {
    "title": "Maximize Spanning Tree Stability with Upgrades",
    "slug": "maximize-spanning-tree-stability-with-upgrades",
    "schema": {
      "Input Structure": [
        "无向图 G = (V, E)，其中 |V| = n，节点编号为 0 到 n-1",
        "边集 edges，每条边为 [u_i, v_i, s_i, must_i]，表示连接 u_i 和 v_i 的无向边",
        "s_i ∈ [1, 1e5]：边的初始强度（正整数）",
        "must_i ∈ {0, 1}：是否为必须包含且不可升级的边",
        "k ∈ [0, n]：最多可执行的升级次数，每次升级使一条 must_i=0 的边强度翻倍，每条边至多升级一次"
      ],
      "Core Constraint": [
        "生成树必须连通所有节点、无环、恰好包含 n-1 条边",
        "must_i == 1 的边必须被包含，且不能参与升级",
        "must_i == 0 的边可选择是否加入生成树，若加入可选择是否使用一次升级使其强度翻倍",
        "全局约束：总升级次数不超过 k",
        "目标是最大化生成树中边的最小强度（稳定性），因此需要平衡最弱边的强度"
      ],
      "Objective Function": "最大化生成树中所有边的最小强度（即最大可能的稳定性）；如果无法构造合法生成树，返回 -1",
      "Algorithmic Invariant": [
        "二分答案框架下，对于候选稳定性 x，判断是否存在一个生成树使得每条边在（原始或升级后）强度 ≥ x，且满足 must 边强制包含、升级次数 ≤ k",
        "边的选择可通过贪心策略构建生成树：优先保留高权重边以提升最小值下界",
        "must 边必须被保留，若其原始强度 < x，则直接判定失败",
        "非 must 边若原始强度 < x ≤ 2*s_i，则需消耗一次升级；否则若 2*s_i < x，则该边也无法满足要求",
        "使用并查集维护连通性，在筛选可行边后尝试构造生成树"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 1e5",
        "边数规模": "1 <= |edges| <= 1e5",
        "边强度值域": "1 <= s_i <= 1e5",
        "k 的范围": "0 <= k <= n",
        "must_i 的分布": "可变比例（全 must / 全可选 / 混合）",
        "图的连通性": "输入图不一定连通",
        "是否允许负强度": false,
        "是否支持动态更新": false,
        "是否在线输入边": false,
        "是否多组数据": "可扩展为多测例输入",
        "目标函数变形": [
          "改为最小化最大强度",
          "改为求最大生成树稳定性下的方案数",
          "改为输出具体边集"
        ],
        "约束变形": [
          "must_i 可升级",
          "每条边可多次升级",
          "升级不是翻倍而是加固定值",
          "允许超过 n-1 条边（如生成森林）"
        ],
        "结构扩展": "可推广至有向图、带点权、或分布式环境"
      }
    }
  },
  {
    "title": "Find Weighted Median Node in Tree",
    "slug": "find-weighted-median-node-in-tree",
    "schema": {
      "Input Structure": {
        "type": "Tree",
        "description": "一棵有 n 个节点的无向带权树，根为 0，由 edges[i] = [u_i, v_i, w_i] 表示边及其权重",
        "n": "2 <= n <= 1e5",
        "edges": "长度为 n - 1 的二维整数数组，每条边连接两个节点并有权重 w_i >= 1",
        "queries": "二维整数数组 queries，每个查询为 [u_j, v_j]，表示从 u_j 到 v_j 的路径"
      },
      "Core Constraint": {
        "constraint": "树中任意两点间路径唯一；带权中位节点定义为路径上第一个节点 x，使得从起点到 x 的边权和 ≥ 路径总权值的一半",
        "uniqueness": "路径唯一性由树结构保证",
        "accumulation": "前缀边权和具有单调非递减性，支持二分或双指针定位中位点"
      },
      "Objective Function": {
        "objective": "对于每个查询 [u_j, v_j]，求出其路径上的带权中位节点编号",
        "type": "构造方案 / 定位首个满足条件的节点"
      },
      "Algorithmic Invariant": {
        "invariant": "在任意路径上，从起点出发的累积权重单调递增；一旦累积和首次 ≥ 总权值一半，该位置即为所求，后续节点不再影响结果",
        "monotonicity": "边权为正，前缀和严格递增，保证解的唯一性和可定位性",
        "path_decomposition": "可通过 LCA 分解路径为 u → LCA(u,v) 和 LCA(u,v) → v 两段，并沿路径顺序遍历求解"
      },
      "Transformable Parameters": {
        "n_range": "2 <= n <= 1e5",
        "query_count": "1 <= queries.length <= 1e5",
        "edge_weight_range": "1 <= w_i <= 1e9",
        "tree_structure": "静态树 / 是否允许动态加边（否）",
        "input_form": "边列表形式输入，树隐式构建",
        "query_type": "离线批量查询 / 可扩展为在线查询",
        "weight_type": "正整数边权（可变形为实数、负权则破坏单调性）",
        "output_requirement": "仅输出中位节点编号 / 可要求输出路径或累积和序列",
        "precision_constraint": "总权值一半可能为小数，判断条件为 '>= half'，适用于整型累加"
      }
    }
  },
  {
    "title": "Sequential Grid Path Cover",
    "slug": "sequential-grid-path-cover",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度",
        "constraints": [
          "n ≥ 1",
          "H[i] ≥ 0, ∀i ∈ [1, n]"
        ]
      },
      "Core Constraint": {
        "description": "每个位置 i 能接住的雨水量由其左侧最大高度和右侧最大高度中的较小者决定，且仅当该值大于当前高度时才可积水",
        "properties": [
          "局部容量依赖全局信息（左右两侧的最大值）",
          "左右边界约束独立但需联合取 min",
          "无后效性：一旦确定某侧更高，则另一侧的容量仅受其自身方向极值影响"
        ]
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total trapped water",
        "description": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": "双指针维护已知一侧的极值，确保移动指针时不丢失最优性",
        "rules": [
          "维护 left = 0, right = n-1，以及 maxLeft 和 maxRight",
          "若 maxLeft ≤ maxRight，则 left 处的积水可由 maxLeft - H[left] 确定，然后 left++",
          "否则，right 处的积水可由 maxRight - H[right] 确定，然后 right--",
          "每次移动都保证被移动端的边界是短板，因此其贡献可安全计算"
        ],
        "proof_basis": "短板原理：若左≤右，则left位置的瓶颈必为左侧极值，无需等待右侧更多信息"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "description": "是否允许负高度值"
          },
          {
            "name": "dimension",
            "options": [
              "1D",
              "2D",
              "circular"
            ],
            "description": "从一维扩展到二维或环形结构"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online_streaming"
            ],
            "description": "输入是一次性给出还是在线流式到达"
          },
          {
            "name": "output_granularity",
            "options": [
              "total_sum",
              "per_position_values"
            ],
            "description": "输出是总和还是每个位置的具体积水量"
          },
          {
            "name": "dynamic_operations",
            "options": [
              "static",
              "support_update_or_delete"
            ],
            "description": "是否支持对数组进行修改、插入或删除操作"
          },
          {
            "name": "data_order",
            "options": [
              "unordered",
              "sorted"
            ],
            "description": "输入是否有序"
          },
          {
            "name": "multiple_queries",
            "options": [
              "single_instance",
              "multiple_test_cases"
            ],
            "description": "是否处理多组测试数据"
          }
        ]
      }
    }
  },
  {
    "title": "Seasonal Sales Analysis",
    "slug": "seasonal-sales-analysis",
    "schema": {
      "Input Structure": [
        "两个关系表：sales 和 products",
        "sales 表包含字段：sale_id (int), product_id (int), sale_date (date), quantity (int), price (decimal)",
        "products 表包含字段：product_id (int), product_name (varchar), category (varchar)",
        "sale_id 是 sales 表的唯一主键，product_id 是 products 表的唯一主键",
        "两表通过 product_id 进行连接"
      ],
      "Core Constraint": [
        "季节由销售日期（sale_date）的月份决定，规则固定：冬季（12,1,2），春季（3,4,5），夏季（6,7,8），秋季（9,10,11）",
        "每个季节内，类别的受欢迎度首先基于总销售量（quantity）排序",
        "若总销售量相同，则按总收入（quantity × price）排序，取最高者",
        "每个季节仅输出最受欢迎的一个类别"
      ],
      "Objective Function": [
        "对每个季节，找出最受欢迎的产品类别",
        "目标函数为：先最大化总销售量，再在并列情况下最大化总收入",
        "构造结果表，包含：season, category, total_quantity, total_revenue",
        "结果按 season 升序排列"
      ],
      "Algorithmic Invariant": [
        "时间分组不变性：每个 sale 记录只能属于一个季节，季节划分是互斥且完备的",
        "聚合顺序不变性：先按 season + category 聚合 quantity 和 revenue，再进行每季节内的排序选择",
        "优先级比较不变性：在同销量下，高收入类别始终优先生效，可通过复合排序保证正确性",
        "连接一致性：product_id 作为外键连接确保 category 映射唯一正确"
      ],
      "Transformable Parameters": {
        "Season Definition": "可修改季节对应的月份（如南半球季节反转）",
        "Tie-breaking Rule": "可变更平局规则（如按字典序选 category，或返回多个）",
        "Aggregation Metric": "可改为仅看收入、平均单价、订单数等",
        "Output Granularity": "可改为输出每个季节前 K 个类别，而非仅 1 个",
        "Temporal Resolution": "可将季节改为月、季度、自定义时间段",
        "Data Input Form": "可变为流式输入（在线销售日志）或批量离线处理",
        "Multiple Groups": "可加入地区、门店等维度进行分组后再求每组每季最优",
        "Null Handling": "可设定 product_id 在 products 中缺失时的处理策略",
        "Date Range": "可限制分析的时间窗口（如最近一年）"
      }
    }
  },
  {
    "title": "Count Number of Trapezoids II",
    "slug": "count-number-of-trapezoids-ii",
    "schema": {
      "Input Structure": [
        "二维整数数组 points[1..n]",
        "points[i] = [x_i, y_i]，表示笛卡尔平面上的点",
        "4 <= n <= 500",
        "所有点两两不同",
        "坐标范围：-1000 <= x_i, y_i <= 1000"
      ],
      "Core Constraint": [
        "梯形定义为凸四边形且至少有一对平行边",
        "两条边平行当且仅当它们的斜率相等",
        "四条边中只需存在一对边平行即可构成梯形",
        "四点必须互不相同且可形成凸四边形（隐含非共线、非退化）"
      ],
      "Objective Function": "计数：从给定点集中选出四个不同点能构成梯形的方案总数",
      "Algorithmic Invariant": [
        "通过枚举所有可能的边对来计算相同斜率的边数量",
        "对于每一对边（无公共点），若其斜率相同，则这两条边可作为梯形的一组平行边",
        "每组四点最多被计数一次（需去重或组合控制）",
        "利用斜率分组 + 枚举四元组或组合数学避免重复计数的不变性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "4 <= n <= 500（当前规模允许 O(n^3)~O(n^2 log n) 解法）",
        "值域": "坐标在 [-1000, 1000] 范围内，影响斜率精度处理方式",
        "是否有序": "输入无序，但可按坐标预排序以辅助枚举",
        "是否循环": "否，平面点集无环形结构",
        "是否多组输入": "可扩展为多测例输入形式",
        "是否在线": "当前为离线输入，可改造为动态增删点的在线版本",
        "斜率处理方式": "是否使用分数化简（gcd）、浮点近似或哈希表示斜率",
        "退化情况约束": "是否允许三点共线、四点共线、凹四边形等",
        "目标变换": "可改为求最大面积梯形、是否存在梯形、构造一个梯形等",
        "几何维度扩展": "可推广至三维投影平面或更高维仿射子空间中的‘类梯形’结构"
      }
    }
  },
  {
    "title": "Minimum Time to Transport All Individuals",
    "slug": "minimum-time-to-transport-all-individuals",
    "schema": {
      "Input Structure": [
        "整数 n：表示人员数量，1 <= n <= 12",
        "整数 k：表示船一次最多承载人数，1 <= k <= 5",
        "整数 m：表示环境周期阶段数，1 <= m <= 5",
        "数组 time[0..n-1]：非负整数，time[i] 表示第 i 个人在中性条件下的渡河时间，1 <= time[i] <= 100",
        "数组 mul[0..m-1]：浮点数，mul[j] 表示第 j 阶段的速度倍率，0.5 <= mul[j] <= 2.0"
      ],
      "Core Constraint": [
        "渡河时间由组内最大划船时间与当前阶段倍率共同决定：group_time = max(time[i] for i in group) * mul[current_stage]",
        "阶段按周期循环更新：next_stage = (current_stage + floor(duration)) % m",
        "每次渡河后若营地仍有人，则必须有一人返回，返回时间 = time[r] * mul[current_stage_after_crossing]",
        "返回操作也会推进阶段",
        "初始阶段为 0",
        "所有人员最终必须到达对岸，船无初始位置偏好"
      ],
      "Objective Function": "最小化将所有人从营地运送到目的地所需的总时间（浮点数）。若无法完成任务，返回 -1。",
      "Algorithmic Invariant": [
        "状态空间可被完全枚举：由于 n <= 12, m <= 5，可用状态压缩动态规划（DP）表示人员分布和当前阶段",
        "每个状态 (mask, stage, boat_side) 中：",
        "  - mask 表示哪些人已在对岸（位掩码）",
        "  - stage 表示当前所处的环境阶段",
        "  - boat_side 表示船当前在营地侧（0）还是对岸（1）",
        "转移时枚举所有可以上船的子集（大小不超过 k），并选择最优返回者以最小化后续代价",
        "贪心不可行，但最优子结构成立：从任意状态出发的最小剩余时间可独立计算",
        "使用记忆化搜索或 Dijkstra 式松弛更新最短时间路径"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可扩展至更大值（如 n=20）以禁用暴力枚举，迫使设计启发式剪枝",
        "k 的限制": "可变为变量或加入容量权重约束（如每人占不同空间）",
        "m 和 mul 数组": [
          "可改为非周期性、在线输入 mul 值",
          "mul 可依赖于船上人员构成",
          "引入 mul 的随机扰动"
        ],
        "time 数组性质": [
          "是否有序",
          "是否允许负值（无效）",
          "是否可修改（动态能力变化）"
        ],
        "是否多组数据": true,
        "是否在线": false,
        "船的操作规则": [
          "是否允许多次连续单向运输（无人返回）——仅当最后一批时合法",
          "是否需要指定返回者策略（固定 vs 自由选择）",
          "是否允许中途换人返回"
        ],
        "目标函数变形": [
          "最小化最大个体耗时（公平性）",
          "计数可行方案数",
          "判定是否存在小于阈值的方案"
        ],
        "附加约束": [
          "某些人不能同行",
          "某些人不能划船",
          "返回者必须是最小 time[i] 者（强制规则）"
        ]
      }
    }
  },
  {
    "title": "Maximize Y‑Sum by Picking a Triplet of Distinct X‑Values",
    "slug": "maximize-ysum-by-picking-a-triplet-of-distinct-xvalues",
    "schema": {
      "Input Structure": [
        "两个长度为 n 的整数数组 x[1..n] 和 y[1..n]",
        "x[i] ∈ [1, 10^6], y[i] ∈ [1, 10^6]",
        "3 <= n <= 10^5"
      ],
      "Core Constraint": [
        "必须选择三个不同的下标 i, j, k",
        "对应的 x[i], x[j], x[k] 互不相等（即三者构成三个不同值）",
        "y 值无约束，但目标函数基于 y[i] + y[j] + y[k]"
      ],
      "Objective Function": "最大化 y[i] + y[j] + y[k] 的和；若不存在满足条件的三元组，则返回 -1",
      "Algorithmic Invariant": [
        "最优解必由三个不同 x 值对应的最大 y 值中产生",
        "对每个 x 值维护其对应的最大（或前三大）y 值可保证候选集完整性",
        "枚举所有可能的三元 x 值组合，并取各自最大 y 贡献，不会遗漏全局最优解",
        "状态空间可压缩：每组 x 值只需保留 top-3 大的 y 值以避免重复下标"
      ],
      "Transformable Parameters": {
        "n 的数量级": "3 <= n <= 10^5 或更小（如 10^3）",
        "值域范围": "x[i] 和 y[i] 的范围可调整（如负值、更大值域）",
        "是否有序": "x 是否预先排序不影响解法，但可优化枚举",
        "是否循环": "否，线性结构",
        "是否多组输入": "可扩展为多测例输入",
        "是否在线": "当前为离线输入，可改造为流式添加 (x_i, y_i) 并查询是否存在有效三元组",
        "约束变化": [
          "从 '三个不同 x 值' 改为 '至少两个相同' 或其他模式",
          "改为计数类问题：统计满足条件的三元组数量",
          "加入权重函数：如 max(y[i]*y[j]*y[k])",
          "推广到四元组或多维属性"
        ],
        "输出形式": "返回最大和 / 返回下标方案 / 返回所有最优方案数量"
      }
    }
  },
  {
    "title": "Generate Tag for Video Caption",
    "slug": "generate-tag-for-video-caption",
    "schema": {
      "Input Structure": "字符串 caption，长度为 n（1 ≤ n ≤ 150），仅由英文字母和空格 ' ' 组成，表示视频标题的单词序列，单词间以空格分隔。",
      "Core Constraint": "1. 所有单词需合并为一个驼峰命名字符串：第一个单词全小写，其余单词首字母大写、其余字母小写；\n2. 非英文字母字符在处理前应被移除（但输入保证只含英文字母和空格）；\n3. 结果必须以 '#' 开头；\n4. 最终结果最多保留前 100 个字符。",
      "Objective Function": "构造并返回满足格式要求的有效标签字符串。",
      "Algorithmic Invariant": "1. 单词顺序保持不变；\n2. 每个单词内部大小写转换规则唯一确定（首字母是否大写取决于是否为首个单词）；\n3. 字符清理与大小写规范化可在线性扫描中完成；\n4. 截断操作不影响前面字符的合法性，且仅发生在末尾。",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 150（当前），可扩展至更大规模如 1e5",
        "值域": "原题仅英文字母和空格，可变体可包含数字、标点等非字母字符需过滤",
        "是否有序": "单词顺序固定，不可重排",
        "是否循环": "否，线性结构",
        "是否多组输入": "当前单组，可改为多组测试用例",
        "是否在线": "否，一次性离线处理；可设计为流式输入单词并动态更新标签",
        "输出形式变化": [
          "返回截断前完整标签",
          "返回是否发生截断的布尔值",
          "要求支持删除/插入单词后的标签更新"
        ],
        "驼峰规则变化": [
          "改为所有单词首字母大写（PascalCase）",
          "改为下划线连接的小写（snake_case）",
          "交替大小写等变形"
        ],
        "长度限制变化": "最大长度可参数化为 K（如 K=50 或 K=200）"
      }
    }
  },
  {
    "title": "Best Time to Buy and Sell Stock V",
    "slug": "best-time-to-buy-and-sell-stock-v",
    "schema": {
      "Input Structure": [
        "一维数组 prices[1..n]，表示第 i 天的股票价格",
        "prices[i] ∈ 正整数，且 n ≥ 2",
        "整数 k，表示最多可进行的交易笔数",
        "约束：k ≤ floor(n / 2)"
      ],
      "Core Constraint": [
        "每笔交易必须在完成前一笔后才能开始（无重叠）",
        "普通交易要求 i < j，利润为 prices[j] - prices[i]",
        "做空交易要求 i < j，利润为 prices[i] - prices[j]",
        "每天至多执行一次买入或卖出操作",
        "交易类型可自由选择（普通或做空），但顺序不可逆"
      ],
      "Objective Function": "最大化总利润，在最多 k 笔非重叠交易下求最优解",
      "Algorithmic Invariant": [
        "状态可划分为持有/未持有两种情形，但需区分当前是普通持仓还是做空持仓",
        "动态规划中，dp[t][i][s] 表示前 i 天完成 t 笔交易、处于状态 s（如：无持仓、持有多头、持有空头）时的最大利润",
        "交易次数是单调递增的，且每笔交易贡献独立可累加",
        "最优子结构成立：前 i 天的最优策略由前 i-1 天转移而来",
        "贪心不适用：局部最优无法保证全局最优，因存在双向操作（买涨与卖跌）"
      ],
      "Transformable Parameters": [
        "k 的数量级：k=1（单次）、k=2、k≥n/2（视为无限次）",
        "是否允许交易重叠（改为在线交易模型）",
        "是否允许多次连续买入/卖出（引入杠杆）",
        "输入形式：离线批量输入 vs 在线流式价格更新",
        "目标函数变化：从最大利润 → 最小亏损 / 判定是否存在正收益方案 / 计数满足利润阈值的方案数",
        "加入手续费或税费约束",
        "扩展到二维：多只股票联合决策",
        "是否隐藏 prices 数组，改为交互式询问（在线查询）",
        "价格序列是否具有单调性（显式或隐式）"
      ]
    }
  },
  {
    "title": "Find Category Recommendation Pairs",
    "slug": "find-category-recommendation-pairs",
    "schema": {
      "Input Structure": [
        "表 ProductPurchases: (user_id: int, product_id: int, quantity: int), 主键为 (user_id, product_id)",
        "表 ProductInfo: (product_id: int, category: varchar, price: decimal), 主键为 product_id",
        "两表通过 product_id 关联",
        "输入为静态、离线的二维关系表数据"
      ],
      "Core Constraint": [
        "每个用户购买的产品通过 product_id 映射到其类别",
        "类别对 (category1, category2) 满足字典序约束：category1 < category2",
        "一个用户被视为同时购买两个类别的条件是：该用户至少购买过每个类别中至少一个产品",
        "判定逻辑基于用户-类别购买行为的集合交集"
      ],
      "Objective Function": [
        "对所有满足 category1 < category2 的类别对，",
        "计算同时在 category1 和 category2 中都有购买记录的不同 user_id 数量",
        "筛选 customer_count ≥ 3 的类别对",
        "输出结果按 customer_count 降序，然后按 category1 升序，再按 category2 升序排序"
      ],
      "Algorithmic Invariant": [
        "用户-类别购买关系具有可分离性：每个用户的购买行为可独立聚合为其购买的类别集合",
        "类别对的联合购买判定是单调的：若用户 u 购买了类别 c1 和 c2，则对 (c1,c2) 的计数贡献为 1，且不随其他用户变化而改变",
        "类别对计数过程可分解为：先构建用户级类别集合 → 再枚举有效类别对 → 最后聚合计数",
        "最终排序规则打破平局，保证输出唯一性"
      ],
      "Transformable Parameters": {
        "阈值参数": "共同用户数的最小阈值（当前为 3），可改为 k 或动态查询",
        "比较规则": "category1 < category2 可改为任意排序约束或允许无序对去重",
        "目标函数变体": [
          "改为求最大/最小 customer_count",
          "改为计数可报告对的总数",
          "改为构造特定用户参与的类别对"
        ],
        "数据动态性": [
          "是否支持在线更新：新增购买记录或新商品",
          "是否多组测试用例 / 多次查询"
        ],
        "输入形式扩展": [
          "支持多层级分类（如 category, subcategory）",
          "引入时间维度，要求在时间窗口内完成购买",
          "quantity 参与判断（如需加权购买量 ≥ threshold）"
        ],
        "输出格式": [
          "仅返回 customer_count，或包含具体用户列表",
          "是否要求去重、分页、Top-K 输出"
        ]
      }
    }
  },
  {
    "title": "Smallest Subarray to Sort in Every Sliding Window",
    "slug": "smallest-subarray-to-sort-in-every-sliding-window",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "一维数组 H[1..n]，其中 H[i] 表示第 i 个柱子的高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右侧最大值可独立维护",
        "global_dependency": "局部积水依赖于全局极值信息"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total trapped water volume",
        "output": "single integer representing the total amount of water that can be trapped after raining"
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariants": [
          "左指针 L 左侧的最大值 maxLeft 已知",
          "右指针 R 右侧的最大值 maxRight 已知",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水可立即确定",
          "移动较小一侧指针并更新对应最大值，不破坏未访问区间的最优性"
        ],
        "correctness_basis": "短板效应保证了当前边界可安全贡献"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_range",
            "options": [
              "non-negative",
              "allow_negative_heights"
            ],
            "impact": "允许负值时需重新定义积水逻辑"
          },
          {
            "name": "dimensionality",
            "options": [
              "1D",
              "2D"
            ],
            "impact": "扩展为二维接雨水问题（如 LeetCode 407）"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online_streaming"
            ],
            "impact": "在线输入时需支持动态插入或查询"
          },
          {
            "name": "output_detail",
            "options": [
              "total_sum",
              "per_position_contribution"
            ],
            "impact": "是否输出每个位置的积水量"
          },
          {
            "name": "data_updates",
            "options": [
              "static",
              "dynamic_with_modifications"
            ],
            "impact": "支持单点修改或区间更新时需结合线段树等数据结构"
          },
          {
            "name": "array_shape",
            "options": [
              "linear",
              "circular"
            ],
            "impact": "环形排列下首尾相连，影响边界处理"
          },
          {
            "name": "multiple_queries",
            "options": [
              "single_instance",
              "multiple_test_cases"
            ],
            "impact": "多组测试数据下的效率要求"
          }
        ]
      }
    }
  },
  {
    "title": "Minimum Cost Path with Teleportations",
    "slug": "minimum-cost-path-with-teleportations",
    "schema": {
      "Input Structure": [
        "二维整数数组 grid[0..m-1][0..n-1]",
        "m, n 表示行数和列数，2 <= m, n <= 80",
        "grid[i][j] >= 0，值域范围 [0, 10^4]",
        "整数 k 表示最多允许的传送次数，0 <= k <= 10",
        "起点为 (0, 0)，终点为 (m-1, n-1)",
        "移动方式：向右或向下（普通移动），或传送到任意满足 grid[x][y] <= grid[i][j] 的位置（成本为 0）"
      ],
      "Core Constraint": [
        "路径必须从左上角 (0, 0) 出发，只能通过右移或下移进行普通移动",
        "传送可以跳转到任意满足高度约束 grid[x][y] <= grid[i][j] 的单元格，且不消耗步数但消耗一次传送配额",
        "传送操作最多使用 k 次",
        "总成本为所有普通移动所经过的目标单元格值之和（起始点不计入成本）",
        "状态空间需同时追踪位置 (i, j) 和已用传送次数 t"
      ],
      "Objective Function": [
        "最小化从 (0, 0) 到 (m-1, n-1) 的总移动成本",
        "目标函数类型：最小化（Minimization）"
      ],
      "Algorithmic Invariant": [
        "状态定义：dp[i][j][t] = 到达 (i, j) 时使用了 t 次传送的最小成本",
        "状态转移：",
        "  - 普通移动：从上方或左方转移，更新成本",
        "  - 传送：若当前节点可通过某前驱传送到达，则可通过松弛优化状态，且 t >= 1",
        "由于传送无代价但受限于 k 次，最优解中不会重复访问同一 (i,j,t) 状态",
        "BFS 或 Dijkstra 在状态图上扩展时，距离单调不减（非负权重），可保证贪心扩展正确性",
        "传送的‘免费跳跃’性质要求在搜索过程中显式建模状态维度中的传送次数"
      ],
      "Transformable Parameters": [
        "m, n 的规模：当前为 80x80，可调整至更大（如 500）以禁止 O(mnk*mn) 解法",
        "k 的上限：当前 k <= 10，可改为 k = 0（退化为纯路径问题）或 k >= max(m,n)（允许充分传送）",
        "grid 值域：当前非负且较小，可改为含负数或极大值以影响传送条件",
        "是否允许反向传送约束（如 grid[x][y] >= grid[i][j]）",
        "是否允许多次使用传送但有冷却时间",
        "是否在线输入：逐行给出 grid，要求流式处理",
        "是否多组测试数据",
        "目标函数变化：改为计数最短路径数量，或判定是否存在成本 ≤ T 的路径",
        "移动方式变形：加入对角线移动，或限制传送只能在同行/同列",
        "结构维度变换：改为一维数组上的跳跃游戏变体，或环形网格"
      ]
    }
  },
  {
    "title": "Maximize Subarray GCD Score",
    "slug": "maximize-subarray-gcd-score",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "positive integer",
        "array_length": "n",
        "value_range": [
          1,
          1000000000
        ],
        "constraints": [
          "nums.length == n",
          "1 <= n <= 1500",
          "each element can be doubled at most once",
          "maximum k doubling operations allowed (k <= n)"
        ]
      },
      "Core Constraint": {
        "operation_constraint": "at most k elements can be doubled, each at most once",
        "subarray_constraint": "score is defined on contiguous subarrays only",
        "gcd_dependence": "GCD of a subarray is non-increasing under extension (adding elements may reduce GCD)",
        "multiplicative_interaction": "doubling an element may increase its value and potentially affect local GCD if it shares factors"
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "maximum score over all contiguous subarrays",
        "score_definition": "score = gcd(subarray) * length(subarray)",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "gcd_monotonicity_in_subarrays": "for fixed left endpoint, as right expands, gcd is non-increasing and changes at most O(log(max_value)) times",
        "limited_effect_of_doubling": "doubling affects only the value of one element; optimal doubling concentrated in promising regions",
        "local_optimality_via_greedy_selection": "within candidate subarrays, prefer applying doublings to elements that preserve or boost gcd while increasing magnitude",
        "dynamic_programming_state_feasibility": "state: (left, right, remaining_k, current_gcd) — transitions maintain gcd consistency"
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          1500
        ],
        "value_domain": [
          1,
          1000000000
        ],
        "k_range": [
          1,
          "n"
        ],
        "doubling_limit_per_element": 1,
        "total_operations_constraint": "k (global budget)",
        "input_form": "static offline array",
        "data_updates": "none (batch input)",
        "ordering": "ordered (sequence matters for subarray)",
        "multi_query": false,
        "online_processing": false,
        "allowed_modifications": [
          "allow more than one doubling with cost model",
          "change operation from double to add/multiply arbitrary factor",
          "allow undo operations",
          "extend to 2D grid submatrices",
          "change objective: minimize/maximize different function (e.g., lcm instead of gcd)",
          "constrain subarray length",
          "hide k and make it learnable from context"
        ]
      }
    }
  },
  {
    "title": "Minimum Cost Path with Edge Reversals",
    "slug": "minimum-cost-path-with-edge-reversals",
    "schema": {
      "Input Structure": [
        "有向带权图 G = (V, E)",
        "节点集合 V: |V| = n，编号从 0 到 n-1",
        "边集合 E: edges[i] = [u_i, v_i, w_i]，表示一条从 u_i 到 v_i 的有向边，权重为 w_i",
        "每条边的成本 w_i ∈ [1, 1000]",
        "数据规模: 2 <= n <= 5 * 10^4, 1 <= |E| <= 10^5"
      ],
      "Core Constraint": [
        "每个节点最多可使用一次‘边反转’开关",
        "开关只能在首次到达该节点时、且尚未使用开关的情况下激活",
        "开关作用：选择一条原始入边 v_i → u_i，将其临时反转为 u_i → v_i 并立即穿过",
        "反转边的移动成本为原边成本的 2 倍",
        "反转仅对本次移动有效，不改变图结构",
        "状态空间需同时追踪当前节点和各节点开关是否已使用（但可通过分层图建模简化）"
      ],
      "Objective Function": [
        "最小化从节点 0 到节点 n-1 的总路径成本",
        "若无法到达，则返回 -1"
      ],
      "Algorithmic Invariant": [
        "将原图扩展为两层状态图：每层代表对应节点的开关是否已被使用（0 表示未使用，1 表示已使用）",
        "状态 (u, s) 表示当前位于节点 u，其开关状态为 s（s ∈ {0,1}）",
        "普通边转移：(u, s) → (v, s)，代价为 w，前提是存在 u→v 的原始边",
        "反转边转移：若存在入边 v→u，在状态 (u, 0) 下可触发反转操作，转移到 (v, 1)，代价为 2*w",
        "Dijkstra 算法适用于此扩展图上的最短路径求解，因所有边权非负",
        "一旦离开某节点的开关未使用状态（即使用或跳过），则不能再触发反转"
      ],
      "Transformable Parameters": [
        "n 的数量级：[2, 5*10^4]",
        "边数 m 的数量级：[1, 10^5]",
        "边权范围：[1, 1000]，可变换为更大值域或含负权（影响算法选择）",
        "是否允许多次使用开关（当前为最多一次）",
        "反转成本系数：当前为 2，可参数化为 k",
        "是否允许对出边反转（当前仅限入边）",
        "是否支持多组查询 / 在线修改图结构",
        "是否要求输出路径方案而非仅最小成本",
        "是否变为无向图基础结构",
        "是否限制只能反转特定类型边"
      ]
    }
  },
  {
    "title": "Count Number of Trapezoids I",
    "slug": "count-number-of-trapezoids-i",
    "schema": {
      "Input Structure": {
        "type": "2D integer array",
        "description": "points[i] = [x_i, y_i], representing coordinates of the i-th point in Cartesian plane",
        "constraints": [
          "4 <= points.length <= 10^5",
          "-10^8 <= x_i, y_i <= 10^8",
          "All points are distinct"
        ]
      },
      "Core Constraint": {
        "geometric_condition": "A horizontal trapezoid is a convex quadrilateral with at least one pair of horizontal edges (parallel to x-axis)",
        "combinatorial_condition": "Four distinct points must be selected such that two of the edges have slope 0 (i.e., same y-coordinate), forming at least one pair of parallel horizontal sides",
        "structural_implication": "Group points by y-coordinate; only groups with >=2 points can form horizontal segments; trapezoid formed by two horizontal segments on different y-levels"
      },
      "Objective Function": {
        "goal": "Count the number of ways to choose four distinct points that form a horizontal trapezoid",
        "output_type": "Integer count modulo 10^9 + 7"
      },
      "Algorithmic Invariant": {
        "grouping_by_y": "Points are grouped by their y-coordinate. Each group represents a horizontal line.",
        "pair_contribution": "For any two distinct y-levels with m and n points respectively, the number of ways to choose one horizontal segment from each level is C(m,2) * C(n,2). These combinations form valid trapezoids if they are non-degenerate and convex (automatically satisfied when two distinct horizontal lines are used with distinct x ranges).",
        "non_overlap_requirement": "No constraint on x-overlap — partial or full overlap still forms a valid trapezoid as long as it's convex and has two horizontal sides.",
        "combinatorial_additivity": "Total count is sum over all unordered pairs of y-groups: Σ_{i < j} [C(|G_i|, 2) * C(|G_j|, 2)] where G_i is the set of points at y = y_i and |G_i| >= 2"
      },
      "Transformable Parameters": {
        "n_magnitude": "10^5 → allows O(n log n) or O(n + k^2) where k is number of distinct y-groups",
        "coordinate_range": "-10^8 to 10^8 → requires hashing or sorting, not bucketing",
        "uniqueness": "All points distinct → no duplicate handling needed",
        "modular_arithmetic": "Output mod 1e9+7 → enables large combinatorics",
        "dimensionality": "2D → possible extension to 3D with planar constraints?",
        "parallelism_definition": "Horizontal defined as slope 0 → could generalize to arbitrary slope s (rotated trapezoid), making problem rotational-invariant",
        "input_form": "Static batch input → could become online: add/remove points dynamically",
        "output_granularity": "Only count → could require listing all trapezoids or filtering by area/perimeter",
        "degeneracy_constraints": "Currently allows any convex configuration — could restrict to strictly convex, non-self-intersecting, or axis-aligned rectangles only"
      }
    }
  },
  {
    "title": "Count Special Triplets",
    "slug": "count-special-triplets",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "nums.length == n, where 3 <= n <= 1e5",
          "0 <= nums[i] <= 1e5",
          "indices are ordered: i < j < k"
        ]
      },
      "Core Constraint": {
        "description": "三元组 (i, j, k) 的合法性依赖于中间元素 nums[j] 的值，且两端元素必须分别为其两倍：nums[i] == nums[j] * 2 且 nums[k] == nums[j] * 2",
        "key_observations": [
          "关系具有中心对称性：以 j 为中心，i 和 k 分别在左侧和右侧满足等比约束",
          "数值关系是确定性的：给定 nums[j]，可唯一确定所需的 nums[i] 和 nums[k] 值",
          "索引顺序强制 i < j < k，因此不能重排数组破坏原始位置信息"
        ]
      },
      "Objective Function": {
        "goal": "count",
        "target": "number of valid index triplets (i, j, k) satisfying the special triplet condition",
        "output_modification": "return result modulo 10^9 + 7"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "对于每个固定的 j，合法的 i 的数量等于在 [0, j-1] 范围内满足 nums[i] == 2 * nums[j] 的元素个数",
          "对于每个固定的 j，合法的 k 的数量等于在 [j+1, n-1] 范围内满足 nums[k] == 2 * nums[j] 的元素个数",
          "总贡献为左右计数的乘积：count_left[j] * count_right[j]",
          "可通过预处理前缀频次与后缀频次实现 O(1) 查询"
        ],
        "optimality_guarantee": "枚举中点 j 并独立统计左右匹配项，可避免重复或遗漏，保证计数完整性"
      },
      "Transformable Parameters": {
        "n_range": "3 <= n <= 1e5",
        "value_domain": "0 <= nums[i] <= 1e5",
        "array_ordering": "original order must be preserved (index-sensitive)",
        "duplicates_allowed": true,
        "modular_arithmetic": "required: output mod 1e9+7",
        "input_variants": [
          "是否允许负数（当前不允许）",
          "是否扩展为浮点数或比例因子非2的情况（如 r=3）",
          "是否改为多组查询形式（在线版本）",
          "是否要求输出所有三元组而非仅计数",
          "是否放宽索引约束（如允许 i != j != k 但无序）",
          "是否升级为四元组结构（例如 a, b, c, d 满足链式关系）"
        ],
        "data_flow": "offline batch input",
        "multi_case_input": false
      }
    }
  },
  {
    "title": "Minimum Absolute Difference in Sliding Submatrix",
    "slug": "minimum-absolute-difference-in-sliding-submatrix",
    "schema": {
      "Input Structure": "二维整数矩阵 grid[1..m][1..n]，其中 m >= 1, n >= 1；以及整数 k，满足 1 <= k <= min(m, n)；grid[i][j] ∈ [-10^5, 10^5]",
      "Core Constraint": "每个查询子矩阵为连续的 k×k 子区域；最小绝对差依赖于子矩阵中所有不同值之间的全局比较；局部信息无法直接推导全局最小差，需维护完整的值集合或有序结构",
      "Objective Function": "对每个 k×k 子矩阵，计算其内部任意两个不同元素之间的最小绝对差；若所有元素相同，则结果为 0；目标是构造输出矩阵 ans[i][j] 表示以 (i,j) 为左上角的子矩阵的结果",
      "Algorithmic Invariant": "滑动窗口内维护一个可重复插入/删除的有序数据结构（如平衡树或多集）；在移动子矩阵时，能增量更新元素集合，并快速查询相邻元素间的最小差值；利用排序后相邻元素决定最小绝对差的性质，保持候选值单调性",
      "Transformable Parameters": {
        "数据规模": "m, n 的范围可扩展至支持更大矩阵（如 1e3 或在线场景），当前限制为 ≤30；k 可变为变量或动态输入",
        "值域": "grid[i][j] 的范围可调整（如非负、正整数、浮点数等）",
        "子矩阵形状": "从 k×k 推广到 a×b 矩形窗口（即非正方形滑动窗口）",
        "是否多组数据": "是否处理多个 k 或多个 grid 的批量查询",
        "是否在线": "grid 是否动态更新，支持单点修改后的实时查询",
        "输入形式": "可改为一维化输入流或带时间戳的数据块",
        "输出要求": "由仅返回最小差，变为返回对应元素对、所有候选差值列表或满足条件的个数"
      }
    }
  },
  {
    "title": "Multiply Two Polynomials",
    "slug": "multiply-two-polynomials",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 height，height[i] 表示第 i 根柱子的高度"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左右两侧最高柱子的最小值决定，且积水仅在当前柱子低于该最小值时发生",
        "independence": "左右侧最大高度可独立维护，但共同约束当前点的积水能力",
        "global_dependency": "局部无法确定最终积水，需依赖全局极值信息"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "计算整个数组能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "two-pointers",
        "invariant": [
          "维护左指针 L 和右指针 R，以及从左侧到 L 的最大值 maxLeft，从右侧到 R 的最大值 maxRight",
          "若 maxLeft ≤ maxRight，则 L 处的积水仅由 maxLeft 决定（因右侧已有足够屏障），可安全计算并右移 L",
          "反之，若 maxRight < maxLeft，则 R 处的积水由 maxRight 决定，可安全计算并左移 R",
          "每次移动指针后更新对应方向的最大值",
          "已计算区域的积水值不变，未访问区间仍满足单调性推进条件"
        ]
      },
      "Transformable Parameters": {
        "value_domain": {
          "allows_negative": false,
          "possible_extension": "允许负值则需重新定义‘地面’与‘坑洼’语义"
        },
        "spatial_dimension": {
          "current": "1D",
          "extension": "可扩展至 2D 接雨水问题（矩阵形式）"
        },
        "input_mode": {
          "current": "offline, static array",
          "extension": "支持在线流式输入或带修改操作（如单点更新）"
        },
        "output_requirement": {
          "current": "总和",
          "alternative": "输出每个位置的积水量 / 最大单段连续积水区"
        },
        "data_variants": {
          "sortedness": "无序",
          "circular": false,
          "duplicate_values": true
        },
        "multiple_queries": false,
        "online_operations": false
      }
    }
  },
  {
    "title": "Partition Array for Maximum XOR and AND",
    "slug": "partition-array-for-maximum-xor-and-and",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": [
          1,
          19
        ],
        "value_range": [
          1,
          1000000000
        ],
        "order_significance": true,
        "allow_empty_subsequence": true
      },
      "Core Constraint": {
        "partition_constraint": "数组必须划分为三个子序列 A、B、C，每个元素恰好属于一个子序列",
        "operation_definition": {
          "XOR": "按位异或，空序列定义为 0",
          "AND": "按位与，空序列定义为 0"
        },
        "combinatorial_dependency": "三个子序列的运算结果相互独立，但共享同一元素集合，存在资源分配冲突"
      },
      "Objective Function": {
        "goal": "maximization",
        "target_expression": "XOR(A) + AND(B) + XOR(C)",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "invariant_type": "状态可枚举性与位独立性",
        "key_insight": [
          "由于数组长度 ≤ 19，可枚举所有可能的划分方式（使用位掩码或递归枚举）",
          "XOR 和 AND 操作具有位独立性，但整体值非线性叠加，需联合优化",
          "最优解中 B（AND 子序列）通常较小且要求高位公共 1，倾向于包含共性高的数",
          "A 和 C 均为 XOR 类型，可通过分摊高异或值元素提升总和"
        ],
        "search_space_reduction": "利用数据规模小的特点，采用状态压缩动态规划或三进制枚举（每元素选 A/B/C），复杂度 O(3^n) 可接受"
      },
      "Transformable Parameters": {
        "n_size": "1 <= n <= 19 (当前约束), 可扩展至更大规模以测试算法效率边界",
        "value_domain": "nums[i] ∈ [1, 1e9], 可调整为负数或更低位宽",
        "number_of_partitions": "可推广为 k 个子序列（如：最大化 Σf_i(S_i)）",
        "operation_set": [
          "替换目标函数中的操作：如 OR(B) 替代 AND(B)",
          "改变组合形式：XOR(A) * AND(B) + XOR(C)"
        ],
        "subsequence_constraints": [
          "是否允许空子序列（当前允许）",
          "是否要求非空"
        ],
        "input_structure": "是否保持顺序不变（当前是子序列而非子集）",
        "online_processing": false,
        "multiple_test_cases": false,
        "hidden_constraints": "例如隐藏某类操作的优势条件（如 AND 在全奇数时更强）"
      }
    }
  },
  {
    "title": "Minimize Maximum Component Cost",
    "slug": "minimize-maximum-component-cost",
    "schema": {
      "Input Structure": [
        "无向连通图 G = (V, E)",
        "节点数 n，节点编号从 0 到 n-1",
        "边集 edges: 每条边为 [u, v, w]，表示连接 u 和 v 的无向边，权重 w ∈ [1, 1e6]",
        "整数 k：最终图中最多允许 k 个连通分量"
      ],
      "Core Constraint": [
        "连通分量的成本定义为该分量中边权的最大值（无边则成本为 0）",
        "目标是控制所有连通分量中的最大成本尽可能小",
        "只能通过删边来分割图，不能添加或修改边",
        "初始图连通，操作后最多有 k 个连通分量"
      ],
      "Objective Function": "最小化：在所有合法的删边方案中，使得各连通分量的最大成本中的最大值最小",
      "Algorithmic Invariant": [
        "边权排序后枚举‘最大允许边权’具有单调性：若答案 ≤ X 可行，则 ≥ X 也有可能可行（但我们要找最小可行上界）",
        "使用并查集维护连通性，在只保留权重 ≤ mid 的边时，统计连通分量个数是否 ≤ k",
        "二分答案框架成立的关键：当限制最大边权为 T 时，保留所有权 ≤ T 的边，形成的连通分量数 c(T) 是 T 的非增函数",
        "最优解一定出现在某条边的权重上（离散候选值）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 5 * 10^4",
        "边数规模": "0 <= |E| <= 10^5",
        "边权值域": "1 <= w_i <= 10^6",
        "k 的取值范围": "1 <= k <= n",
        "是否多组数据": false,
        "是否在线输入": false,
        "图是否初始连通": true,
        "是否允许重边/自环": "未明确禁止，可视为允许（不影响算法）",
        "输出形式变化": [
          "改为输出具体删边方案",
          "改为求最小总成本（而非最大成本的最小值）",
          "改为判定是否存在方案使最大成本 ≤ K"
        ],
        "约束变换": [
          "k 改为至少 k 个连通分量 → 约束反转",
          "改为必须恰好 k 个连通分量",
          "加入点权，成本变为点权最大值"
        ],
        "结构扩展": [
          "推广到有向图（复杂度上升）",
          "二维网格图上的特殊结构优化"
        ],
        "算法路径替代": [
          "主解法：二分答案 + 并查集",
          "辅助解法：Kruskal 过程中动态维护连通分量数（逆向加边）"
        ]
      }
    }
  },
  {
    "title": "Minimum Time to Visit All Houses",
    "slug": "minimum-time-to-visit-all-houses",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示柱子的高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "dependency": "左右边界约束相互独立但需全局一致，局部信息不足以确定容量，必须结合全局极值"
      },
      "Objective Function": {
        "goal": "计算总积水容量",
        "type": "sum",
        "output_semantics": "所有位置上能积攒的雨水单位总数"
      },
      "Algorithmic Invariant": {
        "invariant": "双指针维护已处理区域的最优性",
        "rules": [
          "维护左指针 L 和右指针 R，以及从左到 L 的最大值 maxLeft，从右到 R 的最大值 maxRight",
          "若 maxLeft ≤ maxRight，则 L 处的积水可由 maxLeft 唯一确定，L 右移",
          "否则 R 处的积水可由 maxRight 确定，R 左移",
          "移动指针过程中，已确定区域的解不变且正确"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "description": "是否允许高度为负值（变形题中可能表示凹陷地形）"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D",
              "circular"
            ],
            "description": "输入结构是否扩展至二维矩阵或环形数组"
          },
          {
            "name": "data_mode",
            "options": [
              "offline",
              "online"
            ],
            "description": "是否支持在线查询或动态更新（如增加/删除柱子）"
          },
          {
            "name": "output_granularity",
            "options": [
              "total_sum",
              "per_position"
            ],
            "description": "输出是总量还是每个位置的具体积水值"
          },
          {
            "name": "multiple_queries",
            "type": "boolean",
            "description": "是否为多组输入或多次询问场景"
          },
          {
            "name": "n_scale",
            "range": [
              "1e3",
              "1e5",
              "1e6+"
            ],
            "description": "数据规模变化影响算法选择（例如能否使用 O(n log n) 预处理）"
          }
        ]
      }
    }
  },
  {
    "title": "Find Minimum Log Transportation Cost",
    "slug": "find-minimum-log-transportation-cost",
    "schema": {
      "Input Structure": [
        "两个整数 n 和 m，表示两根木材的长度（1 <= n, m <= 2 * k）",
        "一个整数 k，表示每辆卡车能装载的最大木材长度（2 <= k <= 1e5）",
        "所有输入均为正整数",
        "切割操作可将一段长度为 x 的木材分为 len1 和 len2，满足 len1 + len2 = x"
      ],
      "Core Constraint": [
        "每辆卡车最多装载一根木材，且其长度不能超过 k",
        "总共只有三辆卡车，因此最终必须得到至多三段木材",
        "若某根木材长度 > k，则必须被切割；否则可直接运输",
        "切割成本定义为 cost = len1 * len2，具有乘法代价结构",
        "初始仅有两段木材，最多进行一次分割操作（因为从2段变到3段只需切一次）"
      ],
      "Objective Function": "最小化总切割成本（若无需切割则为0）",
      "Algorithmic Invariant": [
        "最优解中至多只进行一次切割：因为起始有2段，目标≤3段，故最多切1次",
        "当且仅当至少一根木材长度 > k 时才需要切割",
        "若需切割，应选择使 cost = len1 * len2 最小化的分法，其中一段 ≤ k，另一段任意（但后续也需满足 ≤ k 或进一步处理）",
        "由于只能切一次，问题退化为枚举哪一根木材被切割以及如何切，使得所有段 ≤ k 且总成本最小",
        "贪心性质：在固定分割位置下，乘积 len1 * len2 在两者接近时最大，在极端不均时最小 → 应尽可能将超长部分‘剥离’成最小合法段"
      ],
      "Transformable Parameters": {
        "n, m 的数量级": "当前为 O(k)，可扩展至更大规模以要求公式解",
        "k 的范围": "当前为 [2, 1e5]，影响是否可用打表或预处理",
        "是否允许多次切割": "当前隐含限制为最多一次（因只需3段），可改为允许多次并计入累计成本",
        "卡车数量": "当前为3，可推广为 t 辆卡车 → 需要更多段 → 更复杂的切割策略",
        "成本函数形式": "当前为 len1 * len2，可变换为 |len1 - len2|、max(len1, len2) 等以改变优化方向",
        "是否在线输入": "当前为单组数据，可改为多组测试用例批量处理",
        "输出形式": "当前为最小成本，可改为构造方案或判断可行性",
        "木材数量": "当前为2根，可推广为数组 A[1..p] 表示 p 根木材，目标装入 t 辆卡车"
      }
    }
  },
  {
    "title": "Maximize Count of Distinct Primes After Split",
    "slug": "maximize-count-of-distinct-primes-after-split",
    "schema": {
      "Input Structure": {
        "description": "一个长度为 n 的整数数组 nums，以及一个二维整数数组 queries",
        "types": [
          "一维数组 nums[0..n-1], 其中 n >= 2",
          "每个元素 nums[i] ∈ [1, 10^5]",
          "质数定义：大于1且仅能被1和自身整除的自然数",
          "queries 是二维数组，每个 query = [idx, val] 表示将 nums[idx] 更新为 val",
          "所有更新是持久化的（影响后续查询）"
        ]
      },
      "Core Constraint": {
        "description": "每次更新后需选择最优分割点 k ∈ [1, n-1]，使得前缀与后缀中不同质数的个数之和最大",
        "constraints": [
          "前缀为非空子数组 nums[0..k-1]，后缀为非空子数组 nums[k..n-1]",
          "k 的取值范围是 1 <= k < n，保证前后均非空",
          "目标函数依赖于两个子数组中出现的不同质数的数量（集合大小）",
          "质数识别是静态的（基于数值本身，不随位置变化）",
          "数组可重复、无序，且存在频繁单点更新"
        ]
      },
      "Objective Function": {
        "type": "最大化",
        "goal": "在所有可能的分割位置 k 中，找到使（前缀不同质数个数 + 后缀不同质数个数）最大的值",
        "output": "每个查询返回该最大值，构成结果数组"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "整个问题的核心在于快速维护每个位置左右两侧的不同质数集合",
          "使用前缀哈希集和后缀哈希集预处理结构，支持动态更新下的高效重算",
          "由于每次只修改一个位置的值，其影响仅限于包含该位置的所有前缀和后缀",
          "可以维护两个数组：leftPrimes[i] = nums[0..i] 中不同质数集合（或位掩码/哈希），rightPrimes[i] = nums[i..n-1] 中不同质数集合",
          "但直接维护所有 i 的 leftPrimes 和 rightPrimes 在频繁更新下代价高，因此需要惰性更新或分块优化策略",
          "最优解法依赖于‘单点修改对整体分割影响局部化’这一不变量：即只有跨越修改点的分割才受影响",
          "若用线段树或分块结构维护区间质数集合的并，则可在 O(√n) 或 O(log n) 时间内完成一次更新与查询"
        ],
        "key_insight": "答案 = max_{1<=k<n} ( |P_left(k)| + |P_right(k)| )，其中 P_left(k) 是前缀质数集合，P_right(k) 是后缀质数集合。此函数可通过维护从左到右和从右到左的累积质数集合来计算"
      },
      "Transformable Parameters": {
        "parameters": [
          "n 的数量级：当前为 5×10⁴，可调整至 10^5 或更低以适应不同复杂度算法",
          "queries 长度：当前最多 5×10⁴，是否支持离线处理或强制在线",
          "值域范围：nums[i] ≤ 10^5，决定了质数表预处理上限（可用筛法预处理）",
          "是否允许负数或零：当前均为正整数，变形题可引入非自然数",
          "是否多组数据：当前为单组输入，可扩展为 T 组测试用例",
          "更新方式：当前为单点赋值更新，可变为增量更新、区间更新",
          "是否在线：当前 queries 顺序执行且依赖前次状态，属于强在线模式",
          "输出形式：当前只需最大值，可改为输出最优 k 或所有方案计数",
          "约束放松：k 可等于 0 或 n（允许空段），当前不允许",
          "目标变换：由‘最大和’变为‘最小和’或‘是否存在某个阈值以上的分割’"
        ],
        "extensibility": [
          "升级为二维数组上的区域分割问题",
          "加入删除 / 插入操作（动态数组）",
          "质数条件替换为其他数论属性（如完全平方数、斐波那契数等）",
          "将‘不同质数个数’替换为加权和或其他聚合函数"
        ]
      }
    }
  },
  {
    "title": "Two-Letter Card Game",
    "slug": "two-letter-card-game",
    "schema": {
      "Input Structure": [
        "字符串数组 cards[1..n], 其中 n = len(cards)",
        "每个 cards[i] 是长度为 2 的小写英文字母串",
        "字母范围限定为 'a' 到 'j'",
        "给定一个目标字符 x ∈ ['a'..'j']"
      ],
      "Core Constraint": [
        "只有包含字符 x 的牌才能参与配对",
        "两张牌兼容当且仅当它们的字符串在恰好 1 个位置上不同",
        "每轮移除一对兼容牌，每对最多使用一次",
        "游戏结束条件：无法再找到兼容的牌对"
      ],
      "Objective Function": "最大化可形成的兼容牌对数量（即得分）",
      "Algorithmic Invariant": [
        "兼容关系具有对称性但不具传递性，构成无向图匹配结构",
        "最优策略等价于在由兼容性定义的图中求最大基数匹配",
        "由于数据规模较小（n ≤ 10^5 但满足含 x 的牌数实际有限），可在筛选后的候选集上进行贪心或图匹配",
        "局部选择不影响全局最优：因目标仅为计数最大匹配，可建图后使用匈牙利算法或基于位掩码的状态压缩DP（当候选集很小）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题为 ≤ 10^5，但有效节点数受限于含 x 的牌数（通常很小）",
        "字符串长度": "当前固定为 2，可扩展至 k=3 或更长以改变兼容判断复杂度",
        "兼容定义": "可改为 '至多 1 位不同' 或 '恰好 2 位不同' 等",
        "是否允许重复使用牌": "当前不允许，可设为允许多次使用（带权流）",
        "输入形式": "可变为动态添加/删除牌（在线版本）",
        "多组数据": "可支持 T 组测试用例",
        "目标函数变化": "从最大匹配数 → 构造方案 / 判定是否存在完美匹配",
        "约束条件变化": "x 变为多个字符，要求牌包含至少一个指定字符",
        "图结构限制": "当候选牌数较小时，问题退化为小图最大匹配，适合状态压缩"
      }
    }
  },
  {
    "title": "Transform Array to All Equal Elements",
    "slug": "transform-array-to-all-equal-elements",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "values": [
          -1,
          1
        ],
        "length": "n",
        "constraints": {
          "n_range": "1 <= n <= 1e5",
          "element_restriction": "nums[i] ∈ {-1, 1}",
          "initial_condition": "no restrictions on pattern"
        }
      },
      "Core Constraint": {
        "operation_definition": "flip adjacent pair: nums[i] *= -1, nums[i+1] *= -1",
        "operation_limit": "at most k operations",
        "operation_properties": [
          "operations can be applied repeatedly to the same index",
          "each operation affects exactly two adjacent elements",
          "parity of the product of the entire array is invariant"
        ],
        "invariant_observation": "The product of the entire array remains constant modulo sign flips in pairs → overall product is preserved."
      },
      "Objective Function": "determine if it's possible to make all elements equal (either all 1 or all -1) after at most k operations",
      "Algorithmic Invariant": {
        "key_insight": "Making all elements equal implies the final state is either all 1s or all -1s. Since each operation preserves the total product, only one target state is reachable depending on the initial product.",
        "reduction_rule": "Problem reduces to transforming the array into a uniform state via minimal number of adjacent sign-flip operations.",
        "transformation_invariance": "Each operation is equivalent to toggling a 'difference marker' between positions; problem can be transformed into counting and pairing of -1/1 transitions (i.e., boundaries).",
        "greedy_structure": "Optimal strategy involves resolving adjacent mismatches greedily or through interval covering of transition points.",
        "monotonicity": "Number of required operations is determined by the number and positions of sign changes in the array."
      },
      "Transformable Parameters": {
        "k_value": {
          "range": "1 <= k <= n",
          "role": "maximum allowed operations"
        },
        "n_value": {
          "range": "up to 1e5",
          "implication": "requires O(n) or O(n log n) solution"
        },
        "element_domain": {
          "current": "binary {-1, 1}",
          "possible_variants": [
            "generalized to {a, b} with ab < 0",
            "allow more than two values (breaks invariant)"
          ]
        },
        "operation_type": {
          "current": "multiply adjacent pair by -1",
          "variants": [
            "reverse operation direction",
            "allow non-adjacent pairs (increases complexity)",
            "add cost per index"
          ]
        },
        "input_form": {
          "current": "offline, single array",
          "possible_extensions": [
            "online updates",
            "multiple queries with different k",
            "support for element modification"
          ]
        },
        "circular_array": {
          "current": "linear array",
          "variant": "if array is circular (index n-1 and 0 are adjacent), changes connectivity and parity handling"
        },
        "objective_variant": [
          "minimize number of operations needed",
          "count number of ways to achieve uniformity within k steps",
          "return sequence of operations"
        ]
      }
    }
  },
  {
    "title": "Maximum Good Subtree Score",
    "slug": "maximum-good-subtree-score",
    "schema": {
      "Input Structure": [
        "一棵以 0 为根的无向树，包含 n 个节点（编号 0 到 n-1）",
        "每个节点 i 有一个整数值 vals[i]（1 <= vals[i] <= 1e9）",
        "父数组 par 表示树结构：par[0] = -1，其余 par[i] 表示节点 i 的父节点",
        "树通过父数组隐式给出，可通过建图还原子树结构"
      ],
      "Core Constraint": [
        "好子集定义：从子树中选取若干节点，其值的十进制数位中，数字 0~9 每个最多出现一次",
        "子集选择具有全局约束性：一旦某数位被使用，其他含该数位的数不能再选",
        "每个节点的 maxScore[u] 独立计算，但依赖其子树内所有节点的选择组合",
        "同一数字在不同数位中的重复出现会破坏‘好’性质（如 22 含两个 '2'）"
      ],
      "Objective Function": [
        "对每个节点 u，求以 u 为根的子树中，好子集的最大分数（即节点值总和）",
        "最终目标是返回所有 maxScore[u] 的总和（模 1e9+7）"
      ],
      "Algorithmic Invariant": [
        "树形 DP 自底向上递推：每个节点的状态由其子节点合并而来",
        "状态表示使用位掩码（mask）记录当前已使用的数字集合（共 10 位，对应 0~9）",
        "状态转移时枚举当前节点是否加入子集，并与子节点状态做笛卡尔积合并，保留最优值",
        "合并过程中剪枝：仅保留每个 mask 下的最大分数（相同 mask 只需保留最大值）",
        "父子状态合并满足结合律且不影响后续决策的最优性"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前为 ≤500，可调整至 ≤100（简化）或 ≥1000（加强记忆化/状态压缩）",
        "vals[i] 值域：当前为 [1, 1e9]，可限制为小范围（如 <1000）或允许负数",
        "数字唯一性约束：可改为每个数字最多出现 k 次（k>1），变为多重计数问题",
        "是否要求构造方案：当前只需最大值，可改为输出具体子集",
        "是否多组数据：当前单组输入，可扩展为 T 组测试",
        "是否在线构建树：当前离线输入 par 数组，可改为动态加点/删点操作",
        "树形态变化：可推广为 DAG、森林或多根树",
        "状态维度扩展：将‘数字频次’改为更复杂的约束（如奇偶性、模意义下频次）"
      ]
    }
  },
  {
    "title": "Subsequence Sum After Capping Elements",
    "slug": "subsequence-sum-after-capping-elements",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "正整数 k",
        "nums[i] ∈ [1, n]",
        "1 <= n <= 4000",
        "1 <= k <= 4000"
      ],
      "Core Constraint": [
        "对于每个 x ∈ [1, n]，构造限制数组 A_x，其中 A_x[i] = min(nums[i], x)",
        "子序列可任意选择（非空），但不能改变元素顺序",
        "目标值 k 固定，需判断在不同 x 下是否能恰好凑出和为 k 的子序列",
        "随着 x 增大，可用数值单调不减，可行状态集合单调扩张"
      ],
      "Objective Function": [
        "对每个 x ∈ [1, n]，判定是否存在一个子序列，其元素和恰好等于 k",
        "输出长度为 n 的布尔数组 answer，answer[i] 对应 x = i+1 的判定结果"
      ],
      "Algorithmic Invariant": [
        "状态可达性具有单调性：若某个和 s 在 x 时可达，则在所有 x' > x 时仍可能可达（因元素值不会变小）",
        "使用动态规划维护当前可达到的和的集合，随着 x 递增逐步更新 DP 状态",
        "DP[x][s] 表示在限制值为 x 时能否达到和 s；可通过滚动数组优化空间",
        "当处理到 x 时，所有 nums[i] >= x 的元素可贡献至多 x，而 nums[i] < x 的保持不变"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 ~ 4000",
          "k": "1 ~ 4000",
          "nums[i] 范围": "[1, n]"
        },
        "输入形式": "单组离线输入，固定 nums 和 k",
        "是否多组数据": false,
        "是否在线": false,
        "约束变化": [
          "x 的取值范围可改为 [1, M] 且 M ≠ n",
          "允许负数或零元素（需调整 min 操作语义）",
          "要求输出方案而非仅判定",
          "改为求最小/最大可达和不超过 k",
          "目标函数由 '恰好为 k' 改为 '至少为 k' 或 '至多为 k'"
        ],
        "结构扩展": [
          "二维数组版本：对矩阵每行进行 cap 操作后选子序列",
          "改为连续子数组而非子序列",
          "加入删除操作或多次查询的在线版本"
        ],
        "目标变换": [
          "计数问题：对每个 x，统计有多少个子序列和恰好为 k",
          "最优化问题：找最小的 x 使得可以凑出 k"
        ]
      }
    }
  },
  {
    "title": "Find Most Frequent Vowel and Consonant",
    "slug": "find-most-frequent-vowel-and-consonant",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters 'a' to 'z'",
        "length": "n, where 1 <= n <= 100",
        "constraints": [
          "s consists only of lowercase letters"
        ]
      },
      "Core Constraint": {
        "vowel_set": [
          "a",
          "e",
          "i",
          "o",
          "u"
        ],
        "consonant_set": "all lowercase letters not in vowel_set",
        "frequency_definition": "count of occurrences of a letter in s",
        "partitioning": "characters are partitioned into vowels and consonants; frequency maxima are computed independently within each group"
      },
      "Objective Function": {
        "goal": "sum of two maximum frequencies",
        "components": [
          "maximum frequency among vowels (if any, else 0)",
          "maximum frequency among consonants (if any, else 0)"
        ],
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "independence_invariant": "vowel and consonant frequency distributions are independent; maximizing each group separately leads to global optimal sum",
        "monotonicity": "frequency counts are non-decreasing with traversal; maximum can be updated in single pass",
        "greedy_selection": "when multiple letters have same max frequency, any can be chosen — does not affect sum"
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          100
        ],
        "alphabet_type": "fixed: 26 lowercase letters",
        "vowel_definition": "can be modified (e.g., include 'y', or language-specific vowels)",
        "case_sensitivity": "currently case-insensitive (only lowercase); can be made sensitive",
        "input_type": "single string",
        "multiple_queries": false,
        "online_input": false,
        "output_requirements": [
          "current: sum of two maxima",
          "alternative: return the letters themselves",
          "alternative: return both maxima separately"
        ],
        "tie_handling": "currently arbitrary selection allowed; can require lexicographically smallest or all options"
      }
    }
  },
  {
    "title": "Minimum Deletions for At Most K Distinct Characters",
    "slug": "minimum-deletions-for-at-most-k-distinct-characters",
    "schema": {
      "Input Structure": [
        "字符串 s（由小写英文字母组成），长度为 n",
        "整数 k，表示结果字符串中最多允许的不同字符数量",
        "1 <= n <= 16, 1 <= k <= 16"
      ],
      "Core Constraint": [
        "不同字符的数量必须 ≤ k",
        "删除操作是全局的：若删除某个字符，则该字符在串中的所有出现均被移除",
        "保留的字符相对顺序不变",
        "目标是最小化删除的总字符数，等价于最大化保留的字符总数"
      ],
      "Objective Function": "最小化需要删除的字符数量（即：最小化 |s| - |保留子序列长度|）",
      "Algorithmic Invariant": [
        "最优解中保留的字符集合大小 ≤ k",
        "对于任意保留字符集 C（|C| ≤ k），其贡献为该集合中各字符在原串中的总出现次数之和",
        "枚举所有可能的字符子集（共 2^26 种但实际受限于 s 中出现的字符），选择使保留总数最大的子集",
        "由于字符集仅 26 个小写字母，且输入规模极小（n ≤ 16），暴力枚举子集是可行且最优的"
      ],
      "Transformable Parameters": {
        "n 的数量级": "当前为 [1,16]，可扩展至 1e5（此时需贪心+频率排序）",
        "k 的范围": "当前为 [1,16]，可变为 0 或 ≥26 的情况",
        "是否允许字符重复计数": "当前不允许，可改为限制每字符最多保留 t 次",
        "输入形式": "当前为单组字符串，可改为多组数据或在线查询",
        "字符集类型": "当前为小写字母 a-z，可推广至大写、数字或 Unicode",
        "操作类型": "当前只能删除，可增加插入/替换形成编辑距离类问题",
        "目标函数变换": "从‘最小删除数’变为‘是否存在方案’或‘计数满足条件的方案数’",
        "约束方向反转": "从‘最多 k 个不同字符’变为‘至少 k 个’",
        "数据流化": "从静态字符串变为动态添加字符的流式输入"
      }
    }
  },
  {
    "title": "Minimum Moves to Clean the Classroom",
    "slug": "minimum-moves-to-clean-the-classroom",
    "schema": {
      "Input Structure": [
        "二维网格图 classroom[1..m][1..n]",
        "每个单元格为字符：'S'(起点), 'L'(垃圾), 'R'(能量重置点), 'X'(障碍), '.'(空地)",
        "整数 energy 表示最大能量容量",
        "m, n ∈ [1, 20], energy ∈ [1, 50]",
        "恰好一个 'S', 最多 10 个 'L'"
      ],
      "Core Constraint": [
        "移动消耗：每次向相邻四方向移动消耗 1 单位能量",
        "能量为 0 时，仅当位于 'R' 上可继续移动（立即恢复至 energy）",
        "'R' 可多次使用且无冷却",
        "不可进入 'X'",
        "必须收集所有 'L'（即访问每一个 'L' 至少一次）",
        "状态依赖于位置 + 当前能量值 + 已收集垃圾集合"
      ],
      "Objective Function": "求收集所有垃圾所需的最少移动次数；若无法完成，返回 -1",
      "Algorithmic Invariant": [
        "状态空间具有有限性：位置 (i,j) × 能量值 e ∈ [0,energy] × 已收集垃圾子集 mask",
        "BFS 在状态三元组 (i, j, e, mask) 上保持最短路径性质",
        "一旦某个状态 (i, j, e, mask) 被访问，后续到达该状态的路径不会更优",
        "能量恢复机制在 'R' 上触发，允许无限续航但需路径可达",
        "最优子结构：从当前状态到完成收集的最小代价不随历史路径变化"
      ],
      "Transformable Parameters": [
        "网格规模：m, n 的数量级（当前 ≤20，可扩展至支持更大或动态）",
        "垃圾数量上限（当前 ≤10，影响 mask 维度）",
        "energy 值范围（当前 ≤50）",
        "是否允许多个起始点",
        "是否在线输入（逐步给出移动指令）",
        "是否加入时间限制或移动顺序约束",
        "'R' 是否有使用次数限制",
        "能量恢复是否部分恢复而非满额",
        "目标函数变换：改为最小化能量消耗 / 判定可行性 / 计数方案数",
        "输入维度变换：3D 网格 / 图结构替代网格",
        "隐藏条件：'R' 的位置隐式满足某种模式（如曼哈顿距离最近）"
      ]
    }
  },
  {
    "title": "Smallest Index With Digit Sum Equal to Index",
    "slug": "smallest-index-with-digit-sum-equal-to-index",
    "schema": {
      "Input Structure": "一维整数数组 nums[0..n-1]，其中 n >= 1；nums[i] 为非负整数且值域在 [0, 1000] 范围内",
      "Core Constraint": "每个下标 i 的判定条件依赖于 nums[i] 的数位和（digit sum）与下标 i 本身的数值相等性；判断逻辑仅涉及单个元素的局部计算，无前后依赖",
      "Objective Function": "寻找满足数位和等于下标 i 的最小下标 i；若不存在则返回 -1",
      "Algorithmic Invariant": "从左到右遍历过程中，一旦找到首个满足条件的下标 i，则后续更优解不可能存在（因下标严格递增），可立即终止搜索",
      "Transformable Parameters": {
        "数据规模 n": "1 <= n <= 100（当前）；可扩展至 1e5 或更大以要求预处理优化",
        "nums[i] 值域": "0 <= nums[i] <= 1000（当前）；可调整至更高（如 1e9）以强调数位和计算效率",
        "是否有序": "数组无序（默认）；可设定为有序以引入二分查找变体",
        "目标函数形式": "当前求‘最小下标’；可改为求‘最大下标’或‘所有满足下标的数量’",
        "数位和定义": "当前为十进制各位相加；可变换进制（如二进制、八进制）或加权数位和",
        "是否多组数据": "单组输入（当前）；可改为多组测试用例批量处理",
        "是否在线": "离线一次性输入（当前）；可设计为流式输入动态查询"
      }
    }
  },
  {
    "title": "Find Maximum Area of a Triangle",
    "slug": "find-maximum-area-of-a-triangle",
    "schema": {
      "Input Structure": "二维数组 coords[1..n][2]，其中 n 个点的坐标为 (x_i, y_i)，满足 x_i, y_i ∈ [1, 10^6]，所有点互不相同，定义在无限笛卡尔平面上",
      "Core Constraint": "三角形必须至少有一条边与 x 轴或 y 轴平行；即存在两个顶点具有相同的 x 坐标（竖直边）或相同的 y 坐标（水平边）；且面积非零（三点不共线）",
      "Objective Function": "最大化三角形面积的两倍（即返回 2 * A），若不存在满足条件的三角形则返回 -1",
      "Algorithmic Invariant": "对于每一条与坐标轴平行的边（固定 x 或固定 y），可通过枚举同一线上的端点对，并寻找第三个不在该线上的点使高最大，从而局部确定最大贡献；最优解必出现在某条水平线或竖直线上的点对与其最远垂直/水平距离点构成的三角形中",
      "Transformable Parameters": {
        "n 的数量级": "n ∈ [1, 10^5]",
        "值域范围": "x_i, y_i ∈ [1, 10^6]",
        "是否有序": "输入无序，可按 x 或 y 排序预处理",
        "是否循环": "否",
        "是否多组输入": "单组输入（可扩展为多组测试用例）",
        "是否在线": "离线处理全部点",
        "约束变化": [
          "改为要求两条边与坐标轴平行（直角三角形且直角边平行轴）",
          "改为任意方向边均可（一般最大面积三角形，退化为凸包+旋转卡壳）",
          "加入面积为零允许与否的开关",
          "输出实际三角形顶点而非仅面积"
        ],
        "目标变换": [
          "从最大面积 → 计数满足条件的非退化三角形个数",
          "从最大 → 最小正面积"
        ],
        "维度扩展": "可推广至三维中与坐标平面平行的面所形成的四面体体积问题"
      }
    }
  },
  {
    "title": "Lexicographically Smallest String After Adjacent Removals",
    "slug": "lexicographically-smallest-string-after-adjacent-removals",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length_range": [
          1,
          250
        ],
        "circular_alphabet": true
      },
      "Core Constraint": {
        "removable_pair": "two adjacent characters that are consecutive in the circular alphabet (e.g., 'a' and 'b', 'z' and 'a')",
        "operation_effect": "after removal, remaining characters are left-shifted to fill the gap",
        "operation_repetition": "arbitrary number of operations allowed, including zero"
      },
      "Objective Function": "construct the lexicographically smallest string achievable after any sequence of valid removals",
      "Algorithmic Invariant": {
        "greedy_reduction": "if a removable pair exists and its removal leads to a lexicographically smaller or equally good result, it can be processed greedily under certain conditions",
        "stack_monotonicity": "use a stack to maintain a non-increasing sequence with respect to adjacency constraints; when top two elements form a consecutive pair in the circular alphabet, they can be removed",
        "local_optimality": "removing a consecutive pair early does not prevent achieving global optimality if done within a monotonic stack framework",
        "irreversibility": "once a pair is removed, the resulting string cannot reintroduce the original adjacency — operations are irreversible and reduce length"
      },
      "Transformable Parameters": {
        "string_length": "n ∈ [1, 250]",
        "character_set": "can be generalized to arbitrary ordered set or larger alphabets",
        "consecutive_definition": "can change from circular ('a' and 'z' are consecutive) to linear (non-circular)",
        "operation_direction": "can restrict removal to only forward-order (e.g., 'a' then 'b') or allow both",
        "objective_variation": [
          "change objective from lexicographically smallest to longest/shortest possible string",
          "count number of distinct reachable strings",
          "determine if empty string is reachable"
        ],
        "input_dynamics": "can transform into an online version where characters are appended one by one and query for current optimal string",
        "multiple_operations": "allow other types of operations (e.g., insertions, swaps) alongside removals"
      }
    }
  },
  {
    "title": "Minimum Steps to Convert String with Operations",
    "slug": "minimum-steps-to-convert-string-with-operations",
    "schema": {
      "Input Structure": [
        "两个长度相等的字符串 word1[1..n] 和 word2[1..n]",
        "字符集为小写英文字母（a-z）",
        "1 <= n <= 100"
      ],
      "Core Constraint": [
        "允许将 word1 分割为若干连续非空子串",
        "每个子串可独立进行三种操作：替换、交换、反转",
        "每个字符在每种操作中最多参与一次（即单个字符不能在同一操作类型中被多次使用）",
        "操作成本按操作次数计，而非字符数",
        "目标是联合优化分割策略与子串操作序列"
      ],
      "Objective Function": "最小化将 word1 转换为 word2 所需的总操作次数",
      "Algorithmic Invariant": [
        "子问题具有最优子结构：任意前缀的最优分割与操作方案可递推构建",
        "对于固定子串区间 [i, j]，其转换到目标子串的最小操作数仅依赖于字符频率、匹配模式和顺序差异",
        "反转和交换操作可改变字符顺序，但不改变字符多重集合；替换操作可改变字符内容",
        "动态规划状态可定义为 dp[i] = 将 word1[1..i] 转换为 word2[1..i] 的最小操作数",
        "枚举最后一个子串的起始位置 k，转移时求解 substr(word1[k..i], word2[k..i]) 的最小操作代价"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题 n ≤ 100，可扩展至 n ≤ 1e3（需优化子串代价预处理）或 n ≤ 1e5（需贪心/近似）",
        "字符集": "当前为小写字母，可变为大写、数字、Unicode 字符等",
        "是否允许操作复用": "当前禁止字符重复参与同种操作，可改为允许有限次（如最多两次）",
        "操作种类": [
          "可删除某类操作（如禁用反转，则退化为编辑距离+交换）",
          "可增加操作（如插入/删除字符，变为传统编辑距离）",
          "可限制操作顺序（如必须先交换再替换）"
        ],
        "子串约束": [
          "是否强制必须分割成至少 k 段",
          "是否限制最大子串长度"
        ],
        "是否多组数据": "当前单组输入，可改为 T 组测试数据",
        "是否在线": "当前离线处理两字符串，可设计为逐步输入字符并实时更新答案",
        "输出形式": [
          "当前仅输出最小操作数",
          "可要求输出具体分割方案与每步操作序列"
        ],
        "目标函数变体": [
          "计数：求最小操作数的方案总数",
          "判定：是否存在不超过 K 次操作的转换方式",
          "最大化保留原始字符数（对偶视角）"
        ]
      }
    }
  },
  {
    "title": "Find Product Recommendation Pairs",
    "slug": "find-product-recommendation-pairs",
    "schema": {
      "Input Structure": [
        "表 ProductPurchases: (user_id: int, product_id: int, quantity: int), 主键为 (user_id, product_id)",
        "表 ProductInfo: (product_id: int, category: varchar, price: decimal), 主键为 product_id",
        "数据表示用户购买记录与产品元信息"
      ],
      "Core Constraint": [
        "同一用户购买的不同 product_id 构成一个可挖掘的共现集合",
        "产品对 (p1, p2) 必须满足 p1 < p2 以避免重复计数",
        "仅考虑至少被 3 个不同用户共同购买的产品对",
        "共现关系基于用户粒度，不依赖购买数量（quantity 不影响共现判定）"
      ],
      "Objective Function": [
        "识别所有满足最小支持度（≥3 用户）的频繁共现产品对",
        "对每个符合条件的产品对，统计共同购买的用户数量（customer_count）",
        "输出包含 product1_id, product2_id, 对应类别及 customer_count",
        "结果按 customer_count 降序，再按 product1_id 升序，product2_id 升序排序"
      ],
      "Algorithmic Invariant": [
        "用户内部的产品集合是无序但完整的共现单元",
        "任意两个产品在同一个用户的购买历史中最多贡献一次共现",
        "通过哈希映射维护：(min_product_id, max_product_id) → 用户集合，保证去重与有序",
        "最终筛选时，集合大小 ≥3 的产品对具有稳定的支持度计数"
      ],
      "Transformable Parameters": {
        "Minimum Support Threshold": "共现所需的最少用户数（当前为3，可调整为k）",
        "Co-occurrence Definition": "是否要求同一订单内共现 vs. 历史累计共现",
        "Quantity-aware": "是否将 quantity 作为权重纳入共现强度计算",
        "Temporal Window": "是否限制在时间窗口内的购买行为（如最近30天）",
        "Output Filtering": "是否加入类别一致性约束（如同类推荐）或跨类限制",
        "Sorting Priority": "排序字段可变：如优先按 product1_category 分组等",
        "Data Scale": "用户数和产品数规模，影响哈希表或分布式处理需求",
        "Online Processing": "是否流式接收购买事件并动态更新共现频率"
      }
    }
  },
  {
    "title": "Count the Number of Computer Unlocking Permutations",
    "slug": "count-the-number-of-computer-unlocking-permutations",
    "schema": {
      "Input Structure": {
        "type": "array",
        "description": "长度为 n 的一维数组 complexity[0..n-1]",
        "element_type": "非负整数",
        "constraints": [
          "2 <= n <= 1e5",
          "1 <= complexity[i] <= 1e9",
          "数组元素可重复"
        ],
        "initial_state": "编号为 0 的计算机已解锁，作为根节点；其余计算机初始上锁"
      },
      "Core Constraint": {
        "unlock_rule": "只有当存在 j < i 且 complexity[j] < complexity[i] 时，才能通过计算机 j 解锁计算机 i",
        "dependency_structure": "解锁顺序必须满足拓扑依赖：每个位置 i 的解锁依赖于其左侧某个复杂度更小的已解锁计算机",
        "connectivity_requirement": "所有计算机必须能从编号 0 的根节点通过合法路径依次解锁",
        "structural_implication": "若存在某个 i > 0 且对所有 j < i 都有 complexity[j] >= complexity[i]，则无法解锁该计算机 → 整体无解"
      },
      "Objective Function": {
        "goal": "计数",
        "target": "统计所有 [0, 1, ..., n-1] 的排列中，能够表示有效解锁顺序的总数",
        "output_form": "返回结果对 10^9 + 7 取模",
        "note": "排列中的顺序代表解锁时间顺序，而非索引顺序；要求整个序列构成合法的依赖演化过程"
      },
      "Algorithmic Invariant": {
        "monotonicity_in_blocks": "将数组按复杂度分组后，相同复杂度的块之间具有独立性与顺序约束",
        "combinatorial_independence": "在满足全局可达的前提下，不同连通分量或层级之间的插入顺序可组合计数",
        "greedy_merge_condition": "对于每个最小不可达前缀（如第一个 complexity[i] <= min(complexity[0..i-1]) 的位置），若不满足解锁条件则整体为 0",
        "dp_combination_rule": "设 f(i) 表示前 i+1 个元素的有效方案数，则可通过维护‘可扩展点’的数量进行乘法合并",
        "stack_property": "使用单调栈维护当前可用的‘较低复杂度’解锁源，以支持后续更高复杂度节点的接入"
      },
      "Transformable Parameters": {
        "n_range": "2 <= n <= 1e5 (可调整至更小用于 DP 枚举)",
        "value_domain": "complexity[i] ∈ [1, 1e9] (可改为有序/离散化/负值等变形)",
        "uniqueness": "允许重复值（关键）→ 若改为全唯一则简化为树形结构计数",
        "initial_unlocked_nodes": "可扩展为多个初始解锁节点（如所有 complexity[i] == min_val 的节点自动解锁）",
        "dependency_direction": "当前仅允许 j < i → 可改为任意 j ≠ i（图结构建模）",
        "online_query": "是否支持动态修改 complexity 数组并重新查询答案",
        "output_detail": "是否要求输出具体方案而非仅计数",
        "modular_arithmetic": "模数是否固定为 1e9+7 或可变",
        "constraint_type": "当前为 '<' 比较 → 可变换为 '≤', '>', 或加入差值阈值约束"
      }
    }
  },
  {
    "title": "Power Grid Maintenance",
    "slug": "power-grid-maintenance",
    "schema": {
      "Input Structure": [
        "整数 c，表示电站数量，编号从 1 到 c",
        "二维数组 connections，长度为 n，表示 c 个节点之间的无向边，构成一个静态图结构",
        "二维数组 queries，每个元素为 [type, x]，其中 type ∈ {1, 2}，x 是电站编号",
        "图结构是静态的（连接关系不变），但节点状态动态变化（在线/离线）"
      ],
      "Core Constraint": [
        "电网由连通分量定义：初始时通过 connections 构建连通性，后续不因离线而改变拓扑结构",
        "离线节点仍属于原连通分量，但不能响应查询",
        "每个查询类型 [1, x] 的响应依赖于 x 所在连通分量中当前在线且编号最小的电站",
        "问题本质是：在静态图的连通分量上维护动态点状态，并支持快速查询连通分量内的最小活跃节点"
      ],
      "Objective Function": [
        "对每个类型为 [1, x] 的查询，输出能响应该检查的电站 id；若无，则返回 -1",
        "目标函数是构造型 + 判定型：构造响应者 id 或判定不存在",
        "输出顺序与查询中 [1, x] 出现顺序一致"
      ],
      "Algorithmic Invariant": [
        "使用并查集（Union-Find）预处理初始连通分量，保证 O(α(n)) 查询连通性归属",
        "每个连通分量维护一个可更新的最小堆（或有序集合），仅包含当前在线的电站",
        "当执行 [2, x] 操作时，将 x 从其所属连通分量的活跃集合中移除",
        "每次查询 [1, x] 时，定位 x 所属连通分量，取其活跃集合中的最小值（若存在）",
        "并查集结构不变，仅活跃节点集合动态演化；支持高效删除和最小值查询"
      ],
      "Transformable Parameters": {
        "c 的数量级": "1 <= c <= 1e5",
        "connections 规模": "0 <= n <= min(1e5, c*(c-1)/2)",
        "queries 规模": "1 <= queries.length <= 2e5",
        "图是否连通": "可以是多个连通分量",
        "是否允许重边/自环": "不允许（输入约束 u_i ≠ v_i）",
        "节点状态变化形式": "只支持离线操作（不可恢复在线）",
        "是否支持在线恢复": "否（本题中只有 down，无 up）",
        "是否多组数据": "否（单次输入）",
        "是否在线输入": "是（queries 逐个处理）",
        "最小标识符策略": "可改为最大、最近访问、优先级权重等（变形空间）",
        "活跃集合维护方式": "可用 TreeSet、堆 + 延迟删除、或线段树替代"
      }
    }
  },
  {
    "title": "Range XOR Queries with Subarray Reversals",
    "slug": "range-xor-queries-with-subarray-reversals",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given a 1D array H[1..n], where each element H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The water that can be trapped at any position depends on the minimum of the maximum heights to its left and right, minus its own height.",
        "key_insight": "Local trapping capacity is bounded by global left and right maxima; left and right constraints are separable but must be jointly considered."
      },
      "Objective Function": {
        "goal": "sum",
        "description": "Compute the total amount of rainwater that can be trapped after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers (L, R) move toward each other while maintaining the invariants:",
        "rules": [
          "maxLeft maintains the maximum height from the left up to L",
          "maxRight maintains the maximum height from the right up to R",
          "If maxLeft ≤ maxRight, then the trapped water at L is determined solely by maxLeft - H[L], because the right side has a larger or equal barrier",
          "Similarly, if maxRight < maxLeft, then the trapped water at R is determined by maxRight - H[R]",
          "Pointer movement preserves correctness: smaller side is advanced without missing optimal contributions"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allows_negative_heights"
            ],
            "note": "Negative values break physical meaning but may appear in variants"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D"
            ],
            "note": "2D version becomes volumetric trapping over a height map"
          },
          {
            "name": "input_form",
            "options": [
              "offline_batch",
              "online_streaming"
            ],
            "note": "Streaming input requires incremental state update design"
          },
          {
            "name": "query_type",
            "options": [
              "total_sum",
              "per_position_output",
              "range_query_trapping"
            ],
            "note": "Changes output format and potentially data structure needs"
          },
          {
            "name": "dynamic_operations",
            "options": [
              "static",
              "supports_update_delete"
            ],
            "note": "Support for point updates leads to segment tree / sqrt decomposition solutions"
          },
          {
            "name": "data_order",
            "options": [
              "arbitrary",
              "sorted"
            ],
            "note": "Sorted arrays may allow binary search acceleration"
          },
          {
            "name": "spatial_topology",
            "options": [
              "linear",
              "circular"
            ],
            "note": "Circular array connects last to first, changing boundary conditions"
          },
          {
            "name": "multi_instance",
            "options": [
              "single_case",
              "multiple_test_cases"
            ],
            "note": "Impacts initialization overhead and I/O handling"
          }
        ]
      }
    }
  },
  {
    "title": "Minimum Threshold for Inversion Pairs Count",
    "slug": "minimum-threshold-for-inversion-pairs-count",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "An array H[1..n] representing heights of vertical lines or bars, where each element H[i] ≥ 0"
      },
      "Core Constraint": {
        "left_right_independence": true,
        "bottleneck_by_min_of_maxima": true,
        "global_dependency": "The contribution of position i depends on min(max_left[i], max_right[i]))",
        "monotonicity_implication": "Prefix and suffix maximums determine local constraints"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "Compute total trapped water capacity after rain",
        "per_position_contribution": "max(0, min(max_left[i], max_right[i]) - H[i])"
      },
      "Algorithmic Invariant": {
        "two_pointers": true,
        "invariant_description": "Maintain maxLeft and maxRight as the highest bar encountered so far from left and right respectively; if maxLeft ≤ maxRight, then the water at the left pointer is determined solely by maxLeft (and vice versa)",
        "pointer_movement_rule": "Move the pointer with smaller edge height because the trapped water on that side is bottlenecked by the lower outer boundary",
        "optimality_preservation": "No future state will alter the correctness of already computed positions"
      },
      "Transformable Parameters": {
        "value_domain": {
          "allows_negative_heights": false,
          "possible_extension_to_negative": "Would require redefinition of 'trapped water'"
        },
        "spatial_dimension": {
          "current": "1D",
          "possible_extensions": [
            "2D grid",
            "circular array"
          ]
        },
        "input_mode": {
          "default": "offline batch input",
          "extensions": [
            "online queries",
            "dynamic updates (insert/delete/modify)"
          ]
        },
        "output_requirements": {
          "current": "total sum",
          "variants": [
            "per-position contribution",
            "maximum single-trap region",
            "first k units of trapped water location"
          ]
        },
        "data_properties": {
          "sortedness": "unsorted",
          "multiplicity": "duplicates allowed",
          "constraints_on_n": "1 ≤ n ≤ 10^5"
        },
        "multiple_test_cases": false,
        "additional_constraints": []
      }
    }
  },
  {
    "title": "Resulting String After Adjacent Removals",
    "slug": "resulting-string-after-adjacent-removals",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n",
        "n_range": [
          1,
          100000
        ],
        "cyclic_alphabet": true,
        "description": "A string s of length n consisting of lowercase English letters. The alphabet is cyclic: 'a' and 'z' are considered adjacent."
      },
      "Core Constraint": {
        "removal_condition": "two consecutive characters in the alphabet (in either order, forward or backward)",
        "continuity_definition": "characters c1 and c2 are continuous if (ord(c1) - ord(c2)) % 26 == 1 or (ord(c2) - ord(c1)) % 26 == 1",
        "operation_rule": "always remove the leftmost valid pair of adjacent continuous characters",
        "dependency": "the removal operation may create new adjacent pairs, so order of removal matters structurally but result is deterministic due to greedy leftmost rule"
      },
      "Objective Function": {
        "goal": "construct final string",
        "objective_type": "construction",
        "output_requirement": "return the remaining string after no more operations can be performed"
      },
      "Algorithmic Invariant": {
        "invariant_description": "using a stack-based simulation to emulate greedy leftmost elimination",
        "stack_property": "top of stack and current character form a contiguous pair iff they can be removed",
        "monotonicity": "each character is pushed and popped at most once, ensuring O(n) time complexity",
        "correctness_guarantee": "the stack maintains the irreducible prefix under the given removal rules; no earlier decision invalidates later optimality because removals are local and non-overlapping in effect when processed left-to-right"
      },
      "Transformable Parameters": {
        "alphabet_cyclic": {
          "default": true,
          "possible_values": [
            true,
            false
          ]
        },
        "direction_policy": {
          "default": "leftmost",
          "possible_values": [
            "leftmost",
            "rightmost",
            "any"
          ]
        },
        "target_objective": {
          "default": "final string",
          "possible_variants": [
            "final string",
            "length of final string",
            "whether final string is empty",
            "number of operations"
          ]
        },
        "input_dimension": {
          "default": "1D string",
          "possible_extensions": [
            "2D grid of characters",
            "circular string"
          ]
        },
        "operation_rules": {
          "default": "remove one pair per step, leftmost first",
          "possible_modifications": [
            "allow parallel removals",
            "add cost per removal",
            "restrict removal count"
          ]
        },
        "online_processing": {
          "default": "offline",
          "possible_modes": [
            "offline",
            "online character streaming"
          ]
        },
        "data_size": {
          "n_range": [
            1,
            100000
          ],
          "extension_potential": "up to 1e6 with efficient implementation"
        }
      }
    }
  },
  {
    "title": "Maximum Product of Two Digits",
    "slug": "maximum-product-of-two-digits",
    "schema": {
      "Input Structure": "正整数 n（10 <= n <= 10^9），其十进制数字构成一个可重复的一维数字集合 D = {d_0, d_1, ..., d_{k-1}}，其中 k 是 n 的位数，d_i ∈ [0,9] 且 d_0 ≠ 0",
      "Core Constraint": "可以从数字集合 D 中任意选取两个数字（允许重复选取同一位置的数字，若该数字在 n 中出现多次）进行乘法运算；所有可能的两数组合构成有限搜索空间",
      "Objective Function": "求所有可选两位数字对 (a, b) 的乘积 a * b 的最大值",
      "Algorithmic Invariant": "最大乘积一定由集合 D 中的两个最大数字取得；即若 max1 = max(D), max2 = max(D \\ {max1}) 或 max2 = max1（当 max1 出现至少两次时），则最优解为 max1 * max2；该性质不依赖于顺序或位置，仅依赖数值大小和频次",
      "Transformable Parameters": {
        "n的数量级": "10 <= n <= 10^9（最多10位）",
        "值域": "每位数字 ∈ [0,9]，首位非零",
        "是否有序": "输入数字序列无序处理，只关注数值与频次",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "可变目标函数": [
          "改为最小乘积（排除0干扰）",
          "计数：有多少对数字乘积等于最大值",
          "判定：是否存在一对数字乘积 >= K"
        ],
        "扩展操作": [
          "限制只能使用不同位置的数字",
          "每个数字只能使用一次（考虑频次约束）",
          "选择三位数字乘积的最大值",
          "要求输出具体是哪两个数字"
        ],
        "输入形式变形": [
          "直接给定数字数组而非整数 n",
          "以字符串形式输入 n",
          "支持负整数（引入符号影响乘积）"
        ]
      }
    }
  },
  {
    "title": "Subtree Inversion Sum",
    "slug": "subtree-inversion-sum",
    "schema": {
      "Input Structure": {
        "type": "Tree",
        "representation": "Undirected tree with n nodes, rooted at node 0",
        "edges": "2D integer array edges of length n - 1, where edges[i] = [u_i, v_i] denotes an edge between nodes u_i and v_i",
        "values": "Integer array nums of length n, where nums[i] represents the value of node i",
        "constraint_parameter": "Integer k representing minimum distance between ancestor-descendant reversed nodes",
        "node_count": "n, where 2 <= n <= 5 * 10^4",
        "value_range": "-5 * 10^4 <= nums[i] <= 5 * 10^4",
        "k_range": "1 <= k <= 50"
      },
      "Core Constraint": {
        "reversal_operation": "Reversing a node multiplies all values in its subtree by -1",
        "distance_restriction": "If two reversed nodes are in ancestor-descendant relationship, their path distance (number of edges) must be at least k",
        "dependency_structure": "Subtree reversal affects all descendants; decisions are coupled across paths from root to leaves",
        "independence_condition": "Two reversal choices can coexist only if either they are not on the same root-to-leaf path or are separated by at least k edges when one is ancestor of the other"
      },
      "Objective Function": {
        "goal": "Maximize",
        "output_type": "Maximum possible sum of node values after applying valid reversals",
        "optimization_target": "Global sum of nums array post-reversals under constraints"
      },
      "Algorithmic Invariant": {
        "state_representation": "Dynamic programming state per node includes depth and last reversal ancestor within k-distance",
        "tree_dp_propagation": "Decision at a node depends only on ancestors within k steps above due to constraint locality",
        "optimal_substructure": "For each node, optimal choice (reverse or not) can be determined recursively based on children's outcomes and nearest conflicting ancestor decision",
        "state_compression": "Only need to track up to k generations of ancestral reversal states due to bounded dependency range",
        "monotonicity_in_dependency": "The farther apart two potential reversal nodes are along a path, the less direct interference they have"
      },
      "Transformable Parameters": {
        "tree_structure": [
          "Rooted tree → Unrooted tree requiring re-rooting DP",
          "General tree → Binary tree / Chain (linear) tree"
        ],
        "k_value": [
          "k = 1: adjacent ancestor reversal allowed",
          "k large (e.g., > depth): only one reversal per path allowed",
          "k as variable vs fixed small constant"
        ],
        "operation_rules": [
          "Change reversal scope: reverse only self instead of whole subtree",
          "Reverse non-ancestor pairs within distance < k forbidden (symmetric constraint)",
          "Allow multiple operations with different cost models"
        ],
        "objective_variation": [
          "Maximize sum → Minimize sum → Count number of valid reversal sets → Decide existence of solution ≥ target"
        ],
        "input_form": [
          "Offline batch input → Online edge/value updates",
          "Single query → Multiple k queries over same tree"
        ],
        "data_properties": [
          "nums[i] can be zero/negative/positive → restrict to positive-only for greedy baselines",
          "Add weights to edges for distance computation"
        ],
        "additional_operations": [
          "Support point updates to nums → dynamic version",
          "Support structural changes to tree"
        ]
      }
    }
  },
  {
    "title": "Find Maximum Number of Non Intersecting Substrings",
    "slug": "find-maximum-number-of-non-intersecting-substrings",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n",
        "constraints": [
          "1 <= n <= 2 * 10^5",
          "non-empty contiguous substring allowed"
        ]
      },
      "Core Constraint": {
        "substring_properties": [
          "first and last characters are the same",
          "length >= 4"
        ],
        "selection_constraint": "selected substrings must be non-overlapping (disjoint)"
      },
      "Objective Function": "maximization",
      "Algorithmic Invariant": {
        "greedy_selection": "once a valid substring is selected, it blocks overlapping candidates",
        "state_separation": "after fixing a chosen substring [i, j], the problem reduces independently to the right of j",
        "monotonic_progress": "scan from left to right; if a maximal short valid substring (e.g., length 4) starting at i can be taken, it does not harm optimality due to non-overlap and maximization of count"
      },
      "Transformable Parameters": {
        "length_constraint": "minimum length k (default 4), can be parameterized",
        "character_condition": "first and last character equality,可替换为 other symmetric conditions (e.g., palindrome prefix/suffix)",
        "overlap_policy": [
          "non-overlapping (current)",
          "overlapping allowed",
          "at most one overlap"
        ],
        "objective_variation": [
          "maximize number of substrings (current)",
          "maximize total length of substrings",
          "minimize uncovered characters"
        ],
        "alphabet_type": [
          "lowercase letters (current)",
          "general string",
          "binary string"
        ],
        "input_form": [
          "single string (current)",
          "multiple queries",
          "online character stream"
        ],
        "data_scale": "n up to 2*10^5,可扩展至支持更大规模或分块处理"
      }
    }
  },
  {
    "title": "Maximum Weighted K-Edge Path",
    "slug": "maximum-weighted-k-edge-path",
    "schema": {
      "Input Structure": [
        "有向无环图（DAG），节点数 n（1 ≤ n ≤ 300）",
        "边集 edges，其中每条边为 [u_i, v_i, w_i]，表示从 u_i 到 v_i 的有向边，权值 w_i ∈ [1,10]",
        "整数 k（0 ≤ k ≤ 300），表示路径必须恰好包含 k 条边",
        "整数 t（1 ≤ t ≤ 600），表示路径总权值必须严格小于 t"
      ],
      "Core Constraint": [
        "图是有向无环图（DAG），可进行拓扑排序与动态规划状态转移",
        "路径必须恰好包含 k 条边，不能多也不能少",
        "路径的边权和必须严格小于 t，即 sum < t",
        "目标是在满足上述约束下最大化边权和"
      ],
      "Objective Function": "在所有恰好包含 k 条边且总权值严格小于 t 的路径中，求最大边权和；若不存在则返回 -1",
      "Algorithmic Invariant": [
        "使用分层动态规划（DP over steps）：定义 dp[i][v][s] 表示从前若干节点出发、经过 i 条边到达节点 v、总权值为 s 时是否可达（或记录最大值）",
        "由于是 DAG，可通过拓扑序逐步推进状态，避免环导致的无限递归",
        "状态转移满足：若存在边 (u, v, w)，则 dp[i+1][v][s + w] 可由 dp[i][u][s] 转移而来",
        "最终答案为 max{ s | 存在节点 v，使得 dp[k][v][s] = true 且 s < t }，若无则为 -1",
        "可优化为二维滚动数组 + 按步迭代的方式，控制复杂度"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前为 ≤300，可扩展至支持更大规模（如引入矩阵快速幂优化）",
        "k 的范围：当前 ≤300，可设为变量槽位用于控制路径长度约束",
        "t 的范围与含义：可变换为目标函数类型（如改为 ≥t 或 =t），或变为在线查询模式",
        "边权类型：当前为正整数 [1,10]，可改为负权、实数、或带权重区间",
        "图结构：当前为 DAG，可变形为一般有向图（允许环，需处理无限长路径）或树形结构",
        "是否允许多组数据输入",
        "是否要求输出具体路径方案（构造解）而非仅数值",
        "目标函数变换：从‘最大边权和’变为‘是否存在’或‘计数’满足条件的路径",
        "约束组合变化：如将‘恰好 k 条边’改为‘最多 k 条边’，或将‘<t’改为‘≤t’"
      ]
    }
  },
  {
    "title": "Make a Positive Array",
    "slug": "make-a-positive-array",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "ordered": false,
        "duplicate_allowed": true,
        "description": "An integer array height of length n, where each element represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The amount of water that can be trapped at any position depends on the minimum of the maximum heights to its left and right, minus its own height.",
        "key_insight": "Water trapping is determined by global left-right maxima; local decisions depend on non-local information.",
        "structure_property": "Each position's contribution is bounded by the shorter of the two tallest bars on either side."
      },
      "Objective Function": {
        "goal": "sum",
        "objective": "Compute the total amount of rainwater that can be trapped after raining.",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "Two pointers (left and right) move toward each other based on which side has the smaller current maximum.",
          "At each step, if max_left <= max_right, then the water level at left is determined solely by max_left (and vice versa for right).",
          "The correctness of the trapped water at the current end with smaller max is preserved regardless of future values beyond the opposite pointer."
        ],
        "state_preservation": "The invariant ensures that moving the pointer from the side with smaller maximum does not affect the validity of accumulated result."
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          "0",
          "10^5"
        ],
        "input_variations": [
          "Allow negative heights (interpretation changes)",
          "Change to 2D grid (e.g., elevation map)",
          "Circular arrangement of bars",
          "Online version: process queries dynamically as heights are updated",
          "Output per-position trapped water instead of total sum",
          "Support update operations (e.g., change one height)"
        ],
        "data_mode": "offline",
        "multiple_test_cases": false,
        "constraints_modifiable": {
          "monotonicity": "Original array not sorted; variant could assume partial order",
          "bounded_memory": "Standard case assumes full array access; streaming variant restricts memory"
        }
      }
    }
  },
  {
    "title": "Maximum Profit from Trading Stocks with Discounts",
    "slug": "maximum-profit-from-trading-stocks-with-discounts",
    "schema": {
      "Input Structure": [
        "整数 n，表示员工数量（1 ≤ n ≤ 160）",
        "两个长度为 n 的整数数组 present[1..n] 和 future[1..n]，其中 present[i] 表示第 i 位员工当前购买价格，future[i] 表示其明日卖出价格（1 ≤ present[i], future[i] ≤ 50）",
        "二维整数数组 hierarchy，长度为 n-1，表示树形层级关系：hierarchy[i] = [u_i, v_i] 表示 u_i 是 v_i 的直属上司",
        "整数 budget，表示总预算（1 ≤ budget ≤ 160）",
        "员工编号从 1 到 n，员工 1 为 CEO，构成一棵以 1 为根的有向树"
      ],
      "Core Constraint": [
        "层级依赖约束：只有当某员工的直属上司购买了股票，该员工才能以折扣价 floor(present[v] / 2) 购买",
        "每个员工最多只能购买一次股票",
        "购买决策具有依赖性：子节点是否享受折扣取决于父节点是否购买",
        "利润独立可加：每位员工若购买，贡献利润为 future[i] - cost[i]，其中 cost[i] 为实际购买价",
        "预算约束全局耦合：所有购买成本之和不得超过 budget"
      ],
      "Objective Function": "在不超过 budget 的前提下，选择一组员工及其购买策略（原价或折扣价），使得总利润（即 ∑(future[i] - cost[i])）最大化",
      "Algorithmic Invariant": [
        "树形 DP 状态定义不变量：dp[u][b] 表示在以员工 u 为根的子树中，使用预算 b 所能获得的最大利润",
        "状态转移时考虑两种情况：u 是否购买股票（影响其子节点能否享受折扣）",
        "子树间背包合并：对每个子节点 v，将 dp[v][*] 作为分组背包的一组选项，进行卷积式合并",
        "折扣条件触发不变量：仅当 u 购买时，其子节点 v 可以按 floor(present[v]/2) 的成本参与决策",
        "状态单调性：dp[u][b] 关于 b 非递减"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前为 160，可扩展至支持更大规模（如 1e3）并要求更优复杂度",
        "budget 范围：当前 ≤160，可改为更大的值或引入 log 值域压缩",
        "树结构形式：当前为普通有根树，可变换为链状、星型、完全二叉树等特殊结构",
        "折扣规则变化：例如改为 '任意祖先购买即可享折扣' 或 '需所有上级都购买'（AND 条件）",
        "多级折扣：根据上级链长度逐层打折",
        "输入形式：是否在线添加员工/层级、是否动态修改价格",
        "目标函数变换：改为最小化成本、判断是否存在可行解、计数满足利润阈值的方案数",
        "是否允许重复购买或多次交易",
        "是否允许多次预算注入（如未来收益可再投资）",
        "present/future 值域范围：当前较小（≤50），可用于设计位运算或状态压缩变形题"
      ]
    }
  },
  {
    "title": "Minimum Weighted Subgraph With the Required Paths II",
    "slug": "minimum-weighted-subgraph-with-the-required-paths-ii",
    "schema": {
      "Input Structure": [
        "无向带权树，节点数为 n（3 <= n <= 10^5）",
        "边集 edges 表示：edges[i] = [u_i, v_i, w_i]，长度为 n - 1，构成一棵树",
        "权重 w_i 为正整数（1 <= w_i <= 10^4）",
        "查询数组 queries：queries[j] = [src1_j, src2_j, dest_j]，其中三个节点互不相同",
        "输入保证是连通无环图（即树结构）"
      ],
      "Core Constraint": [
        "子树必须是原树中的连通子图，且包含从 src1_j 和 src2_j 到 dest_j 的路径",
        "最优子树的边集应最小化总权重，同时满足双源点可达目标点",
        "由于是树结构，任意两点间路径唯一；因此问题可转化为路径并集上的优化",
        "最终子树至少需包含 src1_j → dest_j 和 src2_j → dest_j 两条路径的并集"
      ],
      "Objective Function": [
        "对每个查询 [src1, src2, dest]，求一个连通子树的最小总权重",
        "该子树需支持从 src1 和 src2 均能到达 dest",
        "目标函数为：最小化所选边的权重和"
      ],
      "Algorithmic Invariant": [
        "在树中，任意两节点路径唯一，路径可通过 LCA 或 DFS 预处理得到",
        "src1 → dest 与 src2 → dest 路径的并集构成候选边集的下界（必须包含）",
        "最优解对应的子树恰好是这两条路径的边的并集（因为添加额外边只会增加代价）",
        "因此答案等于 path(src1, dest) ∪ path(src2, dest) 上所有边权之和",
        "使用预处理（如倍增法求LCA + 边权前缀和）可在 O(1) 或 O(log n) 时间响应每条查询"
      ],
      "Transformable Parameters": [
        "n 的数量级：[1e3, 1e5] 可变，影响是否需要预处理加速",
        "边权值域：正整数，可扩展为非负或允许负权（改变贪心性质）",
        "是否多组数据：当前单棵树+多查询，可改为多测试用例",
        "查询类型变化：从 (src1, src2, dest) 改为更多源点（如 k 个起点到 dest）",
        "是否在线：当前离线查询，可设计为动态加入查询或动态修改边权",
        "输入形式：可由显式边列表变为父节点表示或邻接表直接输入",
        "约束放松：从‘必须形成子树’变为‘只需连通路径’，但本题因树结构自动满足",
        "输出形式：可要求输出具体边集而非仅总权重"
      ]
    }
  },
  {
    "title": "Path Existence Queries in a Graph II",
    "slug": "path-existence-queries-in-a-graph-ii",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1]，表示每个节点的值",
        "整数 n 表示节点数量（编号从 0 到 n-1）",
        "整数 maxDiff 表示建边阈值",
        "二维整数数组 queries，每个查询为 [u_i, v_i]"
      ],
      "Core Constraint": [
        "图中节点 i 和 j 之间存在无向边当且仅当 |nums[i] - nums[j]| <= maxDiff",
        "边是无权重的，因此最短路径即为边数最少的路径",
        "图结构由数值差约束隐式定义，而非直接给出邻接关系",
        "queries 数量大，要求高效响应多组查询"
      ],
      "Objective Function": [
        "对每个查询 [u_i, v_i]，求节点 u_i 到 v_i 的最短距离（边数）",
        "若不可达，则返回 -1",
        "最终输出所有查询结果组成的数组"
      ],
      "Algorithmic Invariant": [
        "连通性仅依赖于节点值之间的绝对差是否 <= maxDiff",
        "可预处理构建图的邻接表，利用 BFS 求解无权图最短路径",
        "多源查询可通过预处理连通分量 + 分量内BFS 或 Floyd-Warshall（受限于n规模）优化",
        "由于 n <= 1e5，但边可能密集，需注意建图复杂度；实际有效做法是：先排序+滑动窗口建图以避免 O(n^2) 全比较"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^5",
        "nums 值域": "0 <= nums[i] <= 10^5",
        "maxDiff 范围": "0 <= maxDiff <= 10^5",
        "是否有序": "nums 无序，但可通过排序辅助建图",
        "是否循环": "否",
        "是否多组输入": "否，单次输入",
        "是否在线": "queries 可视为离线，允许预处理后批量回答",
        "图构建方式": "隐式图（由数值条件动态生成），可变体包括显式建图 / 在线加点",
        "查询类型扩展": "可改为连通性判定 / 路径计数 / 动态修改 nums 后重查"
      }
    }
  },
  {
    "title": "Find Sum of Array Product of Magical Sequences",
    "slug": "find-sum-of-array-product-of-magical-sequences",
    "schema": {
      "Input Structure": [
        "整数 m：表示魔法序列的长度",
        "整数 k：表示二进制置位数量的目标",
        "整数数组 nums[0..n-1]，其中 n = nums.length，1 <= n <= 50",
        "每个 seq[i] 是索引，满足 0 <= seq[i] < n"
      ],
      "Core Constraint": [
        "魔法序列 seq 的长度为 m，元素为 nums 的合法索引",
        "表达式 2^seq[0] + 2^seq[1] + ... + 2^seq[m-1] 的二进制表示中恰好有 k 个 1",
        "由于 2^i 在二进制中是单一位，因此该和的二进制形式等价于将这些位 i 置 1，即相当于从 [0, n-1] 中选择若干索引（允许重复）并统计其在二进制位上的合并结果是否含 k 个 1",
        "注意：相同索引可多次出现，因此 2^i 可能被累加多次，但若次数为偶数，则对应位为 0（模 2 意义下），这引入了 GF(2) 上的线性代数结构"
      ],
      "Objective Function": "计算所有满足条件的魔法序列 seq 的数组乘积 prod(seq) = ∏_{j=0}^{m-1} nums[seq[j]] 的总和，并对 10^9 + 7 取模",
      "Algorithmic Invariant": [
        "使用动态规划维护状态 dp[i][mask][ones] 表示前 i 步选择后，当前二进制掩码为 mask（或更优地，在 GF(2) 下的向量空间），且最终结果中置位数为 ones 的所有路径的乘积和",
        "但由于 m <= 30 且 n <= 50，直接枚举掩码不可行；关键不变量是：每一步添加一个索引 j，相当于在二进制位 j 上执行异或（若考虑模 2 加法）或计数模 2",
        "真正的不变量是：最终和的二进制中第 b 位是否为 1，取决于所有选中的 2^j 中有多少个 j == b 且其出现次数为奇数",
        "因此可以转换视角：设 cnt[b] 表示索引 b 被选中的次数，则最终该位是否置位 = (cnt[b] % 2 == 1)，而总置位数 = sum_b (cnt[b] % 2) == k",
        "目标函数具有可分解性：总乘积和 = 所有满足 ∑(cnt[b] % 2) = k 的组合下，(m! / ∏ cnt[b]!) × ∏ (nums[b] ^ cnt[b]) 的和 —— 但这涉及多重组合，需用生成函数或 DP over bit parity",
        "最优解法依赖于状态压缩 DP：令 dp[i][parity_mask] 表示已选 i 个元素，当前各位置位奇偶性组成的掩码为 parity_mask 时的所有方案的乘积和。转移：枚举下一个使用的索引 j ∈ [0, n)，更新 parity_mask ^= (1 << j)，并乘上 nums[j]"
      ],
      "Transformable Parameters": [
        "m 的范围：当前 1 <= m <= 30 → 可扩展至更大值（如 1e5）以要求数学优化",
        "k 的取值：当前 1 <= k <= m → 可改为 k >= K 或 k != K 等约束反转",
        "nums.length 和值域：当前 <= 50, nums[i] <= 1e8 → 可增大以测试模运算性能",
        "是否允许负数？→ 当前均为正整数",
        "是否要求输出方案而非求和？→ 当前为计数型求和",
        "是否在线构造？→ 当前为离线一次性输入",
        "是否多组测试数据？→ 提示未说明，但可设定为多组",
        "变换维度：从一维索引选择 → 二维网格路径选择仍满足位条件",
        "目标函数变换：从‘乘积之和’变为‘最大乘积’或‘方案数’",
        "约束隐藏：不显式给出 2^seq[i] 形式，而是描述为‘某个编码函数的汉明权重为 k’"
      ]
    }
  },
  {
    "title": "Equal Sum Grid Partition II",
    "slug": "equal-sum-grid-partition-ii",
    "schema": {
      "Input Structure": {
        "type": "2D grid",
        "dimensions": "m x n",
        "element_type": "positive integers",
        "constraints": [
          "1 <= m == grid.length <= 10^5",
          "1 <= n == grid[i].length <= 10^5",
          "2 <= m * n <= 10^5",
          "1 <= grid[i][j] <= 10^5"
        ]
      },
      "Core Constraint": {
        "partition_rule": "exactly one horizontal or vertical cut",
        "non_empty_parts": true,
        "balance_condition": "sums of two parts are equal, or can become equal by removing at most one cell",
        "connectivity_requirement": "after removal (if any), both parts must remain 4-directionally connected",
        "removal_impact": "removed cell must belong to one part only; the rest of that part must stay connected"
      },
      "Objective Function": "boolean decision: return true if there exists a valid cut (with optional removal under constraints) that satisfies sum equality and connectivity; otherwise false",
      "Algorithmic Invariant": {
        "cut_evaluation_invariance": "for each candidate cut (horizontal or vertical), total sum of both sides can be computed incrementally using prefix sums",
        "balance_check_logic": "if total_sum is even, check for exact split; if odd, check whether (total_sum ± removed_value) can yield balance with one cell removal",
        "connectivity_preservation_rule": "after removing a cell, perform BFS/DFS on remaining cells in each part to verify 4-directional connectivity",
        "early_termination": "once a valid configuration (cut + optional removal + connectivity) is found, return true immediately"
      },
      "Transformable Parameters": {
        "grid_dimensions": [
          "1D array reduction",
          "larger 2D grids",
          "toroidal/cylindrical grid"
        ],
        "cut_types": [
          "multiple cuts allowed",
          "diagonal cuts",
          "arbitrary shape partitions"
        ],
        "removal_limit": [
          "zero removal",
          "up to k removals",
          "weighted penalty instead of removal"
        ],
        "connectivity_model": [
          "8-directional",
          "fixed anchor points",
          "dynamic connectivity queries"
        ],
        "objective_variation": [
          "count number of valid cuts",
          "find optimal cell to remove",
          "minimize removed value"
        ],
        "input_mode": [
          "offline static grid",
          "online updates (cell modifications)",
          "streaming rows/columns"
        ],
        "data_properties": [
          "allow negative values",
          "non-integer elements",
          "unordered vs sorted grids"
        ]
      }
    }
  },
  {
    "title": "Equal Sum Grid Partition I",
    "slug": "equal-sum-grid-partition-i",
    "schema": {
      "Input Structure": "二维矩阵 grid[1..m][1..n]，其中 m ≥ 1, n ≥ 1, 元素为正整数；总元素个数满足 2 <= m * n <= 10^5",
      "Core Constraint": "只能使用一条水平或一条垂直分割线（即沿行间或列间切分），分割后两部分均为非空子矩阵；两部分的元素和必须相等",
      "Objective Function": "判定是否存在一种合法的水平或垂直分割方式，使得分割后的两个非空部分元素和相等",
      "Algorithmic Invariant": "全局总和为 S，则任一前缀和等于 S/2 的位置即为有效分割点；行方向上前缀和单调递增，列方向同理；若 S 为奇数，则不可能存在合法分割",
      "Transformable Parameters": {
        "数据规模": {
          "m 和 n 的数量级": "可扩展至 10^6 或更高（需优化输入处理）",
          "值域范围": "grid[i][j] 可变为非负整数、允许零或负数"
        },
        "输入形式": {
          "是否有序": "当前无序，可考虑特殊结构（如每行/列有序）",
          "是否循环": "可设计环形矩阵变形（首尾相连）"
        },
        "分割方式限制": {
          "切割维度": "可限定仅水平 / 仅垂直 / 允许两者之一 / 允许多条切割线",
          "切割次数": "从单一切割扩展为恰好 k 次切割"
        },
        "目标函数变化": [
          "计数：求所有可行分割方案的数量",
          "最小化：两部分差值的绝对值最小化",
          "构造：输出具体分割位置"
        ],
        "在线性": "是否支持动态修改矩阵元素并实时查询是否存在合法分割",
        "多组数据": "是否处理多个独立测试用例"
      }
    }
  },
  {
    "title": "Analyze Subscription Conversion ",
    "slug": "analyze-subscription-conversion",
    "schema": {
      "Input Structure": [
        "表 UserActivity，包含字段：user_id (int), activity_date (date), activity_type (varchar), activity_duration (int)",
        "主键为 (user_id, activity_date, activity_type)",
        "activity_type ∈ {'free_trial', 'paid', 'cancelled'}",
        "activity_duration ≥ 0，表示用户当日使用时长（分钟）",
        "每个 user_id 可有多条记录，按时间分布"
      ],
      "Core Constraint": [
        "用户行为具有状态序列性：必须先有 free_trial，之后可转为 paid 或 cancelled",
        "只关注完成状态转移路径 'free_trial → paid' 的用户",
        "同一用户的多个活动按 activity_date 时间顺序排列",
        "免费试用期和付费期的时间段不重叠，且付费期严格在试用期之后"
      ],
      "Objective Function": [
        "筛选出从 free_trial 成功转为 paid 的用户",
        "对每位符合条件的用户：",
        "  - 计算其在所有 free_trial 日的平均 daily activity_duration（保留两位小数）",
        "  - 计算其在所有 paid 日的平均 daily activity_duration（保留两位小数）",
        "返回结果按 user_id 升序排序"
      ],
      "Algorithmic Invariant": [
        "状态转移方向不可逆：free_trial → paid 是唯一有效路径，cancelled 为终止态",
        "每个用户的数据可通过分组聚合独立处理（无跨用户依赖）",
        "平均值计算满足可分离性：sum(duration)/count(days)，支持增量更新",
        "排序输出仅依赖 user_id，可在最后一步统一完成"
      ],
      "Transformable Parameters": {
        "n_users": "用户数量，可变范围（例如 10^2 ~ 10^6）",
        "n_activities_per_user": "每用户活动记录数，是否稀疏或密集",
        "trial_period_days": "免费试用期长度约束（如固定7天，或任意长度）",
        "conversion_path": [
          "可变换的状态路径：如 'free_trial → paid'",
          "扩展路径如 'free_trial → paid → cancelled'",
          "或多阶段路径分析"
        ],
        "aggregation_function": [
          "目标函数可改为：总时长、最大单日时长、中位数等",
          "是否加入加权平均（如按时间衰减）"
        ],
        "output_format": [
          "是否要求输出试用/付费期间的起止时间",
          "是否输出原始数据列表",
          "是否四舍五入，精度是否可调"
        ],
        "filtering_criteria": [
          "是否要求试用期满7天才计入",
          "是否排除中途取消后又付费的用户（多轮行为）",
          "是否允许多次转换（multi-conversion 用户建模）"
        ],
        "data_mode": [
          "离线批处理（一次性全量输入）",
          "在线流式输入（逐条插入，支持实时查询）"
        ],
        "ordering_requirement": "是否必须按 user_id 排序；可改为按平均时长排序"
      }
    }
  },
  {
    "title": "Minimum Swaps to Sort by Digit Sum",
    "slug": "minimum-swaps-to-sort-by-digit-sum",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums[i] 是互不相同的正整数",
        "1 <= n <= 10^5",
        "1 <= nums[i] <= 10^9"
      ],
      "Core Constraint": [
        "排序规则基于数位和（digit sum）升序",
        "若两个数的数位和相等，则数值较小者排在前面",
        "目标排列是唯一的稳定排序结果",
        "原数组与目标排列之间存在一一对应的元素映射关系"
      ],
      "Objective Function": "计算将原数组通过最少次数的相邻或非相邻交换变为目标排序顺序所需的最小交换次数",
      "Algorithmic Invariant": [
        "每个元素在最终排列中的位置可预先确定（通过自定义比较器排序生成目标序列）",
        "最小交换次数等于将当前排列转换为目标排列所需置换环的数量：总交换次数 = n - 环数",
        "置换环内元素可通过环长-1次交换归位，且环间独立不影响最优性",
        "交换操作不改变其他元素相对状态，仅更新参与交换元素的位置信息"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5（允许 O(n log n) 解法）",
        "值域范围": "nums[i] ∈ [1, 1e9]，支持快速数位和计算",
        "是否有序": "输入无序，但可通过自定义排序构造有序目标",
        "排序稳定性要求": "数位和相同时按原数值升序（稳定排序约束）",
        "是否多组数据": "可扩展为多组测试用例",
        "是否在线": "当前为离线输入；可变形为流式输入并动态维护交换代价",
        "交换类型限制": "可限定为‘仅允许相邻交换’（此时需逆序对计数），当前为任意位置交换",
        "数位和定义方式": "可变换为二进制位和、加权位和等变体",
        "排序目标变换": "可改为降序、奇偶分组后再排序等复合规则"
      }
    }
  },
  {
    "title": "Minimum Operations to Make Array Sum Divisible by K",
    "slug": "minimum-operations-to-make-array-sum-divisible-by-k",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 1000",
        "value_range": "1 <= nums[i] <= 1000",
        "modulus_k_range": "1 <= k <= 100",
        "properties": [
          "一维整数数组 nums[1..n]",
          "元素为正整数",
          "k 为给定正整数模数"
        ]
      },
      "Core Constraint": {
        "operation_rule": "只能对任意下标 i 执行 nums[i] -= 1 操作",
        "monotonicity": "数组元素只能减小或不变，不能增加",
        "divisibility_condition": "最终数组元素之和 ≡ 0 (mod k)",
        "optimality_condition": "操作具有可推迟性：若总和 mod k = r，则只需减少总和 r 或 r + k 的倍数即可满足条件"
      },
      "Objective Function": {
        "goal": "最小化操作次数",
        "type": "minimization",
        "target": "使 sum(nums) ≡ 0 (mod k) 的最小减量总和"
      },
      "Algorithmic Invariant": {
        "invariant_description": "最优解中，最终数组和应为不超过原始和的最大且能被 k 整除的非负整数",
        "key_insight": "设原和为 S，则目标和为 T = S - r，其中 r = S mod k；若 r == 0 则无需操作，否则需总共减少 r（若 T >= 0）或更多以达到 0（当 S < k 时可能需归零）",
        "greedy_property": "由于每次操作只减 1，且无其他代价差异，最小操作数等于需要从总和中减去的数值量，即 (S mod k == 0 ? 0 : k - (S mod k)) 当允许结果为 0 时等价于 (-S) mod k",
        "state_preservation": "无论哪个元素被减，总减量才是决定因素；因此分配方式不影响总数，只需保证总减量 ≡ S (mod k)"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_size_n",
            "range": "1 to 1000",
            "transformable": true,
            "example_transforms": [
              "n → 1e5",
              "在线数据流"
            ]
          },
          {
            "name": "value_domain",
            "original": "nums[i] ≥ 1",
            "possible_variation": "允许 nums[i] = 0 或负值，改变边界行为"
          },
          {
            "name": "operation_direction",
            "original": "仅支持减 1",
            "variation": "允许 +1 和 -1，变为双向调整，目标仍为 sum ≡ 0 mod k"
          },
          {
            "name": "modulus_k",
            "range": "1 to 100",
            "transformable": true,
            "scale_extension": "k → 1e9，要求使用模运算优化"
          },
          {
            "name": "objective_function",
            "original": "最小操作次数",
            "alternative": [
              "计数方案数（有多少种方式达成）",
              "构造字典序最小的操作序列"
            ]
          },
          {
            "name": "input_form",
            "original": "静态一次性输入",
            "extension": "多组测试用例 / 在线查询 k 值"
          },
          {
            "name": "constraint_structure",
            "variation": "加入每元素最多操作 t_i 次的限制，转化为有界贪心或背包类问题"
          },
          {
            "name": "output_requirement",
            "variation": "不仅输出次数，还需输出具体操作分布"
          }
        ]
      }
    }
  },
  {
    "title": "Maximum Sum of Edge Values in a Graph",
    "slug": "maximum-sum-of-edge-values-in-a-graph",
    "schema": {
      "Input Structure": [
        "无向连通图 G = (V, E)",
        "节点集合 V，|V| = n，编号从 0 到 n-1",
        "边集合 E，|E| = m，用二维数组 edges 表示，edges[i] = [a_i, b_i]",
        "每个节点的度数最多为 2"
      ],
      "Core Constraint": [
        "由于每个节点最多连接两个其他节点，整个图的结构必为一条路径或一个环",
        "图是连通的 → 整个图是一个链状结构（路径）或环状结构（环）",
        "节点值必须是从 1 到 n 的唯一整数分配（即一个排列）",
        "边的值为其两端节点所分配值的乘积",
        "目标是最大化所有边值的总和"
      ],
      "Objective Function": "最大化图中所有边的端点值乘积之和（即 ∑_{(u,v)∈E} val[u] × val[v]）",
      "Algorithmic Invariant": [
        "图的结构是路径或环 → 可转化为序列上的数值分配问题",
        "较大的数值应尽可能分配给在“中心”位置、度数较高的节点（即边连接较多的节点）以最大化贡献",
        "贪心策略成立：将较大的数分配给度数较大的节点可以保证局部最优可扩展为全局最优",
        "当图是路径或环时，度数序列决定了节点的重要性排序",
        "最优解下，节点赋值与节点度数正相关"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 5 * 10^4",
        "图的结构类型": [
          "路径（两个端点度数为1，其余为2）",
          "环（所有节点度数为2）"
        ],
        "是否连通": true,
        "是否允许重复边": false,
        "节点度数限制": "每个节点最多连接两个其他节点（度 ≤ 2）",
        "是否多组数据": false,
        "是否在线输入": false,
        "值域约束": "节点值必须是 1 到 n 的唯一整数",
        "目标函数变形可能": [
          "最小化边值总和",
          "计数最大得分方案数",
          "加入权重限制：某些节点不能分配特定值"
        ],
        "图结构扩展": [
          "放宽度数限制 → 一般图（变为更复杂的组合优化）",
          "非连通图 → 多个链/环分别处理"
        ]
      }
    }
  },
  {
    "title": "Number of Ways to Assign Edge Weights I",
    "slug": "number-of-ways-to-assign-edge-weights-i",
    "schema": {
      "Input Structure": {
        "type": "Tree",
        "representation": "Undirected tree with n nodes, rooted at node 1",
        "edges": "2D integer array edges of length n - 1, where edges[i] = [u_i, v_i] represents an edge between nodes u_i and v_i",
        "node_range": "1 <= u_i, v_i <= n",
        "size_constraint": "2 <= n <= 10^5",
        "initial_weights": "All edges initially have weight 0,可赋值为 1 or 2"
      },
      "Core Constraint": {
        "tree_structure": "The input forms a valid tree (connected, acyclic, undirected)",
        "rooted_property": "The tree is implicitly rooted at node 1, enabling parent-child relationships via DFS/BFS traversal",
        "path_relevance": "Only the path from root (node 1) to a deepest node x matters; other edges can be ignored for the objective",
        "depth_definition": "Depth of a node is the number of edges from the root; maximum depth determines candidate target nodes",
        "parity_dependency": "The sum along the path is odd if and only if the number of edges assigned weight 1 on the path is odd"
      },
      "Objective Function": {
        "goal": "Count the number of ways to assign each edge a weight in {1, 2} such that the path from root to some fixed deepest node x has an odd total weight",
        "output_type": "Integer count modulo 10^9 + 7",
        "target_node_selection": "Choose any one deepest node x (all such nodes yield same count due to structural symmetry in counting)"
      },
      "Algorithmic Invariant": {
        "path_length_parity": "For a path of length L (number of edges), the number of assignments making the sum odd depends only on L: it is 2^(L-1)",
        "independence_of_off-path_edges": "Edges not on the root-to-x path can be freely assigned 1 or 2 without affecting parity; contributes factor of 2^(n-1 - L)",
        "total_count_formula": "Total valid assignments = 2^(L-1) * 2^(n-1 - L) = 2^(n-2), independent of specific path as long as L >= 1",
        "invariance_under_depth": "As long as there exists at least one node at maximum depth with path length L, the result depends only on existence, not on L itself, because formula simplifies globally"
      },
      "Transformable Parameters": {
        "n_value_range": "2 <= n <= 10^5",
        "modulus": "10^9 + 7 (fixed in this version, but can be parameterized)",
        "weight_set": "Currently {1,2}; could generalize to arbitrary integer weights or sets with parity properties",
        "objective_variation": "Change target parity: odd → even; or count both",
        "counting_scope": "Count over all deepest nodes jointly (with inclusion-exclusion), instead of choosing one",
        "constraint_addition": "Add constraints on total weight, or require balanced assignment",
        "input_form": "Multiple test cases / online queries on dynamic trees?",
        "tree_type": "Generalize from tree to DAG or general graph (would change algorithm drastically)",
        "assignment_restrictions": "Limit number of edges that can be assigned 1 or 2"
      }
    }
  },
  {
    "title": "Partition Array into Two Equal Product Subsets",
    "slug": "partition-array-into-two-equal-product-subsets",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element_type": "positive integer",
        "uniqueness": true,
        "size_range": [
          3,
          12
        ],
        "value_range": [
          1,
          100
        ],
        "target_value": {
          "type": "integer",
          "range": [
            1,
            1000000000000000.0
          ]
        }
      },
      "Core Constraint": {
        "partition_constraint": "两个非空、互不相交的子集",
        "coverage_constraint": "每个元素恰好属于一个子集",
        "product_equality_constraint": "两个子集的元素乘积均等于 target",
        "feasibility_condition": "若存在解，则整个数组乘积必须为 target^2，且 target 必须能整除总乘积"
      },
      "Objective Function": {
        "type": "decision",
        "goal": "判断是否存在一种划分方式，使得两个子集的乘积都等于 target"
      },
      "Algorithmic Invariant": {
        "search_space_invariant": "由于数组长度 ≤ 12，可枚举所有非空真子集（共 2^n - 2 种）进行检查",
        "pruning_invariant": "若当前子集乘积超过 target 或不能整除 target，则提前剪枝",
        "complement_invariant": "一旦找到一个非空子集其乘积为 target，且补集非空且乘积也为 target，则返回 true",
        "multiplicative_closure": "乘积在正整数下封闭，且无重复元素减少冗余状态"
      },
      "Transformable Parameters": {
        "n_magnitude": "小规模（n ≤ 12），支持暴力枚举或状态压缩DP",
        "value_domain": "nums[i] ∈ [1,100], target ∈ [1,1e15]",
        "uniqueness_of_elements": true,
        "subset_requirement": "必须是非空且互不相交的两个子集",
        "product_objective": "双子集乘积相等且等于 target",
        "input_form": "单组离线输入",
        "online_variation": false,
        "data_update_support": false,
        "dimension_extension": "可扩展至 2D 数组或树形结构上的乘积分割问题",
        "objective_transformation": [
          "计数：满足条件的划分数目",
          "构造：输出任意一组合法划分",
          "最小化子集大小差异"
        ],
        "constraint_reversal": "改为和相等（即子集和问题），或多个子集乘积相等"
      }
    }
  },
  {
    "title": "Number of Ways to Assign Edge Weights II",
    "slug": "number-of-ways-to-assign-edge-weights-ii",
    "schema": {
      "Input Structure": [
        "无向树，节点数为 n（2 <= n <= 1e5）",
        "树以节点 1 为根，由长度为 n-1 的二维数组 edges 表示：edges[i] = [u_i, v_i]",
        "每条边初始权重可设为 1 或 2",
        "查询数组 queries，长度为 q（1 <= q <= 1e5），每个查询 queries[i] = [u_i, v_i]"
      ],
      "Core Constraint": [
        "路径代价为奇数当且仅当路径上权重为 1 的边数量为奇数（因为 1 贡献奇，2 贡献偶）",
        "每条边独立赋值为 1 或 2，共 2^(总边数) 种方式，但只关心路径上的边",
        "对于每个查询 [u, v]，只需考虑 u 到 v 唯一路径上的边；树中任意两点路径唯一",
        "非路径上的边可任意赋值（不影响该查询结果），其贡献为乘法因子 2^(m - k)，其中 m 是总边数，k 是路径边数"
      ],
      "Objective Function": [
        "对每个查询 [u_i, v_i]，计算使得 u_i 到 v_i 路径代价为奇数的边权分配方案数",
        "返回所有查询的答案数组 answer，answer[i] 对应第 i 个查询的结果",
        "答案需对 1e9+7 取模"
      ],
      "Algorithmic Invariant": [
        "树中任意两节点间路径唯一，可通过 LCA 或 DFS 确定路径长度（边数）",
        "一条路径能产生奇数代价的方案数，仅依赖于路径上的边数 k：",
        "  - 若 k == 0（起点等于终点），则代价恒为 0（偶数），合法方案数为 0",
        "  - 否则，路径上 k 条边中，有 2^(k-1) 种方式使权重为 1 的边数为奇数",
        "非路径边可自由选择（每条边 2 种选择），贡献因子为 2^(m - k)，其中 m = n - 1",
        "因此总方案数为：若 k > 0，则为 2^(m - 1)；若 k == 0，则为 0",
        "即：答案仅取决于路径是否存在（k=0?），而与具体路径结构无关——只要 k>0，答案恒为 2^(n-2)"
      ],
      "Transformable Parameters": [
        "n 的数量级：[2, 1e5]",
        "queries 长度：[1, 1e5]",
        "是否多组数据：否（单棵树）",
        "是否在线：当前为离线查询，可预处理；可变形为在线添加查询",
        "边权选择集合：当前为 {1,2}，可推广为任意整数集，判断奇偶性仍由 mod 2 决定",
        "目标函数变化：改为求偶数代价、模 3 意义下余 1 的代价等",
        "输入形式：可改为有向树、森林、图（引入多路径）",
        "模数：当前为 1e9+7，可参数化",
        "是否要求输出方案构造：当前仅为计数",
        "是否允许动态修改边或查询：可扩展为动态树问题"
      ]
    }
  },
  {
    "title": "Concatenated Divisibility",
    "slug": "concatenated-divisibility",
    "schema": {
      "Input Structure": [
        "数组 nums[1..n]，其中每个元素 nums[i] 是正整数",
        "1 <= n <= 13",
        "1 <= nums[i] <= 1e5",
        "1 <= k <= 100"
      ],
      "Core Constraint": [
        "连接操作是将排列中的数字按顺序拼接其十进制字符串形成一个大整数",
        "由于数值可能极大，不能直接计算连接后的整数",
        "模运算性质：(a * 10^L + b) mod k = ((a mod k) * (10^L mod k) + (b mod k)) mod k",
        "问题状态依赖于当前累积的模 k 值和已使用数字的集合（组合状态）"
      ],
      "Objective Function": [
        "在所有能形成被 k 整除的连接排列中，找出字典序最小的一个",
        "如果不存在，返回空列表",
        "目标函数为：构造性 + 字典序最小化（优先存在性，再最小化序列）"
      ],
      "Algorithmic Invariant": [
        "状态压缩动态规划（DP）或记忆化搜索中，状态 (mask, r) 表示已使用的数字集合（mask）和当前连接结果对 k 取模的余数 r",
        "转移时，枚举下一个未使用的数字，并利用预计算的位数长度与幂模更新新余数",
        "为了保证字典序最小，搜索过程中优先尝试数值小的数字（贪心序探索），一旦找到可行解即返回（最优性剪枝）",
        "模意义下的状态转移具有无后效性和可合并性"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前为 13，支持状压；若增大需考虑启发式或近似",
        "k 的范围：影响状态空间大小（模数维度），可扩展至更大模数（如 1e5）以引入滚动数组优化需求",
        "nums[i] 的值域：当前最大为 1e5，影响字符串长度与模幂计算；可限制为个位数以简化",
        "是否要求输出所有可行解（计数型变形）",
        "是否改为求字典序最大、或最短连接数等目标函数",
        "是否允许重复数字（当前隐含允许，因输入为普通数组）",
        "是否在线：逐步添加数字并查询是否存在可整除连接排列",
        "是否改为判断存在性问题（判定型）而非构造最小字典序解"
      ]
    }
  },
  {
    "title": "Find X Value of Array II",
    "slug": "find-x-value-of-array-ii",
    "schema": {
      "Input Structure": {
        "nums": "一维正整数数组 A[1..n], 其中 n ∈ [1, 1e5], A[i] ∈ [1, 1e9]",
        "k": "正整数模数, k ∈ [1, 5]",
        "queries": "二维数组 Q[m][4], 每个查询为 [index_i, value_i, start_i, x_i], m ∈ [1, 2e4]"
      },
      "Core Constraint": {
        "operation": "仅允许执行一次操作：移除任意后缀（可为空），要求剩余数组非空",
        "prefix_removal": "每次查询前会先移除前缀 nums[0..(start_i - 1)]，形成子数组 S = nums[start_i..n-1]",
        "update_persistence": "对 nums[index_i] 的更新是永久性的，影响后续所有查询",
        "modular_product": "x值定义为：在移除某个后缀后，剩余元素乘积 mod k 等于 x_i 的方案数"
      },
      "Objective Function": "计数 —— 统计使得子数组前缀（从 start_i 开始）的某非空前缀的乘积 mod k 等于给定 x_i 的合法后缀移除方案数量",
      "Algorithmic Invariant": {
        "monotonic_suffix_removal": "后缀移除等价于选择一个结束位置 j ∈ [start_i, n-1]，保留子数组 nums[start_i..j]，且该子数组非空",
        "prefix_product_mod_evolution": "从 start_i 开始向右遍历，维护当前前缀乘积 mod k，由于 k 很小（≤5），状态空间有限",
        "state_compression_by_mod": "乘积 mod k 的值域仅为 {0,1,...,k-1}，可使用动态规划或哈希表记录每个余数出现次数",
        "persistent_updates_handling": "单点修改可通过直接赋值处理，结合离线重算或在线递推维护区间信息"
      },
      "Transformable Parameters": {
        "array_properties": {
          "order": "有序（索引顺序重要）",
          "element_type": "正整数",
          "duplicates_allowed": true,
          "negatives_allowed": false,
          "cyclic": false
        },
        "data_size": {
          "n_range": "[1, 1e5]",
          "q_range": "[1, 2e4]",
          "k_range": "[1, 5]"
        },
        "input_form": {
          "initial_array_static": true,
          "updates_persistent": true,
          "prefix_removal_per_query": true,
          "online_query_processing": true
        },
        "output_form": "整数数组 result，长度等于 queries.length，result[i] 表示第 i 次查询时满足条件的方案数",
        "variation_slots": [
          "k 是否为质数？ → 影响逆元使用",
          "是否允许多次操作？ → 改变问题结构",
          "是否改为最小化/最大化目标余数？ → 改变目标函数",
          "是否支持区间更新？ → 增加数据结构复杂度",
          "是否要求输出具体方案？ → 构造类变形",
          "是否将乘积改为异或或和？ → 运算符替换",
          "是否离线批量处理查询？ → 可优化顺序"
        ]
      }
    }
  },
  {
    "title": "Maximize Score After Pair Deletions",
    "slug": "maximize-score-after-pair-deletions",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max：当 left_max ≤ right_max 时，left 处的积水可确定；反之则 right 处的积水可确定；指针移动过程中不破坏已计算部分的正确性",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许为负数（如坑洞建模）",
        "维度扩展": "从 1D 扩展到 2D 矩阵（二维接雨水问题）",
        "操作类型": "是否支持单点更新或区间修改（动态接雨水）",
        "输入模式": "是否在线输入高度流（数据流场景）",
        "输出要求": "是否需要输出每个位置的具体蓄水量而非总和",
        "结构变形": "数组是否环形连接（首尾相连）",
        "多组数据": "是否存在多组测试用例连续处理"
      }
    }
  },
  {
    "title": "Path Existence Queries in a Graph I",
    "slug": "path-existence-queries-in-a-graph-i",
    "schema": {
      "Input Structure": [
        "整数 n，表示节点数量（编号从 0 到 n-1）",
        "长度为 n 的非递减整数数组 nums，其中 nums[i] 对应节点 i 的值",
        "整数 maxDiff，表示边存在的阈值条件",
        "二维整数数组 queries，每个查询为 [u_i, v_i]，表示判断节点 u_i 与 v_i 是否连通"
      ],
      "Core Constraint": [
        "图的边由值域差决定：当且仅当 |nums[i] - nums[j]| <= maxDiff 时，节点 i 和 j 之间存在无向边",
        "nums 数组是非递减的，因此索引顺序与值大小顺序一致",
        "连通性是传递的（即路径可以经过多个中间节点）",
        "图的结构隐式定义，不显式构建邻接表或边集"
      ],
      "Objective Function": [
        "对每个查询 [u_i, v_i]，判定两个节点是否在同一个连通分量中",
        "返回布尔数组 answer，answer[i] 表示第 i 个查询的结果"
      ],
      "Algorithmic Invariant": [
        "由于 nums 非递减，若 |nums[i] - nums[j]| <= maxDiff 且 i < j，则所有满足 i <= k < l <= j 且相邻差 <= maxDiff 的节点可形成连续段",
        "连通分量在数组上是区间连续的：即若一段下标 [l, r] 满足任意相邻元素差 <= maxDiff，则该区间内所有节点互相连通",
        "可用并查集或离线双指针合并区间维护连通块，利用单调性避免 O(n^2) 建图",
        "查询可通过预处理连通块后 O(1) 回答"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5，要求 O(n log n) 或 O(n α(n)) 解法",
        "nums 是否有序": [
          "当前为非递减，可变形为乱序（需排序+离散化）",
          "或引入坐标映射"
        ],
        "maxDiff 性质": [
          "可变为动态更新（在线修改 maxDiff）",
          "或作为每条边独立约束"
        ],
        "queries 形式": [
          "是否多组输入",
          "是否在线查询（强制在线）",
          "是否支持修改操作（如修改 nums[i]）"
        ],
        "图构建方式": [
          "是否显式建图（受限于 O(n^2) 边数）",
          "是否允许负权值"
        ],
        "连通性目标": [
          "改为求最短路径长度",
          "改为计数连通分量大小",
          "改为构造路径方案"
        ],
        "数据流形式": [
          "一次性离线处理 → 在线逐个回答查询",
          "加入删除节点操作"
        ]
      }
    }
  },
  {
    "title": "Grid Teleportation Traversal",
    "slug": "grid-teleportation-traversal",
    "schema": {
      "Input Structure": [
        "二维字符网格 matrix[0..m-1][0..n-1]",
        "m, n ∈ [1, 10^3]",
        "每个 cell ∈ {'.', '#', 'A'..'Z'}",
        "起点 (0, 0)，终点 (m-1, n-1)",
        "起点和终点保证不是 '#'"
      ],
      "Core Constraint": [
        "移动仅允许上下左右，目标为最短路径",
        "传送门由相同大写字母配对，每对最多使用一次",
        "踏入传送门单元格时若未使用过该字母，可免费传送到另一端",
        "传送不计步数，但使用后该字母通道关闭",
        "状态需记录已使用的传送门集合（最多26个字母）"
      ],
      "Objective Function": "求从 (0,0) 到 (m-1,n-1) 的最少移动次数；若不可达则返回 -1",
      "Algorithmic Invariant": [
        "BFS 层序扩展保证首次到达某状态即为最短步数",
        "状态 = (行, 列, 已使用传送门掩码) → 最小步数确定",
        "同一位置在不同传送门使用状态下可重复访问",
        "传送操作不增加步数，可在进入传送门时立即触发转移",
        "状态空间有限：O(m * n * 2^26) 可接受（因实际可用字母少且剪枝有效）"
      ],
      "Transformable Parameters": {
        "网格规模": {
          "m, n 范围": "[1, 10^3]",
          "可调整至在线场景或流式输入": false
        },
        "传送门机制": {
          "是否允许多重传送门（>2 同字母）": false,
          "是否允许单向传送": false,
          "是否支持嵌套传送": false,
          "是否支持传送门连锁触发": false
        },
        "使用限制": {
          "每个字母最多使用次数": 1,
          "是否可逆向使用传送门": true,
          "是否计入使用次数的判断时机": "首次踏入即标记"
        },
        "目标函数变形": [
          "改为求路径方案数（模意义下）",
          "是否存在一条路径（判定问题）",
          "最小化传送门使用次数的前提下最小化移动步数（双目标）"
        ],
        "输入形式": {
          "是否多组测试数据": true,
          "matrix 是否静态离线输入": true,
          "是否支持动态修改网格": false
        },
        "扩展方向": [
          "三维网格扩展",
          "加入时间维度约束（如 t 秒内必须到达）",
          "加入能量系统（传送消耗能量，移动消耗体力）",
          "变为两人协同逃生，共享传送门使用"
        ]
      }
    }
  },
  {
    "title": "Phone Number Prefix",
    "slug": "phone-number-prefix",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置能接住的雨水量由其左侧最大高度和右侧最大高度中的较小值决定，且左右边界约束可分离处理",
        "property": "局部贡献依赖于全局极值，但可通过双端推进逐步确定"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示 [0, L) 区间的最大值，maxRight 表示 (R, n-1] 区间的最大值",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水高度由 maxLeft 决定，可直接计算并右移 L",
          "否则，位置 R 处的积水高度由 maxRight 决定，可直接计算并左移 R",
          "指针移动过程中，已确定区域的解保持不变且正确"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "description": "H[i] 是否允许负值",
            "options": [
              true,
              false
            ]
          },
          {
            "name": "input_dimension",
            "description": "是否扩展到二维平面（2D 接雨水）",
            "options": [
              true,
              false
            ]
          },
          {
            "name": "input_mode",
            "description": "输入是一次性离线给出还是在线流式输入",
            "options": [
              "offline",
              "online"
            ]
          },
          {
            "name": "output_granularity",
            "description": "是否要求输出每个位置的积水量而非总和",
            "options": [
              true,
              false
            ]
          },
          {
            "name": "dynamic_operations",
            "description": "是否支持修改、插入或删除操作（动态版本）",
            "options": [
              true,
              false
            ]
          },
          {
            "name": "data_order",
            "description": "数组是否有序（如单调递增/递减）",
            "options": [
              "unsorted",
              "sorted",
              "partially_sorted"
            ]
          },
          {
            "name": "circular_array",
            "description": "是否为环形数组（首尾相连）",
            "options": [
              true,
              false
            ]
          },
          {
            "name": "multiple_test_cases",
            "description": "是否包含多组测试数据",
            "options": [
              true,
              false
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Count Partitions With Max-Min Difference at Most K",
    "slug": "count-partitions-with-max-min-difference-at-most-k",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n ∈ [2, 5×10⁴]，nums[i] ∈ [1, 10⁹]；给定整数 k ∈ [0, 10⁹]",
      "Core Constraint": "每个连续子段的最大值与最小值之差 ≤ k；分割必须覆盖整个数组且子段非空、连续、不重叠",
      "Objective Function": "计数：求满足条件的分割方案总数（模 10⁹ + 7）",
      "Algorithmic Invariant": "动态规划状态 dp[i] 表示前 i 个元素的合法分割数；转移时枚举以位置 i 结尾的最后一个子段的起点 j，利用滑动窗口维护 [j, i] 区间内的 max - min ≤ k；可用双端队列维护区间最值，保证状态转移高效性",
      "Transformable Parameters": [
        "n 的数量级：可扩展至 10^5 或更高（影响是否需线性对数解）",
        "值域范围：nums[i] 是否可负 / 更大（影响单调队列实现细节）",
        "k 的取值范围：如 k=0 可退化为全相等段问题",
        "是否要求输出具体方案（构造类目标）而非仅计数",
        "是否允许多组测试数据输入",
        "是否在线处理数组流（数据流化）",
        "输入结构是否变为环形数组",
        "约束条件变化：如改为 ≥k 或方差限制等"
      ]
    }
  },
  {
    "title": "Minimum Operations to Convert All Elements to Zero",
    "slug": "minimum-operations-to-convert-all-elements-to-zero",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "size": "n",
        "range": [
          0,
          100000
        ],
        "sorted": false,
        "allow_zero": true,
        "description": "一维非负整数数组 nums[0..n-1]，长度 n ∈ [1, 1e5]"
      },
      "Core Constraint": {
        "constraint": "每次操作只能将某个子数组中所有最小的非零元素置为 0",
        "implication": "操作具有贪心可分解性：低值元素的操作不会影响更高值元素的必要操作次数",
        "dependency": "操作顺序依赖数值大小层次：必须先处理较小值，再处理较大值",
        "structure_impact": "相同数值的分布连续性会影响是否能合并操作"
      },
      "Objective Function": {
        "goal": "最小化操作次数",
        "type": "minimization",
        "target": "使整个数组变为全 0 所需的最少操作数",
        "output_single_value": true
      },
      "Algorithmic Invariant": {
        "invariant": "按值从小到大逐层消除时，每一层的最少操作数等于该值在数组中的极大连续段数（即去零后连续段数）",
        "greedy_condition": "对于当前最小未处理值 v，选择覆盖所有 v 的最小子数组集合，等价于统计 v 在剩余非零位置中的连续段数",
        "monotonicity": "一旦某值被清除，后续操作不再涉及该值；更高值的操作独立于更低值的内部结构",
        "optimality_preservation": "局部最优段划分（每段至少一次操作）可合并为全局最优解"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_range",
            "options": [
              "non-negative",
              "positive-only",
              "with-negative (invalid case)",
              "bounded",
              "unbounded"
            ]
          },
          {
            "name": "array_dimension",
            "options": [
              "1D",
              "2D (grid extension)",
              "circular array"
            ]
          },
          {
            "name": "operation_granularity",
            "options": [
              "set-min-to-zero",
              "decrement-all-by-one",
              "set-arbitrary-subarray-to-zero"
            ]
          },
          {
            "name": "objective_function",
            "options": [
              "minimize_operations",
              "maximize_operations",
              "count_ways_to_clear",
              "construct_sequence"
            ]
          },
          {
            "name": "input_form",
            "options": [
              "offline_batch",
              "online_streaming",
              "dynamic_updates_with_insert_delete"
            ]
          },
          {
            "name": "constraints_on_subarray",
            "options": [
              "any_contiguous",
              "fixed_length",
              "must_include_extremes",
              "overlap_limit"
            ]
          },
          {
            "name": "value_distribution",
            "options": [
              "arbitrary",
              "distinct",
              "sorted",
              "palindromic",
              "periodic"
            ]
          },
          {
            "name": "multi_query",
            "options": [
              "single_instance",
              "multiple_test_cases",
              "persistent_version_queries"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Merge Operations for Minimum Travel Time",
    "slug": "merge-operations-for-minimum-travel-time",
    "schema": {
      "Input Structure": [
        "一维整数数组 position[0..n-1]，表示路标位置，严格升序，position[0] = 0，position[n-1] = l",
        "一维整数数组 time[0..n-1]，表示从 position[i] 到 position[i+1] 每公里行驶时间",
        "整数 l：道路总长度（公里）",
        "整数 n：初始路标数量",
        "整数 k：必须执行恰好 k 次合并操作",
        "路段 i 的距离为 position[i+1] - position[i]，i ∈ [0, n-2]"
      ],
      "Core Constraint": [
        "每次合并操作只能作用于两个相邻的内部路标（即下标 i 和 i+1，其中 i > 0 且 i+1 < n）",
        "合并后删除前一个路标（下标 i），并将后一个路标的时间更新为 time[i] + time[i+1]",
        "合并操作改变路段划分和对应时间权重，但不改变总路程 l",
        "每段旅行时间为 (distance) × (time[i])，总时间为各段之和",
        "必须恰好执行 k 次合并，最终剩余 n - k 个路标"
      ],
      "Objective Function": "最小化从 0 到 l 的总旅行时间（分钟）",
      "Algorithmic Invariant": [
        "贪心可解性：局部代价高的路段应优先避免被长距离使用（即高 time 值应尽量与短距离绑定）",
        "合并的本质是将相邻 time 值相加，相当于构造一个新的‘复合’速度段",
        "所有合并操作等价于在 time 数组中选择 k 个非首尾的相邻对进行合并，形成新的序列",
        "问题转化为：在不允许合并首尾元素的前提下，在中间 n-2 个可选位置中选择 k 次合并，使得总代价最小",
        "代价函数具有可分离性：总时间 = Σ (position[i+1] - position[i]) × effective_time[i]",
        "effective_time[i] 是经过若干次合并后的最终 time 值，其值为原始连续子数组 time 的和"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 50",
        "k 的范围": "0 <= k <= min(n - 2, 10)",
        "l 的范围": "1 <= l <= 1e5",
        "time[i] 值域": "1 <= time[i] <= 100",
        "sum(time) 上界": "<= 100",
        "是否有序": "position 严格升序",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "是否允许负值": false,
        "是否可修改操作类型": true,
        "合并规则变化": [
          "可变为取最大值/平均值",
          "可允许首尾合并",
          "可限制不能连续合并"
        ],
        "目标函数变化": [
          "最小化最大路段耗时",
          "计数满足条件的合并方案数",
          "判定是否存在方案使总时间 ≤ T"
        ],
        "输入维度扩展": [
          "二维路径网络",
          "树形结构路径"
        ],
        "数据流化": "支持动态插入或查询某次合并后的结果"
      }
    }
  },
  {
    "title": "Minimum Cost to Reach Every Position",
    "slug": "minimum-cost-to-reach-every-position",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "range": "1 <= cost[i] <= 100",
        "initial_position": "n (end of array, 0-indexed position n)",
        "indices": "0 to n, total n+1 positions"
      },
      "Core Constraint": {
        "forward_swap_cost": "must pay cost[i] to swap with person at position i if they are in front",
        "backward_swap_free": "can freely swap with anyone behind current position",
        "movement_rule": "each swap moves exactly one position; forward requires payment, backward is free",
        "dependency": "cost to reach position i depends on minimum cost among positions from i+1 to n"
      },
      "Objective Function": {
        "goal": "compute minimum total cost",
        "output_type": "array",
        "per_index": "answer[i] = minimum cost to reach position i",
        "objective": "minimization"
      },
      "Algorithmic Invariant": {
        "monotonic_suffix_min": "from right to left, the minimum cost encountered so far determines the optimal incoming cost for all previous positions",
        "greedy_propagation": "once a low-cost position is reached, all preceding positions can leverage it via free backward swaps",
        "state_independence": "the minimal cost to reach any position i only depends on min(cost[j]) for j > i, due to free backward movement",
        "reverse_iteration_suffices": "processing from last to first ensures optimal substructure and greedy choice correctness"
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 100",
        "value_domain": "positive integers, currently bounded [1,100], can be extended or relaxed",
        "ordering": "input cost array is arbitrary order; variant could assume sortedness or reverse order",
        "online_offline": "current version is offline; can transform into online query mode where cost updates dynamically",
        "operation_support": "current: static array; variants may support point update, range update, deletion",
        "dimension_extension": "1D → 2D grid movement with directional cost rules",
        "constraint_modification": "introduce limits on number of swaps, or make backward swaps costly under conditions",
        "multiple_queries": "support multiple starting positions or dynamic start/end queries",
        "output_form": "current outputs full array; variant may ask only for min cost to reach position 0 or specific index"
      }
    }
  },
  {
    "title": "Find X Value of Array I",
    "slug": "find-x-value-of-array-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "positive integers",
        "length": "n",
        "constraints": [
          "1 <= nums.length <= 1e5",
          "1 <= nums[i] <= 1e9",
          "1 <= k <= 5"
        ],
        "description": "一维正整数数组 nums，以及一个正整数 k"
      },
      "Core Constraint": {
        "operation": "恰好执行一次操作",
        "operation_type": "移除任意不重叠的前缀和后缀（可为空）",
        "result_condition": "剩余子数组非空",
        "modular_arithmetic": "关注剩余元素乘积 mod k 的结果",
        "key_insight": "所有可能的剩余子数组是原数组的一个连续子数组（即中段），且必须非空"
      },
      "Objective Function": {
        "goal": "计数",
        "target": "对每个余数 x ∈ [0, k-1]，统计有多少种操作方式使得剩余子数组的元素乘积 mod k 等于 x",
        "output": "长度为 k 的数组 result，其中 result[x] 表示余数为 x 的方案数"
      },
      "Algorithmic Invariant": {
        "invariant_1": "所有合法操作对应唯一一个非空前缀-后缀移除后的连续子数组（即中间连续段）",
        "invariant_2": "每个连续子数组 [i, j] 对应一种唯一操作：移除前缀 [0, i-1] 和后缀 [j+1, n-1]",
        "invariant_3": "问题转化为：枚举所有非空连续子数组，计算其乘积 mod k，并累加计数",
        "optimization_opportunity": "由于 k 很小（≤5），可以使用动态规划维护以当前位置结尾的所有可能的乘积模 k 值的出现次数",
        "dp_state": "dp[r][v] = 遍历到位置 r 时，以 r 结尾的子数组中，乘积 mod k == v 的个数",
        "state_transition": "从 dp[r-1][*] 推导 dp[r][*]：当前值 nums[r] mod k 与之前状态组合并取模"
      },
      "Transformable Parameters": {
        "n_magnitude": [
          "1e1",
          "1e3",
          "1e5"
        ],
        "k_value": {
          "range": [
            1,
            10
          ],
          "special_cases": "k prime / composite / small (≤6)"
        },
        "nums_value_domain": {
          "positive_integers": true,
          "negative_allowed": false,
          "zero_allowed": false,
          "upper_bound": "1e9"
        },
        "modular_objective": {
          "current": "product mod k",
          "possible_transforms": [
            "sum mod k",
            "GCD mod k",
            "XOR mod k"
          ]
        },
        "operation_constraints": {
          "num_operations": "exactly one",
          "transformable_to": [
            "zero or one operation",
            "at most m operations"
          ]
        },
        "input_form": {
          "single_array": true,
          "multi_dimensional": false,
          "online_input": false,
          "multiple_test_cases": true
        },
        "output_form": {
          "full_counting_array": true,
          "query_based": false,
          "specific_x_only": false
        },
        "hidden_monotonicity": false,
        "data_streaming": false
      }
    }
  },
  {
    "title": "Find Closest Person",
    "slug": "find-closest-person",
    "schema": {
      "Input Structure": "三个整数 x, y, z ∈ [1, 100]，表示数轴上三个人的位置：x 是第 1 个人的初始位置，y 是第 2 个人的初始位置，z 是第 3 个人（目标点）的固定位置。",
      "Core Constraint": "第 1 个人和第 2 个人以相同速度向固定的第 3 个人移动；到达时间仅取决于初始位置到 z 的绝对距离。",
      "Objective Function": "判定谁先到达 z：若 |x - z| < |y - z|，返回 1；若 |x - z| > |y - z|，返回 2；若相等，返回 0。",
      "Algorithmic Invariant": "比较两个独立距离的大小关系具有可判定性：|x - z| 与 |y - z| 的差值符号不变，且无需动态更新或状态维护，结果由初态唯一确定。",
      "Transformable Parameters": {
        "数据规模": "x, y, z 的范围可扩展至更大整数（如 ±1e9），或支持浮点坐标",
        "是否多组输入": "可改为处理多组 (x, y, z) 查询",
        "是否在线": "可设计为在线模式：z 固定，动态添加多个 (x_i, y_i) 并实时判断",
        "移动规则变化": "可变为不同速度、加速度运动，或引入障碍物",
        "维度扩展": "可推广到二维平面或多维空间中的欧几里得距离比较",
        "目标函数变形": "从判定转向计数（如统计 n 人中最早到达者数量）或构造（输出所有同时最优者）"
      }
    }
  },
  {
    "title": "Shortest Path in a Weighted Tree",
    "slug": "shortest-path-in-a-weighted-tree",
    "schema": {
      "Input Structure": [
        "n: 整数，表示树的节点数量（1 <= n <= 10^5）",
        "edges: 长度为 n - 1 的二维数组，其中 edges[i] = [u_i, v_i, w_i]，表示连接节点 u_i 和 v_i 的无向边，权重为 w_i（1 <= w_i <= 10^4）",
        "queries: 二维整数数组，长度为 q（1 <= q <= 10^5），每个元素是以下之一：",
        "   - [1, u, v, w']: 更新边 (u, v) 的权重为 w'",
        "   - [2, x]: 查询从根节点 1 到节点 x 的最短路径距离"
      ],
      "Core Constraint": [
        "输入构成一棵以节点 1 为根的无向带权树（连通无环图）",
        "每条边在更新操作中可被修改权重，且更新后仍保持树结构",
        "所有查询和更新按顺序执行，具有时间序列依赖性",
        "路径唯一性：任意两节点间有且仅有一条简单路径（树的性质）"
      ],
      "Objective Function": [
        "对每个类型为 [2, x] 的查询，输出从根节点 1 到节点 x 的路径距离总和",
        "目标函数为：构造一个整数数组 answer，answer[i] 对应第 i 个查询 [2, x] 的结果",
        "本质是动态维护根到各节点的距离"
      ],
      "Algorithmic Invariant": [
        "由于是树结构，任意节点 x 到根的路径唯一，因此距离 = 路径上所有边权之和",
        "当某条边 (u, v) 的权重被修改时，只有该边子树内的节点的距离会发生变化",
        "可预处理父子关系与深度优先遍历序，标记每条边所影响的子树范围",
        "使用 Euler Tour 或 DFS 序 + 差分数组 / 树状数组 / 线段树 维护子树整体加减操作",
        "每次更新操作：确定边 (u, v) 在树中的父子方向，对该子树整体增加 (new_w - old_w)"
      ],
      "Transformable Parameters": [
        "n 的数量级：1e5 → 可扩展至更高（需考虑数据结构效率）",
        "边权值域：[1, 1e4] → 可支持负权重或更大范围",
        "是否静态：当前为动态更新 → 可变体包括离线批量更新、回滚操作（可持久化）",
        "查询类型：仅支持单点距离查询 → 可扩展为路径和、LCA 相关、区间子树查询",
        "输入形式：在线序列式操作 → 可改为离线重排、强制在线等",
        "树的形态：普通树 → 可变为链状、菊花树、完全二叉树等特殊结构用于卡常分析",
        "更新方式：直接赋值 → 可变为增量修改、乘法更新等",
        "是否多组数据：当前为单组 → 可设计为 T 组测试用例"
      ]
    }
  },
  {
    "title": "Analyze Organization Hierarchy",
    "slug": "analyze-organization-hierarchy",
    "schema": {
      "Input Structure": {
        "type": "tree-structured relational table",
        "schema": {
          "employee_id": "int, primary key",
          "employee_name": "varchar",
          "manager_id": "int, nullable (null for root)",
          "salary": "int, non-negative",
          "department": "varchar"
        },
        "structure": "directed tree (hierarchical organization), each node points to its parent via manager_id, root is CEO with manager_id = null"
      },
      "Core Constraint": {
        "hierarchy": "each employee has exactly one direct manager (parent), forming a rooted tree",
        "aggregation_dependency": "team_size and budget for a manager depend on recursive aggregation over all descendants (transitive closure of subordinates)",
        "level_propagation": "level of a node = level of parent + 1, with root at level 1"
      },
      "Objective Function": {
        "outputs": [
          "level: compute hierarchical depth of each employee from root (CEO = 1)",
          "team_size: for each manager, count total number of direct and indirect subordinates (subtree size excluding self)",
          "budget: for each employee who is a manager, sum of own salary plus all subordinates' salaries (recursive)"
        ],
        "sorting_criteria": [
          "order by level ascending",
          "then by budget descending",
          "then by employee_name ascending"
        ]
      },
      "Algorithmic Invariant": {
        "tree_traversal_invariant": "post-order DFS ensures that children are processed before parents, enabling correct accumulation of team_size and budget",
        "dynamic_aggregation": "each node aggregates results from all children before returning values to its parent",
        "single_pass_feasibility": "entire hierarchy can be reconstructed and aggregated in O(n) time using adjacency list representation and memoization of computed values"
      },
      "Transformable Parameters": {
        "data_scale": "n ∈ [1, 10^5] — supports both small organizations and large enterprises",
        "value_domain": {
          "salary_range": "[0, 10^6]",
          "name_uniqueness": "employee_name may not be unique"
        },
        "structural_variants": [
          "allow multiple roots (forest) → multi-company analysis",
          "allow cyclic references (corrupted data) → require cycle detection",
          "add team depth limit (e.g., only aggregate up to k levels down)"
        ],
        "input_form": [
          "offline batch input (static table)",
          "online updates (insert/delete employee, change manager) → need dynamic tree maintenance"
        ],
        "output_options": [
          "include/exclude non-managers in output",
          "return intermediate paths (e.g., path from employee to CEO)",
          "add filtering: only show managers with team_size ≥ K"
        ],
        "extension_dimensions": [
          "2D hierarchy (matrix org: dual reporting lines)",
          "weighted aggregation (e.g., budget weighted by department factor)",
          "threshold constraints (e.g., only include subordinates earning > X)"
        ]
      }
    }
  },
  {
    "title": "Implement Router",
    "slug": "implement-router",
    "schema": {
      "Input Structure": [
        "Router(memoryLimit): integer constraint on maximum packet storage capacity",
        "Stream of operations: ['addPacket', 'forwardPacket', 'getCount']",
        "Each packet is a tuple (source: int, destination: int, timestamp: int)",
        "Operations are processed sequentially in time",
        "addPacket calls have non-decreasing timestamp order"
      ],
      "Core Constraint": [
        "Memory bounded by fixed limit → FIFO eviction policy when full",
        "Duplicate packets (same source, destination, timestamp) are rejected",
        "Forwarding follows strict FIFO order (oldest added, first forwarded)",
        "Queries must be answered online; no future knowledge available",
        "State evolves incrementally with each operation"
      ],
      "Objective Function": [
        "Support dynamic insertion with deduplication and capacity control",
        "Enable FIFO packet forwarding (construction of next packet)",
        "Answer range count queries over current active set: count packets by destination and timestamp interval"
      ],
      "Algorithmic Invariant": [
        "The internal queue maintains packets in arrival order (by timestamp, then by insertion order for ties)",
        "All packets in the router are unique (enforced via duplicate check on insert)",
        "Size of stored packets ≤ memoryLimit at all times (eviction ensures invariant)",
        "For getCount: query is over current memory-resident packets only (not historical)",
        "Timestamp monotonicity of addPacket allows safe use of queue and simplifies duplicate detection"
      ],
      "Transformable Parameters": {
        "memoryLimit": {
          "range": "2 <= memoryLimit <= 1e5",
          "can_be_infinite": false,
          "dynamic_or_fixed": "fixed at initialization"
        },
        "data_stream_properties": {
          "timestamp_order": "non-decreasing (monotonic input stream)",
          "duplicate_policy": "exact triple (source, dest, timestamp) rejection",
          "arrival_pattern": "online, sequential"
        },
        "query_types": [
          "addPacket: insertion with side effects and boolean feedback",
          "forwardPacket: destructive retrieval (FIFO)",
          "getCount: offline-style range counting over current state"
        ],
        "count_query_dimensions": {
          "filter_by": [
            "destination",
            "timestamp ∈ [startTime, endTime]"
          ],
          "aggregation": "count only (not list or sum)",
          "scope": "current un-forwarded packets"
        },
        "implementation_constraints": {
          "total_operations": "≤ 1e5",
          "value_ranges": {
            "source, destination": "1 to 2e5",
            "timestamp, startTime, endTime": "1 to 1e9"
          },
          "latency_requirements": "efficient per-operation time (amortized O(log n) or O(1) expected)"
        },
        "possible_variants": [
          "Change eviction policy: LRU, LFU, or based on destination",
          "Allow time-based expiration instead of size-based",
          "Make timestamp not monotonic → breaks queue assumption",
          "Support multiple duplicates with TTL",
          "Output full list in getCount instead of just count",
          "Add update/delete operations",
          "Make memoryLimit adjustable dynamically",
          "Support 2D range queries: (source, destination) + time"
        ]
      }
    }
  },
  {
    "title": "Maximum Profit from Valid Topological Order in DAG",
    "slug": "maximum-profit-from-valid-topological-order-in-dag",
    "schema": {
      "Input Structure": [
        "有向无环图 G = (V, E)，其中 V = {0, 1, ..., n-1}",
        "边集 edges[i] = [u_i, v_i] 表示从 u_i 到 v_i 的有向边",
        "每个节点 i 有权重 score[i] ∈ 正整数",
        "n <= 22，适合状态压缩"
      ],
      "Core Constraint": [
        "拓扑排序必须满足所有有向边 u → v 中，u 出现在 v 之前",
        "节点处理顺序受限于入度依赖：只有当前无未处理前驱的节点可被选择",
        "目标函数非对称：高得分节点越早出现贡献越大（位置乘子递增）",
        "局部决策影响全局收益：选择顺序直接影响加权和"
      ],
      "Objective Function": "在所有合法拓扑排序中，最大化 ∑(score[i] × position(i))，即最大利润",
      "Algorithmic Invariant": [
        "贪心不可行：不能简单按 score 排序（受拓扑约束限制）",
        "动态规划状态可定义为：dp[mask] = 已选节点集合 mask 下能获得的最大利润",
        "状态转移时，枚举所有在当前 mask 下入度已满足（前驱全被选）的可选节点",
        "每步扩展一个节点 j，则新利润 = dp[mask] + score[j] × (popcount(mask) + 1)",
        "状态空间单调扩展（子集向超集推进），无后效性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "n ≤ 22 → 支持状压DP",
            "n 可扩大至 1e5 → 需启发式或近似"
          ],
          "score 值域": [
            "正整数，1 ≤ score[i] ≤ 1e5"
          ]
        },
        "图结构变化": [
          "DAG → 含环图（需先判环或缩点）",
          "边数稀疏 / 密集",
          "是否为树形结构 / 森林"
        ],
        "输入形式": [
          "一次性离线输入",
          "在线添加边或节点（动态拓扑）"
        ],
        "输出目标变换": [
          "求最大利润 → 求最小利润",
          "计数：有多少种拓扑排序能达到最大利润",
          "构造方案：输出字典序最小的最优拓扑序列"
        ],
        "约束反转": [
          "位置乘子从 1 开始递增 → 从 n 开始递减（晚处理更优）",
          "改为平方权重：score[i] × position(i)^2"
        ],
        "多组数据": "是否处理多组 DAG 实例",
        "隐藏条件": "score 是否隐式给出（如通过节点深度计算）"
      }
    }
  },
  {
    "title": "Apply Substitutions",
    "slug": "apply-substitutions",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "一维数组 H[1..n]，其中 H[i] 表示柱子的高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右侧最大值可独立维护",
        "global_dependency": "局部积水依赖于全局极值信息",
        "reason_for_algorithm": "由于无法通过单次遍历直接获取两侧极值，需设计机制逐步推进并保证正确性"
      },
      "Objective Function": {
        "goal": "sum",
        "target": "total trapped water",
        "description": "计算能接住的雨水总量，即所有位置上可积累的水量之和"
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariants": [
          "维护 left 和 right 指针，分别从两端向中间移动",
          "维护 maxLeft = max(H[0..L]) 和 maxRight = max(H[R..n-1])",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水可确定为 maxLeft - H[L]，且 L 可安全右移",
          "反之，若 maxRight < maxLeft，则位置 R 处的积水可确定，R 可安全左移",
          "指针移动过程中，已确定区域的贡献值不变且最优"
        ],
        "optimality_preservation": true,
        "state_monotonicity": "maxLeft 和 maxRight 单调不减"
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          "0",
          "10^5"
        ],
        "negative_values_allowed": false,
        "input_dimension": "1D → 2D (e.g., 二维接雨水)",
        "input_form": "offline batch input",
        "online_queries": false,
        "mutable_array": false,
        "output_granularity": "total sum only",
        "can_extend_to": [
          "output per-position trapped water",
          "support update/delete operations",
          "circular array variant",
          "constrained trapping (e.g., at most K units allowed)",
          "count number of positions that can trap water"
        ],
        "multi_test_cases": false,
        "sorted_input": false
      }
    }
  },
  {
    "title": "Number of Unique XOR Triplets I",
    "slug": "number-of-unique-xor-triplets-i",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "nums 是 [1, n] 范围内所有整数的一个排列",
        "1 <= n <= 10^5",
        "每个元素满足 1 <= nums[i] <= n"
      ],
      "Core Constraint": [
        "三元组下标满足 i <= j <= k，允许重复索引",
        "XOR 运算具有结合性和交换性，且 a XOR a = 0",
        "由于是排列，所有值唯一但位置随机",
        "异或结果的值域被限制在较小范围内（最多 n 个不同数）"
      ],
      "Objective Function": "计数：返回所有可能的 (i, j, k) 三元组中，不同的 nums[i] XOR nums[j] XOR nums[k] 值的数量",
      "Algorithmic Invariant": [
        "对于任意固定 j，可以将三元组拆分为前缀部分 (i <= j) 和后缀部分 (k >= j)，但直接拆分难以去重",
        "由于 n 较大而值域有限，可利用异或值域小的特点进行枚举优化",
        "可通过枚举中间点 j，并维护左侧所有可能的 nums[i] XOR nums[j]（i <= j）集合，再与右侧组合，但本题只需统计最终不同结果，无需构造全部三元组",
        "最优解法依赖于值域范围小（异或结果不超过 2*n），因此可用布尔数组或哈希集合记录可达异或值"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1e5",
            "可调整至 1e3 或 1e6"
          ],
          "是否支持更大值域": false
        },
        "输入形式": {
          "是否仍为排列": true,
          "是否推广到一般数组": "可变（非排列、含重复）",
          "是否有序": false
        },
        "约束条件": {
          "下标关系": "i <= j <= k（可改为严格递增 i < j < k）",
          "是否允许负数": false,
          "是否要求模意义下结果": false
        },
        "目标函数变化": [
          "求最大/最小 XOR 值（极值）",
          "求出现次数最多的 XOR 值（众数）",
          "判断某个特定值是否可达（判定）",
          "输出所有可达 XOR 值的列表（构造）"
        ],
        "数据流化": {
          "是否在线处理": false,
          "是否支持动态修改数组": "可扩展为带单点更新的版本"
        },
        "多组数据": false
      }
    }
  },
  {
    "title": "Count Islands With Total Value Divisible by K",
    "slug": "count-islands-with-total-value-divisible-by-k",
    "schema": {
      "Input Structure": [
        "二维矩阵 grid[1..m][1..n]",
        "每个元素 grid[i][j] 是非负整数",
        "陆地定义为值 > 0 的单元格",
        "连通性：上下左右四连通"
      ],
      "Core Constraint": [
        "岛屿是由正整数单元格组成的四连通分量",
        "每个岛屿的价值独立计算，且仅依赖其内部连通块的和",
        "问题的关键在于识别连通块并聚合其总和模 k 的信息"
      ],
      "Objective Function": "计数：统计价值总和能被 k 整除的岛屿数量",
      "Algorithmic Invariant": [
        "使用 DFS/BFS 遍历每个未访问的陆地单元格，形成极大连通块",
        "在遍历过程中累加当前岛屿的总价值",
        "访问过的单元格不再参与后续岛屿的构成（状态可标记）",
        "模 k 的余数可用于剪枝或状态压缩（如动态规划辅助），但本题只需最终判断 sum % k == 0"
      ],
      "Transformable Parameters": {
        "grid 维度": {
          "m, n 范围": "1 <= m, n <= 1000",
          "总单元数限制": "1 <= m * n <= 1e5"
        },
        "值域参数": {
          "grid[i][j] 值域": "0 <= grid[i][j] <= 1e6",
          "k 的范围": "1 <= k <= 1e6"
        },
        "连通方式": [
          "四连通（当前）",
          "可变换为八连通"
        ],
        "是否允许零值陆地": [
          "当前：陆地必须 > 0",
          "可变：允许 0 表示陆地（需重新定义）"
        ],
        "目标函数形式": [
          "计数满足 sum ≡ 0 (mod k) 的岛屿（当前）",
          "可改为：最大/最小价值岛屿中满足模条件者",
          "可改为：构造一个修改使得答案变化"
        ],
        "输入模式": [
          "离线一次性输入（当前）",
          "可扩展为在线更新（支持添加/删除陆地）"
        ],
        "数据特性": [
          "grid 是否有序无影响",
          "是否存在多个相同余数岛屿可合并统计"
        ]
      }
    }
  },
  {
    "title": "Fill a Special Grid",
    "slug": "fill-a-special-grid",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "name": "N",
        "domain": "non-negative integer",
        "range": "0 <= N <= 10",
        "derived_object": {
          "grid_size": "2^N x 2^N",
          "value_domain": "integers from 0 to 2^(2N) - 1",
          "structure": "quadrant-partitioned square matrix"
        }
      },
      "Core Constraint": {
        "global_ordering": [
          "max(quadrant[0]) < min(quadrant[1])",
          "max(quadrant[1]) < min(quadrant[2])",
          "max(quadrant[2]) < min(quadrant[3])"
        ],
        "quadrant_indexing": {
          "0": "top-right",
          "1": "bottom-right",
          "2": "bottom-left",
          "3": "top-left"
        },
        "recursive_structure": "each quadrant must also be a special grid of size 2^(N-1) x 2^(N-1)",
        "base_case": "1x1 grid is trivially special"
      },
      "Objective Function": "construct a valid 2^N x 2^N special grid satisfying all ordering and recursive constraints",
      "Algorithmic Invariant": {
        "invariant_type": "recursive construction with value partitioning",
        "value_allocation": "values are partitioned into four contiguous intervals assigned to quadrants in increasing order",
        "construction_order": "top-left (largest) ← top-right (smallest), bottom-right, bottom-left → recursively fill each quadrant with offset values",
        "monotonicity_preservation": "within each recursive level, relative ordering across quadrants ensures global constraint satisfaction",
        "inductive_correctness": "if subgrids are special and value ranges satisfy inter-quadrant inequalities, full grid is special"
      },
      "Transformable Parameters": {
        "N_value_range": "0 to 10",
        "output_format": "2D integer matrix",
        "input_form": "single integer N",
        "recursion_depth": "N levels",
        "value_restriction": "must use exactly integers 0 to 4^N - 1 without repetition",
        "symmetry_options": [
          "allow alternative quadrant orderings (e.g., clockwise vs counterclockwise)"
        ],
        "constraint_modifications": [
          "change quadrant comparison chain (e.g., different inequality pattern)",
          "relax strict min/max conditions to average-based or sum-based rules"
        ],
        "extension_potential": {
          "higher_dimensions": "extend to 3D cube octants",
          "online_construction": "support incremental N queries",
          "multiple_solutions": "enumerate all possible special grids"
        }
      }
    }
  },
  {
    "title": "Count Cells in Overlapping Horizontal and Vertical Substrings",
    "slug": "count-cells-in-overlapping-horizontal-and-vertical-substrings",
    "schema": {
      "Input Structure": [
        "二维字符矩阵 grid[1..m][1..n]",
        "字符串 pattern[1..p]",
        "grid[i][j] ∈ {a-z}, pattern[k] ∈ {a-z}",
        "1 <= m, n <= 1000",
        "1 <= m * n <= 10^5",
        "1 <= p <= m * n"
      ],
      "Core Constraint": [
        "水平子串可跨越行边界：从某行末尾延续至下一行开头，但不循环（非环形）",
        "垂直子串可跨越列边界：从某列底部延续至下一列顶部，但不循环（非环形）",
        "子串必须连续且方向固定（水平为行优先顺序，垂直为列优先顺序）",
        "一个单元格属于某个子串当且仅当它在该子串的连续路径上"
      ],
      "Objective Function": "计数 — 统计同时满足以下两个条件的单元格数量：\n- 属于至少一个与 pattern 相等的水平子串\n- 属于至少一个与 pattern 相等的垂直子串",
      "Algorithmic Invariant": [
        "水平匹配的遍历可以按行优先顺序展开，使用滑动窗口在线性化数组中查找 pattern 的所有出现位置",
        "垂直匹配的遍历可以按列优先顺序展开，同样使用滑动窗口在线性化数组中查找 pattern 的所有出现位置",
        "一旦确定所有水平匹配覆盖的单元格集合 H_set 和所有垂直匹配覆盖的单元格集合 V_set，则答案为 |H_set ∩ V_set|",
        "匹配过程具有局部独立性：每个起始位置是否构成 pattern 可独立验证，不影响其他位置"
      ],
      "Transformable Parameters": {
        "pattern_length": "p ∈ [1, m*n], 可变以控制搜索复杂度",
        "grid_dimensions": "m, n 可调整，支持矩形或细长结构",
        "linearization_direction": [
          "水平：行优先（row-major）",
          "垂直：列优先（column-major）",
          "可扩展为环形线性化（如最后一行连第一行）"
        ],
        "matching_case_sensitivity": "当前为严格匹配，可改为忽略大小写",
        "pattern_type": "当前为单一 pattern，可变为多个 pattern 要求交集",
        "input_form": "当前为离线静态 grid + pattern，可改为在线查询多个 pattern",
        "subsequence_mode": "当前为连续子串，可变形为子序列匹配",
        "direction_constraints": "当前限定水平和垂直，可加入对角线或其他路径模式",
        "output_requirement": "当前输出交集单元格数量，可改为输出坐标列表或布尔判定"
      }
    }
  },
  {
    "title": "Number of Unique XOR Triplets II",
    "slug": "number-of-unique-xor-triplets-ii",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n <= 1500，nums[i] ∈ [1, 1500]",
      "Core Constraint": "三元组索引满足 i <= j <= k，XOR 值由 nums[i] XOR nums[j] XOR nums[k] 决定；由于异或运算的结合性与交换性，值域受限于数值范围且存在重复可能",
      "Objective Function": "统计所有满足条件的三元组 (i, j, k) 中不同 XOR 结果的数量（去重计数）",
      "Algorithmic Invariant": "利用异或前缀和性质：若 pre[i] = nums[0] XOR ... XOR nums[i-1]，则子数组异或可表示为 pre[j] XOR pre[i]；但本题中三元组非连续区间，无法直接使用前缀和优化。暴力枚举下，可通过固定 j 并预处理左右侧异或集合，实现中间扩展的去重合并不变性",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1500 → 可调整至 O(n²) 可接受范围，或压缩至小规模用于 DP",
        "值域范围": "nums[i] <= 1500 → 可扩展至更大值域（需哈希），或限制在较小空间（如 <= 256）以启用位向量优化",
        "是否有序": "当前无序 → 可考虑排序后分析模式，但异或不具备单调性",
        "是否循环": "否 → 可设计环形数组版本（i <= j <= k 模 n）作为变形",
        "是否多组输入": "单组 → 可改为多测数据以测试常数优化能力",
        "是否在线": "离线输入 → 可设计动态添加元素并实时维护三元组异或集的问题变体",
        "目标函数变化": "从‘不同值数量’变为‘出现次数最多的异或值’或‘某个特定值是否存在’",
        "约束条件变化": "i <= j <= k → 改为 i < j < k 或允许任意顺序（全排列）"
      }
    }
  },
  {
    "title": "Count Covered Buildings",
    "slug": "count-covered-buildings",
    "schema": {
      "Input Structure": {
        "type": "2D Grid with Point Set",
        "description": "An n x n grid where n is a positive integer, and a set of buildings represented as coordinates [x, y] in the grid.",
        "constraints": [
          "n >= 2 && n <= 1e5",
          "buildings.length >= 1 && <= 1e5",
          "each building = [x, y], with 1 <= x, y <= n",
          "all coordinates in buildings are unique"
        ]
      },
      "Core Constraint": {
        "description": "A building is 'covered' if and only if, in each of the four cardinal directions (up, down, left, right), there exists at least one other building along that row or column.",
        "key_insight": "Directional coverage depends on existence (not distance) — for a building at (x, y), we require: at least one building with same y and smaller x (left), same y and larger x (right), same x and smaller y (up), same x and larger y (down)."
      },
      "Objective Function": {
        "type": "Counting",
        "goal": "Count the number of buildings that are covered, i.e., have at least one building in each of the four directions."
      },
      "Algorithmic Invariant": {
        "invariant": "For any building to be covered, it must not be extremal in any of the four directions among buildings sharing its row or column.",
        "optimization_principle": "Group buildings by row and by column. For each row, compute min and max x (but actually: all x-values); similarly for each column. Then, for a building (x, y) to be covered: in row y, there must exist buildings both to the left (x' < x) and right (x' > x); in column x, there must exist buildings both above (y' < y) and below (y' > y).",
        "data_structure_implication": "Efficient lookup of neighbors in row and column via grouping (hash map of rows and columns)."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "grid_dimension",
            "type": "int",
            "range": [
              2,
              100000.0
            ],
            "transformations": [
              "1D reduction",
              "3D extension",
              "toroidal/circular grid"
            ]
          },
          {
            "name": "building_density",
            "type": "int",
            "range": [
              1,
              100000.0
            ],
            "transformations": [
              "sparse vs dense",
              "online insertion/deletion of buildings"
            ]
          },
          {
            "name": "coverage_directions",
            "type": "set",
            "possible_values": [
              "4-directional",
              "8-directional",
              "diagonal-only",
              "k-nearest"
            ],
            "default": "4-directional"
          },
          {
            "name": "coverage_condition",
            "type": "logical",
            "options": [
              "existential (at least one in each direction)",
              "count-based (at least k in each direction)",
              "distance-bounded (within radius r)"
            ],
            "default": "existential"
          },
          {
            "name": "input_form",
            "options": [
              "static list of buildings",
              "streaming / online queries",
              "with updates (add/remove)"
            ],
            "default": "static"
          },
          {
            "name": "output_type",
            "options": [
              "count only",
              "list of covered buildings",
              "maximum contiguous covered region"
            ],
            "default": "count"
          },
          {
            "name": "uniqueness_constraint",
            "options": [
              "coordinates unique (default)",
              "allow multiple buildings at same location"
            ],
            "default": "unique"
          }
        ]
      }
    }
  },
  {
    "title": "Maximize Profit from Task Assignment",
    "slug": "maximize-profit-from-task-assignment",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at that index."
      },
      "Core Constraint": {
        "constraint": "The amount of water that can be trapped between two lines depends on the shorter of the two heights and the distance between them.",
        "key_insight": "Water level at any interval is determined by the minimum of the maximum heights to the left and right, minus the current height.",
        "dependency": "Each position's contribution depends on global left-max and right-max values."
      },
      "Objective Function": {
        "goal": "maximize",
        "output_type": "scalar",
        "objective": "Find the maximum amount of water that can be contained between any two elements in the array (i.e., maximum area formed by two lines and the x-axis)."
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers (left and right) start from both ends; at each step, moving the pointer with the smaller height maintains the possibility of finding a larger area.",
        "proof_condition": "Since the area is limited by the shorter line, moving the taller one cannot increase the area due to decreasing width, so only the shorter one should be advanced.",
        "state_preservation": "At every step, the maximum possible area for the current boundary is considered, and no optimal solution outside the current window is missed."
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "10^5"
        ],
        "value_range": [
          "0",
          "10^4"
        ],
        "input_form": "static offline array",
        "online_queries": false,
        "mutable_array": false,
        "multi_dimensional": false,
        "circular": false,
        "multiple_test_cases": true,
        "output_detail_level": "single integer (maximum area)",
        "variants": [
          "2D version: container with topography",
          "Dynamic updates: support point updates",
          "Minimum area ≥ K: decision problem variant",
          "Count number of valid containers ≥ threshold",
          "Reverse objective: minimize area under constraints"
        ]
      }
    }
  },
  {
    "title": "Maximum Containers on a Ship",
    "slug": "maximum-containers-on-a-ship",
    "schema": {
      "Input Structure": [
        "正整数 n，表示 n x n 的二维网格（甲板）",
        "每个单元格可装载一个重量恰好为 w 的集装箱",
        "w 为正整数",
        "maxWeight 为船的最大承载重量，是正整数",
        "总可选位置数为 n²"
      ],
      "Core Constraint": [
        "每个集装箱重量固定为 w，不可分割",
        "总装载重量不能超过 maxWeight",
        "集装箱只能整箱装载，无部分装载",
        "所有位置等价，无空间约束或布局限制"
      ],
      "Objective Function": "最大化可以装载的集装箱数量（即求最大可行个数 k，使得 k * w ≤ maxWeight 且 k ≤ n²）",
      "Algorithmic Invariant": [
        "最优解具有单调性：若能装 k 个，则一定能装 k-1 个",
        "问题可退化为一维线性约束下的整数最优化问题",
        "贪心策略成立：优先装更多集装箱不会破坏可行性",
        "解空间被上界 min(n², floor(maxWeight / w)) 所决定"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1000 → 可扩展至 1e5 或更高以强制使用 O(1) 解法",
        "w 是否可变": "当前固定 → 可改为数组形式 w[i][j] 表示不同位置集装箱重量不同",
        "maxWeight 值域": "1 <= maxWeight <= 1e9 → 可缩小至小值域以启用 DP 或枚举",
        "是否多组输入": "单组 → 可改为多测 case",
        "是否在线": "离线一次性输入 → 可设计为动态修改 w 或 maxWeight 的查询问题",
        "输入形式变化": "当前为标量参数 → 可变为每个位置有不同限重或容量",
        "目标函数变形": "最大数量 → 是否存在恰好装满的方案（判定型）或计数满足条件的装载方式"
      }
    }
  },
  {
    "title": "DNA Pattern Recognition ",
    "slug": "dna-pattern-recognition",
    "schema": {
      "Input Structure": [
        "表 Samples，包含字段：sample_id (int), dna_sequence (varchar), species (varchar)",
        "dna_sequence 是由字符 'A', 'T', 'G', 'C' 组成的非空字符串",
        "sample_id 为唯一主键",
        "输入规模：n 行记录，每条 dna_sequence 长度 ≤ 1000"
      ],
      "Core Constraint": [
        "每个模式检测是局部子串/前缀/后缀匹配问题",
        "四个独立布尔条件需分别判断：",
        "  - 起始密码子：序列以 'ATG' 开头（前缀匹配）",
        "  - 终止密码子：序列以 'TAA', 'TAG', 或 'TGA' 结尾（后缀匹配）",
        "  - 重复基序：序列中任意位置包含子串 'ATAT'",
        "  - 连续G段：序列中存在至少3个连续的 'G'（即包含 'GGG'）",
        "所有判断基于单个字符串的结构特征，无跨样本依赖"
      ],
      "Objective Function": [
        "对每条记录输出其 sample_id, dna_sequence, species 及四个布尔标志位",
        "每个标志位表示对应模式是否存在（1 存在，0 不存在）",
        "目标函数为多属性判定（multi-predicate classification），非最优化或计数",
        "结果按 sample_id 升序排序"
      ],
      "Algorithmic Invariant": [
        "各模式检测相互独立，可并行处理",
        "字符串匹配具有确定性有限状态：",
        "  - 前缀匹配：比较前3字符是否等于 'ATG'",
        "  - 后缀匹配：检查最后3字符是否属于 {'TAA','TAG','TGA'}",
        "  - 子串匹配：使用内置子串查找（如 KMP 或直接扫描）判断 'ATAT' 是否出现",
        "  - 连续字符检测：滑动窗口扫描是否存在 'GGG' 模式",
        "所有操作保持线性时间复杂度 O(|s|)，且不改变原始数据顺序"
      ],
      "Transformable Parameters": {
        "Pattern Conditions": {
          "start_codon": {
            "value": [
              "ATG"
            ],
            "possible_transforms": [
              "可替换为其他起始密码子如 'GTG'",
              "可允许多种起始模式"
            ]
          },
          "stop_codons": {
            "value": [
              "TAA",
              "TAG",
              "TGA"
            ],
            "possible_transforms": [
              "可增删终止密码子集合",
              "可改为非标准终止子"
            ]
          },
          "motif_patterns": {
            "value": [
              "ATAT"
            ],
            "possible_transforms": [
              "可变为更长重复模式如 'ATATAT'",
              "可推广为任意 k-mer 重复"
            ]
          },
          "repetition_constraint": {
            "value": "≥3 consecutive 'G'",
            "possible_transforms": [
              "可改为 'A', 'T', 'C' 的连续出现",
              "可参数化长度 k（如 ≥k G's）"
            ]
          }
        },
        "Data Scale": {
          "num_samples": "1 ≤ n ≤ 10^4",
          "sequence_length": "1 ≤ |dna_sequence| ≤ 1000",
          "possible_transforms": [
            "可扩展至大规模基因组数据（在线流式处理）",
            "可支持压缩存储格式"
          ]
        },
        "Input Output Form": {
          "input_form": "静态关系表（离线批处理）",
          "output_form": "扩展原表字段，新增布尔列",
          "possible_transforms": [
            "改为仅返回满足所有条件的样本（过滤）",
            "改为返回匹配位置索引",
            "改为多组查询（不同模式组合）"
          ]
        },
        "Execution Mode": {
          "mode": "离线一次性处理",
          "possible_transforms": [
            "在线模式：实时接收新序列并更新结果",
            "增量计算：支持插入/删除样本"
          ]
        },
        "Sorting Requirement": {
          "order_by": "sample_id ASC",
          "possible_transforms": [
            "可改为按物种分组输出",
            "可取消排序要求"
          ]
        }
      }
    }
  },
  {
    "title": "Sum of Largest Prime Substrings",
    "slug": "sum-of-largest-prime-substrings",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "给定一个长度为 n 的字符串 s，1 <= n <= 10",
        "element": "字符为数字 '0'-'9'",
        "constraints": [
          "s.length ∈ [1, 10]",
          "s 仅由数字字符组成"
        ]
      },
      "Core Constraint": {
        "constraint": "所有可能的子字符串可生成有限个整数值（忽略前导零），每个值最多贡献一次质数判定",
        "key_properties": [
          "子字符串连续且数量为 O(n²)",
          "数值范围受限于字符串长度（最大不超过 10 位数）",
          "重复数值视为同一质数候选",
          "质数定义：大于 1 且因数仅为 1 和自身"
        ]
      },
      "Objective Function": "从所有由子字符串转换而来的不同质数中，选出最大的至多 3 个，并求其和；若不足 3 个，则取所有质数之和",
      "Algorithmic Invariant": {
        "invariant": "枚举所有子字符串 → 去重整数值 → 质数判定 → 排序降序 → 取前 min(3, count) 项求和",
        "proof_based": [
          "子字符串集合完备：O(n²) 枚举可覆盖所有连续子序列",
          "整数转换唯一性：忽略前导零后数值唯一（如 '0023' → 23）",
          "质数判定独立：每个数值是否为质数是确定性问题",
          "贪心选取正确性：最大和等价于取最大几个，无需考虑组合冲突"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "字符串长度 n",
            "range": "原题 [1,10]，可扩展至 [1, 100] 或更高以引入大数处理"
          },
          {
            "name": "字符集",
            "options": [
              "仅数字",
              "含非数字需过滤"
            ]
          },
          {
            "name": "前导零处理方式",
            "options": [
              "忽略（当前设定）",
              "视为不同字符串但同值",
              "禁止出现"
            ]
          },
          {
            "name": "目标函数形式",
            "options": [
              "求最大 k 个质数和（k=3）",
              "求第 k 大质数",
              "计数不同质数个数",
              "判断是否存在至少 k 个"
            ]
          },
          {
            "name": "k 的取值",
            "options": "可变参数 k ∈ [1, ∞)，当前 k=3"
          },
          {
            "name": "输入形式",
            "options": [
              "单组字符串",
              "多组字符串批量处理"
            ]
          },
          {
            "name": "数据流模式",
            "options": [
              "离线处理",
              "在线动态添加字符并查询当前状态"
            ]
          },
          {
            "name": "数值去重粒度",
            "options": [
              "按整数值去重（当前）",
              "按子字符串位置去重"
            ]
          },
          {
            "name": "质数判定边界优化",
            "options": [
              "预筛小质数表（≤1e5）",
              "实时试除法"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Find Time Required to Eliminate Bacterial Strains",
    "slug": "find-time-required-to-eliminate-bacterial-strains",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度的较小值决定，且仅当当前高度低于该值时才能积水",
      "Objective Function": "计算整个数组能接的雨水总量（求和）",
      "Algorithmic Invariant": "维护两个指针 L 和 R 分别从左右两端向内移动，同时记录 left_max 和 right_max；若 left_max ≤ right_max，则左指针当前位置的积水可确定，并向右移动 L；否则向左移动 R；指针移动过程中不破坏已计算区域的正确性",
      "Transformable Parameters": {
        "H 是否允许负值": false,
        "维度扩展": "可扩展至二维矩阵（2D接雨水）",
        "输入模式": "可改为在线流式输入或支持区间修改的动态版本",
        "输出要求": "可要求输出每个位置的具体积水量而非总和",
        "数据规模 n": "1 <= n <= 3 * 10^4",
        "值域范围": "0 <= H[i] <= 10^5",
        "是否多组数据": false,
        "是否循环数组": false
      }
    }
  },
  {
    "title": "Smallest Palindromic Rearrangement II",
    "slug": "smallest-palindromic-rearrangement-ii",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，其中 1 <= n <= 10^4",
        "s 由小写英文字母组成",
        "保证 s 是回文字符串",
        "给定整数 k，1 <= k <= 10^6"
      ],
      "Core Constraint": [
        "回文排列的构造依赖于字符频次统计：至多一个字符可出现奇数次（作为中心）",
        "不同重排若生成相同字符串，则视为同一回文排列",
        "字典序由前半部分字符决定，后半部分对称确定",
        "所有回文排列可通过枚举左半部分 + 中心 + 右半部分（镜像）唯一构造"
      ],
      "Objective Function": [
        "求 s 的所有不同回文排列中，按字典序排序的第 k 小字符串",
        "若不同回文排列总数 < k，则返回空字符串"
      ],
      "Algorithmic Invariant": [
        "回文结构具有对称不变性：右半部分由左半部分唯一确定",
        "字典序最小性可通过贪心构造左半部分实现",
        "通过阶乘计数（多重排列去重）可跳过无效分支（类似康托展开思想）",
        "在生成过程中，使用字符频次的可排列数剪枝，避免全枚举"
      ],
      "Transformable Parameters": [
        "字符串长度 n 的数量级（当前：1e4，可调整至 1e5 或更小）",
        "字符集大小（当前：26个小写字母，可扩展为大写或数字）",
        "是否保证输入为回文（可改为非回文，需先判断能否构成回文）",
        "k 的范围（当前：1e6，可改为更大并要求模意义下计数）",
        "是否多组数据输入",
        "是否在线查询第 k 小排列（动态修改 s 或 k）",
        "目标函数变化：改为第 k 大、计数总数、或输出所有排列",
        "约束变化：允许最多 m 个奇数频次字符（广义回文）"
      ]
    }
  },
  {
    "title": "Smallest Palindromic Rearrangement I",
    "slug": "smallest-palindromic-rearrangement-i",
    "schema": {
      "Input Structure": [
        "字符串 s[1..n]",
        "s 由小写英文字母组成",
        "1 <= n <= 10^5",
        "保证 s 是回文字符串"
      ],
      "Core Constraint": [
        "回文结构要求字符对称分布",
        "字符重排后仍需保持回文性质",
        "最多只能有一个字符出现奇数次（位于中心），但原串已为回文，奇偶性已满足",
        "字典序最小目标驱动贪心分配：较小字符应优先放在外侧"
      ],
      "Objective Function": "构造 s 的一个字符重排，使其仍是回文，并且在所有可能的回文排列中字典序最小",
      "Algorithmic Invariant": [
        "回文结构可拆分为前半段 + 中心（若有）+ 前半段逆序",
        "字典序最小 ⇒ 应将字符按升序尽量填充到前半段",
        "字符频次统计后，可逐个分配给左侧半段，中心留到最后处理奇数频次字符",
        "一旦字符频率确定，最优构造唯一：贪心从 'a' 到 'z' 分配左半部分"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^5（可改为更小或支持动态）",
        "字符集": "当前为小写英文 a-z，可扩展为大写、数字或任意字符集",
        "是否保证输入为回文": "当前是，可改为‘不保证’，增加判定步骤",
        "输出形式": [
          "返回最小字典序回文",
          "变体：返回第 k 小回文排列",
          "变体：返回能否构造字典序小于某字符串的回文"
        ],
        "是否多组数据": "否，可改为多组测试用例",
        "是否在线": "离线处理，可设计为流式字符输入下的动态维护最小回文排列",
        "约束变化": [
          "加入字符位置固定限制（某些字符不能移动）",
          "要求结果回文且是原串的子序列而非排列"
        ]
      }
    }
  },
  {
    "title": "Reverse Degree of a String",
    "slug": "reverse-degree-of-a-string",
    "schema": {
      "Input Structure": "一维字符串 s[1..n]，其中每个字符 s[i] ∈ {'a'..'z'}，长度 n 满足 1 ≤ n ≤ 1000",
      "Core Constraint": "每个字符的贡献由其在反转字母表中的固定映射值（'a'=26, 'b'=25, ..., 'z'=1）和其在字符串中的位置（下标从1开始）共同决定；各字符贡献独立可加",
      "Objective Function": "计算所有字符的（反转字母表位置 × 字符串中位置）之和",
      "Algorithmic Invariant": "单次线性遍历过程中，每一步累加当前字符的映射值与其位置的乘积，总和保持不变且逐步收敛至最终结果",
      "Transformable Parameters": {
        "n 的数量级": "1e3（可扩展至 1e5 或更高以要求预处理优化）",
        "值域": "字符集是否扩展至大写、数字或特殊字符",
        "是否有序": "输入字符串是否有特定顺序约束（如字典序）",
        "是否循环": "字符串是否视为环形结构",
        "是否多组输入": "支持多组测试用例或批量处理",
        "是否在线": "字符流式输入，动态更新反转度",
        "映射规则可变": "反转映射是否改为其他函数（如 'a'=1, 'b'=2 或自定义权重数组）",
        "输出形式变化": "返回最大贡献字符、前k大贡献和等"
      }
    }
  },
  {
    "title": "Count Numbers with Non-Decreasing Digits ",
    "slug": "count-numbers-with-non-decreasing-digits",
    "schema": {
      "Input Structure": [
        "字符串形式的整数 l 和 r，表示一个闭区间 [l, r]",
        "整数 b 表示进制（2 <= b <= 10）",
        "l 和 r 的长度在 1 到 100 之间，无前导零，且 l <= r",
        "输入为非负整数的十进制字符串表示"
      ],
      "Core Constraint": [
        "需要枚举区间 [l, r] 内的所有整数，并将其转换为 b 进制下的数字序列",
        "b 进制表示的每一位数字必须构成非递减序列（即 digit[i] <= digit[i+1]）",
        "由于区间极大（字符串长度达 100），不能暴力遍历，需数位动态规划处理"
      ],
      "Objective Function": "计数：统计在 [l, r] 区间内，以 b 进制表示时各位数字非递减的整数个数，结果对 10^9 + 7 取余",
      "Algorithmic Invariant": [
        "使用数位 DP（Digit DP）进行状态压缩搜索：逐位构造满足非递减条件的数字",
        "状态包括：当前位、上一位选择的数字、是否受上界限制（tight）、是否仍处于前导零阶段",
        "非递减性质保证状态转移中只需记录最后一位，即可维护合法性",
        "通过记忆化搜索避免重复子问题计算，复杂度与位数和进制相关但可接受"
      ],
      "Transformable Parameters": {
        "n 的数量级": "字符串长度 up to 100 → 数值范围极大，O(n) 算法不可行，必须用数位DP",
        "值域": "进制 b ∈ [2,10]，可扩展至更高进制或字母表示（如十六进制）",
        "是否有序": "输入 l <= r，天然有序；可变体可考虑多区间求和",
        "是否循环": "否；可变形为环形数字（首位 >= 末位）",
        "是否多组输入": "原题单组；可扩展为多组查询（在线/离线）",
        "是否在线": "否；可设计为流式输入区间，要求实时回答",
        "其他变形点": [
          "目标函数变化：改为最小化/最大化某个非递减数",
          "约束变化：非递增、严格递增、回文数字等",
          "输出形式变化：返回所有满足条件的数的列表（小规模下）",
          "增加维度：二维数阵的非递减路径计数"
        ]
      }
    }
  },
  {
    "title": "Properties Graph",
    "slug": "properties-graph",
    "schema": {
      "Input Structure": [
        "二维整数数组 properties，维度为 n × m",
        "每个 properties[i] 是一个长度为 m 的整数列表",
        "元素值域：1 <= properties[i][j] <= 100",
        "1 <= n <= 100, 1 <= m <= 100",
        "给定整数 k，满足 1 <= k <= m"
      ],
      "Core Constraint": [
        "图的构建基于节点属性集合的交集大小",
        "边 (i, j) 存在当且仅当 |set(properties[i]) ∩ set(properties[j])| >= k",
        "交集计算针对不同整数（去重后）",
        "图是无向图，自环被排除（i ≠ j）"
      ],
      "Objective Function": [
        "求构造出的无向图中连通分量的数量",
        "目标函数为计数型：统计连通块个数"
      ],
      "Algorithmic Invariant": [
        "连通性可通过并查集（Union-Find）动态维护",
        "若两个节点满足 intersect >= k，则合并其所在集合",
        "遍历所有节点对 (i, j) 可保证不遗漏边",
        "集合交集大小的判定具有对称性，支持无向图建模"
      ],
      "Transformable Parameters": {
        "n 的数量级": "当前 n ≤ 100，可扩展至 1e3~1e4（需优化算法）",
        "m 的长度与值域": "当前 m ≤ 100，值域小且有限（1~100），适合位运算或哈希优化",
        "k 的约束": "可变为变量、或随节点变化（个性化阈值）",
        "是否去重": "properties[i] 中是否考虑重复元素（当前题中去重影响结果）",
        "输入形式": "可改为稀疏表示、流式输入、在线查询节点邻居",
        "图构建方式": "显式建图（O(n²) 预处理） vs 隐式推导（实时判断边存在性）",
        "多组数据": "是否处理多个测试用例",
        "目标函数变换": "改为最大连通分量大小 / 判定是否全连通 / 输出生成树等",
        "属性类型扩展": "从整数集合扩展为字符串、区间、向量等"
      }
    }
  },
  {
    "title": "Longest Palindrome After Substring Concatenation II",
    "slug": "longest-palindrome-after-substring-concatenation-ii",
    "schema": {
      "Input Structure": [
        "两个字符串 s 和 t",
        "s 的长度为 n，t 的长度为 m，1 <= n, m <= 1000",
        "字符串仅由小写英文字母组成",
        "可从 s 中选一个子串（连续），从 t 中选一个子串（连续），按顺序拼接"
      ],
      "Core Constraint": [
        "回文串的构造必须来自 s 的子串和 t 的子串的拼接（s_sub + t_sub）",
        "拼接后的字符串需整体构成回文",
        "子串可以为空（允许单边贡献）",
        "最长回文结构依赖于两边字符的对称匹配能力"
      ],
      "Objective Function": "最大化拼接后回文串的长度（即求最长可能的回文长度）",
      "Algorithmic Invariant": [
        "枚举所有可能的拼接中心位置或边界对齐方式",
        "固定 s 中某子串的右端部分与 t 中某子串的左端部分进行镜像匹配",
        "对于任意 i, j，考虑 s[i:k] 与 t[l:j] 拼接形成回文时，其外层匹配成功则内层仍保持回文性质",
        "可通过预处理 s 的所有后缀与 t 的所有前缀的最长公共回文扩展长度来加速计算",
        "最优解必然出现在以下三种情况之一：完全来自 s 的回文、完全来自 t 的回文、跨串拼接形成的回文"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 的数量级": [
            "1e3（当前）",
            "可扩展至 1e5（需优化算法）"
          ]
        },
        "字符串性质": [
          "是否允许大写字母或特殊字符",
          "是否有序 / 是否周期性"
        ],
        "子串限制": [
          "是否允许空子串",
          "是否要求非空子串",
          "是否限制子串长度"
        ],
        "拼接方式": [
          "按顺序连接（当前）",
          "可交换顺序（如也允许 t_sub + s_sub）",
          "允许多段交替拼接（变形题）"
        ],
        "目标函数变体": [
          "最长回文长度（当前）",
          "最短能构造的回文",
          "回文串的数量计数",
          "是否存在长度 ≥ K 的回文"
        ],
        "输入形式": [
          "静态输入（当前）",
          "多组测试数据",
          "在线查询：动态修改 s 或 t 后询问答案"
        ],
        "约束隐藏": [
          "显式枚举所有子串（暴力可做）",
          "隐式结构（如只给哈希值或压缩表示）"
        ]
      }
    }
  },
  {
    "title": "Maximum Coin Collection ",
    "slug": "maximum-coin-collection",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；若当前高度低于该值，则可积水",
      "Objective Function": "计算整个数组能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针 L 和 R 分别从左右两端向内收缩；维护 maxLeft 表示 H[0..L] 的最大值，maxRight 表示 H[R..n-1] 的最大值；若 maxLeft ≤ maxRight，则 L 处的积水仅由 maxLeft 决定，可安全计算并右移 L；否则由 maxRight 决定，可计算 R 并左移 R",
      "Transformable Parameters": {
        "H 是否允许负值": false,
        "维度扩展": [
          "1D → 2D（二维接雨水）",
          "环形数组版本"
        ],
        "目标函数变化": [
          "最大单区间盛水量（如‘盛水最多的容器’）",
          "每个位置的积水量输出"
        ],
        "输入形式": [
          "静态离线输入",
          "在线流式更新",
          "支持修改操作的动态版本"
        ],
        "数据规模 n": "1 ≤ n ≤ 10^5",
        "值域范围": "0 ≤ H[i] ≤ 10^4",
        "是否多组数据": false,
        "是否有序": false
      }
    }
  },
  {
    "title": "Maximize Active Section with Trade I",
    "slug": "maximize-active-section-with-trade-i",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": [
          "0",
          "1"
        ],
        "length": "n",
        "constraint": "n >= 1 && n <= 1e5",
        "preprocessing": "t = '1' + s + '1'"
      },
      "Core Constraint": {
        "description": "操作只能执行最多一次，且必须成对进行：先删除一个被'0'包围的连续'1'区块（使其变为全0），再将一个被'1'包围的连续'0'区块变为全1。两侧添加的'1'提供边界稳定性，确保所有内部段均有明确包围。",
        "structural_property": "活跃区段由极大连续'1'构成；变换操作本质是‘合并相邻活跃区段’的间接手段，通过消除中间隔离的'0'块实现。",
        "dependency": "最终活跃区段数取决于原串中'1'段的分布以及是否存在可通过一次翻转实现的大规模连接"
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "number of contiguous '1' segments in the resulting string after at most one operation",
        "note": "两端添加的'1'不参与最终计数，仅用于辅助边界处理"
      },
      "Algorithmic Invariant": {
        "invariant_1": "任意时刻，字符串中每个极大连续'1'段或'0'段的位置和长度可线性扫描确定。",
        "invariant_2": "最优操作一定满足：删除一个孤立的'1'块（被0包围）以释放空间，然后填充一个被'1'包围的'0'块来连接其两侧的'1'段，从而净增加活跃区段数。",
        "invariant_3": "若存在一个长度为k的被'1'包围的'0'区间，则将其转为'1'后，可使左右两个'1'段合并，并可能因中间插入而提升总段数——但需抵消因删去另一个'1'段带来的损失。",
        "greedy_condition": "最大收益发生在选择一个能连接多个孤立'1'段的'0'块进行填充，同时删除代价最小（即只含一个独立'1'段）的区块",
        "monotonicity": "活跃区段总数的变化具有可预测性：填洞增益 = 连接前后的段数差 - 1（删掉的段）"
      },
      "Transformable Parameters": {
        "operation_limit": {
          "default": 1,
          "possible_values": [
            "0",
            "1",
            "k",
            "unlimited"
          ]
        },
        "input_dimension": {
          "current": "1D",
          "possible": [
            "2D binary grid",
            "circular string"
          ]
        },
        "string_order": {
          "sorted": false,
          "monotonic": false
        },
        "data_streaming": {
          "mode": "offline",
          "possible": [
            "online queries",
            "dynamic updates"
          ]
        },
        "output_form": {
          "current": "maximum count",
          "possible": [
            "construct final string",
            "return operation indices"
          ]
        },
        "additional_constraints": {
          "allow_negative": false,
          "with_weights": false,
          "segment_value_based": false
        },
        "side_padding": {
          "enabled": true,
          "value": "'1'",
          "changeable": [
            "'0'",
            "no padding",
            "variable context"
          ]
        }
      }
    }
  },
  {
    "title": "Maximize Active Section with Trade II",
    "slug": "maximize-active-section-with-trade-ii",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "'0' and '1'",
        "length": "n",
        "constraints": [
          "s is a binary string of length n",
          "each character is either '0' (inactive) or '1' (active)"
        ],
        "additional_input": {
          "queries": {
            "type": "2D integer array",
            "element": "[l, r], representing substring indices",
            "range": "0 <= l <= r < n",
            "size": "up to 1e5 queries"
          }
        }
      },
      "Core Constraint": {
        "operation_rule": "exactly one operation allowed per query, consisting of two steps:",
        "step_1": "choose a contiguous '1' segment that is surrounded by '0' on both sides (i.e., isolated), and flip it to all '0'",
        "step_2": "then choose a contiguous '0' segment that is surrounded by '1' on both sides (in the modified string), and flip it to all '1'",
        "boundary_condition": "for each query [l, r], consider t = '1' + s[l..r] + '1'; these added '1's are virtual and do not contribute to final active segment count",
        "independence": "each query is independent; operations apply only to the extracted substring with boundary padding"
      },
      "Objective Function": {
        "goal": "maximize the number of contiguous active ('1') segments in the resulting string after at most one valid operation",
        "output_type": "integer count of maximal active intervals",
        "per_query": true
      },
      "Algorithmic Invariant": {
        "segment_analysis": "the number of active intervals depends on transitions from '0' to '1' and vice versa",
        "effect_of_operation": {
          "first_flip": "removes an existing isolated '1' block, potentially merging surrounding '0' regions",
          "second_flip": "creates a new '1' block inside a previously continuous '0' region that becomes surrounded by '1's",
          "net_change": "optimal operation increases active segment count by up to 2: -1 (removed) + 3 (new splits created around new block)"
        },
        "monotonicity_in_structure": "after adding boundary '1's, internal structure determines whether flips are possible",
        "feasibility_check": "a valid first move requires existence of isolated '1' blocks; second move requires existence of a '0' segment between two '1' regions post-first-flip"
      },
      "Transformable Parameters": {
        "n_value": "1 <= n <= 1e5",
        "query_count": "1 <= queries.length <= 1e5",
        "string_ordering": "arbitrary binary sequence",
        "preprocessing_needed": true,
        "online_offline": "offline preprocessing of s allowed, but each query processed independently",
        "data_updates": false,
        "cyclic": false,
        "multi_group_input": false,
        "hidden_constraints": [
          "presence of isolated '1' blocks determines if operation can start",
          "resulting zero-gap width affects possibility of second flip"
        ],
        "variation_potential": [
          "change objective: minimize/maximize length instead of count",
          "allow multiple operations",
          "remove boundary padding assumption",
          "make operation order flexible",
          "restrict flip locations"
        ]
      }
    }
  },
  {
    "title": "Find Products with Valid Serial Numbers",
    "slug": "find-products-with-valid-serial-numbers",
    "schema": {
      "Input Structure": [
        "二维表 products[1..n]",
        "每行包含: product_id (int), product_name (varchar), description (varchar)",
        "product_id 为唯一主键",
        "description 为非空字符串，长度适中（≤500）",
        "输入数据静态、离线"
      ],
      "Core Constraint": [
        "有效序列号必须满足正则模式：^SN\\d{4}-\\d{4}$，且作为子串出现在 description 中",
        "匹配不区分位置（可在开头、中间、结尾），但必须完整匹配模式",
        "大小写敏感：必须以 'SN' 开头，不能是 'sn' 或 'Sn'",
        "短横 '-' 后必须**恰好**4位数字，不能多也不能少"
      ],
      "Objective Function": [
        "筛选出所有在 description 中包含有效序列号模式的记录",
        "返回原表字段：product_id, product_name, description",
        "按 product_id 升序排序"
      ],
      "Algorithmic Invariant": [
        "字符串匹配具有局部独立性：每个 description 的匹配结果不影响其他行",
        "正则表达式匹配可在线性时间内完成（基于有限状态机）",
        "筛选操作保持原始数据完整性，无状态累积",
        "排序可在筛选后通过比较排序稳定实现"
      ],
      "Transformable Parameters": {
        "Pattern Complexity": {
          "description": "序列号模式是否可变",
          "options": [
            "固定为 SN\\d{4}-\\d{4}",
            "可配置为其他正则模式（如 SN\\w{6}）",
            "支持多模式 OR 匹配"
          ]
        },
        "Case Sensitivity": {
          "description": "是否区分大小写",
          "options": [
            true,
            false
          ]
        },
        "Matching Scope": {
          "description": "匹配范围限制",
          "options": [
            "全局任意位置",
            "必须在句首/句尾",
            "必须单独成词（边界分隔）"
          ]
        },
        "Data Scale": {
          "n": "1 ≤ n ≤ 1e5",
          "description_length": "1 ≤ |description| ≤ 1000"
        },
        "Input Mode": {
          "type": "offline",
          "options": [
            "offline",
            "online_streaming"
          ]
        },
        "Output Requirement": {
          "fields": [
            "full_row",
            "only_product_id"
          ],
          "order": "product_id ASC / DESC / no guarantee"
        },
        "Validation Strictness": {
          "description": "对数字部分的严格性",
          "options": [
            "必须恰好4位",
            "至少4位",
            "不超过4位"
          ]
        }
      }
    }
  },
  {
    "title": "Count Beautiful Numbers",
    "slug": "count-beautiful-numbers",
    "schema": {
      "Input Structure": [
        "两个正整数 l 和 r",
        "1 <= l <= r < 10^9",
        "定义在整数区间 [l, r] 上的数字位运算问题",
        "每个整数视为其十进制数字序列 d_1, d_2, ..., d_k"
      ],
      "Core Constraint": [
        "美丽整数的判定依赖于其各位数字的乘积与和的关系",
        "乘积必须能被和整除（即：product % sum == 0）",
        "若和为 0（不可能，因输入为正整数），则跳过；但实际最小和为 1",
        "数字位之间无序但位置独立，仅需提取所有位即可"
      ],
      "Objective Function": [
        "计数：统计区间 [l, r] 内满足条件的美丽整数个数",
        "目标是返回数目，而非构造或判定单个"
      ],
      "Algorithmic Invariant": [
        "数位分解过程保持不变：任意正整数可唯一分解为其十进制位",
        "乘积与和的计算具有可分离性：每位数字独立贡献",
        "无需记忆化状态转移中的前缀限制（因本题无前导零或大小约束传播）",
        "但由于数据范围大（至 10^9），暴力枚举不可行，应使用数位 DP 的状态设计惯性"
      ],
      "Transformable Parameters": {
        "数值范围": "l, r 可扩展至 10^18（触发数位DP必要性）",
        "是否多组查询": false,
        "输入形式": "闭区间 [l, r]，可改为开区间或多区间合并",
        "在线处理": "可设计为流式询问多个区间的结果",
        "约束变化": [
          "改为乘积整除和 → 和整除乘积",
          "引入非零位限制（如不能含数字0）",
          "增加位数限制（如恰好k位）"
        ],
        "输出形式": [
          "返回数量（当前）",
          "改为返回所有美丽整数列表（小规模下）",
          "返回最长连续子序列等衍生结构"
        ],
        "数制变换": "可改为二进制、八进制下的位操作分析",
        "函数变形": "将‘乘积’替换为‘异或’，‘和’替换为‘按位与’等位运算组合"
      },
      "Note": "尽管当前示例可通过暴力遍历实现（因提示中 r < 10^9，最坏约 1e9 次操作），但从竞赛算法视角，该题本质属于「数位统计类问题」，理想解法应基于数位动态规划（Digit DP）进行状态压缩。因此本 Schema 应归入叶子节点母题：'数位分解下的整除性计数问题'。"
    }
  },
  {
    "title": "Longest Common Prefix Between Adjacent Strings After Removals",
    "slug": "longest-common-prefix-between-adjacent-strings-after-removals",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element_type": "string",
        "description": "一维字符串数组 words[0..n-1]，其中 n = words.length",
        "constraints": [
          "1 <= n <= 1e5",
          "1 <= words[i].length <= 1e4",
          "words[i] 仅由小写英文字母组成",
          "所有 words[i] 的长度总和 <= 1e5"
        ]
      },
      "Core Constraint": {
        "description": "每次移除一个下标 i 后，剩余数组形成新的相邻对序列；每个相邻对的最长公共前缀（LCP）长度取决于两个字符串的逐字符比较；整体最大值由局部相邻对决定",
        "key_properties": [
          "相邻性依赖：只有连续位置构成有效对",
          "局部独立性：每对 LCP 可独立计算",
          "扰动敏感性：移除一个元素会改变其前后连接关系"
        ]
      },
      "Objective Function": {
        "goal": "计数型 + 构造方案",
        "output": "返回长度为 n 的数组 answer，其中 answer[i] 表示移除下标 i 后，剩余数组中所有相邻对的最长公共前缀的最大长度",
        "edge_case": "若无相邻对或无公共前缀，则 answer[i] = 0"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "对于任意位置 i 的删除，只影响原相邻对 (i-1, i) 和 (i, i+1)，其余相邻对保持不变",
          "可通过预处理 pre_lcp[i] = LCP(words[i], words[i+1]) 来快速重构删除后的相邻对集合",
          "删除位置 i 后的新相邻对为 (words[i-1], words[i+1])（当 i-1 和 i+1 存在时），其他 pre_lcp[j]（j ≠ i-1, i）可复用"
        ],
        "optimization_basis": "利用差分思想：每次删除的影响是局部的 O(1) 范围更新，避免重新计算整个数组"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_size",
            "value_range": "n ∈ [1, 1e5], 单词总长 ≤ 1e5",
            "can_scale": true
          },
          {
            "name": "input_structure",
            "options": [
              "linear array",
              "circular array (变形)"
            ],
            "default": "linear array"
          },
          {
            "name": "objective_variation",
            "options": [
              "max(LCP)",
              "sum of all LCPs",
              "number of adjacent pairs with LCP > 0",
              "longest consecutive segment with shared prefix"
            ],
            "default": "max(LCP)"
          },
          {
            "name": "constraint_variation",
            "options": [
              "允许重复删除多个位置",
              "在线查询：动态增删单词后询问",
              "加入后缀而非前缀",
              "要求输出具体前缀字符串而非长度"
            ]
          },
          {
            "name": "alphabet_type",
            "options": [
              "lowercase English",
              "Unicode",
              "digit strings"
            ],
            "default": "lowercase English"
          },
          {
            "name": "multi_query",
            "description": "是否多组输入 / 批量处理",
            "possible": true
          }
        ]
      }
    }
  },
  {
    "title": "Unique 3-Digit Even Numbers",
    "slug": "unique-3-digit-even-numbers",
    "schema": {
      "Input Structure": [
        "一维数组 digits[1..n]",
        "digits[i] ∈ {0,1,...,9}",
        "3 <= n <= 10",
        "数字可重复出现",
        "每个数字只能使用一次（按频次限制）"
      ],
      "Core Constraint": [
        "三位偶数需满足：末位为偶数（0,2,4,6,8）",
        "百位不能为0（无前导零）",
        "构成的三位数由三个不同位置的数字组成，但允许重复数值（依赖频次而非索引）",
        "组合过程中受数字可用频次约束（多重集合排列）"
      ],
      "Objective Function": "计数 - 求能构成的不同三位偶数的总数",
      "Algorithmic Invariant": [
        "枚举所有可能的三位偶数候选时，可通过枚举末位（偶数）→ 百位（非零且不冲突）→ 十位（剩余）的方式进行系统性构造",
        "使用频次计数代替索引选择，避免重复枚举相同数字组合",
        "一旦确定某数字在个位、十位、百位上的合法分配且频次足够，则该组合有效且唯一",
        "通过哈希表或排序+剪枝可保证结果去重"
      ],
      "Transformable Parameters": {
        "n 的数量级": "3 <= n <= 10 → 可扩展至更大（如支持更多位数）",
        "值域": "digits[i] ∈ [0,9] → 可变为任意整数范围或限定子集",
        "是否有序": "输入无序 → 可设计为有序输入以优化搜索",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "目标函数变体": [
          "改为求最大/最小三位偶数（最值问题）",
          "判断是否存在至少一个三位偶数（判定问题）",
          "构造所有可行解（构造方案）"
        ],
        "约束条件变形": [
          "允许前导零（改变百位约束）",
          "要求四位偶数（维度提升）",
          "要求被某数整除（如被6整除：同时是偶数且数位和被3整除）",
          "加入数字使用顺序限制（如必须递增选取）"
        ],
        "数据流化": "当前为离线一次性输入 → 可改造为动态添加数字并查询当前可形成多少三位偶数（在线查询）"
      }
    }
  },
  {
    "title": "Longest Special Path II",
    "slug": "longest-special-path-ii",
    "schema": {
      "Input Structure": {
        "type": "Tree",
        "representation": "Undirected tree with n nodes (0 to n-1), represented by edges array",
        "edges": {
          "dimension": "2D array of size (n-1) x 3",
          "element": "[u_i, v_i, length_i] representing an undirected edge between u_i and v_i with weight length_i"
        },
        "values": {
          "nums": "1D integer array of size n, nums[i] is the value assigned to node i"
        },
        "root": "Node 0 is designated as the root",
        "constraints": {
          "n_range": "2 <= n <= 5 * 10^4",
          "length_range": "1 <= length_i <= 10^3",
          "nums_value_range": "0 <= nums[i] <= 5 * 10^4"
        }
      },
      "Core Constraint": {
        "path_type": "Downward path from ancestor to descendant (simple root-to-leaf or internal downward path)",
        "uniqueness_condition": "All node values on the path must be unique, except for at most one value that may appear exactly twice",
        "structural_dependency": "Path validity depends on both tree topology and value frequency along the path"
      },
      "Objective Function": {
        "primary": "Maximize total edge length of valid special paths",
        "secondary": "Among all longest (maximum-length) special paths, minimize the number of nodes (vertices) in the path"
      },
      "Algorithmic Invariant": {
        "DFS_based_invariance": "During post-order traversal, maintain state of value occurrences from root to current node",
        "state_compression": "Use bitmask or hash-based path state tracking if value range permits; otherwise use stack-managed frequency map",
        "merge_condition": "When combining two child downward paths via current node, ensure combined path still satisfies 'at most one duplicate value' constraint",
        "optimal_substructure": "The longest special path in subtree rooted at u either lies entirely within a child subtree, or passes through u and merges two downward paths from children while satisfying constraints"
      },
      "Transformable Parameters": {
        "value_domain": "Can vary: small range (enables bit masks) vs large range (requires hashing)",
        "duplicate_limit": "Generalizable to 'at most k repeated values' (k=1 here)",
        "path_direction": "Currently downward only; can be extended to arbitrary simple paths (non-rooted)",
        "input_form": "Static offline input; could be adapted to dynamic tree updates (edge/node changes)",
        "output_requirements": [
          "Return only max length",
          "Return count of longest paths",
          "Return actual path(s)",
          "Multi-objective: (length, node_count) as lexicographic key"
        ],
        "tree_type": "From rooted unordered tree to binary tree or DAG extension",
        "online_query": "Support queries for different roots or value arrays"
      }
    }
  },
  {
    "title": "Design Spreadsheet",
    "slug": "design-spreadsheet",
    "schema": {
      "Input Structure": [
        "二维网格结构：26 列（'A' 到 'Z'），行数为 rows（1 ≤ rows ≤ 10^3）",
        "每个单元格存储一个整数值，初始为 0，值域 [0, 10^5]",
        "支持三种操作：setCell(cell, value), resetCell(cell), getValue(formula)",
        "formula 格式固定为 \"=X+Y\"，其中 X 和 Y 是单元格引用或非负整数"
      ],
      "Core Constraint": [
        "单元格值在未显式设置时默认为 0",
        "公式仅包含两个操作数的加法，无嵌套或复杂表达式",
        "所有操作均在线进行，需即时响应查询",
        "列范围固定，行号受限于初始化参数 rows"
      ],
      "Objective Function": [
        "实现电子表格的基本状态维护与即时计算功能",
        "对 getValue 操作返回公式的实时求和结果"
      ],
      "Algorithmic Invariant": [
        "单元格状态映射保持一致性：未设置的单元格视为 0",
        "公式解析过程可分解为独立项求值后相加",
        "setCell 与 resetCell 操作直接修改底层存储，不影响其他单元格的不变性",
        "getValue 的计算不改变任何单元格状态（纯查询）"
      ],
      "Transformable Parameters": {
        "rows": "可变规模：1 ≤ rows ≤ 10^3 → 可扩展至更大规模或动态扩容",
        "columns": "列数是否可变：当前固定为 26 → 可改为任意列数或支持 'AA' 类扩展命名",
        "formula_structure": "公式结构是否可变：当前为二元加法 → 可扩展为多元、带括号、多种运算符",
        "value_range": "值域 [0, 10^5] → 可支持负数、浮点数或大整数",
        "operations": "操作类型：当前为 set/reset/get → 可增加批量操作、撤销机制",
        "evaluation_mode": "计算模式：当前为立即求值 → 可变为延迟求值或依赖追踪（如单元格变更触发重算）",
        "call_count": "总调用次数上限 10^4 → 可调整以测试性能边界",
        "online_processing": "是否在线：当前是 → 可设计离线批处理版本"
      }
    }
  },
  {
    "title": "Longest Common Prefix After at Most One Removal",
    "slug": "longest-common-prefix-after-at-most-one-removal",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右边界约束可分离但需全局一致",
        "determination_condition": "若某侧的最大值小于另一侧，则该侧当前位置的积水可立即确定"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": "双指针推进过程中维护左右已遍历部分的最大值",
        "rules": [
          "维护两个指针 L = 0, R = n - 1",
          "维护 maxLeft 表示左指针左侧的最大高度",
          "维护 maxRight 表示右指针右侧的最大高度",
          "若 maxLeft ≤ maxRight，则 L 处的积水由 maxLeft 决定，L 可前移",
          "否则 R 处的积水由 maxRight 决定，R 可后移",
          "每次移动不会破坏未访问区间的最优性，且已处理区域的贡献正确"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_range",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "default": "non-negative"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D",
              "circular_1D"
            ],
            "default": "1D"
          },
          {
            "name": "data_mode",
            "options": [
              "offline_batch",
              "online_streaming",
              "dynamic_update"
            ],
            "default": "offline_batch"
          },
          {
            "name": "output_type",
            "options": [
              "total_sum",
              "per_position_contribution",
              "maximum_single_container"
            ],
            "default": "total_sum"
          },
          {
            "name": "query_type",
            "options": [
              "single_query",
              "multiple_queries",
              "range_query"
            ],
            "default": "single_query"
          },
          {
            "name": "constraints_variation",
            "options": [
              "unconstrained",
              "with_capacity_limit_K",
              "with_flow_direction"
            ],
            "default": "unconstrained"
          },
          {
            "name": "array_property",
            "options": [
              "unordered",
              "sorted",
              "partially_monotonic"
            ],
            "default": "unordered"
          }
        ]
      }
    }
  },
  {
    "title": "Zero Array Transformation IV",
    "slug": "zero-array-transformation-iv",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1], 其中 n >= 1",
        "二维查询数组 queries, 每个元素为 [l_i, r_i, val_i]",
        "nums[i] ∈ [0, 1000]",
        "queries.length <= 1000",
        "每个 val_i ∈ [1, 10]",
        "l_i, r_i 满足 0 <= l_i <= r_i < n"
      ],
      "Core Constraint": [
        "每次查询只能对区间 [l_i, r_i] 内的任意下标子集执行减法操作，且每个选中的位置必须恰好减去 val_i",
        "不能使任何位置的值变为负数",
        "操作必须按 queries 的顺序依次执行",
        "目标是判断是否存在一个前缀 k，使得经过前 k 个查询后 nums 变为零数组"
      ],
      "Objective Function": "求最小非负整数 k，使得执行前 k 个查询（按顺序）后，nums 可变为零数组；若不存在则返回 -1",
      "Algorithmic Invariant": [
        "贪心可解性：对于每个位置 i，其总减量必须等于 nums[i]，且所有覆盖该位置的查询贡献之和必须恰好等于 nums[i]",
        "可行性约束：每个查询 j 对位置 i 的减量只能是 0 或 val_j（不可拆分），因此每个位置的减量组合必须由若干完整的 val_j 构成",
        "单调性：一旦某个位置变为负数，则当前 k 不可行；k 增大时操作集合增加，但顺序不可逆",
        "局部决策依赖全局匹配：每个位置的减量需求需被其所处区间的查询精确覆盖"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 <= n <= 10 (当前小规模，可枚举或状态压缩)",
          "queries.length": "1 <= m <= 1000",
          "val_i_range": "[1,10]"
        },
        "输入形式": {
          "是否有序": false,
          "是否循环": false,
          "是否多组数据": false,
          "是否在线": false
        },
        "约束变化": [
          "val_i 是否允许大于 nums[i] → 当前不允许（会导致负数）",
          "是否允许部分应用 val_i（如只减 val_i 的一半）→ 当前不允许，必须全用或不用",
          "是否允许多次使用同一查询 → 当前不允许，每个查询最多用一次且顺序固定"
        ],
        "输出形式变化": [
          "返回具体方案（哪些下标在哪个查询中被选中）",
          "返回所有可行的最小 k 集合",
          "判定是否存在 k 而不求最小值"
        ],
        "扩展方向": [
          "二维数组上的区域减操作",
          "支持删除/插入查询的动态版本",
          "在线模式：逐个接收查询并实时判断是否可达零数组"
        ]
      }
    }
  },
  {
    "title": "Find the Minimum Amount of Time to Brew Potions",
    "slug": "find-the-minimum-amount-of-time-to-brew-potions",
    "schema": {
      "Input Structure": [
        "一维整数数组 skill[1..n], 表示 n 个巫师的技能值",
        "一维整数数组 mana[1..m], 表示 m 个药水的法力值",
        "处理时间定义为 time[i][j] = skill[i] * mana[j]",
        "n, m ≥ 1, 值域 [1, 5000]"
      ],
      "Core Constraint": [
        "每个药水必须按顺序依次通过所有巫师处理",
        "药水在前一个巫师完成处理后必须立即传递给下一个巫师，即处理不能中断或延迟",
        "第 j 个药水只能在第 j-1 个药水被第一个巫师开始处理之后才能开始（顺序入队）",
        "每个巫师同一时间只能处理一个药水，形成流水线阻塞约束",
        "总时间由最后一个巫师完成最后一个药水的时间决定"
      ],
      "Objective Function": "最小化酿造所有药水所需的总时间（即最后一个事件的完成时间）",
      "Algorithmic Invariant": [
        "时间演化具有动态规划结构：令 dp[i][j] 表示第 i 个巫师完成第 j 个药水的最晚完成时间",
        "状态转移满足：dp[i][j] = max(dp[i][j-1], dp[i-1][j]) + skill[i] * mana[j]",
        "初始条件：dp[0][j] = sum_{k=0}^{j} skill[0] * mana[k]",
        "边界条件：dp[i][0] = dp[i-1][0] + skill[i] * mana[0]",
        "状态单调递增性：dp[i][j] 随 i 和 j 单调不减",
        "最优子结构：全局最优依赖于局部完成时间的最大值与当前任务的叠加"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 的数量级": "可变范围：小规模 (≤100), 中等 (≤5000), 大规模 (>1e5)",
          "值域变化": "skill[i], mana[j] 是否允许为 0 或负数"
        },
        "输入形式": [
          "是否有序（如 skill/mana 是否已排序）",
          "是否多组测试用例",
          "是否在线输入（药水逐个到达，需实时决策）"
        ],
        "约束变形": [
          "是否允许跳过某些巫师",
          "是否允许多线程并行处理（打破顺序依赖）",
          "是否存在冷却时间或传输延迟",
          "是否限制最大等待时间"
        ],
        "目标函数变换": [
          "求最小最大完成时间（原题）",
          "改为计数满足时间 ≤ T 的方案数",
          "改为判定是否存在调度使得总时间 ≤ K",
          "输出完整调度表而非仅总时间"
        ],
        "结构扩展": [
          "从线性流水线 → 树状依赖图（DAG）",
          "从一维数组 → 二维网格上的技能矩阵",
          "引入资源竞争（多个实验室共享巫师）"
        ]
      }
    }
  },
  {
    "title": "Longest Palindrome After Substring Concatenation I",
    "slug": "longest-palindrome-after-substring-concatenation-i",
    "schema": {
      "Input Structure": [
        "两个字符串 s[1..n] 和 t[1..m]",
        "s 和 t 均为小写英文字母组成的字符串",
        "1 <= n, m <= 30"
      ],
      "Core Constraint": [
        "回文串由 s 的一个子串和 t 的一个子串按顺序拼接而成",
        "拼接后的字符串需满足回文性质：正读与反读相同",
        "回文结构可分解为前缀来自 s、后缀来自 t，且整体对称",
        "最长回文可能完全来自 s 或 t 的内部回文，或跨串边界匹配"
      ],
      "Objective Function": "求所有可能拼接方式中，能构造出的最长回文串的长度（最大化）",
      "Algorithmic Invariant": [
        "若拼接串 s[i..j] + t[k..l] 是回文，则其首尾字符必须相等，并向中心对称扩展",
        "对于任意固定拼接点，最长回文长度可通过枚举中心并尝试向外匹配得到",
        "可以枚举所有 s 的后缀与 t 的前缀的最长回文匹配长度",
        "单独考虑 s 或 t 内部最长回文作为候选解（空另一串）",
        "状态可分解为：枚举中间分割位置，利用双串前后缀匹配更新最大值"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 的数量级": [
            "<= 30 → 可暴力枚举",
            "可扩展至 <= 1000 → 需优化DP",
            "更大则需滚动哈希"
          ]
        },
        "字符串性质": [
          "是否仅小写字母",
          "是否允许空串",
          "是否有序/可重排（变形题）"
        ],
        "输入形式": [
          "是否多组数据",
          "是否在线输入 s 和 t",
          "是否支持动态修改字符"
        ],
        "目标函数变化": [
          "改为计数：有多少种不同回文串可构造",
          "改为判定：是否存在长度 ≥ K 的回文串",
          "输出字典序最小的最长回文串（构造型）"
        ],
        "约束变换": [
          "限制必须非空子串",
          "限制拼接顺序（如必须 s 在前）",
          "允许多次拼接（>2 段）→ 更复杂结构",
          "加入字符使用次数限制"
        ],
        "结构扩展": [
          "从两串拼接 → 多串按序拼接",
          "二维字符串网格中选路径拼接",
          "环形字符串"
        ]
      }
    }
  },
  {
    "title": "Find Invalid IP Addresses",
    "slug": "find-invalid-ip-addresses",
    "schema": {
      "Input Structure": [
        "表 logs，包含字段：log_id (int), ip (varchar), status_code (int)",
        "ip 字段为字符串类型，表示 IPv4 地址格式的候选字符串",
        "每个 ip 应由 4 个以 '.' 分隔的字节（每段为数字）组成"
      ],
      "Core Constraint": [
        "一个有效的 IPv4 地址必须满足：",
        "1. 恰好包含 4 个字节（即被 '.' 分割为 4 段）",
        "2. 每个字节是 [0, 255] 范围内的整数",
        "3. 每个字节不能有前导零（即 '0' 是合法的，但 '01', '001' 等非法）",
        "4. 只能包含数字和 '.'，且格式正确（无连续点、不以点开头或结尾）"
      ],
      "Objective Function": [
        "识别所有无效的 IP 地址",
        "对每个无效 IP 统计其在日志中出现的次数（计数型目标）",
        "输出结果按 invalid_count 降序排序；若相同，则按 ip 字符串降序排序"
      ],
      "Algorithmic Invariant": [
        "IP 合法性判断规则是确定性的且可逐段验证：",
        "- 分割后段数必须为 4 → 全局结构约束",
        "- 每段可独立判断是否为有效整数（无非数字字符）",
        "- 整数值 ∈ [0, 255]",
        "- 无前导零：若长度 > 1，则不能以 '0' 开头",
        "计数过程满足映射叠加不变性：重复 IP 的判定结果一致，可累加"
      ],
      "Transformable Parameters": {
        "IP 版本": {
          "可变": true,
          "选项": [
            "IPv4",
            "IPv6（扩展题）"
          ]
        },
        "数据规模": {
          "n 的数量级": [
            "10^3",
            "10^5",
            "10^7"
          ],
          "是否大数据量下需要流式处理": false
        },
        "输入形式": {
          "单表输入": true,
          "是否多组测试数据": true,
          "是否在线输入（逐条插入）": false
        },
        "输出要求": {
          "是否仅返回 top-k 无效 IP": false,
          "是否返回每条记录的判定原因": false,
          "排序方式": [
            "invalid_count ↓ + ip ↓",
            "可改为 ↑ 或复合键"
          ]
        },
        "校验规则灵活性": {
          "前导零定义": [
            "严格禁止（如 01）",
            "允许科学计数法风格（不可）"
          ],
          "边界值处理": [
            "255 允许，256 不允许"
          ],
          "空段或乱序分隔符": [
            "视为非法"
          ]
        },
        "扩展能力": {
          "是否支持通配符或掩码匹配": false,
          "是否加入状态码过滤条件（如只查 4xx 请求中的无效 IP）": true
        }
      }
    }
  },
  {
    "title": "Fruits Into Baskets III",
    "slug": "fruits-into-baskets-iii",
    "schema": {
      "Input Structure": [
        "长度为 n 的整数数组 fruits[1..n]",
        "长度为 n 的整数数组 baskets[1..n]",
        "fruits[i] ≥ 1, 表示第 i 种水果的数量",
        "baskets[j] ≥ 1, 表示第 j 个篮子的容量",
        "n ∈ [1, 10^5]"
      ],
      "Core Constraint": [
        "每种水果必须按数组顺序从左到右尝试放置（顺序依赖）",
        "每种水果只能放入第一个容量 ≥ 其数量的最左侧可用篮子（贪心定位）",
        "每个篮子最多容纳一种水果（一对一约束）",
        "一旦某个水果被分配，对应篮子即被占用，后续不可再用"
      ],
      "Objective Function": "计数：返回未能成功放置的水果种类数量（即未匹配的 fruits 元素个数）",
      "Algorithmic Invariant": [
        "遍历 fruits 数组时，维护一个可动态查询最小满足条件篮子的数据结构",
        "篮子使用状态具有单调性：一旦使用，不再参与后续匹配",
        "对于当前水果，在未使用的篮子中选择索引最小且容量足够的篮子，该决策不会影响更优解的存在性（局部最优即全局最优）",
        "可通过排序 + 贪心或优先队列模拟实现不变量"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1 <= n <= 10^5",
            "可调整至 n <= 1000（暴力可过）或 n <= 10^6（需优化）"
          ]
        },
        "值域": {
          "fruits[i], baskets[j]": [
            "[1, 10^9]",
            "可改为 [1, 100] 或允许 0 值"
          ]
        },
        "输入顺序约束": [
          "是否必须按 fruits 顺序处理（强顺序）",
          "可变体：是否允许重排 fruits 以最大化/最小化未放置数"
        ],
        "篮子复用规则": [
          "当前为单水果单篮子",
          "变形：一个篮子可放多种水果（总容量限制）"
        ],
        "匹配策略": [
          "当前策略：最左满足篮子",
          "可变换为：任意满足篮子（判定可行性）",
          "或：最优匹配（最小浪费）"
        ],
        "输出形式": [
          "当前：未放置水果种类数",
          "可变为：具体哪些水果未放置 / 最大连续放置长度 / 是否能全放下（判定）"
        ],
        "多组数据": "是否支持多组测试用例输入",
        "在线性": "是否支持动态添加水果或篮子（流式输入）"
      }
    }
  },
  {
    "title": "Fruits Into Baskets II",
    "slug": "fruits-into-baskets-ii",
    "schema": {
      "Input Structure": {
        "fruits": "一维数组 fruits[1..n]，其中 fruits[i] 表示第 i 种水果的数量，fruits[i] ≥ 1",
        "baskets": "一维数组 baskets[1..n]，其中 baskets[j] 表示第 j 个篮子的容量，baskets[j] ≥ 1",
        "constraints": [
          "n == fruits.length == baskets.length",
          "1 <= n <= 100",
          "1 <= fruits[i], baskets[i] <= 1000"
        ]
      },
      "Core Constraint": {
        "assignment_rule": "每种水果必须从左到右依次分配，放入第一个容量大于等于该水果数量的最左侧可用篮子",
        "uniqueness": "每个篮子只能装一种水果（一旦使用即不可再用）",
        "irrevocable": "分配过程是贪心且不可回溯的：当前水果若无法放入后续篮子则永久未放置"
      },
      "Objective Function": "计数 —— 返回在给定分配规则下，未能被放置的水果种类的数量",
      "Algorithmic Invariant": {
        "greedy_feasibility": "对于当前水果 i，只要存在一个尚未使用的篮子 j 满足 baskets[j] >= fruits[i]，且 j 是最左侧满足条件的，则将水果 i 放入篮子 j 是局部最优选择",
        "monotonic_availability": "篮子的可用性随遍历递减（一旦使用即标记为不可用），且由于分配顺序固定，已跳过的篮子不会在未来变得‘更优’",
        "leftmost_priority_preserved": "‘最左侧可用’策略保证了每个水果的决策仅依赖于当前状态，无需回溯或全局重排"
      },
      "Transformable Parameters": {
        "data_scale": {
          "n_range": "1 <= n <= 100 (当前); 可扩展至 1e5（需优化解法）",
          "value_range": "fruits[i], baskets[i] ∈ [1, 1000]; 可扩大至 1e9"
        },
        "input_form": {
          "ordering": "fruits 必须按给定顺序处理；可变体：是否允许重排 fruits 以最大化/最小化未放置数",
          "baskets_sorted": "当前 baskets 无序；可变体：baskets 是否预先排序（升序/降序）"
        },
        "assignment_rules": {
          "placement_policy": "当前为‘首个满足条件的最左篮子’；可变体：改为任意满足条件篮子（判定问题）、或最大剩余容量优先（模拟贪心差异）",
          "reusability": "当前篮子不可重用；可变体：允许多种水果共存于同一篮子（变为背包类问题）"
        },
        "output_form": {
          "objective_variation": [
            "计数未放置种类（当前）",
            "最小化未放置数（通过重排 fruits）",
            "构造具体分配方案",
            "判定是否所有水果均可放置"
          ]
        },
        "query_mode": {
          "offline": "一次性输入（当前）",
          "online": "动态添加水果或篮子，支持插入/删除操作的在线版本"
        },
        "constraint_modification": {
          "capacity_condition": "当前为 ≥ fruits[i]；可反转为 ≤ fruits[i]（小篮装大果？用于异常检测场景）",
          "flexible_assignment": "引入代价函数：放入非最左可行篮子需支付代价"
        }
      }
    }
  },
  {
    "title": "Maximize Subarrays After Removing One Conflicting Pair",
    "slug": "maximize-subarrays-after-removing-one-conflicting-pair",
    "schema": {
      "Input Structure": {
        "nums": "一维有序数组 nums[1..n]，包含从 1 到 n 的连续整数",
        "conflictingPairs": "二维数组 conflictingPairs，每个元素为 [a, b]，表示一对冲突整数",
        "constraints": [
          "2 <= n <= 10^5",
          "1 <= len(conflictingPairs) <= 2 * n",
          "1 <= a, b <= n 且 a != b",
          "nums 是严格递增的顺序数组"
        ]
      },
      "Core Constraint": {
        "conflict_rule": "任意子数组若同时包含某个未被删除的冲突对 [a, b] 中的 a 和 b，则该子数组非法",
        "deletion_constraint": "必须恰好删除一个冲突对，其余冲突对全部生效",
        "structure_implication": "由于 nums 是有序排列，子数组对应区间 [i, j]，其合法性取决于是否包含任一剩余冲突对的两个端点"
      },
      "Objective Function": "最大化删除恰好一个冲突对后，所有不包含任何剩余冲突对的非空连续子数组的数量",
      "Algorithmic Invariant": {
        "invariant_1": "子数组总数在无冲突时为 n*(n+1)/2，每增加一组有效冲突会减少某些区间的合法性",
        "invariant_2": "一个冲突对 [a, b]（假设 a < b）会禁用所有同时包含 a 和 b 的子数组，即左端点 ≤ a 且右端点 ≥ b 的区间",
        "invariant_3": "删除某一个冲突对 k 后，合法子数组数量 = 总子数组数 - 被剩余每个冲突对单独排除的区间并集",
        "invariant_4": "可通过预处理每个冲突对所‘覆盖’的区间数量（即包含其两端点的子数组个数），结合容斥或独立统计来高效计算",
        "invariant_5": "最优解必然出现在删除某个 conflictingPairs[i] 后，枚举每个可能的删除项可得最大值"
      },
      "Transformable Parameters": {
        "n_scale": "n 的数量级：可变范围 [2, 10^5] → 可扩展至更高（如带权版本）或更低（暴力枚举）",
        "conflict_density": "conflictingPairs 长度上限为 2*n，稀疏结构 → 可改为稠密图或树形依赖",
        "deletion_count": "是否允许删除多个冲突对（如最多 k 个）→ 变为 DP 或贪心选择问题",
        "input_ordering": "nums 是否保持有序 → 若打乱则问题变为图约束下的路径计数",
        "conflict_type": "冲突对是显式给出还是隐式定义（如质因数相关、距离约束等）",
        "online_query": "是否支持在线添加/删除冲突对 → 动态数据结构需求",
        "output_form": "返回最大数量 / 返回具体方案 / 返回所有可行删除项",
        "multi_group_input": "是否有多组测试用例 → 影响预处理策略与复杂度容忍度"
      }
    }
  },
  {
    "title": "Maximum Unique Subarray Sum After Deletion",
    "slug": "maximum-unique-subarray-sum-after-deletion",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "1 <= n <= 100",
        "-100 <= nums[i] <= 100",
        "数组可包含负数、零和重复元素",
        "子数组必须是非空连续序列"
      ],
      "Core Constraint": [
        "所选子数组中的所有元素必须互不相同（无重复值）",
        "删除操作可在任意位置进行，但最终保留的子数组必须是原数组中某个连续非空段",
        "不能将数组删为空，至少保留一个元素"
      ],
      "Objective Function": "最大化满足‘元素互不相同’条件的子数组的元素和",
      "Algorithmic Invariant": [
        "使用滑动窗口维护当前无重复元素的区间 [l, r]",
        "右端点 r 扩展时，通过哈希集合记录当前窗口内的元素以检测重复",
        "当出现重复时，左端点 l 持续收缩直到重复元素被移除",
        "在每一步合法状态下更新最大元素和，贪心维护全局最优解",
        "由于允许负数，不能仅靠最长子数组，必须枚举所有有效子数组并比较其和"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的范围：可扩展至 1e5（需优化），当前为 100",
        "值域": "nums[i] 是否全为正数 / 非负 / 可负",
        "是否允许空子数组": "约束条件可改为允许空数组（和为 0）或强制非空",
        "唯一性约束强度": "从‘完全互异’变为‘至多 k 次重复’（k > 1）",
        "输入形式": "是否多组测试用例 / 在线查询模式",
        "操作类型扩展": "是否支持动态修改数组元素 / 插入删除",
        "目标变换": "从最大和 → 最长长度 / 方案计数",
        "维度扩展": "从 1D 数组 → 环形数组 / 树上路径选取"
      }
    }
  },
  {
    "title": "Maximum Students on a Single Bench",
    "slug": "maximum-students-on-a-single-bench",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "一维数组 height[0..n-1]，表示 n 个非负整数的高度柱子"
      },
      "Core Constraint": {
        "constraint": "每个位置的盛水能力由其左右两侧最高柱子的最小值决定",
        "independence": "左右边界约束可分离但需全局一致",
        "local_global_link": "局部容量依赖于全局最大值信息"
      },
      "Objective Function": {
        "goal": "sum",
        "target": "total trapped rainwater",
        "type": "counting",
        "output_single_value": true
      },
      "Algorithmic Invariant": {
        "technique": "two-pointers",
        "invariants": [
          "维护 left 和 right 指针，分别从两端向中间移动",
          "维护 maxLeft 表示 left 左侧的最大高度",
          "维护 maxRight 表示 right 右侧的最大高度",
          "若 maxLeft ≤ maxRight，则当前位置 left 的积水可确定，left++",
          "否则，right 位置的积水可确定，right--",
          "指针移动过程中不破坏已计算区域的正确性"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_range",
            "options": [
              "non-negative",
              "allow-negative-heights"
            ],
            "default": "non-negative"
          },
          {
            "name": "dimension",
            "options": [
              "1D",
              "2D",
              "circular-array"
            ],
            "default": "1D"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online-streaming",
              "dynamic-updates"
            ],
            "default": "offline"
          },
          {
            "name": "output_granularity",
            "options": [
              "total_sum",
              "per_position_contribution"
            ],
            "default": "total_sum"
          },
          {
            "name": "constraints_variation",
            "options": [
              "standard_trapping",
              "volume_with_obstacles",
              "flow_simulation"
            ],
            "default": "standard_trapping"
          },
          {
            "name": "multiple_queries",
            "type": "boolean",
            "description": "是否支持多次查询下的预处理结构（如RMQ）",
            "default": false
          }
        ]
      }
    }
  },
  {
    "title": "Longest Palindromic Subsequence After at Most K Operations",
    "slug": "longest-palindromic-subsequence-after-at-most-k-operations",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "给定一个长度为 n 的字符串 s，仅由小写英文字母组成",
        "length_constraint": "1 <= n <= 200",
        "value_domain": "s[i] ∈ {'a'..'z'}"
      },
      "Core Constraint": {
        "operation_definition": "每次操作可将任意位置字符替换为字母表中相邻字符（循环：'z' ↔ 'a'）",
        "operation_cost": "每个字符最多可被修改若干次，总操作次数不超过 k",
        "subsequence_property": "结果子序列必须保持原字符相对顺序",
        "palindrome_requirement": "目标是构造一个回文子序列，其字符可通过操作变得对称"
      },
      "Objective Function": {
        "goal": "最大化回文子序列的长度",
        "optimization_type": "最大值",
        "feasibility_condition": "在最多 k 次字符变换下可达"
      },
      "Algorithmic Invariant": {
        "dp_state_invariance": "对于区间 [i, j]，若两端字符可通过若干代价变为相同，则该对字符可作为回文对参与构成更长回文",
        "cost_monotonicity": "使 s[i] 和 s[j] 相等的最小操作次数是确定且可预计算的（考虑循环距离）",
        "interval_expansion_rule": "最优解可通过枚举中心或区间动态规划逐步扩展：f[i][j] 表示子串 s[i..j] 中能形成的最长可变回文子序列长度",
        "state_preservation": "已匹配的外层字符对不会影响内层决策；状态转移具有最优子结构性质"
      },
      "Transformable Parameters": {
        "n_value_range": "[1, 200]",
        "k_value_range": "[1, 200]",
        "character_set": "是否扩展至大写字母或多语言字符集",
        "operation_rules": [
          "非循环字母表（如 'a' 无前驱，'z' 无后继）",
          "允许批量修改或限制每字符最多修改次数"
        ],
        "input_form": {
          "single_query": true,
          "multi_case_input": false,
          "online_queries": false
        },
        "output_form": [
          "仅返回最大长度",
          "要求输出具体子序列方案",
          "要求输出操作步骤"
        ],
        "constraint_variants": [
          "改为最少操作次数以形成长度为 L 的回文子序列（目标函数变换）",
          "限定子序列必须连续（即变为回文子串问题）",
          "二维情形：字符矩阵中的最长可变回文子序列"
        ],
        "data_streaming": false
      }
    }
  },
  {
    "title": "Find the Number of Copy Arrays",
    "slug": "find-the-number-of-copy-arrays",
    "schema": {
      "Input Structure": [
        "一维数组 original[1..n]，其中 n >= 2",
        "二维数组 bounds[0..n-1][2]，每个 bounds[i] = [u_i, v_i] 表示 copy[i] 的取值范围",
        "original[i] ∈ [1, 1e9], bounds[i][0] <= bounds[i][1] ∈ [1, 1e9]",
        "数据规模：2 <= n <= 1e5"
      ],
      "Core Constraint": [
        "copy 数组必须与 original 具有相同的相邻差分序列：即对所有 1 <= i <= n-1，有 copy[i] - copy[i-1] = original[i] - original[i-1]",
        "这意味着 copy 完全由其首项 copy[0] 决定",
        "因此问题转化为：求满足所有位置 i 上 u_i <= copy[i] <= v_i 的初值 copy[0] 的个数"
      ],
      "Objective Function": "计数 —— 统计满足条件的合法数组 copy 的总数（等价于合法的 copy[0] 的取值个数）",
      "Algorithmic Invariant": [
        "差分不变性：整个 copy 序列由 copy[0] 唯一确定，且 copy[i] = copy[0] + (original[i] - original[0])",
        "每个位置的约束可转换为对 copy[0] 的线性不等式：u_i <= copy[0] + (original[i] - original[0]) <= v_i",
        "所有约束合并为关于 copy[0] 的区间交集问题：求满足所有 i 的 [L_i, R_i] 的公共整数点个数",
        "最终解空间是若干区间的交集，具有单调可合并性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "当前为 1e5，可改为小规模（如 n <= 20）用于 DP 改编或大规模式在线处理",
        "值域范围": "当前为 1e9，可压缩至 1e5 以支持离散化或扩展为负数域",
        "original 是否有序": "当前任意，可限定为单调/周期序列以引入额外结构",
        "bounds 是否动态": "当前静态离线输入，可改为在线更新某个 bound[i]",
        "是否多组数据": "当前单组，可扩展为 T 组测试用例",
        "目标函数变化": [
          "判定是否存在解（布尔型）",
          "最大化 / 最小化 copy[0] 或 copy[n-1]",
          "输出所有方案（构造题）"
        ],
        "差分约束变化": "可推广为更一般的线性递推关系（如二阶差分固定），进入 DP 范畴",
        "维度扩展": "可设计二维网格上差分传播问题（中间层母题）"
      }
    }
  },
  {
    "title": "Longest Common Prefix of K Strings After Removal",
    "slug": "longest-common-prefix-of-k-strings-after-removal",
    "schema": {
      "Input Structure": [
        "字符串数组 words[0..n-1], 其中 n = words.length",
        "每个字符串 words[i] 由小写英文字母组成，长度 ≥ 1",
        "整数 k，满足 1 <= k <= n <= 10^5",
        "所有字符串长度总和 ≤ 10^5"
      ],
      "Core Constraint": [
        "对每个下标 i，在移除 words[i] 后的剩余数组中，需从至少 k 个不同下标中选出 k 个字符串",
        "最长公共前缀（LCP）仅由所选字符串共同拥有的起始字符段决定",
        "若剩余字符串数量 < k，则 answer[i] = 0",
        "LCP 长度受限于最短字符串长度及字符逐位匹配情况"
      ],
      "Objective Function": [
        "对每个 i ∈ [0, n-1]，计算在删除 words[i] 后的数组中，任选 k 个不同字符串所能得到的最长公共前缀的长度",
        "目标函数为：最大化所选 k 个字符串的 LCP 长度",
        "输出为长度数组 answer，answer[i] 表示对应下标的最优结果"
      ],
      "Algorithmic Invariant": [
        "对于任意位置 i 的删除操作，问题独立且可离线处理：answer[i] 仅依赖于 words 中除 i 外的元素",
        "LCP 长度具有单调性：增加更多字符串不会延长 LCP，但可能通过更优组合提升",
        "可通过预处理所有字符串的 Trie 结构加速公共前缀查询",
        "枚举候选组时，相同字符串多次出现可合并考虑（频次 ≥ k 可直接取自身 LCP）",
        "答案上界受最长字符串与字符一致性约束限制"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前 ≤ 10^5，可调整至更小规模用于教学或更大规模引入在线结构",
        "k 的取值范围：可变为变量、或多组查询（如多个 k 值）",
        "是否允许重复字符串：当前允许，可改为去重约束",
        "输入形式：可改为动态添加/删除字符串（支持修改操作）",
        "是否在线：当前为一次性输入，可扩展为流式输入并维护实时 answer 数组",
        "输出形式：当前输出长度数组，可改为输出具体字符串组合或 LCP 字符串本身",
        "字符集类型：当前为小写英文，可推广至大写、数字或 Unicode",
        "约束反转：目标函数由 '最大 LCP 长度' 改为 '至少达到某长度的方案数'（计数型）",
        "结构维度变换：从一维字符串数组扩展到二维字符矩阵，求子矩阵公共前缀"
      ]
    }
  },
  {
    "title": "Permutations IV",
    "slug": "permutations-iv",
    "schema": {
      "Input Structure": [
        "整数 n：表示排列的长度，取值范围为 [1, 100]",
        "整数 k：表示字典序中第 k 个有效交替排列，取值范围为 [1, 1e15]",
        "排列由前 n 个正整数构成，即集合 {1, 2, ..., n}",
        "交替排列定义：任意相邻两个元素不同时为奇数或不同时为偶数"
      ],
      "Core Constraint": [
        "排列必须是交替的：相邻元素奇偶性不同",
        "所有排列基于前 n 个正整数的全排列子集生成",
        "有效排列数量受奇偶数分布限制：设 odd = ceil(n/2), even = floor(n/2)，则合法序列必须满足奇偶交替模式（以奇开头或以偶开头）",
        "字典序排序在整个有效交替排列集合上进行"
      ],
      "Objective Function": [
        "返回字典序中第 k 个交替排列",
        "若总有效交替排列数少于 k，则返回空列表"
      ],
      "Algorithmic Invariant": [
        "奇偶位置分离：可将问题分解为从奇数集和偶数集中按交替顺序构造排列",
        "字典序生成不变量：高位决定性原则 —— 高位越小，字典序越小；可通过组合计数跳过不可能包含第 k 项的分支",
        "可预计算每种起始模式（奇/偶开头）下的合法排列数，并按需展开搜索路径",
        "使用类似‘康托展开’的思想逐位确定答案中的数值，避免枚举全部排列"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 100（当前），可扩展至支持更大规模（如 n <= 1000）并要求模意义下计数",
        "k 的范围": "1 <= k <= 1e15（当前），可调整为在线查询多个 k 或强制要求 k 超出时返回特定标记",
        "是否有序输入": "固定输入 (n,k)，可变形为多组测试数据输入",
        "是否在线": "当前为离线单次查询，可改为动态修改 n 或允许流式生成第 k 项",
        "奇偶约束形式": "当前为严格交替（奇偶交替），可隐藏为图染色约束或推广为模 m 不同余约束",
        "输出形式": "返回完整排列列表，可变更为仅返回第 k 项的某个位置值或哈希值",
        "交替模式限定": "当前两种模式（奇头/偶头）均允许，可增加约束只允许某一类",
        "数据结构增强": "加入删除/插入操作形成动态交替排列维护问题"
      }
    }
  },
  {
    "title": "Find Valid Emails",
    "slug": "find-valid-emails",
    "schema": {
      "Input Structure": [
        "表 Users，包含两列：user_id (int)，email (varchar)",
        "user_id 是唯一主键",
        "每一行表示一个用户的 ID 和邮箱地址",
        "输入为静态、离线的二维表格数据"
      ],
      "Core Constraint": [
        "合法邮箱必须满足四个条件：",
        "1. 只包含一个 '@' 符号（不能缺失或多于一个）",
        "2. 以 '.com' 结尾",
        "3. '@' 前面的部分（本地名）只能包含字母、数字和下划线",
        "4. '@' 后面到 '.com' 之前的部分（域名主体）必须只包含字母字符，且不能为空"
      ],
      "Objective Function": [
        "筛选出所有满足上述邮箱格式规则的用户记录",
        "返回结果表包含 user_id 和 email",
        "按 user_id 升序排序"
      ],
      "Algorithmic Invariant": [
        "邮箱合法性判断是局部字符级模式匹配问题",
        "每个 email 字符串可独立验证，无需跨行依赖",
        "正则表达式 /^\\w+@[a-zA-Z]+\\.com$/ 能完整刻画合法条件（注意：\\w 等价 [a-zA-Z0-9_]）",
        "字符串扫描过程具有确定性状态转移：起始 → 本地名 → '@' → 域名 → '.com' 结尾"
      ],
      "Transformable Parameters": [
        "值域约束变化：允许其他顶级域名（如 .org, .net）→ 修改结尾约束",
        "增加大小写敏感要求 → 当前不敏感，可改为敏感",
        "是否允许多个 '@' 或嵌套结构 → 改变 '@' 数量约束",
        "本地名是否允许特殊字符（如 '.' 或 '-'）→ 放宽或收紧字符集",
        "是否支持国际化域名（Unicode 字符）→ 扩展字符集范围",
        "输入规模：n 的数量级（小规模 SQL 查询 vs 海量日志流实时过滤）",
        "是否在线处理：从批量查询变为流式邮箱校验服务",
        "是否多组数据：多个表或分区数据联合判断",
        "输出形式变化：仅返回 user_id / 统计合法比例 / 构造修正建议"
      ]
    }
  },
  {
    "title": "Maximize the Distance Between Points on a Square",
    "slug": "maximize-the-distance-between-points-on-a-square",
    "schema": {
      "Input Structure": [
        "正整数 side，表示正方形边长，坐标范围为 [0, side]",
        "二维整数数组 points，其中每个元素 points[i] = [x_i, y_i] 表示位于正方形边界上的一个点",
        "正整数 k，表示需要从 points 中选择的点的数量",
        "约束：所有点都在正方形边界上（即 x ∈ {0, side} 或 y ∈ {0, side}），且 4 <= points.length <= min(4 * side, 15000)，4 <= k <= min(25, points.length)"
      ],
      "Core Constraint": [
        "所选点必须全部来自给定的 points 数组",
        "点位于正方形边界上，其分布具有环形拓扑结构（四条边构成闭合路径）",
        "目标是最小曼哈顿距离的最大化，属于‘最大化最小值’类问题（max-min fairness）",
        "曼哈顿距离在边界上可转化为沿边界的路径距离或分段计算"
      ],
      "Objective Function": "最大化选定 k 个点中任意两点间最小曼哈顿距离的值",
      "Algorithmic Invariant": [
        "二分答案可行性：对候选的最小距离 d，判断是否存在至少 k 个点的子集，使得任意两点间曼哈顿距离 ≥ d",
        "基于贪心构造的验证过程：在排序后的边界序列上使用双指针或贪心选取策略，确保每次选择最靠前且满足距离约束的点",
        "状态单调性：若距离 d 可行，则所有 d' < d 也可行；若 d 不可行，则所有 d'' > d 也不可行",
        "可将二维边界点映射到一维环形序列（按顺时针展开），从而支持滑动窗口或动态规划进行子集选择"
      ],
      "Transformable Parameters": [
        "side 的数量级：可变范围 [1, 1e9]，影响是否可以枚举整个边界",
        "points 是否完整覆盖边界（稀疏 vs 密集）",
        "k 的大小：小常数（如 ≤25）允许指数级算法（如状压DP），但一般使用二分+贪心",
        "输入形式：points 是显式给出还是隐式生成（如所有整数坐标边界点）",
        "是否允许多组测试数据",
        "是否在线添加点",
        "距离度量变化：曼哈顿 → 欧几里得 → 切比雪夫",
        "拓扑结构变化：平面边界 → 环形排列 → 树形结构",
        "目标函数变换：最大化最小距离 → 最小化最大距离 → 计数满足条件的方案数"
      ]
    }
  },
  {
    "title": "Permutations III",
    "slug": "permutations-iii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "size": "n",
        "description": "一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右边界约束可分离，但需满足全局一致性",
        "condition": "局部积水依赖于全局极值信息"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算所有位置上能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示 L 左侧的最大高度，maxRight 表示 R 右侧的最大高度",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水可以确定，且仅取决于 maxLeft",
          "移动较小一侧的指针不会影响已确定区域的正确性",
          "每一步推进都保持未访问区域的最优子结构"
        ]
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 3 * 10^4",
          "可调整为更大规模或小规模"
        ],
        "value_range": [
          "0 <= H[i] <= 10^5",
          "可扩展至负数（变形）"
        ],
        "ordering": "无序输入，但隐含单调性可用于优化",
        "circular": false,
        "online": false,
        "mutable": false,
        "output_detail": "只需输出总和；可变体要求输出每个位置的积水量",
        "dimensionality": "1D；可变换为2D网格上的接雨水问题",
        "operation_support": "静态数组；可支持单点更新/插入删除（动态版本）",
        "query_mode": "单次查询；可改为多组数据或在线查询模式"
      }
    }
  },
  {
    "title": "Eat Pizzas!",
    "slug": "eat-pizzas",
    "schema": {
      "Input Structure": [
        "一维整数数组 pizzas[1..n]",
        "pizzas[i] ≥ 1",
        "n 是 4 的倍数",
        "每个元素表示披萨的重量"
      ],
      "Core Constraint": [
        "每天恰好吃 4 个披萨，共 n/4 天",
        "奇数天（第1,3,5,...天）体重增加当天所吃披萨中最大值 Z",
        "偶数天（第2,4,6,...天）体重增加当天所吃披萨中第二大值 Y",
        "所有披萨必须被恰好分配到某一天，且仅使用一次",
        "目标是最大化总增重，因此需策略性安排高重量披萨出现在关键位置"
      ],
      "Objective Function": "最大化总增重 = 所有奇数天的 Z 值之和 + 所有偶数天的 Y 值之和",
      "Algorithmic Invariant": [
        "排序后可通过贪心控制大值是否作为奇数天的 Z 或偶数天的 Y 被计入",
        "最优解中，较大的披萨应优先用于贡献奇数天的最大值或偶数天的次大值",
        "通过逆序枚举并动态决定分组，可保证局部选择不破坏全局最优性",
        "存在一种排序+贪心构造方案：将数组排序后，利用后缀结构预留大值给奇数天，中间值用于偶数天"
      ],
      "Transformable Parameters": {
        "n 的数量级": "4 <= n <= 2 * 10^5",
        "值域范围": "pizzas[i] ∈ [1, 10^5]",
        "是否有序": "输入无序，但最优解依赖排序预处理",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "天数奇偶规则是否可变": true,
        "体重增长规则变形": [
          "改为取 X（第三大）在偶数天",
          "改为奇数天取 Y、偶数天取 Z",
          "改为每天取最小值"
        ],
        "每组披萨数量": "固定为4，可推广为k个披萨/天",
        "分组方式限制": "当前无限制，可添加相邻性约束或区间选择约束"
      }
    }
  },
  {
    "title": "Transform Array by Parity",
    "slug": "transform-array-by-parity",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element_type": "integer",
        "size_range": "1 <= n <= 100",
        "value_range": "1 <= nums[i] <= 1000",
        "order": "unordered",
        "duplicates": true
      },
      "Core Constraint": {
        "transformation_rules": [
          "所有偶数被映射为 0",
          "所有奇数被映射为 1"
        ],
        "post_transformation_operation": "必须对转换后的数组进行非递减排序",
        "dependency": "元素独立处理，无前后依赖"
      },
      "Objective Function": {
        "goal": "构造",
        "output_type": "transformed and sorted array",
        "specifics": "返回经过偶奇性替换并按非递减顺序排序后的结果数组"
      },
      "Algorithmic Invariant": {
        "invariant_type": "值域压缩不变性",
        "description": "偶数→0、奇数→1 的映射将原数组压缩至仅含 {0,1} 的二元集合；在此二元集合上排序等价于将所有 0 排在 1 前面",
        "optimality_preservation": "映射与排序操作可分离：先映射再排序是唯一最优路径"
      },
      "Transformable Parameters": {
        "n_magnitude": "small (≤ 100)",
        "value_domain": "positive integers",
        "mapping_rule": {
          "even_to": 0,
          "odd_to": 1,
          "slot": "可替换为其他分类映射（如模k映射）"
        },
        "sorting_order": "non-decreasing (可变参数：可改为 non-increasing 或稳定排序要求)",
        "output_form": "full array (可改为统计 0/1 个数或仅返回某位置值)",
        "input_variability": "single instance (可扩展为多组测试数据)",
        "processing_mode": "offline batch processing (可设为在线流式输入)"
      }
    }
  },
  {
    "title": "Maximum Product of Subsequences With an Alternating Sum Equal to K",
    "slug": "maximum-product-of-subsequences-with-an-alternating-sum-equal-to-k",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 150",
        "value_range": "0 <= nums[i] <= 12",
        "ordered": true,
        "allows_duplicates": true,
        "description": "一维整数数组 nums，表示可构成子序列的元素集合，保持原有顺序"
      },
      "Core Constraint": {
        "constraint_logic": "子序列必须保持原数组中元素的相对顺序；交错和定义为偶数下标（0-based）元素之和减去奇数下标元素之和；目标是使交错和恰好等于 k，同时乘积不超过 limit",
        "dependency_structure": "每个位置是否被选影响后续下标的奇偶性归属，因此选择具有状态依赖性",
        "state_dimension": "需要同时追踪当前交错和、当前位置、当前乘积以及当前下标奇偶角色"
      },
      "Objective Function": {
        "goal": "maximization",
        "target_value": "maximum product",
        "condition": "subject to: alternating sum == k and product <= limit",
        "fallback": "return -1 if no valid subsequence exists"
      },
      "Algorithmic Invariant": {
        "invariant_description": "在遍历过程中，使用动态规划维护从起始位置到当前索引的所有可能 (alternating_sum, product) 状态对；一旦某个状态满足 alternating_sum == k 且 product <= limit，则可用于更新全局最大乘积解",
        "state_preservation": "对于相同 (index, alternating_sum) 状态，若存在两个不同路径导致相同或更大的乘积，则保留更优者以剪枝搜索空间",
        "monotonicity_or_optimality": "由于数值非负，乘积随元素增加单调不减，但受限于 limit，需显式检查边界"
      },
      "Transformable Parameters": {
        "n_scale": "small scale (<= 150), suitable for DP or DFS with memoization",
        "value_domain": "nums[i] in [0,12], allows optimization via bounded state space",
        "k_range": "-1e5 <= k <= 1e5, suggests need for offset-based indexing in DP",
        "limit_bound": "limit <= 5000, enables state dimensioning on product",
        "input_form": "single offline batch input",
        "multi_query": false,
        "online_processing": false,
        "modification_support": false,
        "additional_outputs": "can be extended to return the subsequence itself or count of valid subsequences",
        "objective_variants": [
          "change objective to counting number of valid subsequences",
          "minimize absolute difference |alternating_sum - k| under product constraint",
          "find lexicographically smallest subsequence achieving target"
        ],
        "structural_transforms": [
          "extend to circular array (ring structure)",
          "allow reordering (becomes combination instead of subsequence)",
          "transform into two-dimensional version with matrix traversal paths"
        ]
      }
    }
  },
  {
    "title": "Find Minimum Cost to Remove Array Elements",
    "slug": "find-minimum-cost-to-remove-array-elements",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "整数元素，满足 1 <= nums[i] <= 1e6",
        "无序，允许重复"
      ],
      "Core Constraint": [
        "每次操作最多从当前数组的前三个元素中选择两个进行移除",
        "当剩余元素少于三个时，必须一次性移除所有剩余元素",
        "操作顺序影响总成本，需决定最优移除策略"
      ],
      "Objective Function": "最小化移除所有元素的总成本（即各次操作成本之和）",
      "Algorithmic Invariant": [
        "贪心策略：在每一步中，优先保留较大值到后续操作可能更优，但必须考虑‘被迫在最后一步处理大值’的风险",
        "动态规划状态可定义为 f[i] 表示处理完前 i 个元素的最小成本，但由于操作依赖位置顺序和局部选择，状态转移需枚举前几步的移除组合",
        "最优子结构：全局最优解包含子数组上的最优移除策略",
        "决策无后效性仅在固定排序下成立；由于只能从前三元素选，推进过程具有前向依赖性"
      ],
      "Transformable Parameters": {
        "数据规模 n": "1 <= n <= 1000（当前），可扩展至 1e5 要求线性或近线性解法",
        "值域范围": "nums[i] ∈ [1, 1e6]，可调整为负数或更大范围以改变贪心有效性",
        "操作窗口大小": "从前 k 个中选两个（当前 k=3），可作为参数变换",
        "每次移除数量": "可改为选1个、2个或3个并影响成本计算方式",
        "成本函数形式": "当前为 max(移除元素)，可变更为 sum / min / (max-min) 等",
        "是否允许多次全删操作": "当前仅允许最后一次使用全删，可放宽为任意阶段触发但代价更高",
        "是否在线输入": "当前为离线一次性输入，可改为流式添加元素并支持回溯操作",
        "是否多组测试数据": "提示中未说明，可设为单组或多组作为参数位",
        "数组是否可重排": "当前不可重排（顺序重要），若允许重排则转化为贪心排序问题"
      }
    }
  },
  {
    "title": "Separate Squares II",
    "slug": "separate-squares-ii",
    "schema": {
      "Input Structure": [
        "二维整数数组 squares",
        "squares[i] = [x_i, y_i, l_i]",
        "表示左下角坐标为 (x_i, y_i)，边长为 l_i 的与 x 轴平行的正方形",
        "n = squares.length, 1 <= n <= 5 * 10^4",
        "坐标和边长范围：0 <= x_i, y_i <= 10^9, 1 <= l_i <= 10^9",
        "所有正方形总面积不超过 10^15"
      ],
      "Core Constraint": [
        "目标线为水平线（固定 y 坐标）",
        "线上方和线下方的正方形面积之和需相等（各占总面积的一半）",
        "正方形可能重叠，重叠区域在总面积中只统计一次",
        "面积计算需基于几何并集的空间覆盖，而非简单加总"
      ],
      "Objective Function": [
        "求最小的 y 坐标",
        "使得该水平线以上部分覆盖的正方形面积（去重后）等于以下部分的面积",
        "误差容忍：|computed - actual| <= 1e-5 视为正确"
      ],
      "Algorithmic Invariant": [
        "总面积具有单调性：随着 y 增大，下方累计面积单调不减，上方面积单调不增",
        "存在唯一的分割点 y 满足上下面积相等（由连续性和单调性保证）",
        "可通过二分查找 y 值，每次用扫描线 + 区间合并计算指定 y 下的实际覆盖面积",
        "面积函数关于 y 是分段线性且连续的，支持浮点二分"
      ],
      "Transformable Parameters": [
        "输入维度：1D（仅 y 方向切分）→ 可扩展为 x 或任意角度线",
        "目标函数变换：等于 → 大于等于 / 最小化差值",
        "约束反转：面积相等 → 上方面积 ≥ K",
        "数据形式：静态数组 → 在线添加/删除正方形",
        "重叠处理：去重 → 可重复计数（权重版）",
        "精度要求：1e-5 → 自定义误差或精确解",
        "是否多组查询：单次 y 查找 → 多个分割比例查询（如 1/3, 2/3）",
        "是否循环空间：普通平面 → 圆柱面或环形 y 坐标"
      ]
    }
  },
  {
    "title": "Check If Digits Are Equal in String After Operations II",
    "slug": "check-if-digits-are-equal-in-string-after-operations-ii",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n",
        "s[i] ∈ {'0','1',...,'9'}，表示数字字符",
        "3 <= n <= 10^5"
      ],
      "Core Constraint": [
        "每轮操作将原字符串相邻字符对 (s[i], s[i+1]) 映射为 ((int)s[i] + (int)s[i+1]) % 10 的结果",
        "新字符串由所有相邻对的运算结果按顺序构成，长度每次减 1",
        "重复操作直至字符串长度为 2",
        "整个变换过程是确定性的、不可逆的、逐层收缩的"
      ],
      "Objective Function": "判断最终剩余两个数字是否相等（即返回布尔值：true 当且仅当两个数字相同）",
      "Algorithmic Invariant": [
        "每轮变换保持顺序性：第 k 轮的结果仅依赖于第 k-1 轮的连续相邻对",
        "变换具有局部可组合性：每个输出位独立由输入中两个相邻位决定",
        "整体结构形成类似帕斯卡三角的递推路径，每一位的贡献可通过带权异或/模和分析",
        "若使用数学归纳法或组合权重视角，每一位初始数字对最终两位的影响具有周期性和模 10 不变性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "3 <= n <= 10^5（当前），可扩展至支持更大规模以考察优化算法",
        "模数": "当前为模 10，可改为模 m（如模 2 判奇偶合并）",
        "终止条件": "当前为长度等于 2，可变为长度 ≤ K 或其他逻辑",
        "目标函数变化": [
          "改为判定最终两数之和是否为偶数",
          "计数：有多少种子序列能导出相同终态",
          "构造：寻找字典序最小的初态使得终态满足条件"
        ],
        "操作规则变形": [
          "使用乘积代替加法",
          "使用异或代替模加",
          "非连续配对（如首尾配对）"
        ],
        "是否多组输入": "当前单组，可扩展为多组测试数据",
        "是否在线处理": "当前离线处理整串，可设计流式输入场景",
        "字符集扩展": "从纯数字扩展到字母或自定义符号映射"
      }
    }
  },
  {
    "title": "Minimum Pair Removal to Sort Array I",
    "slug": "minimum-pair-removal-to-sort-array-i",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "n ∈ [1, 50]",
        "nums[i] ∈ [-1000, 1000]",
        "元素可为负数、零或正数",
        "输入为静态离线数据"
      ],
      "Core Constraint": [
        "每次操作必须选择相邻元素对中和最小的（若有多个，取最左）",
        "操作会合并两个相邻元素为一个新元素（其值为二者之和）",
        "数组长度随操作递减：n → n-1 每步",
        "目标状态是最终数组为非递减序列",
        "操作顺序影响中间状态，进而影响后续可选操作路径"
      ],
      "Objective Function": "最小化将数组变为非递减所需的合并操作次数",
      "Algorithmic Invariant": [
        "局部贪心选择（最小和最左相邻对）不破坏全局最优解的存在性",
        "一旦某对被合并，其结果参与后续计算，且不可逆",
        "状态空间可通过动态规划枚举所有可能的合并顺序以验证最优性",
        "子区间合并后的值和顺序具有前缀可组合性",
        "最优子结构：任意区间的最优合并策略可在更大问题中复用"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题为 ≤50，可扩展至 1e3（需优化算法）或缩小至 ≤10（暴力可行）",
        "值域范围": "当前为 [-1000,1000]，可限制为非负或全正以简化贪心行为",
        "是否有序": "初始数组无序；可设为已部分有序作为变体",
        "是否循环": "原题为线性数组，可改为环形数组（首尾相邻）",
        "是否多组输入": "当前单组输入，可改为多组测试用例",
        "是否在线": "当前离线处理，可设计为流式输入并要求实时决策",
        "操作规则变化": [
          "选择最大和而非最小和",
          "随机选择最小和对（非最左优先）",
          "替换为乘积或其他函数",
          "允许多个元素同时合并"
        ],
        "目标函数变形": [
          "求最大操作次数",
          "判断是否能在 k 次内完成",
          "计数满足条件的操作序列数目"
        ],
        "终止条件变化": "改为要求严格递增、常数数组、回文结构等"
      }
    }
  },
  {
    "title": "Minimum Pair Removal to Sort Array II",
    "slug": "minimum-pair-removal-to-sort-array-ii",
    "schema": ""
  },
  {
    "title": "Select K Disjoint Special Substrings",
    "slug": "select-k-disjoint-special-substrings",
    "schema": ""
  },
  {
    "title": "Lexicographically Smallest Generated String",
    "slug": "lexicographically-smallest-generated-string",
    "schema": ""
  },
  {
    "title": "Check If Digits Are Equal in String After Operations I",
    "slug": "check-if-digits-are-equal-in-string-after-operations-i",
    "schema": ""
  },
  {
    "title": "Find Students Who Improved",
    "slug": "find-students-who-improved",
    "schema": {
      "Input Structure": [
        "关系表 Scores[1..n]",
        "每行包含字段：student_id (int), subject (varchar), score (int), exam_date (varchar)",
        "主键为 (student_id, subject, exam_date)",
        "score ∈ [0, 100]",
        "exam_date 格式为 'YYYY-MM-DD'"
      ],
      "Core Constraint": [
        "同一学生在同科目下的多条记录按 exam_date 可排序",
        "需识别每个 (student_id, subject) 组内的最早和最晚考试记录",
        "只有当某学生在某科目下至少有两个不同日期的考试时，才可评估是否‘进步’",
        "时间顺序决定状态演化方向"
      ],
      "Objective Function": [
        "筛选出满足以下条件的学生-科目对：",
        "1. 至少参加过两个不同日期的考试（同一科目）",
        "2. 最近一次考试分数 > 第一次考试分数",
        "输出每个符合条件的 student_id, subject, first_score, latest_score",
        "结果按 student_id 升序、subject 升序排序"
      ],
      "Algorithmic Invariant": [
        "对每个 (student_id, subject) 分组内记录按 exam_date 排序后，首尾元素分别对应第一次和最近一次考试",
        "分组内的时间单调性保证了首尾即极值点",
        "比较首尾 score 不破坏分组独立性",
        "全局结果可通过分组聚合合并，无跨组依赖"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的数量级（例如 10^3 ~ 10^6），影响是否需要流式处理",
        "分数变化判定方式": [
          "严格大于（>）→ 可改为 ≥（非降）、≠（变化）、<（退步）",
          "可扩展为进步幅度 ≥ K"
        ],
        "时间粒度": [
          "exam_date 精确到日 → 可改为周/月聚合",
          "是否允许同一天多次考试（当前不允许，因主键含 exam_date）"
        ],
        "输入形式": [
          "静态全量表 → 可改为在线追加记录的流数据",
          "是否支持删除或更新操作"
        ],
        "输出要求": [
          "仅输出进步学生 → 可改为输出所有有多次考试者，并标记状态",
          "是否输出中间分数序列",
          "是否统计总进步科目数 per student"
        ],
        "分组维度": [
          "当前为 (student_id, subject) → 可加入 school/year 等新维度",
          "是否允许多科目联合判断"
        ],
        "排序要求": "结果排序字段可变（如按进步幅度排序）"
      }
    }
  },
  {
    "title": "Maximum Median Sum of Subsequences of Size 3",
    "slug": "maximum-median-sum-of-subsequences-of-size-3",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "n % 3 == 0",
        "nums[i] ∈ [1, 10^9]",
        "数组长度 n ≤ 5 × 10^5"
      ],
      "Core Constraint": [
        "每次操作必须恰好移除三个元素",
        "中位数由三元组排序后的中间元素决定",
        "所有元素必须被分组且仅属于一个三元组",
        "目标是最大化中位数之和，因此需策略性选择三元组以保留高值作为中位数"
      ],
      "Objective Function": "最大化所有操作中产生的中位数之和",
      "Algorithmic Invariant": [
        "排序后，若希望某较大元素成为中位数，则其左右两侧各需一个小于等于它的元素",
        "贪心策略成立：为使大值尽可能成为中位数，应‘牺牲’两个较小值与其配对",
        "最优解中，参与构成中位数的元素在排序数组中呈现非递增可选性：从右往左构造三元组时，可用左侧未使用的小值填充低秩位置",
        "双指针或逆序贪心构造下，已确定的中位数不会影响后续合法构造的可行性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": [
            "3 ≤ n ≤ 5×10^5",
            "可扩展至支持更大规模"
          ],
          "值域": [
            "正整数",
            "可改为允许负数或零"
          ]
        },
        "分组约束": {
          "每组大小": [
            "固定为3",
            "可变参数：推广为每组k个元素（k奇数）"
          ],
          "是否必须整除": [
            "是",
            "否（剩余元素丢弃或惩罚）"
          ]
        },
        "中位数定义": [
          "奇数长度下取中间元素",
          "可变形为加权中位数或近似中位数"
        ],
        "目标函数形式": [
          "最大化中位数之和",
          "可变换为最小化、计数可行方案数、判定能否达到某阈值"
        ],
        "输入形式": [
          "一次性离线输入",
          "可改为在线流式添加元素并询问当前最优解"
        ],
        "操作限制": [
          "无限制选择任意三元组",
          "可增加索引连续性约束（如只能选连续三个元素）"
        ],
        "多组数据": "支持多测试用例（竞赛常见）"
      }
    }
  },
  {
    "title": "Minimum Cost to Divide Array Into Subarrays",
    "slug": "minimum-cost-to-divide-array-into-subarrays",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "一维整数数组 cost[1..n]",
        "整数 k",
        "n >= 1, nums[i] >= 1, cost[i] >= 1, k >= 1",
        "nums 和 cost 长度相等"
      ],
      "Core Constraint": [
        "总代价由子数组划分位置决定",
        "每个子数组的代价依赖于：前缀和（包含之前所有元素） + 当前段索引 i × k，乘以当前段 cost 的和",
        "代价函数具有非局部性：当前段的权重系数依赖全局前缀信息",
        "划分必须覆盖整个数组，且为连续非空子数组"
      ],
      "Objective Function": "最小化 总代价（所有子数组代价之和）",
      "Algorithmic Invariant": [
        "动态规划状态定义：dp[i] 表示将 nums[1..i] 划分后的最小总代价",
        "状态转移时枚举最后一个子数组的起始位置 j，计算从 j 到 i 的段贡献",
        "可利用前缀和优化：sum_nums[i] 表示 nums 前 i 项和，sum_cost[i] 表示 cost 前 i 项和",
        "在 O(1) 时间内计算任意区间 [j, i] 的 nums 和与 cost 和",
        "dp[i] = min_{1 <= j <= i} { dp[j-1] + (sum_nums[i] + k * segment_count) * (sum_cost[i] - sum_cost[j-1]) }",
        "segment_count 可通过额外状态或预处理推导（实际为当前是第几个段，依赖于划分次数）"
      ],
      "Transformable Parameters": {
        "数据规模 n": "1 <= n <= 1000 （当前），可扩展至 1e5 要求更优算法",
        "值域范围": "nums[i], cost[i] ∈ [1, 1000]，可改为负数或更大范围影响溢出处理",
        "k 的性质": "正整数，可变为负数（鼓励更多划分）或零（退化情形）",
        "是否有序": "数组无序，可研究特殊顺序（如单调）下的贪心策略",
        "是否多组数据": "单组输入，可改为多测测试",
        "是否在线": "离线一次性输入，可设计流式添加元素的在线版本",
        "划分限制": "当前无段数限制，可加入最多/最少划分数约束",
        "目标函数变化": "可改为最大化总代价、求方案数、判定是否存在小于阈值的划分",
        "cost 数组作用形式": "当前为区间和，可改为最大值、加权平均等变形"
      }
    }
  },
  {
    "title": "Maximum Sum With at Most K Elements",
    "slug": "maximum-sum-with-at-most-k-elements",
    "schema": "{\n  \"Input Structure\": [\n    \"二维矩阵 grid[1..n][1..m]，其中 n >= 1, m >= 1\",\n    \"整数数组 limits[1..n]，表示每行最多可提取的元素个数\",\n    \"整数 k，表示总共最多可提取的元素个数\",\n    \"grid[i][j] 是非负整数（0 <= grid[i][j] <= 1e5）\"\n  ],\n  \"Core Constraint\": [\n    \"从第 i 行提取的元素数量不能超过 limits[i]\",\n    \"总共提取的元素数量不能超过 k\",\n    \"每个元素只能被提取一次\",\n    \"目标是在双重约束下最大化总和：行级上限 + 全局上限\"\n  ],\n  \"Objective Function\": \"最大化所提取至多 k 个元素的总和\",\n  \"Algorithmic Invariant\": [\n    \"每行内部应优先选择最大值（局部贪心最优）\",\n    \"全局选择应在所有行的候选最大值中按降序取前 k 个（整体贪心策略）\",\n    \"可通过将每行排序后构建全局候选池，并使用堆或排序维护选择不变性\",\n    \"行内预处理（排序）不改变全局最优解结构\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n, m 的范围：可调整至 1e3 或更高以要求更优复杂度\",\n      \"k 的范围：可等于 sum(limits) 或远小于 min(n*m, sum(limits))\",\n      \"grid 值域：是否允许负数（影响贪心有效性）\"\n    },\n    \"输入形式\": {\n      \"是否有序：grid 每行是否已按降序排列（影响预处理需求）\",\n      \"limits 数组构造方式：均匀 / 不均衡 / 单一限制\"\n    },\n    \"约束条件\": {\n      \"行限制类型：改为至少提取？或恰好提取？\",\n      \"全局约束类型：改为必须提取恰好 k 个？\",\n      \"是否引入列限制？如每列最多选 c 个\"\n    },\n    \"多组数据\": \"是否支持多组测试用例批量处理\",\n    \"在线性\": \"是否支持动态更新 grid 或 limits 后重新查询最大和\",\n    \"输出形式\": [\n      \"仅返回最大和\",\n      \"返回具体选取方案（构造解）\",\n      \"返回每行选取个数分布\"\n    ]\n  }\n}"
  },
  {
    "title": "Separate Squares I",
    "slug": "separate-squares-i",
    "schema": {
      "Input Structure": [
        "二维整数数组 squares",
        "squares[i] = [x_i, y_i, l_i]",
        "表示左下角坐标为 (x_i, y_i)，边长为 l_i 的与 x 轴平行的正方形",
        "1 <= squares.length <= 5 * 10^4",
        "0 <= x_i, y_i <= 10^9",
        "1 <= l_i <= 10^9",
        "所有正方形总面积不超过 10^12"
      ],
      "Core Constraint": [
        "水平线将平面分为上下两部分",
        "每个正方形与水平线相交时，其面积按上下比例分配（可能被切割）",
        "重叠区域不合并计数，需独立多次计算",
        "目标是使线上总面积等于线下总面积",
        "答案要求最小的满足条件的 y 坐标"
      ],
      "Objective Function": [
        "求最小的 y 坐标",
        "使得该水平线以上（含线？不含？根据题意：线上指严格上方）的正方形面积之和等于以下的面积之和",
        "注意：线上面积 ≠ 线下面积时需调整 y；目标函数为判定+优化双重性质",
        "最终输出一个浮点数解，误差容忍 1e-5"
      ],
      "Algorithmic Invariant": [
        "总面积固定 => 目标上下各占 total_area / 2",
        "关于 y 的上线面积函数 f(y) 是单调非增函数（随着 y 上升，线上面积减少，线下增加）",
        "因此可以使用二分查找在 y 值域上搜索满足 f(y) = total_area / 2 的最小 y",
        "每次计算 f(y) 可遍历所有正方形，计算其在 y 上方的部分面积",
        "面积计算具有可加性和局部独立性，支持逐个处理"
      ],
      "Transformable Parameters": {
        "值域范围": {
          "y_i 和 l_i 是否扩大至 1e18（需要高精度或离散化）": false,
          "总面积是否超过 1e18（影响浮点精度策略）": false
        },
        "输入形式": {
          "是否改为在线输入正方形流": false,
          "是否支持动态添加/删除正方形": false
        },
        "几何维度": {
          "是否推广到三维立方体（z 方向切片）": false,
          "是否变为圆形或其他形状": false
        },
        "目标函数变化": {
          "由 '等于' 改为 '差值最小化'": false,
          "改为求分割比为 k:(1-k) 的 y 值": true
        },
        "约束条件变化": {
          "重叠区域只算一次（去重面积）": true,
          "限制 y 必须经过某个正方形内部": false
        },
        "数据规模": {
          "squares.length 是否达到 1e6（推动离散化+扫描线优化）": true
        },
        "输出精度": {
          "是否要求精确分数输出": false,
          "误差容限是否收紧至 1e-8 或放宽至 1e-3": true
        },
        "是否多组数据": false,
        "是否离线处理": true
      }
    }
  },
  {
    "title": "Maximize the Minimum Game Score",
    "slug": "maximize-the-minimum-game-score",
    "schema": {
      "Input Structure": [
        "一维数组 points[0..n-1]，其中 n >= 2",
        "整数 m 表示最多可执行的操作次数",
        "辅助数组 gameScore[0..n-1]，初始全为 0",
        "起始位置为下标 -1（在数组左侧边界外）",
        "points[i] ∈ [1, 1e6], m ∈ [1, 1e9], n ∈ [2, 5e4]"
      ],
      "Core Constraint": [
        "每次操作只能将当前下标 +1 或 -1，并将目标位置的 points[i] 加到 gameScore[i]",
        "第一次移动后，下标必须始终位于 [0, n-1] 范围内",
        "每个位置 gameScore[i] 的值由经过该位置的次数 × points[i] 决定",
        "总移动步数不超过 m 次（含前进和后退）",
        "路径必须从 -1 出发，后续所有位置访问均需通过相邻移动实现"
      ],
      "Objective Function": "最大化 gameScore 数组中的最小值（即 max(min(gameScore[0..n-1]))）",
      "Algorithmic Invariant": [
        "最优路径具有中心对称或单峰结构：先向右走到某点，再往复移动以均衡得分",
        "对于任意最终分布，gameScore[i] = cnt[i] * points[i]，其中 cnt[i] 是访问次数",
        "总步数约束转化为路径长度限制：从 -1 出发，走 m 步以内，覆盖各位置若干次",
        "使用二分答案时，判定 '是否能让所有 gameScore[i] ≥ X' 具有单调性",
        "检查可行性时，可通过贪心构造最短路径达成目标计数"
      ],
      "Transformable Parameters": {
        "n 的数量级": "n ∈ [2, 5e4] → 可扩展至 1e5 或更高（若允许离线处理）",
        "m 的范围": "m ∈ [1, 1e9] → 可改为在线查询或多组数据",
        "points 值域": "points[i] ≥ 1 → 可引入负值或零（改变贪心策略）",
        "是否有序": "points 无序 → 可假设已排序以启用不同优化",
        "输入形式": "单组输入 → 多组测试用例",
        "是否在线": "静态输入 → 支持动态修改 points 或 m 并实时查询",
        "移动规则变化": "仅 ±1 移动 → 可加入跳跃操作或传送机制",
        "目标函数变形": "max min(gameScore) → max median / maximize sum under min constraint",
        "gameScore 更新方式": "每次经过都加 points[i] → 仅首次加分 / 奇数次加分",
        "起始位置变化": "固定 -1 → 可选择起始点"
      }
    }
  },
  {
    "title": "Maximum Difference Between Even and Odd Frequency II",
    "slug": "maximum-difference-between-even-and-odd-frequency-ii",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "s[1..n], where n >= 3 and n <= 3 * 10^4",
        "character_set": "'0' to '4'",
        "additional_input": "integer k, 1 <= k <= n"
      },
      "Core Constraint": {
        "substring_length_constraint": "length(subs) >= k",
        "character_frequency_parity_constraints": {
          "a": "must appear odd number of times in subs",
          "b": "must appear even number of times and at least once in subs"
        },
        "independence_of_characters": "a and b can be any two distinct characters in subs; subs may contain more than two distinct characters"
      },
      "Objective Function": "maximize (freq[a] - freq[b]) over all valid substrings subs of s with length >= k, where a has odd frequency and b has non-zero even frequency. If no such pair exists, return -1.",
      "Algorithmic Invariant": {
        "sliding_window_feasibility": "any substring of length >= k can be considered; expanding window does not break feasibility",
        "frequency_tracking_invariance": "character frequencies within current window can be maintained in O(1) per expansion/contraction using array of size 5",
        "parity_aware_optimization": "for each window, only characters with odd and even counts are candidates for a and b respectively",
        "monotonicity_absent": "objective is not monotonic with window size — optimal solution may occur at any valid length >= k"
      },
      "Transformable Parameters": {
        "n_range": [
          3,
          30000
        ],
        "k_range": [
          1,
          "n"
        ],
        "character_set_size": "5 ('0'-'4'), but can be generalized to larger alphabets",
        "is_multitest": false,
        "is_online": false,
        "output_type": "single integer: maximum difference or -1",
        "allow_negative_result": true,
        "require_constructive_output": false,
        "constraints_on_a_b": "can be relaxed (e.g., specific a/b), or made symmetric",
        "frequency_condition_transformation": "change parity constraints: e.g., both odd, both even, mod 3 instead of mod 2"
      }
    }
  },
  {
    "title": "Assign Elements to Groups with Constraints",
    "slug": "assign-elements-to-groups-with-constraints",
    "schema": {
      "Input Structure": [
        "一维整数数组 groups[1..n], 其中 n = groups.length, 1 <= n <= 1e5",
        "一维整数数组 elements[1..m], 其中 m = elements.length, 1 <= m <= 1e5",
        "groups[i] >= 1, elements[j] >= 1",
        "数组无序，允许重复值"
      ],
      "Core Constraint": [
        "元素 j 可分配给组 i 当且仅当 groups[i] % elements[j] == 0",
        "每个组 i 的分配必须选择满足条件的最小索引 j",
        "一个 elements[j] 可被多个组重复使用（无占用约束）",
        "决策具有局部唯一性：一旦找到最小合法 j，无需回溯"
      ],
      "Objective Function": "为每个组 i 构造 assigned[i]，表示分配给它的最小下标 j；若无合法元素，则为 -1",
      "Algorithmic Invariant": [
        "对每个组 i，遍历 elements 数组时，首次满足 groups[i] % elements[j] == 0 的 j 即为最优解",
        "elements 的索引顺序决定优先级，不可排序后处理（会破坏下标最小性）",
        "每组独立决策，无状态依赖，可并行处理",
        "贪心选择安全：因目标是‘最小下标’而非‘最优值’，故先到先得策略成立"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "groups.length 和 elements.length 的数量级": [
            "1e5",
            "可扩展至 1e6（要求预处理优化）"
          ]
        },
        "输入形式": [
          "是否多组测试数据",
          "是否在线输入 groups（逐个给出组大小，实时响应）"
        ],
        "约束变形": [
          "elements[j] 必须严格整除 groups[i] → 改为 groups[i] / elements[j] <= K",
          "改为每个 elements[j] 只能使用一次（引入资源竞争，需匹配或贪心+标记）",
          "改为分配‘最大’下标而非最小（改变贪心方向）"
        ],
        "目标函数变化": [
          "求 assigned 数组 → 改为统计成功分配的组数",
          "改为构造字典序最小的 assigned 数组（引入全局调整）"
        ],
        "结构扩展": [
          "从一维数组 → 二维分组矩阵（多维输入）",
          "引入 group 权重，目标变为最大化加权和"
        ],
        "隐藏条件": [
          "显式枚举 elements → 隐藏为生成器函数（如素因子集合）",
          "elements 隐含单调性（如已排序），但题目不声明"
        ]
      }
    }
  },
  {
    "title": "Choose K Elements With Maximum Sum",
    "slug": "choose-k-elements-with-maximum-sum",
    "schema": {
      "Input Structure": [
        "两个长度为 n 的整数数组 nums1[0..n-1] 和 nums2[0..n-1]",
        "nums1[i] ≥ 1, nums2[i] ≥ 1",
        "正整数 k（1 ≤ k ≤ n）",
        "所有数组元素均为正整数"
      ],
      "Core Constraint": [
        "对于每个下标 i，合法的 j 必须满足 j ∈ [0, n-1] 且 nums1[j] < nums1[i]",
        "在所有满足条件的 j 中，只能选择至多 k 个对应的 nums2[j] 值",
        "选择过程独立于其他下标 i，即每个 i 独立求解一个子问题",
        "决策依赖于 nums1 的相对大小关系和 nums2 的数值分布"
      ],
      "Objective Function": [
        "对每个下标 i，最大化所选至多 k 个 nums2[j] 的总和",
        "返回一个长度为 n 的数组 answer，其中 answer[i] 表示对应的最大和"
      ],
      "Algorithmic Invariant": [
        "若将 (nums1[j], nums2[j]) 按 nums1 升序排列，则处理到某个值域时，所有更小的 nums1 对应的 nums2 候选值已可被收集",
        "使用数据结构（如有序集合或堆）维护候选的 nums2 值，并支持动态插入与前 k 大值快速求和",
        "贪心策略成立：为了最大化总和，总是优先选取当前可用候选中最大的至多 k 个 nums2[j]",
        "排序 + 离线处理保证每个位置 i 的查询仅依赖于 nums1 更小的项，不会遗漏或越界访问"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5（适合 O(n log n) 解法）",
        "值域范围": "nums1[i], nums2[i] ∈ [1, 1e6]",
        "是否有序": [
          "原始输入无序；可通过按 nums1 排序转化为有序处理（离线）",
          "可变体：输入是否已经按 nums1 排好序"
        ],
        "k 的约束形式": [
          "固定全局 k",
          "变形：k_i 可随 i 变化，或作为查询参数在线给出"
        ],
        "是否多组数据": false,
        "是否在线处理": [
          "原题为离线：所有数据一次性给定",
          "可扩展为在线流式输入，要求实时回答每个 i 的结果"
        ],
        "输入维度扩展": [
          "二维版本：改为矩阵形式，基于二维偏序选择候选",
          "多数组联动：引入更多关联数组"
        ],
        "目标函数变形": [
          "最小化前 k 个之和",
          "计数满足条件的方案数",
          "构造最优选择的具体下标集合"
        ],
        "比较关系变形": [
          "nums1[j] ≤ nums1[i]（允许相等）",
          "加入下标限制：j < i（时间顺序约束）"
        ],
        "操作类型增强": [
          "支持单点修改 nums1 或 nums2 元素",
          "支持区间查询形式而非逐个下标输出"
        ]
      }
    }
  },
  {
    "title": "Minimum Unlocked Indices to Sort Nums",
    "slug": "minimum-unlocked-indices-to-sort-nums",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"array\",\n    \"dimension\": 1,\n    \"elements\": \"non-negative integers\",\n    \"size\": \"n\",\n    \"notation\": \"H[1..n]\",\n    \"properties\": [\n      \"represents bar heights\",\n      \"indexable and ordered\"\n    ]\n  },\n  \"Core Constraint\": {\n    \"description\": \"The water trapped at each position is determined by the minimum of the maximum height to the left and the maximum height to the right, minus the current height.\",\n    \"key_conditions\": [\n      \"left_max[i] = max(H[1..i-1])\",\n      \"right_max[i] = max(H[i+1..n])\",\n      \"trapped_water[i] = max(0, min(left_max[i], right_max[i]) - H[i])\",\n      \"left and right constraints are globally dependent but locally decoupled\"\n    ]\n  },\n  \"Objective Function\": {\n    \"goal\": \"sum\",\n    \"target\": \"total amount of trapped rainwater\",\n    \"type\": \"numeric aggregation\",\n    \"output\": \"single integer representing total capacity\"\n  },\n  \"Algorithmic Invariant\": {\n    \"invariants\": [\n      \"Two pointers L and R start from both ends and move toward each other.\",\n      \"At each step, if maxLeft <= maxRight, then the water at L is solely constrained by maxLeft (since a valid bottleneck exists on the left), so it can be safely computed.\",\n      \"Similarly, if maxRight < maxLeft, the water at R is constrained by maxRight.\",\n      \"Pointer movement preserves correctness: advancing L or R does not affect already-determined regions.\",\n      \"maxLeft and maxRight are maintained incrementally as pointers move.\"\n    ],\n    \"proof_basis\": \"Monotonicity of boundary maxima ensures that smaller side always has its limiting factor known.\"\n  },\n  \"Transformable Parameters\": {\n    \"n_range\": [\"1 <= n <= 10^5\", \"can scale to 10^7 for optimized variants\"],\n    \"value_domain\": [\"H[i] >= 0\", \"can allow negative (interpretation change)\", \"bounded vs unbounded\"],\n    \"array_properties\": {\n      \"sorted\": \"not required\",\n      \"distinctness\": \"duplicates allowed\"\n    },\n    \"input_form\": {\n      \"static\": true,\n      \"online_queries\": false,\n      \"mutable\": false\n    },\n    \"extensions\": [\n      \"2D version: trap rainwater on a 2D elevation map\",\n      \"dynamic updates: support point updates to H[i]\",\n      \"circular array: connect H[n] to H[1]\",\n      \"output_detail\": \"return per-position contribution instead of total sum\",\n      \"constraint_reversal\": \"find minimum trapped water under rearrangement\",\n      \"multi-instance\": \"multiple test cases in one run\"\n    ]\n  }\n}"
  },
  {
    "title": "Find Products with Three Consecutive Digits ",
    "slug": "find-products-with-three-consecutive-digits",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "一维数组 H[1..n]，其中 H[i] 表示柱子的高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度中的较小者决定",
        "independence": "左右边界约束可分离但需全局一致",
        "local_global_dependency": "局部容量依赖于全局极值信息"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total trapped water",
        "output": "单个整数：所有位置累计接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariants": [
          "维护左指针 L 和右指针 R，分别从两端向中间移动",
          "维护 maxLeft = max(H[0..L]) 和 maxRight = max(H[R..n-1])",
          "若 maxLeft ≤ maxRight，则位置 L 的盛水量可确定为 maxLeft - H[L]",
          "移动较小一侧的指针，确保每次推进都不会丢失当前侧的瓶颈信息",
          "已处理区域的解是最终且不可变的（最优性保持）"
        ]
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          0,
          "10^5"
        ],
        "negative_values_allowed": false,
        "is_sorted": false,
        "is_circular": false,
        "multiple_test_cases": false,
        "online_queries": false,
        "support_updates": false,
        "output_detail_level": "total sum only",
        "dimension_extension": "1D → 2D (e.g., 2D trapping rain water)",
        "operation_dynamic": false,
        "hidden_monotonicity": false
      }
    }
  },
  {
    "title": "Subsequences with a Unique Middle Mode II",
    "slug": "subsequences-with-a-unique-middle-mode-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 H[1..n]，表示每个位置的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置能接雨水的量由其左侧最大高度和右侧最大高度中的较小值决定",
        "independence": "左右两侧的最大值可以独立维护",
        "global_consistency": "必须满足全局左右边界约束的一致性才能确定局部容量"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "two-pointers",
        "invariants": [
          "维护左指针 L 和右指针 R，分别从两端向中间移动",
          "维护 maxLeft = max(H[0..L]) 和 maxRight = max(H[R..n-1])",
          "若 maxLeft ≤ maxRight，则位置 L 处的可接雨水量为 max(0, maxLeft - H[L])，且 L 可安全右移",
          "若 maxRight < maxLeft，则位置 R 处的可接雨水量为 max(0, maxRight - H[R])，且 R 可安全左移",
          "指针移动过程中，已确定区域的贡献始终保持最优且不再更改"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "description": "高度是否允许负数（影响单调性和物理意义）"
          },
          {
            "name": "dimension",
            "options": [
              "1D",
              "2D",
              "3D"
            ],
            "description": "扩展到二维接雨水问题（如 LeetCode 407）"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online_streaming"
            ],
            "description": "输入是否在线流式到达"
          },
          {
            "name": "query_type",
            "options": [
              "total_sum",
              "per_position",
              "range_query"
            ],
            "description": "输出是总和、每个位置的值或区间查询结果"
          },
          {
            "name": "update_support",
            "options": [
              "static",
              "dynamic_with_updates"
            ],
            "description": "是否支持单点修改或区间更新操作"
          },
          {
            "name": "data_order",
            "options": [
              "arbitrary",
              "sorted",
              "partially_ordered"
            ],
            "description": "数组是否有序或具有某种预排序性质"
          },
          {
            "name": "multiple_test_cases",
            "type": "boolean",
            "description": "是否包含多组测试数据"
          },
          {
            "name": "circular_array",
            "type": "boolean",
            "description": "数组是否首尾相连形成环形结构"
          }
        ]
      }
    }
  },
  {
    "title": "Maximum Product of First and Last Elements of a Subsequence",
    "slug": "maximum-product-of-first-and-last-elements-of-a-subsequence",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          -100000,
          100000
        ],
        "constraints": [
          "nums.length >= 1",
          "nums.length <= 100000",
          "m >= 1",
          "m <= nums.length"
        ],
        "order_matters": true,
        "allows_duplicates": true,
        "is_ordered": false
      },
      "Core Constraint": {
        "subsequence_definition": "通过删除若干元素（可不删）保持原顺序得到的序列",
        "fixed_length": "子序列长度必须恰好为 m",
        "boundary_dependence": "目标函数仅依赖子序列首尾元素，与中间元素无关",
        "combinatorial_restriction": "选择位置 i_1 < i_2 < ... < i_m，仅关注 i_1 和 i_m 处的值"
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "product of first and last element in subsequence",
        "output_type": "integer",
        "objective_expression": "max{ nums[i] * nums[j] | 存在一个长度为 m 的子序列，其首元素下标为 i，尾元素下标为 j }"
      },
      "Algorithmic Invariant": {
        "extremal_boundary_property": "最优子序列的首尾元素必来自数组中的极值候选点（极大/极小）",
        "monotonic_preference": "对于固定首尾位置距离 ≥ m-1，优先考虑绝对值大或符号有利的乘积组合",
        "two_pointers_feasibility": "对每一对可能的首尾索引 (i, j) 满足 j - i >= m - 1，存在长度为 m 的子序列当且仅当区间 [i+1, j-1] 中至少有 m-2 个可用元素",
        "candidate_reduction": "有效候选首尾对的数量可通过预处理极值点剪枝控制在常数级别（如最大/最小/最大负等）"
      },
      "Transformable Parameters": {
        "n_scale": [
          "1e5",
          "1e3",
          "10"
        ],
        "value_domain": [
          "signed integers",
          "non-negative only",
          "positive only",
          "all negative"
        ],
        "m_fixed_or_variable": "m is fixed input parameter",
        "objective_variants": [
          "minimize product",
          "count number of max-product subsequences",
          "maximize sum of boundary elements",
          "maximize |first * last|"
        ],
        "structural_transformations": [
          "2D grid path with fixed step count (instead of 1D)",
          "circular array",
          "online queries for different m values",
          "support update operations (dynamic array)"
        ],
        "input_form": [
          "single test case",
          "multiple test cases",
          "interactive input"
        ],
        "output_detail": [
          "return maximum product only",
          "return indices of chosen subsequence",
          "return lexicographically smallest solution"
        ],
        "additional_constraints": [
          "must include specific element",
          "cannot include adjacent elements",
          "elements must be strictly increasing"
        ]
      }
    }
  },
  {
    "title": "Maximum Manhattan Distance After K Changes",
    "slug": "maximum-manhattan-distance-after-k-changes",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，由字符 'N', 'S', 'E', 'W' 组成",
        "每个字符表示在无限二维网格上的单位移动：N=(0,1), S=(0,-1), E=(1,0), W=(-1,0)",
        "初始位置为原点 (0, 0)",
        "允许最多修改 k 个字符为任意方向"
      ],
      "Core Constraint": [
        "移动是顺序执行的，路径是连续的，每一步的位置依赖前一步",
        "曼哈顿距离在任意时刻 t 定义为 |x_t| + |y_t|，需考虑路径中所有前缀位置",
        "修改操作可在任意位置进行，但最多 k 次",
        "最优策略必须在不改变操作顺序的前提下，最大化路径中的最大曼哈顿距离"
      ],
      "Objective Function": "最大化在执行移动过程中（任意前缀时刻）所能达到的离原点的最大曼哈顿距离",
      "Algorithmic Invariant": [
        "路径的曼哈顿距离峰值通常出现在某一前缀终点，可通过前缀模拟评估",
        "每次修改应尽可能增强当前主导方向（即增加 |x| 或 |y| 的趋势）",
        "对于任意区间 [l, r]，若将其中最多 k 个操作改为同一方向，可最大化该段净位移",
        "使用滑动窗口思想：固定一个方向 d ∈ {N, S, E, W}，尝试让某段连续操作通过至多 k 次修改全部朝向 d 或其反方向以增强贡献",
        "最大曼哈顿距离 = max(|x| + |y|) 可分解为四个象限方向的最大投影，等价于 max(x+y, x−y, −x+y, −x−y)，因此可转化为四个方向上的最大前缀和问题"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^5，支持线性或 O(n log n) 解法",
        "k 的取值范围": "0 <= k <= n，可为 0（无修改）、满修改等边界情况",
        "是否在线": "否，输入为一次性字符串；可改编为流式输入并支持动态修改",
        "是否多组数据": "否，单次输入；可扩展为多组测试用例",
        "方向集合是否可变": "基础为 4 方向；可推广到 8 方向或极坐标离散化移动",
        "目标函数变形": [
          "求最终位置的最大曼哈顿距离（仅终点）",
          "求最小可能的最大距离（对抗型）",
          "计数能达到最大距离的方案数"
        ],
        "约束反转": [
          "改为最多删除 k 个操作",
          "改为必须恰好修改 k 次",
          "加入不能连续两次相同方向等限制"
        ],
        "输入维度变换": "从一维字符串序列 → 二维指令矩阵（如网格行走脚本）",
        "隐藏条件": "方向序列隐含周期性或对称结构，可用于压缩状态"
      }
    }
  },
  {
    "title": "Maximum Difference Between Even and Odd Frequency I",
    "slug": "maximum-difference-between-even-and-odd-frequency-i",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n",
        "constraints": [
          "3 <= n <= 100",
          "s consists only of lowercase English letters",
          "at least one character appears odd times",
          "at least one character appears even times"
        ]
      },
      "Core Constraint": {
        "description": "The difference is defined only between frequencies of characters with odd occurrence count and those with even occurrence count. The parity of frequency determines eligibility for role as a1 or a2.",
        "key_insight": "Only global frequency counts matter; positions in string are irrelevant. This reduces the problem to analyzing the frequency distribution's parity-separated extrema."
      },
      "Objective Function": {
        "goal": "maximize difference",
        "expression": "diff = freq(a1) - freq(a2)",
        "conditions": [
          "a1 must appear odd number of times",
          "a2 must appear even number of times"
        ],
        "objective_type": "maximum"
      },
      "Algorithmic Invariant": {
        "invariant_description": "After computing all character frequencies, the maximum valid difference is achieved by pairing the highest odd-frequency character with the lowest even-frequency character.",
        "proof_basis": "Greedy choice: since we want to maximize (freq_odd - freq_even), it suffices to take max(freq over odd-count chars) and min(freq over even-count chars). This choice is optimal due to separability of constraints by parity.",
        "optimality_condition": "The solution space separates cleanly by frequency parity, enabling independent maximization and minimization."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "string length",
            "range": "n",
            "default": "3 <= n <= 100",
            "transformations": [
              "increase scale",
              "allow larger inputs up to 1e5",
              "add constraint on alphabet size"
            ]
          },
          {
            "name": "character set",
            "values": "lowercase English letters",
            "transformations": [
              "extend to uppercase",
              "allow digits/symbols",
              "restrict to k distinct letters"
            ]
          },
          {
            "name": "frequency parity constraint",
            "original": [
              "odd for a1",
              "even for a2"
            ],
            "transformations": [
              "swap: a1 even, a2 odd",
              "generalize: mod-k residue constraints",
              "hide parity: encode via other rules (e.g., prime vs composite count)"
            ]
          },
          {
            "name": "objective function",
            "original": "maximize difference",
            "transformations": [
              "minimize difference",
              "count number of valid pairs achieving max diff",
              "find lexicographically smallest pair achieving max diff"
            ]
          },
          {
            "name": "input format",
            "original": "static string",
            "transformations": [
              "online queries: update character, recompute result",
              "multiple strings",
              "streaming input"
            ]
          },
          {
            "name": "output requirement",
            "original": "return integer diff",
            "transformations": [
              "return pair of characters",
              "return all maximal pairs",
              "construct such a string under constraints"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Unit Conversion II",
    "slug": "unit-conversion-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at that position."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the distance between their indices and the minimum of their heights.",
        "key_insight": "Wider intervals may compensate for shorter heights; optimal solution does not necessarily involve the tallest lines.",
        "dependency": "Pairwise comparison with monotonic scanning possible due to one-dimensional layout and min-based objective."
      },
      "Objective Function": {
        "type": "maximization",
        "goal": "Find the maximum area of water that can be contained between any two lines in the array."
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariant": [
          "At each step, the current maximum area is recorded.",
          "The pointer with smaller height is advanced because moving the taller one cannot increase the area (width decreases and height is bounded by the shorter).",
          "This ensures that no better configuration involving the current extremal pointer is missed."
        ],
        "proof_condition": "For any fixed pair (L, R), if H[L] < H[R], then all containers using L and an index inside R must have less or equal area — thus safe to discard L."
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 1e5",
          "small n: brute-force viable"
        ],
        "value_domain": "H[i] >= 0",
        "ordering": "unordered input; relative positions matter",
        "circular": false,
        "online": false,
        "multiple_queries": false,
        "output_type": "single integer: maximum area",
        "modifications_allowed": false,
        "extensions": [
          "2D version: matrix with elevation map",
          "Dynamic updates: support insert/delete/update operations",
          "Constraint variation: require non-adjacent lines or minimum distance",
          "Objective variation: minimize area under constraints, count number of valid pairs exceeding threshold"
        ]
      }
    }
  },
  {
    "title": "Maximum Frequency After Subarray Operation",
    "slug": "maximum-frequency-after-subarray-operation",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "name": "nums",
        "size": "n",
        "element_type": "integer",
        "value_range": "[1, 50]",
        "constraints": [
          "n == nums.length",
          "1 <= n <= 1e5",
          "1 <= nums[i] <= 50",
          "k is a given integer in [1, 50]"
        ]
      },
      "Core Constraint": {
        "operation": "exactly one operation allowed",
        "action": "choose a contiguous subarray nums[i..j] and add an integer x to all its elements",
        "impact": "the value k can be created or reinforced in multiple positions via adjustment of x",
        "key_insight": "each element nums[i] can become k if and only if x = k - nums[i], so applying same x over a subarray means we can only make k appear at indices where the required x is consistent"
      },
      "Objective Function": {
        "goal": "maximize frequency of k in the array after one operation",
        "type": "maximization",
        "target_value": "k",
        "output_type": "integer (maximum count)"
      },
      "Algorithmic Invariant": {
        "invariant": "for any fixed x, the set of indices i where nums[i] + x == k forms candidate positions for k's appearance",
        "subarray_constraint": "x must be applied to a contiguous subarray, so only those indices with the same required delta (x = k - nums[i]) that lie within a common contiguous interval can be jointly enhanced",
        "optimality_condition": "maximum number of indices i such that k - nums[i] is constant and they form part of a contiguous segment where this delta can be uniformly applied",
        "strategy": "enumerate possible deltas d = k - nums[i]; for each d, use sliding window or grouping by value to find longest contiguous segment enriched with high density of indices where nums[i] + d == k"
      },
      "Transformable Parameters": {
        "n_range": [
          "1e1",
          "1e3",
          "1e5"
        ],
        "value_domain": {
          "nums[i]": "[1,50] or generalized to [-1e9,1e9]",
          "k": "[1,50] or arbitrary integer"
        },
        "operation_count": [
          "1 (fixed)",
          "up to m operations"
        ],
        "contiguity_requirement": [
          "contiguous subarray",
          "non-contiguous subset (would change problem structure)"
        ],
        "input_form": [
          "static offline array",
          "online updates",
          "multiple queries on k"
        ],
        "output_form": [
          "maximum frequency",
          "also return optimal subarray and x",
          "count number of ways achieving max frequency"
        ],
        "data_ordering": [
          "unordered",
          "sorted (alters feasible strategies)"
        ],
        "extension_dimensions": [
          "2D grid version",
          "circular array"
        ]
      }
    }
  },
  {
    "title": "Closest Equal Element Queries",
    "slug": "closest-equal-element-queries",
    "schema": {
      "Input Structure": {
        "nums": "环形数组 nums[0..n-1], 其中 n = len(nums), nums[i] ∈ [1, 10^6]",
        "queries": "查询数组 queries[0..q-1], q <= n, 每个元素为下标值，满足 0 <= queries[i] < n"
      },
      "Core Constraint": {
        "value_equality": "只考虑与查询位置值相等的其他下标 j（即 nums[j] == nums[queries[i]] 且 j != queries[i]）",
        "circular_distance": "距离定义为环形数组中的最短路径：min(|i - j|, n - |i - j|)",
        "existence_condition": "若不存在相同值的其他下标，则结果为 -1"
      },
      "Objective Function": "对每个查询 i，求出下标 queries[i] 到任意其他相同值下标的最小环形距离；若无则返回 -1",
      "Algorithmic Invariant": {
        "precomputation_invariance": "对于每个数值 v，预处理其所有出现下标的位置列表，保持有序",
        "monotonic_search": "在有序下标列表中使用二分查找定位最近邻候选（前驱和后继），利用环形性质计算最小距离",
        "query_independence": "各查询相互独立，可离线处理；答案仅依赖于预计算的值到位置映射"
      },
      "Transformable Parameters": {
        "circularity": "是否为环形数组（是/否）——当前为环形，可变更为线性结构",
        "data_scale": {
          "n": "1 <= n <= 1e5",
          "value_range": "1 <= nums[i] <= 1e6"
        },
        "input_form": {
          "queries_online": "是否在线查询（当前为离线批量输入）",
          "multiple_queries_per_index": "是否允许多次查询同一位置"
        },
        "uniqueness_constraint": "是否存在唯一值（影响 -1 出现频率）",
        "output_requirement": "是否要求输出具体下标而非距离",
        "dynamic_updates": "是否支持数组修改操作（如点更新、插入删除）"
      }
    }
  },
  {
    "title": "Find the Lexicographically Largest String From the Box II",
    "slug": "find-the-lexicographically-largest-string-from-the-box-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 H[1..n]，表示每个位置的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度中的较小值决定，且仅当该值大于 H[i] 时才能储水",
        "key_insight": "左右边界约束可分离，局部储水能力依赖于全局极值信息"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示 H[0..L] 的最大值，maxRight 表示 H[R..n-1] 的最大值",
          "若 maxLeft ≤ maxRight，则位置 L 处的储水量由 maxLeft 决定，可直接计算并右移 L",
          "否则，位置 R 处的储水量由 maxRight 决定，可直接计算并左移 R",
          "指针移动过程中不破坏已确定区域的最优性"
        ],
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_range",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "default": "non-negative"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D",
              "3D"
            ],
            "default": "1D"
          },
          {
            "name": "input_form",
            "options": [
              "offline_batch",
              "online_streaming"
            ],
            "default": "offline_batch"
          },
          {
            "name": "query_type",
            "options": [
              "total_sum",
              "per_position_output",
              "range_query"
            ],
            "default": "total_sum"
          },
          {
            "name": "update_support",
            "options": [
              "static",
              "dynamic_with_point_update"
            ],
            "default": "static"
          },
          {
            "name": "data_order",
            "options": [
              "unordered",
              "sorted",
              "circular_array"
            ],
            "default": "unordered"
          },
          {
            "name": "multi_test_cases",
            "type": "boolean",
            "default": false
          }
        ]
      }
    }
  },
  {
    "title": "Sort Matrix by Diagonals",
    "slug": "sort-matrix-by-diagonals",
    "schema": {
      "Input Structure": "二维整数方阵 grid[1..n][1..n]，其中 n ≥ 1；元素值域为 [-10^5, 10^5]；输入为有限规模的离线静态矩阵",
      "Core Constraint": "矩阵的每条对角线（从左上到右下方向）可独立提取和排序；左下三角区域（包括主对角线）的对角线必须非递增排序，右上三角区域的对角线必须非递减排序；不同对角线之间无数据依赖",
      "Objective Function": "构造并返回调整后的矩阵，使得所有指定区域内的对角线满足各自的单调性要求",
      "Algorithmic Invariant": "每条对角线的元素集合不变，仅重排顺序以满足单调约束；排序操作保持原位置所属对角线的映射关系；处理过程中不跨对角线移动元素",
      "Transformable Parameters": {
        "n 的数量级": "原题 n ≤ 10，可扩展至 n ≤ 1000（影响实现方式）",
        "值域范围": "当前为 [-10^5, 10^5]，可设为非负或正整数限制",
        "是否有序初始化": "可设定输入中部分对角线已满足条件",
        "是否循环结构": "可变形为环形对角线或螺旋对角线结构（暂未体现）",
        "是否多组输入": "当前为单组，可改为多测试用例批量处理",
        "是否在线": "当前为离线处理，可设计为动态修改+查询模式",
        "排序方向控制": "可引入参数 k 控制各对角线排序规则（如奇数行非增，偶数行非减）",
        "区域划分方式": "可将‘左下/右上’改为按距离主对角线偏移量划分"
      }
    }
  },
  {
    "title": "Maximum Difference Between Adjacent Elements in a Circular Array",
    "slug": "maximum-difference-between-adjacent-elements-in-a-circular-array",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "circular": true,
        "element_type": "integer",
        "value_range": [
          -100,
          100
        ],
        "length_range": [
          2,
          100
        ],
        "description": "给定一个长度为 n 的循环一维整数数组 nums[0..n-1]，其中第一个元素与最后一个元素相邻"
      },
      "Core Constraint": {
        "adjacency_definition": "在循环数组中，位置 i 与 (i+1) % n 是相邻的",
        "difference_property": "任意两个相邻元素之间的绝对差值 |nums[i] - nums[(i+1)%n]| 构成候选解集",
        "constraint_reasoning": "由于数组是循环的，必须显式处理首尾连接带来的额外相邻关系"
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "maximum absolute difference between adjacent elements",
        "output_type": "integer",
        "description": "求所有相邻元素对中最大的绝对差值"
      },
      "Algorithmic Invariant": {
        "invariant_description": "最大绝对差值必然出现在某一对相邻元素之间（包括首尾）",
        "scanning_property": "线性遍历过程中维护当前最大差值，不会遗漏全局最优解",
        "monotonicity": "目标函数具有单调可合并性：局部最大差值可通过逐对比较合并为全局最大值",
        "optimality_preservation": "每次更新 max_diff 都保持已访问部分的最优性"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "array circularity",
            "options": [
              "linear",
              "circular"
            ],
            "default": "circular",
            "impact": "决定是否考虑首尾相邻"
          },
          {
            "name": "objective type",
            "options": [
              "maximization",
              "minimization",
              "counting"
            ],
            "default": "maximization",
            "impact": "可改编为最小相邻差、差值等于K的对数等"
          },
          {
            "name": "data range",
            "value_domain": "[-10^9, 10^9]",
            "current": [
              -100,
              100
            ],
            "impact": "影响是否可用桶排序或计数类方法"
          },
          {
            "name": "array length",
            "size": "n",
            "current_range": [
              2,
              100
            ],
            "scalability": [
              "small n ≤ 100",
              "large n ≤ 1e5",
              "streaming"
            ]
          },
          {
            "name": "input mode",
            "modes": [
              "offline single",
              "multi-test cases",
              "online queries"
            ],
            "default": "offline single",
            "impact": "是否支持动态修改或批量处理"
          },
          {
            "name": "output requirement",
            "options": [
              "max value only",
              "position of max pair",
              "all pairs achieving max"
            ],
            "default": "max value only"
          },
          {
            "name": "element type",
            "types": [
              "integer",
              "float",
              "real number"
            ],
            "default": "integer"
          }
        ]
      }
    }
  },
  {
    "title": "Find Circular Gift Exchange Chains",
    "slug": "find-circular-gift-exchange-chains",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度中的较小值决定，且仅当该值大于当前高度时才可储水",
        "independence": "左右侧最大值可独立维护，但最终约束依赖于双边极值的最小值"
      },
      "Objective Function": {
        "goal": "求和",
        "description": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": "双指针推进过程中，始终维护 left_max 和 right_max；若 left_max ≤ right_max，则左指针当前位置的储水量可确定，并可安全右移左指针；反之亦然",
        "properties": [
          "已确定区域的储水量不依赖未来未访问元素",
          "指针移动保持未访问区间的最优性不变",
          "每一步推进均保留全局解的完整性"
        ]
      },
      "Transformable Parameters": {
        "n_range": "1 ≤ n ≤ 10^5",
        "value_range": "0 ≤ H[i] ≤ 10^4",
        "ordering": "无序输入，但隐含单调结构可用于优化",
        "negatives_allowed": false,
        "dimension_extension": "可扩展至二维矩阵（2D接雨水）",
        "online_queries": false,
        "updates_supported": false,
        "output_detail": "只需输出总量，无需记录每个位置的储水量",
        "multiple_test_cases": false,
        "circular_array": false
      }
    }
  },
  {
    "title": "Minimum Operations to Make Array Elements Zero",
    "slug": "minimum-operations-to-make-array-elements-zero",
    "schema": {
      "Input Structure": [
        "二维数组 queries，其中 queries[i] = [l, r]",
        "每个查询表示一个整数区间 [l, r]（包含端点）",
        "对应生成的数组 nums 包含所有整数从 l 到 r",
        "1 <= l < r <= 1e9",
        "1 <= queries.length <= 1e5"
      ],
      "Core Constraint": [
        "每次操作可选择两个元素 a 和 b，替换为 floor(a / 4) 和 floor(b / 4)",
        "单个元素不能单独操作，必须成对选取",
        "目标是将整个数组中所有元素变为 0",
        "floor(x / 4) 可视为对数值的快速衰减操作",
        "操作次数受限于每个数需要经过多少次 '除以4' 才能归零，但因必须成对操作，存在协同优化空间"
      ],
      "Objective Function": [
        "最小化将每个查询对应的数组全部变为 0 的操作次数",
        "对每个查询独立求解最小操作次数",
        "返回所有查询结果的总和"
      ],
      "Algorithmic Invariant": [
        "每个数字 x 转换为 0 所需的最少‘处理轮次’等于其四进制下非零位被消除的步数，即迭代 floor(x / 4) 直到 0 的次数，记作 depth(x)",
        "一次操作处理两个数，因此每轮操作最多减少两个单位的‘待处理任务量’",
        "总操作次数至少为 ceil(total_depth / 2)，其中 total_depth 是区间内所有数的 depth(x) 之和",
        "贪心不变量：只要存在两个 depth > 0 的数，就可以进行有效操作；最优策略不会造成额外浪费",
        "由于操作不改变其他元素，且 depth 是确定性函数，问题可分解为：统计 sum_{x=l}^{r} depth(x)，然后向上取整除以 2"
      ],
      "Transformable Parameters": {
        "值域范围": "l, r ∈ [1, 1e9]，可调整为更小或支持负数",
        "操作规则": "当前为 floor(a/4), 可改为 floor(a/k) 或 a>>k 等参数化形式",
        "操作方式": "是否允许单元素操作？是否允许多元组操作（如三个一起）？",
        "输入结构": "queries 是否可以是多维区间（如 2D 网格上的矩形）？",
        "在线性": "queries 是否在线给出？是否支持动态插入查询？",
        "输出形式": "返回总和 / 每个查询单独返回 / 最大操作次数等",
        "数据规模": "queries.length 当前最大 1e5，可扩展至 1e6 或更高以限制算法复杂度",
        "是否有序": "queries 是否按 l/r 排序？是否需要离线处理？"
      }
    }
  },
  {
    "title": "Reschedule Meetings for Maximum Free Time I",
    "slug": "reschedule-meetings-for-maximum-free-time-i",
    "schema": {
      "Input Structure": {
        "eventTime": "integer, 1 <= eventTime <= 1e9",
        "k": "integer, 1 <= k <= n",
        "startTime": "array of integers, length n, 0 <= startTime[i] < endTime[i] <= eventTime",
        "endTime": "array of integers, length n, endTime[i] <= startTime[i+1] for i in [0, n-2]",
        "constraints": [
          "会议时间无重叠",
          "会议按开始时间升序排列",
          "相邻会议之间可能存在空隙",
          "所有会议在 [0, eventTime] 范围内"
        ]
      },
      "Core Constraint": {
        "rearrangement_rule": "至多 k 个会议可被平移，保持原时长和相对顺序",
        "non_overlap": "移动后所有会议仍互不重叠",
        "order_preservation": "会议的相对顺序必须保持不变（即不能交换两个会议的位置）",
        "time_bound": "所有会议必须完全落在 [0, eventTime] 区间内",
        "objective_dependency": "最大连续空余时间取决于会议之间的间隙分布，且可通过调整部分会议位置来扩大关键间隙"
      },
      "Objective Function": "最大化相邻两个会议之间的最长连续空余时间（即 max gap between consecutive meetings after reordering at most k meetings）",
      "Algorithmic Invariant": {
        "greedy_gap_expansion": "最优解中，最大的空余时间段一定出现在某两个相邻会议之间，且可通过将中间的至多 k 个会议向左或向右压缩来扩展该间隙",
        "sliding_window_on_gaps": "考虑固定一个目标间隙区间 [L, R]，通过最多移动 k 个内部会议使其腾出空间，其余会议不动以维持顺序",
        "monotonicity_of_feasibility": "对于某个目标空闲长度 T，判断是否能构造出 ≥T 的空闲段具有单调性，支持二分答案",
        "prefix_suffix_preservation": "为最大化某一中间空隙，可将左侧会议尽量右对齐、右侧会议尽量左对齐，中间留出空白"
      },
      "Transformable Parameters": {
        "n_value": "2 <= n <= 1e5",
        "k_value": "1 <= k <= n",
        "eventTime_range": "[1, 1e9]",
        "input_order": "startTime 和 endTime 已按时间排序，且无重叠",
        "overlap_allowed": "false（本题不允许重叠，可变形为允许少量重叠但需惩罚）",
        "online_queries": "false（当前为离线输入，可扩展为在线添加/删除会议）",
        "multiple_test_cases": "否（当前单组数据，可改为多组）",
        "movement_constraints": "只能平移，不可缩放或翻转；可变参数位包括：是否允许改变会议顺序（若允许则变为更复杂调度问题）",
        "objective_variation": [
          "改为最小化最大空隙",
          "改为计数超过阈值的空隙数量",
          "改为求期望最大空隙（随机k选择）"
        ],
        "dimension_extension": "可推广到二维时间块（如会议室资源分配）",
        "additional_operations": "支持动态修改会议或查询历史安排"
      }
    }
  },
  {
    "title": "Reschedule Meetings for Maximum Free Time II",
    "slug": "reschedule-meetings-for-maximum-free-time-ii",
    "schema": {
      "Input Structure": [
        "整数 eventTime 表示活动总时长，时间范围为 [0, eventTime]",
        "两个长度为 n 的整数数组 startTime 和 endTime",
        "每个会议 i 的原始时间为 [startTime[i], endTime[i]]",
        "所有原始会议互不重叠且按结束时间非降序排列：endTime[i] <= startTime[i+1]",
        "会议时长固定：duration[i] = endTime[i] - startTime[i]"
      ],
      "Core Constraint": [
        "只能重新安排至多一个会议",
        "会议平移后必须保持原有时长，且不能超出 [0, eventTime] 范围",
        "平移后的会议必须与其他未移动的会议保持不重叠",
        "会议顺序可以改变，即不要求按时间顺序排列",
        "空余时间由会议之间的间隙构成，目标是最大化最长连续空余时间段"
      ],
      "Objective Function": "最大化最长连续空余时间（即最大区间长度，其中没有会议占据）",
      "Algorithmic Invariant": [
        "未被移动的会议构成固定的障碍点集，其相对位置不变",
        "若不移动任何会议，则最大空闲段为 max(startTime[0], gap between meetings, eventTime - endTime[n-1])",
        "当尝试移动某个会议时，其余 n-1 个会议形成固定的时间占用集合，剩余空间可视为若干候选空隙",
        "最优解一定出现在将某一个会议移动到最左端、最右端或夹在两个大间隔之间的情况",
        "枚举每一个可能被移动的会议，并计算将其移出后剩余空间中能形成的最长连续空闲段",
        "使用预处理前缀最大空隙和后缀最大空隙，可在 O(n) 内完成每次枚举的评估"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 1e5，支持线性或 O(n log n) 解法",
        "eventTime 值域": "1 <= eventTime <= 1e9，要求算法不依赖值域大小",
        "输入是否有序": "原始输入满足 endTime[i] <= startTime[i+1]，即会议按结束时间排序",
        "是否允许会议重叠": "否，约束条件禁止重叠",
        "是否多组数据": "单组输入（可扩展为多组）",
        "是否在线": "离线处理，所有会议信息已知",
        "是否可修改多个会议": "当前仅限至多一个；可变参数位：k 个可移动会议（推广为 k=1 的特例）",
        "目标函数变化可能性": [
          "改为最小化最大空闲时间（负载均衡类）",
          "计数：有多少种方式使得最大空闲 ≥ K",
          "判定：是否存在一种安排使最大空闲 ≥ K"
        ],
        "输入维度扩展": [
          "二维时间表（如会议室 + 时间），变为资源调度问题",
          "环形时间轴（t = eventTime 后接 t = 0）"
        ],
        "操作类型扩展": [
          "支持删除/插入会议",
          "允许缩放会议时长（非刚性平移）"
        ]
      }
    }
  },
  {
    "title": "Maximum Number of Matching Indices After Right Shifts",
    "slug": "maximum-number-of-matching-indices-after-right-shifts",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given an integer array height of length n, where each element represents the height of a vertical line at that index."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is bounded by the shorter line and the distance between their indices.",
        "key_insight": "For any pair (i, j), the container's capacity is determined by min(height[i], height[j]) * |j - i|.",
        "independence": "Left and right boundary choices are interdependent due to the min-height limitation."
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "the maximum area of water that can be contained between any two lines"
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariant": [
          "Maintain two pointers L = 0 and R = n-1 starting from both ends.",
          "At each step, the smaller height side has its optimal contribution already achieved with the current opposite pointer.",
          "Moving the pointer with smaller height preserves optimality: no future configuration with the same or lower bound can yield greater area."
        ],
        "proof_basis": "Monotonicity of width decrease; moving innerward from taller side cannot improve upon current bottleneck-limited area."
      },
      "Transformable Parameters": {
        "n_range": [
          2,
          100000
        ],
        "value_range": [
          0,
          10000
        ],
        "sortedness": "unsorted",
        "uniqueness": "values may repeat",
        "input_form": "single static array",
        "online_processing": false,
        "modifications_allowed": false,
        "output_type": "single integer (maximum area)",
        "extensions": [
          "2D version: matrix with elevation values",
          "Circular arrangement: connect first and last elements",
          "Query-based: support dynamic updates or range queries",
          "Variant objective: minimize area under constraints",
          "Counting: number of valid containers above threshold K"
        ]
      }
    }
  },
  {
    "title": "Manhattan Distances of All Arrangements of Pieces",
    "slug": "manhattan-distances-of-all-arrangements-of-pieces",
    "schema": "{\n  \"Input Structure\": [\n    \"二维矩形网格，大小为 m × n，其中 m, n ≥ 1\",\n    \"整数 k 表示要放置的不可区分棋子数量\",\n    \"每个格子最多放置一个棋子\",\n    \"坐标系中位置表示为 (x, y)，x ∈ [0, m-1], y ∈ [0, n-1]\"\n  ],\n  \"Core Constraint\": [\n    \"所有 k 个棋子必须被放置在不同的格子中（无重复）\",\n    \"方案总数为组合数 C(m*n, k)，但需枚举所有合法方案\",\n    \"曼哈顿距离具有可分解性：|x_i - x_j| + |y_i - y_j| = 横向距离 + 纵向距离\",\n    \"总距离和可拆分为：所有方案下所有点对横向距离之和 + 所有点对纵向距离之和\"\n  ],\n  \"Objective Function\": [\n    \"计算所有合法放置方案中，每对棋子之间的曼哈顿距离之和\",\n    \"结果对 10^9 + 7 取模\",\n    \"目标函数是‘计数型’：对方案空间进行加权求和（权重为点对距离）\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"曼哈顿距离的线性可分性：总距离 = 所有方案中所有点对的水平距离之和 + 垂直距离之和\",\n    \"对于任意两个列 j1 < j2，其贡献的水平距离 (j2 - j1) 在所有跨越这两列的点对中可独立统计\",\n    \"通过组合数学预计算：固定一对坐标轴方向上的位置后，其余位置的选择可用组合数表示\",\n    \"利用对称性和期望思想：可转化为‘任取两个不同格子，在所有包含它们的方案中，它们作为点对出现的次数’乘以距离并累加\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"m, n 的范围：[1, 1e5]，但保证 m * n ≤ 1e5\",\n      \"k 的范围：[2, m * n]\"\n    },\n    \"是否有序\": false,\n    \"是否循环\": false,\n    \"是否多组输入\": false,\n    \"是否在线\": false,\n    \"值域限制\": \"答案需对 10^9 + 7 取模\",\n    \"输入形式变化\": [\n      \"改为输出平均距离而非总和\",\n      \"改为只考虑某类特殊方案（如连通性约束）\",\n      \"加入障碍格子或禁止区域\",\n      \"棋子可区分 → 方案数变为排列，影响计数方式\",\n      \"从求和变为求最大/最小可能的总距离\",\n      \"从静态输入变为动态添加棋子（在线查询）\"\n    ],\n    \"结构维度扩展\": [\n      \"从 2D 网格扩展到 3D 立方体\",\n      \"从曼哈顿距离改为切比雪夫距离或欧几里得平方距离\",\n      \"从网格变为图结构，边权为距离\"\n    ]\n  }\n}"
  },
  {
    "title": "Make Array Non-decreasing",
    "slug": "make-array-non-decreasing",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "nums.length ∈ [1, 2×10^5]",
          "nums[i] ∈ [1, 2×10^5]",
          "non-empty contiguous subarray operations allowed"
        ],
        "initial_state": "arbitrary integer array, not necessarily sorted"
      },
      "Core Constraint": {
        "operation_rule": "replace a contiguous non-empty subarray with a single element equal to its maximum",
        "invariant_preservation": "resulting array must remain non-decreasing (i.e., sorted in non-decreasing order)",
        "structural_implication": "each operation reduces length by (k - 1) for subarray of length k; merging decisions affect feasibility of future merges"
      },
      "Objective Function": {
        "goal": "maximize the final length of the array",
        "condition": "subject to the resulting array being non-decreasing",
        "operation_scope": "zero or more operations allowed"
      },
      "Algorithmic Invariant": {
        "monotonicity_preservation": "after any sequence of valid operations, segments must be mergeable only if they do not violate non-decreasing order",
        "left_prefix_optimality": "if a prefix can be reduced to a non-decreasing sequence of certain length, it should not prevent extension unless constrained by right-side values",
        "greedy_merge_condition": "a segment [i..j] can be merged into one element (max value) only if doing so maintains compatibility with adjacent segments' endpoints in non-decreasing order",
        "dp_state_invariant": "state dp[i][x] = whether prefix ending at i can end with value x and achieve certain maximal length; transition depends on monotonicity between last value and current max"
      },
      "Transformable Parameters": {
        "data_scale": {
          "n_range": "[1, 2×10^5]",
          "value_range": "[1, 2×10^5]"
        },
        "input_form": {
          "order_requirement": "no initial order guarantee",
          "multiplicity_allowed": true
        },
        "output_form": {
          "return_type": "integer: maximum possible length",
          "construction_required": false
        },
        "operation_constraints": {
          "subarray_replacement_rule": "replaced by max of subarray",
          "alternative_rules": [
            "replace with min",
            "replace with median",
            "replace with sum (if allowed)"
          ]
        },
        "objective_variants": [
          "minimize final length",
          "count number of distinct outcomes",
          "determine if target array is reachable"
        ],
        "structural_transforms": [
          "2D version: grid blocks replaced by local maxima under non-decreasing matrix constraint",
          "circular array variant"
        ],
        "query_mode": {
          "online_updates": false,
          "batch_processing": true
        },
        "additional_constraints": {
          "limited_operations": false,
          "cost_per_operation": null
        }
      }
    }
  },
  {
    "title": "Paint House IV",
    "slug": "paint-house-iv",
    "schema": {
      "Input Structure": [
        "一维偶数长度的房屋序列，n ∈ [2, 10^5]，n 为偶数",
        "二维数组 cost[0..n-1][0..2]，其中 cost[i][j] 表示将第 i 个房屋涂成颜色 j+1 的成本",
        "每个 cost[i][j] ∈ [0, 10^5]"
      ],
      "Core Constraint": [
        "相邻房屋不能涂相同颜色（局部相邻约束）",
        "对称位置房屋不能涂相同颜色：即对任意 i ∈ [0, n/2)，位置 i 与位置 n-1-i 的颜色不同（全局对称约束）",
        "颜色种类固定为 3 种，每间房屋必须选择一种颜色涂刷"
      ],
      "Objective Function": "最小化总涂色成本，使得所有约束满足",
      "Algorithmic Invariant": [
        "状态可定义为 dp[i][c][d]：表示处理完前 i+1 个房屋，且第 i 个房屋颜色为 c，第 n-1-i 个房屋颜色为 d 时的最小成本（适用于从外向内双端推进）",
        "由于对称性约束仅作用于配对位置，可将问题拆分为从两端向中心同步转移的状态设计",
        "状态转移时，当前左侧位置 i 的颜色选择仅受 i-1 位置和其对称位置 n-1-i 的颜色限制",
        "利用颜色数小（仅3种）的特性，枚举合法颜色组合进行转移，保证最优子结构成立"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 10^5，可调整至更小规模用于 DP 枚举",
        "颜色数量": "当前为 3，可推广为 k 种颜色（k ≥ 2）",
        "cost 值域": "[0, 10^5]，可扩展或压缩",
        "是否偶数限制": "当前 n 必须为偶数，可变形为奇数时中心房屋无对称约束",
        "对称约束强度": "可改为部分对称位置允许同色，或加入权重阈值",
        "输入形式": "可变为在线输入 cost 流，或分块给出",
        "多组数据": "支持多测试用例批量处理",
        "目标函数变化": "可改为判断是否存在可行解、计数合法方案数、构造字典序最小染色方案"
      }
    }
  },
  {
    "title": "Find Valid Pair of Adjacent Digits in String",
    "slug": "find-valid-pair-of-adjacent-digits-in-string",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "s[1..n]",
        "constraints": [
          "s is a string of digits",
          "s.length >= 2 and s.length <= 100",
          "s contains only characters from '1' to '9'",
          "each character represents a digit d where 1 <= d <= 9"
        ]
      },
      "Core Constraint": {
        "adjacent_condition": "two adjacent digits d1 and d2 must satisfy d1 != d2",
        "frequency_condition": "digit d appears in s exactly d times",
        "evaluation_order": "traverse from left to right, first valid pair wins"
      },
      "Objective Function": {
        "goal": "find the first (leftmost) adjacent pair of digits satisfying the conditions",
        "output_type": "string",
        "return_empty_if_not_found": true
      },
      "Algorithmic Invariant": {
        "invariant_1": "the frequency count of each digit can be precomputed and remains constant during traversal",
        "invariant_2": "once a valid adjacent pair (d1, d2) is found with d1 != d2 and count(d1)==d1 and count(d2)==d2, it is optimal due to left-to-right order",
        "invariant_3": "no future pair can override an already found earlier valid pair due to problem's greedy return policy"
      },
      "Transformable Parameters": {
        "n_value_range": "2 <= n <= 100",
        "digit_range": "'1' to '9'",
        "allow_zero_digit": false,
        "frequency_constraint_form": "exact match: count(d) == d",
        "target_objective_variation": [
          "maximize digit sum of valid pair",
          "count total valid adjacent pairs",
          "return all valid pairs instead of first"
        ],
        "input_structure_variation": [
          "non-adjacent pairs within window",
          "circular string (last and first are adjacent)",
          "multi-character substrings of length k"
        ],
        "data_flow_mode": "offline single input",
        "online_queries": false,
        "update_operations": false,
        "multiple_test_cases": false
      }
    }
  },
  {
    "title": "Design a 3D Binary Matrix with Efficient Layer Tracking",
    "slug": "design-a-3d-binary-matrix-with-efficient-layer-tracking",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given an array H[1..n] where each element H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The water trapped at any position depends on the maximum height to its left and right; specifically, the effective boundary is determined by the minimum of the two side maxima.",
        "key_insight": "Left and right maxima can be precomputed or dynamically maintained; the trapping condition is local but relies on global information."
      },
      "Objective Function": {
        "goal": "sum",
        "description": "Compute the total amount of rainwater that can be trapped after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers (L, R) move from both ends toward the center, maintaining maxLeft and maxRight. If maxLeft ≤ maxRight, then the water at L is solely bounded by maxLeft (and vice versa for R). Moving the smaller-side pointer preserves correctness of accumulated result.",
        "properties": [
          "Pointer movement does not skip optimal contributions",
          "The invariant ensures no overcounting or undercounting"
        ]
      },
      "Transformable Parameters": {
        "n_range": "1 ≤ n ≤ 2×10^4",
        "value_domain": "0 ≤ H[i] ≤ 10^5",
        "ordering": "arbitrary (not necessarily sorted)",
        "extensions": [
          "Allow negative values (interpretation change required)",
          "Extend to 2D grid (‘Trapping Rain Water II’)",
          "Circular arrangement of bars",
          "Online version: process queries with updates (e.g., modify a height)",
          "Output per-position contribution instead of total sum",
          "Multiple queries over subarrays"
        ],
        "input_mode": "offline, single batch",
        "output_type": "scalar integer"
      }
    }
  },
  {
    "title": "Length of Longest V-Shaped Diagonal Segment",
    "slug": "length-of-longest-v-shaped-diagonal-segment",
    "schema": "{\n  \"Input Structure\": [\n    \"二维整数矩阵 grid[1..n][1..m]\",\n    \"n, m ∈ [1, 500]\",\n    \"grid[i][j] ∈ {0, 1, 2}\",\n    \"元素值有限（三值系统）\",\n    \"静态离线输入\"\n  ],\n  \"Core Constraint\": [\n    \"V 形对角线段必须从值为 1 的位置开始\",\n    \"后续路径必须严格遵循无限模式序列：2, 0, 2, 0, ...\",\n    \"初始方向为四大对角方向之一（左上→右下、右下→左上、右上→左下、左下→右上）\",\n    \"在保持序列模式的前提下，最多允许一次顺时针 90 度转向另一对角方向\",\n    \"路径必须沿对角线移动（每次行、列变化 ±1）\",\n    \"转向后的新方向必须是原方向顺时针旋转 90 度后的对角方向（如右下 → 左下）\"\n  ],\n  \"Objective Function\": [\n    \"最大化 V 形对角线段的长度（经过的格子总数）\",\n    \"若不存在合法线段，返回 0\",\n    \"仅需返回最大长度，无需构造方案\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"对于每个起始点 (i,j) 满足 grid[i][j] == 1，可预计算其在四个对角方向上能延伸的最长合法路径（按模式匹配）\",\n    \"转向点的选择必须满足：前段路径末尾元素与后段路径开头元素在序列中连续（例如前段以 0 结尾，则后段应以 2 开头）\",\n    \"两次路径拼接时，总长度 = 前段长度 + 后段长度，且共享转向点不重复计数\",\n    \"由于最多一次转向，最优解结构具有分段线性特性，可通过枚举起点和转向点进行分解\",\n    \"状态独立性：各方向上的扩展能力可独立预处理，用于加速组合查询\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n, m 范围\": \"[1, 500]\",\n      \"可扩展至更大规模（引入线段树或稀疏优化）\"\n    },\n    \"值域约束\": {\n      \"当前值域\": \"{0, 1, 2}\",\n      \"可变形式\": \"推广到更长周期序列（如 a,b,c,...）\"\n    },\n    \"序列模式\": {\n      \"当前模式\": \"固定为 2,0,2,0,...（从第一个 2 开始）\",\n      \"可变换\": \"改为任意给定循环模式\"\n    },\n    \"转向规则\": [\n      \"当前：最多一次顺时针 90 度转向\",\n      \"可变体：允许多次转向 / 逆时针转向 / 自由换向但有代价\"\n    ],\n    \"方向集合\": [\n      \"当前：仅限四种对角方向\",\n      \"可扩展为包括正交方向（形成八邻域）\"\n    ],\n    \"输入形式\": [\n      \"当前：一次性静态矩阵\",\n      \"可变形：在线更新（支持修改操作）、流式块输入\"\n    ],\n    \"是否多组数据\": false,\n    \"是否要求输出路径\": false,\n    \"起始条件\": [\n      \"当前：必须从 1 开始\",\n      \"可变体：允许从特定模式位置开始（如任意位置只要符合序列偏移）\"\n    ]\n  }\n}"
  },
  {
    "title": "Calculate Score After Performing Instructions",
    "slug": "calculate-score-after-performing-instructions",
    "schema": {
      "Input Structure": [
        "一维数组 instructions[0..n-1]，每个元素为字符串，取值范围 ∈ {\"add\", \"jump\"}",
        "一维数组 values[0..n-1]，整数数组，-10^5 <= values[i] <= 10^5",
        "n >= 1，n <= 10^5",
        "初始下标 i = 0，初始得分 = 0"
      ],
      "Core Constraint": [
        "指令执行顺序由当前下标和指令类型动态决定：\"add\" 移动到 i+1，\"jump\" 移动到 i + values[i]",
        "过程终止条件有两个：越界（i < 0 或 i >= n）或访问已执行过的下标",
        "每个下标最多执行一次，重复访问即终止",
        "控制流依赖于显式跳转逻辑，形成潜在的链式或环形执行路径"
      ],
      "Objective Function": "计算并返回过程终止时的最终得分（所有成功执行的 \"add\" 指令对应的 values[i] 之和）",
      "Algorithmic Invariant": [
        "已访问下标集合 visited 记录不可重复执行的状态，保证每个位置仅贡献一次或不被处理",
        "当前下标 i 的转移是确定性的：若 instructions[i] == \"add\"，则下一位置为 i+1；否则为 i + values[i]",
        "得分累加仅发生在未访问且有效的 \"add\" 指令上，且累加后才标记为已访问",
        "指针移动与状态更新顺序严格分离：先判断是否可执行 → 若可则更新得分/标记 → 再跳转"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1 <= n <= 10^5",
            "可扩展至 1e6（在线约束下需优化）"
          ]
        },
        "输入形式": [
          "instructions 是否有序 / 可预处理",
          "values 是否允许浮点（本题为整数）",
          "是否支持多组测试用例"
        ],
        "控制流结构": [
          "跳转目标是否可形成环（如 values[i]=0 导致自环）",
          "是否允许多入口（如从多个起点开始）",
          "是否改为 'call'/'return' 类栈行为（增强复杂度）"
        ],
        "执行策略": [
          "是否在线模拟（逐条执行）",
          "是否支持修改指令后重新查询（加入 update 操作）",
          "是否要求输出执行路径"
        ],
        "终止条件变形": [
          "限制最大执行步数（如最多执行 k 步）",
          "改为遇到特定指令（如 \"halt\"）才终止",
          "允许重复执行但得分只加一次（幂等 add）"
        ],
        "目标函数变化": [
          "求最大可能得分（在可选跳转路径中）→ 变为图上最长路径",
          "计数被执行的指令数",
          "判定是否能到达某个下标"
        ]
      }
    }
  },
  {
    "title": "Sum of Variable Length Subarrays",
    "slug": "sum-of-variable-length-subarrays",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "range": "1 <= n <= 100, 1 <= nums[i] <= 1000",
        "constraints": [
          "nums is a 1D integer array of length n",
          "each element nums[i] satisfies 1 <= nums[i] <= 1000",
          "non-empty contiguous subarrays are defined for each index"
        ]
      },
      "Core Constraint": {
        "description": "For each index i, the left boundary of the subarray is determined by max(0, i - nums[i]), and the subarray extends to i. The subarray depends only on local information at i but affects global sum accumulation.",
        "properties": [
          "subarray start position is uniquely determined by current index and value",
          "dependency is forward-local: each index defines a range ending at itself",
          "overlap between subarrays introduces additive redundancy that must be summed directly or optimized"
        ]
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total sum of all subarray sums defined by each index i",
        "output": "single integer representing the aggregated sum over all valid subarrays"
      },
      "Algorithmic Invariant": {
        "primary": "direct summation invariant",
        "invariants": [
          "for each index i, the subarray [start, i] where start = max(0, i - nums[i])] is fixed and non-extendable",
          "the contribution of each element nums[j] to the final sum can be determined by counting how many times it appears across all such subarrays (potential optimization path)",
          "no greedy choice or state transition reduces computation unless rephrased as frequency counting"
        ],
        "note": "Optimal solution in contest setting is typically O(n^2) direct simulation due to small constraints; however, an O(n) solution exists via contribution technique (counting how many times each nums[j] is included). This makes 'contribution counting' a viable alternative, but given n ≤ 100, both methods are acceptable — yet the intended invariant in competition context is usually iterative inclusion."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_size",
            "values": [
              "n ~ 100",
              "n ~ 1e5"
            ],
            "impact": "if n increases beyond 1e4, forces shift from O(n^2) to O(n) using contribution method"
          },
          {
            "name": "input_dimension",
            "values": [
              "1D",
              "2D grid"
            ],
            "impact": "extension to 2D would define rectangular regions based on (i,j) and nums[i][j]"
          },
          {
            "name": "subarray_definition",
            "values": [
              "start = max(0, i - nums[i])",
              "start = max(0, i - k)",
              "start = i - nums[i] (allow negative)"
            ],
            "impact": "changes bounds behavior and potential validity check"
          },
          {
            "name": "objective_variation",
            "values": [
              "sum of subarray sums",
              "maximum subarray sum",
              "number of distinct sums",
              "XOR of all subarray sums"
            ],
            "impact": "alters reduction strategy and possible use of prefix XOR / segment trees"
          },
          {
            "name": "query_mode",
            "values": [
              "offline static",
              "online update-query"
            ],
            "impact": "introduces need for Fenwick tree or segment tree if updates allowed"
          },
          {
            "name": "modifications",
            "values": [
              "static array",
              "support point update"
            ],
            "impact": "determines whether precomputation suffices or dynamic structure needed"
          }
        ]
      }
    }
  },
  {
    "title": "Unit Conversion I",
    "slug": "unit-conversion-i",
    "schema": {
      "Input Structure": [
        "n: 整数，表示单位类型的数量，编号从 0 到 n-1",
        "conversions: 二维整数数组，长度为 n - 1，其中 conversions[i] = [sourceUnit_i, targetUnit_i, conversionFactor_i]",
        "conversionFactor_i ≥ 1，表示 1 个 sourceUnit_i 单位等于 conversionFactor_i 个 targetUnit_i 单位",
        "输入构成一个以 0 为根的有向树结构：每个节点（单位）有唯一路径从 0 到达"
      ],
      "Core Constraint": [
        "转换关系形成一棵以单位 0 为根的有向树（DAG 中无环，且每个节点有唯一前驱路径）",
        "转换具有传递性：若 A → B 有因子 f1，B → C 有因子 f2，则 A → C 为 f1 * f2",
        "无需反向转换：所有转换方向一致，从源到目标单向进行",
        "结果由唯一路径决定，不存在多路径冲突或需要取最值的情况"
      ],
      "Objective Function": [
        "构造长度为 n 的数组 baseUnitConversion",
        "baseUnitConversion[i] 表示 1 个单位 0 可转换为多少个单位 i",
        "求积型计数问题：沿唯一路径上所有 conversionFactor 的乘积",
        "输出每个结果对 10^9 + 7 取模"
      ],
      "Algorithmic Invariant": [
        "从根节点 0 出发进行树形遍历（DFS 或 BFS），累积路径上的转换因子乘积",
        "每访问一个节点，其值 = 父节点的 baseUnitConversion[父] × conversionFactor(父→子)",
        "由于路径唯一，任意节点的值在首次访问时即确定，无需更新",
        "模运算下乘法封闭性保证中间结果可安全取模"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 1e5",
        "conversionFactor 值域": "1 <= factor <= 1e9",
        "是否取模": "是，模数为 1e9+7；可改为其他模数或不取模（大数输出）",
        "图结构变体": [
          "允许多路径 → 需定义合并策略（如取最小/最大/模意义下统一）",
          "存在环 → 需检测并处理循环依赖（非法或需特殊规则）",
          "双向转换 → 输入变为无向图，需构建等价类或归一化基准"
        ],
        "输入形式": [
          "离线一次性输入（当前形式）",
          "在线添加转换边 → 要求动态维护 baseUnitConversion"
        ],
        "根节点固定性": "当前固定为 0；可推广为任意基准单位查询",
        "输出形式": [
          "返回所有单位相对于 0 的转换系数（当前）",
          "改为仅查询某个单位",
          "改为返回任意两单位间的转换率"
        ],
        "数据类型扩展": "支持浮点因子（精度控制）、负因子（带符号单位）"
      }
    }
  },
  {
    "title": "Longest Team Pass Streak",
    "slug": "longest-team-pass-streak",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "properties": [
          "H[i] >= 0",
          "represents bar height at position i"
        ]
      },
      "Core Constraint": {
        "description": "The water trapped at each position is determined by the minimum of the maximum heights to its left and right, minus the current height.",
        "key_conditions": [
          "Left and right maxima are independent but must be globally consistent",
          "Water trapping capacity depends on boundary constraints rather than local neighbors"
        ]
      },
      "Objective Function": {
        "type": "sum",
        "goal": "total amount of trapped rainwater",
        "operation": "compute cumulative capacity over all positions"
      },
      "Algorithmic Invariant": {
        "invariant_type": "two-pointer movement with state preservation",
        "rules": [
          "Maintain two pointers L = 0 and R = n-1, and track maxLeft and maxRight",
          "If maxLeft <= maxRight, then the left pointer's contribution is fixed by maxLeft - H[L], and L++",
          "Else, fix right pointer’s contribution and R--",
          "Pointer movement preserves correctness of computed regions"
        ],
        "proof_basis": "Monotonicity of maxLeft and maxRight ensures no future update will affect already-trapped water"
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4",
          "up to 1e5 for extended versions"
        ],
        "value_domain": [
          "non-negative integers",
          "allow negative? (variant)",
          "bounded vs unbounded"
        ],
        "array_properties": {
          "sorted": "no",
          "duplicate_values_allowed": true,
          "circular": false
        },
        "input_mode": {
          "offline": true,
          "online_queries": false,
          "mutable": false,
          "supports_updates": false
        },
        "output_requirements": [
          "total sum only",
          "per-position breakdown (optional extension)",
          "first valid interval (decision variant)"
        ],
        "dimension_extension": {
          "2D_grid": false,
          "3D_voxel": false
        },
        "constraint_modifications": [
          "volume limit per column",
          "maximum container area instead (target change: max width * min height)",
          "at least K units of water required (decision problem)"
        ]
      }
    }
  },
  {
    "title": "Maximum and Minimum Sums of at Most Size K Subarrays",
    "slug": "maximum-and-minimum-sums-of-at-most-size-k-subarrays",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 1 <= n <= 80000，-10^6 <= nums[i] <= 10^6；给定正整数 k，1 <= k <= n",
      "Core Constraint": "子数组长度不超过 k，且为连续非空序列；每个子数组的贡献由其最小值和最大值共同决定；需枚举所有长度 ∈ [1, k] 的连续子数组",
      "Objective Function": "计算所有满足长度最多为 k 的子数组中，（最小值 + 最大值）之和的总和",
      "Algorithmic Invariant": "对于任意位置 i，其作为最小值或最大值的贡献区间可通过单调栈确定；在固定左端点时，滑动窗口内极值变化具有单调性；可分别预处理每个元素作为最小值/最大值的影响范围，并结合前缀和快速统计总贡献",
      "Transformable Parameters": {
        "数据规模": "n 的范围：1 到 80000，k 的范围：1 到 n",
        "值域": "nums[i] ∈ [-10^6, 10^6]",
        "子数组长度约束": "最多 k 个元素（可改为恰好 k、至少 k 等）",
        "目标函数形式": "求 (min + max) 的总和（可改为仅 max、仅 min、max - min 等）",
        "是否多组数据": "可扩展为多组测试用例输入",
        "是否在线": "当前为离线输入，可改造为流式添加元素并查询动态结果",
        "数组类型": "可推广至二维矩阵中求子矩阵的同类指标"
      }
    }
  },
  {
    "title": "Sum of Good Numbers",
    "slug": "sum-of-good-numbers",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": "[1, 1000]",
        "constraints": [
          "2 <= n <= 100",
          "1 <= k <= floor(n / 2)"
        ],
        "description": "一维整数数组 nums[0..n-1]，每个元素为正整数"
      },
      "Core Constraint": {
        "constraint": "一个元素 nums[i] 是‘好’的，当且仅当它严格大于其左右距离为 k 的邻居（若存在）",
        "neighbor_definition": "左邻居为 nums[i - k]（如果 i - k >= 0），右邻居为 nums[i + k]（如果 i + k < n）",
        "boundary_behavior": "若两个邻居都不存在，则该元素自动视为‘好’"
      },
      "Objective Function": {
        "goal": "求所有‘好’元素的和",
        "type": "summation",
        "target_elements": "满足局部比较条件的元素"
      },
      "Algorithmic Invariant": {
        "invariant": "对每个位置 i，判断 nums[i] > max(neighbor_left, neighbor_right) 的条件可独立验证",
        "independence": "各位置是否为‘好’元素相互独立，无状态依赖",
        "computation_order": "可顺序遍历每个下标 i 并局部决策，无需回溯或全局信息"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "k_constraint",
            "variants": [
              "k 可变：从固定值变为每元素不同",
              "约束反转：改为 ≤k 距离内至少有一个不小于它的",
              "目标变换：统计个数而非求和"
            ]
          },
          {
            "name": "comparison_logic",
            "variants": [
              "非严格大于 → 大于等于",
              "加入多个邻居：如 i-k..i+k 区间内的最大值比较"
            ]
          },
          {
            "name": "input_structure",
            "variants": [
              "数组变为环形（circular array）",
              "升维到二维网格：比较 (i±k,j) 和 (i,j±k)"
            ]
          },
          {
            "name": "data_mode",
            "variants": [
              "离线批量输入 → 在线流式查询每个位置是否为好元素",
              "支持单点更新：动态修改 nums[i]"
            ]
          },
          {
            "name": "output_form",
            "variants": [
              "返回和 → 返回索引列表",
              "要求构造使‘好’元素最多的排列"
            ]
          }
        ],
        "default_values": {
          "k": "fixed positive integer",
          "array_ordered": "no",
          "online": false,
          "multi_query": false
        }
      }
    }
  },
  {
    "title": "Sum of K Subarrays With Length at Least M",
    "slug": "sum-of-k-subarrays-with-length-at-least-m",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 2000",
        "value_range": "-10^4 <= nums[i] <= 10^4",
        "properties": [
          "一维数组 nums[1..n]",
          "元素可为负数",
          "连续子数组定义明确"
        ]
      },
      "Core Constraint": {
        "subarray_count": "恰好 k 个不重叠子数组",
        "length_constraint": "每个子数组长度至少为 m",
        "coverage": "所有子数组覆盖原数组的部分或全部元素，且互不重叠",
        "dependency": "前 i 个元素中选择 j 个子数组的最优解依赖于更小规模的子问题"
      },
      "Objective Function": {
        "goal": "最大化",
        "target": "k 个满足长度约束的不重叠子数组的和的总和"
      },
      "Algorithmic Invariant": {
        "dp_state_invariant": "dp[i][j] 表示考虑前 i 个元素、选出 j 个合法子数组时的最大和",
        "transition_invariant": "转移时枚举最后一个子数组的起始位置，确保其长度 ≥ m，且该段和可加至 dp[start-1][j-1]",
        "monotonicity": "随着 i 增大，dp[i][j] 具有动态规划的最优子结构和无后效性",
        "separability": "子数组之间不重叠 → 状态可分段转移"
      },
      "Transformable Parameters": {
        "constraints": {
          "k_range": "1 <= k <= floor(n / m), 可调整为变量或放宽至允许稀疏覆盖",
          "m_range": "1 <= m <= 3, 可扩展至任意 m 或变为上限约束",
          "subarray_overlap": "是否允许重叠（当前为不允许）",
          "subarray_count_objective": "改为最小化个数以达到目标和"
        },
        "data_form": {
          "array_type": "是否有序 / 是否循环数组",
          "sign_constraint": "nums[i] 是否非负",
          "dimensionality": "可推广至二维矩阵中选取 k 个块"
        },
        "input_output_mode": {
          "online_queries": "支持在线修改数组元素并重新查询结果",
          "multiple_test_cases": "多组测试数据输入",
          "output_detail": "仅输出最大和 / 输出具体子数组划分方案"
        },
        "objective_variants": {
          "counting_version": "求方案数（模意义下）",
          "feasibility_version": "判断是否存在和 ≥ target 的划分",
          "minimize_maximum_sum": "改为最小化最大子数组和（调度类变形）"
        },
        "complexity_parameters": {
          "n_scale": "n 是否可达 1e5 → 决定是否需斜率优化或单调队列加速 DP",
          "m_fixed_or_variable": "m 是否固定或也作为变量"
        }
      }
    }
  },
  {
    "title": "Count Mentions Per User",
    "slug": "count-mentions-per-user",
    "schema": {
      "Input Structure": [
        "整数 numberOfUsers，表示用户总数，取值范围 [1, 100]",
        "二维字符串数组 events，长度为 n（1 ≤ n ≤ 100），每个元素为 [type, timestamp, detail] 形式",
        "timestamp 为整数字符串，转换后范围 [1, 10^5]",
        "事件类型仅限于 \"MESSAGE\" 或 \"OFFLINE\"",
        "初始时所有用户在线"
      ],
      "Core Constraint": [
        "用户状态具有时效性：离线事件使用户在 timestamp_i 开始离线 60 单位时间，于 timestamp_i + 60 自动上线",
        "同一时间点的事件处理顺序：所有 OFFLINE 状态变更先于 MESSAGE 事件处理",
        "提及规则依赖当前用户在线状态：",
        "  - id<number>：直接提及指定用户，无论其是否在线，均计入次数",
        "  - \"ALL\"：提及所有用户（包括离线用户）",
        "  - \"HERE\"：仅提及当前在线的用户",
        "单条消息中同一用户可被多次提及，需分别计数"
      ],
      "Objective Function": "计数 —— 返回长度为 numberOfUsers 的数组 mentions，其中 mentions[i] 表示用户 i 在所有 MESSAGE 事件中被提及的总次数",
      "Algorithmic Invariant": [
        "用户状态演化是单调且可预测的时间区间覆盖问题：每个 OFFLINE 事件产生一个固定的 [t, t+60) 离线区间",
        "事件按 timestamp 排序处理时，状态与提及判定具备时间一致性",
        "对每个 MESSAGE 事件，可在 O(numberOfUsers) 内完成提及集合的确定，因规模小且约束明确",
        "提及计数过程满足叠加不变性：每次 MESSAGE 的贡献独立，可累加至全局结果数组"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "numberOfUsers": "可变范围：[1, 100] → 可扩展至 [1, 1e5]（触发离散化或差分优化）",
          "events.length": "可变范围：[1, 100] → 可支持更大流式输入",
          "每条消息提及 id 数量": "当前 ≤100，可设为变量或限制稀疏性"
        },
        "时间模型": {
          "时间范围": "[1, 1e5] → 可变为更大范围，引入时间压缩需求",
          "离线持续时间": "固定 60 → 可参数化为 K，或由事件指定",
          "时间粒度": "单位整数 → 可变为浮点或非均匀"
        },
        "事件类型扩展": {
          "新增事件类型": "如 ONLINE 手动触发、CANCEL_OFFLINE、SCHEDULED_MESSAGE",
          "提及关键字扩展": "如 HERE_NOW、ABSENT_ONLY 等基于状态的逻辑"
        },
        "输入形式": {
          "是否排序": "当前 events 按时间有序？题目未明确要求排序，但逻辑依赖时序 → 可设为无序，需预排序",
          "是否多组数据": "单例输入 → 可改为批量测试用例",
          "是否在线处理": "离线批处理 → 可改为实时流式事件处理（在线查询）"
        },
        "状态管理方式": {
          "状态存储": "布尔数组 + 时间戳 → 可改为事件队列、优先队列（自动上线调度）",
          "状态查询模式": "当前逐事件模拟 → 可抽象为时间轴上的区间覆盖查询"
        },
        "输出变化": {
          "目标函数变形": "从计数 → 是否被提及过（判定）、最大提及次数用户（最值）、构造提及序列（构造）"
        }
      }
    }
  },
  {
    "title": "Minimize the Maximum Edge Weight of Graph",
    "slug": "minimize-the-maximum-edge-weight-of-graph",
    "schema": {
      "Input Structure": [
        "有向带权图 G = (V, E)",
        "节点数 n，编号从 0 到 n-1",
        "边集 edges，其中每条边为 [u, v, w]，表示 u → v 的有向边，权重为 w",
        "所有边权 w ≥ 1",
        "可能存在多条平行边（但权值互不相同）"
      ],
      "Core Constraint": [
        "最终图中所有节点必须能到达节点 0",
        "每个节点的出度至多为 threshold",
        "目标是控制剩余边中最大边权尽可能小",
        "边的删除是唯一操作，不能添加或修改边"
      ],
      "Objective Function": "最小化剩余边中的最大边权值；若无法满足连通性和出度约束，则返回 -1",
      "Algorithmic Invariant": [
        "二分答案：对最大允许边权 mid 进行二分，只保留权值 ≤ mid 的边，检查是否存在合法方案",
        "在固定边权上限下，贪心策略成立：对每个节点，最多选择 threshold 条出边，优先保留有助于到达 0 的边",
        "可达性具有单调性：若最大边权限制更宽松（更大），则更容易满足所有节点到达 0",
        "出度约束与路径存在性可独立验证：先建图，再用 BFS/DFS 验证反向可达性（从 0 出发反向遍历）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 1e5",
        "边数规模": "edges.length <= min(1e5, n*(n-1)/2)",
        "边权值域": "1 <= w <= 1e6",
        "threshold 范围": "1 <= threshold <= n - 1",
        "图类型变体": [
          "无向图版本",
          "要求最小化总边权而非最大边权",
          "改为入度限制",
          "允许多次查询（在线）",
          "动态增删边",
          "变为二维坐标点间距离建图"
        ],
        "是否多组数据": false,
        "是否在线": false,
        "输入形式变化": [
          "邻接表直接输入",
          "流式输入边（需在线处理）"
        ],
        "隐藏条件设计点": "threshold = 1 时退化为树形结构约束"
      }
    }
  },
  {
    "title": "Team Dominance by Pass Success",
    "slug": "team-dominance-by-pass-success",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；左右边界约束独立但需全局一致",
      "Objective Function": "计算所有位置可累计的雨水容量总和（求和型目标函数）",
      "Algorithmic Invariant": "维护双指针 L 和 R，分别从左右两端向内移动；维护 maxLeft 和 maxRight 表示当前遍历过的最大高度；若 maxLeft ≤ maxRight，则左指针当前位置的积水可确定，并可安全右移 L；反之则右指针左移；已确定区域不再受影响",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许负值（如坑洼地形）",
        "维度扩展": "是否推广到二维矩阵（2D 接雨水问题）",
        "输入模式": "是否在线输入或支持动态修改（加入/删除/更新操作）",
        "输出要求": "是否需要输出每个位置的具体积水量而非总和",
        "数据形式": "是否多组测试用例、是否循环数组（环形接雨水）",
        "约束强度": "是否加入容量上限或其他物理限制"
      }
    }
  },
  {
    "title": "Minimum Runes to Add to Cast Spell",
    "slug": "minimum-runes-to-add-to-cast-spell",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates_allowed": true,
        "description": "Given an integer array height of length n, where each element represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The amount of water that can be trapped at any position depends on the maximum height to its left and right.",
        "key_insight": "Water trapping capacity at index i is determined by min(left_max[i], right_max[i]) - height[i], if positive.",
        "dependency": "Each position's contribution is constrained by global extrema on both sides; local decisions require global context."
      },
      "Objective Function": {
        "goal": "sum",
        "objective": "Compute the total amount of water that can be trapped after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two-pointer traversal maintains sufficient state to determine trapped water without full precomputation.",
        "rules": [
          "Maintain max_left and max_right as the highest bars seen so far from left and right.",
          "If max_left <= max_right, then the water at the left pointer is solely limited by max_left, and can be safely added.",
          "Similarly, if max_right < max_left, the right pointer's contribution is bounded by max_right.",
          "Moving the smaller side pointer preserves correctness because bottleneck is known."
        ],
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          "0",
          "10^5"
        ],
        "input_variations": [
          "Allow negative heights (meaning underground walls)",
          "Change to 2D grid (rain trapping over terrain matrix)",
          "Circular arrangement (last connects to first)",
          "Online version: process queries with dynamic height updates",
          "Output per-position values instead of total sum",
          "Multiple rain events with varying directions"
        ],
        "data_mode": "offline",
        "multiple_test_cases": false,
        "constraints_modifiable": {
          "monotonicity_required": false,
          "bounded_heights": true
        }
      }
    }
  },
  {
    "title": "Minimum Operations to Make Elements Within K Subarrays Equal",
    "slug": "minimum-operations-to-make-elements-within-k-subarrays-equal",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "integer",
        "length": "n",
        "value_range": [
          -1000000,
          1000000
        ],
        "constraints": [
          "2 <= n <= 10^5",
          "2 <= x <= n",
          "1 <= k <= 15",
          "2 <= k * x <= n"
        ]
      },
      "Core Constraint": {
        "description": "需要在数组中构造至少 k 个长度恰好为 x 的不重叠子数组，每个子数组内所有元素相等",
        "key_properties": [
          "子数组必须连续且非空",
          "子数组之间不能重叠",
          "每个目标子数组的长度固定为 x",
          "目标子数组的值可以不同（即不同段可等于不同常数）"
        ]
      },
      "Objective Function": {
        "type": "minimization",
        "goal": "minimum total operations",
        "operation_def": "each operation: increment or decrement one element by 1",
        "target": "make at least k non-overlapping subarrays of length x with all elements equal"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "最优解中，每一个选中的长度为 x 的子数组会被统一成其原始元素的中位数（最小化绝对偏差和）",
          "子数组的选择具有位置离散性，但可通过动态规划按顺序决策",
          "一旦确定某段作为目标块，其代价独立于其他块（局部可分离）",
          "使用 DP 状态：dp[i][j] = 考虑前 i 个位置，已构造 j 个完整块时的最小代价",
          "状态转移时枚举是否以当前位置结尾形成一个长度为 x 的块"
        ],
        "monotonicity": false,
        "overlapping_subproblems": true,
        "optimal_substructure": true
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "x",
            "role": "subarray length",
            "transformations": [
              "fixed",
              "variable",
              "range_query"
            ]
          },
          {
            "name": "k",
            "role": "number of required blocks",
            "transformations": [
              "exact",
              "at_least",
              "at_most"
            ]
          },
          {
            "name": "overlap_allowed",
            "type": "boolean",
            "default": false,
            "possible_values": [
              true,
              false
            ]
          },
          {
            "name": "all_blocks_same_value",
            "type": "constraint",
            "default": false,
            "possible_values": [
              true,
              false
            ]
          },
          {
            "name": "cost_function",
            "type": "operation cost",
            "options": [
              "absolute difference (|Δ|)",
              "squared difference (Δ²)",
              "step cost (only count if changed)"
            ]
          },
          {
            "name": "input_form",
            "type": "data flow",
            "options": [
              "offline batch",
              "online streaming"
            ]
          },
          {
            "name": "output_requirement",
            "type": "query type",
            "options": [
              "minimum operations",
              "construct solution",
              "count valid configurations"
            ]
          },
          {
            "name": "array_modification",
            "type": "operation set",
            "options": [
              "increment/decrement only",
              "arbitrary reassignment allowed",
              "with deletion/insertion"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Longest Subsequence With Decreasing Adjacent Difference",
    "slug": "longest-subsequence-with-decreasing-adjacent-difference",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": [
          2,
          10000
        ],
        "value_range": [
          1,
          300
        ],
        "order_property": "unordered",
        "duplicates_allowed": true
      },
      "Core Constraint": {
        "description": "子序列中相邻元素的绝对差构成非递增序列",
        "mathematical_form": "|seq[i+1] - seq[i]| >= |seq[i+2] - seq[i+1]| for all valid i",
        "structural_implication": "局部差值约束具有前后依赖性，后一项差值不能超过前一项"
      },
      "Objective Function": {
        "type": "maximization",
        "target": "length of subsequence",
        "goal": "find the longest subsequence satisfying non-increasing absolute differences"
      },
      "Algorithmic Invariant": {
        "invariant_description": "以每个位置为结尾的状态可由之前所有满足差值不增条件的转移路径更新",
        "dp_state_form": "dp[i][d] = maximum length ending at index i with last absolute difference d",
        "monotonicity_preserved": false,
        "optimal_substructure": true,
        "overlapping_subproblems": true,
        "transition_rule": "for each j < i, if |nums[i] - nums[j]| <= last_difference_in_sequence_ending_at_j, then update dp[i][|nums[i]-nums[j]|] = max(dp[i][...], dp[j][...] + 1)"
      },
      "Transformable Parameters": {
        "n_value_range": [
          2,
          10000
        ],
        "nums_value_domain": [
          1,
          300
        ],
        "input_ordering": [
          "arbitrary",
          "sorted",
          "reverse_sorted"
        ],
        "allow_negative_values": false,
        "subsequence_type": "strictly_non_increasing_differences",
        "objective_variation": [
          "max_length",
          "min_length_above_k",
          "count_of_valid_sequences"
        ],
        "constraint_variation": [
          "non-decreasing instead of non-increasing",
          "exact decrease by 1",
          "absolute difference >= K for all adjacent pairs"
        ],
        "data_mode": "offline_single_instance",
        "online_queries": false,
        "update_operations": false,
        "output_detail": [
          "length_only",
          "reconstruct_sequence"
        ]
      }
    }
  },
  {
    "title": "Maximum Coins From K Consecutive Bags",
    "slug": "maximum-coins-from-k-consecutive-bags",
    "schema": {
      "Input Structure": [
        "二维数组 coins，其中 coins[i] = [l_i, r_i, c_i]",
        "每个三元组表示一个左闭右闭区间 [l_i, r_i] 上的每个位置都有 c_i 枚硬币",
        "所有区间互不重叠",
        "硬币值为正整数：c_i ≥ 1",
        "坐标范围极大：l_i, r_i ≤ 1e9",
        "k 为连续选取的袋子数量，k ≤ 1e9"
      ],
      "Core Constraint": [
        "硬币分布具有区间常量特性：在同一个 [l_i, r_i] 内，每袋硬币数恒为 c_i",
        "区间之间互不重叠，可按坐标排序后线性处理",
        "目标区间长度固定为 k，但起始点可在无限数轴上任意选择",
        "最优解必定覆盖若干完整原始区间段和最多两个区间的部分边界段"
      ],
      "Objective Function": "最大化连续 k 个袋子中收集的硬币总数",
      "Algorithmic Invariant": [
        "将问题离散化为事件点（区间端点）后，有效候选起始位置仅出现在事件点附近（如左端点、右端点 - k + 1 等）",
        "使用滑动窗口思想：当窗口移动时，维护当前覆盖的区间贡献总和",
        "利用差分 + 离散化避免遍历大坐标空间",
        "由于区间不重叠且有序，可通过二分查找快速定位窗口内的区间段",
        "每次移动窗口边界时，增量更新总硬币数，保持 O(1) 更新复杂度"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "coins.length": "1e5",
          "坐标范围": "1 <= l_i <= r_i <= 1e9",
          "k 范围": "1 <= k <= 1e9",
          "c_i 值域": "1 <= c_i <= 1000"
        },
        "输入形式": [
          "是否保证区间有序（按 l_i）",
          "是否允许区间重叠（若允许，则需合并）",
          "是否多组测试数据"
        ],
        "输出要求": [
          "返回最大值 / 返回最优起点 / 返回具体方案"
        ],
        "约束变化": [
          "k 是否可变（在线查询多个 k）",
          "是否限制选择区间必须完全包含某个原区间",
          "是否加入删除或修改操作（动态版本）"
        ],
        "结构扩展": [
          "从一维线段变为二维矩形区域（2D 版本）",
          "从固定长度 k 变为最小覆盖需求（目标变换：最小化 k 满足总和 ≥ T）",
          "从最大值变为计数问题（有多少种方式获得 ≥ X 的硬币）"
        ],
        "隐藏条件": [
          "显式给出区间 → 隐式生成区间（如通过函数或规则推导）",
          "离线输入 → 在线流式添加新区间"
        ]
      }
    }
  },
  {
    "title": "Maximum and Minimum Sums of at Most Size K Subsequences",
    "slug": "maximum-and-minimum-sums-of-at-most-size-k-subsequences",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "非负整数元素，0 <= nums[i] <= 1e9",
        "正整数参数 k，表示子序列长度上限",
        "1 <= n <= 1e5, 1 <= k <= min(100, n)"
      ],
      "Core Constraint": [
        "子序列保持原数组中元素的相对顺序",
        "每个子序列的最小值和最大值由其包含的元素决定",
        "长度不超过 k 的所有非空子序列均需考虑",
        "相同数值可能重复出现，但来自不同位置视为独立贡献"
      ],
      "Objective Function": [
        "对所有长度在 [1, k] 范围内的非空子序列，计算（最小值 + 最大值）之和",
        "最终结果对 1e9+7 取模",
        "目标函数为计数型求和（sum over combinatorial objects）"
      ],
      "Algorithmic Invariant": [
        "通过排序后枚举每个元素作为最小值或最大值的贡献次数，实现线性组合优化",
        "对于已排序数组，若固定某元素为最小值，则其作为最小值的子序列必须仅包含它及其右侧元素",
        "利用组合数学预处理幂次和组合系数，支持快速区间选择计数",
        "每个位置 i 的贡献可分解为：以 nums[i] 为最小值的子序列数量 × nums[i] + 以 nums[i] 为最大值的子序列数量 × nums[i]",
        "双指针或滑动窗口可用于限定有效右边界范围（最多 k 个元素参与）"
      ],
      "Transformable Parameters": [
        "k 的取值范围：从 1 到 min(n, 100)，可变为全局允许任意长度（k = n）",
        "是否要求模运算：可改为输出原始整数或使用其他模数",
        "输入是否有序：原题无序，但可通过排序转化；可设计为强制在线不可排序",
        "数据规模：n 可扩展至 1e6 或缩小至 20（允许状压DP）",
        "是否多组测试数据：可设定 T 组输入",
        "是否在线查询：动态添加元素并实时更新答案",
        "目标函数变化：改为只求最大值之和、或最小值与最大值差的绝对值之和",
        "约束反转：改为长度至少为 k，或恰好为 k",
        "子序列定义变化：是否允许重排（则退化为集合问题）"
      ]
    }
  },
  {
    "title": "Frequencies of Shortest Supersequences",
    "slug": "frequencies-of-shortest-supersequences",
    "schema": {
      "Input Structure": [
        "给定一个字符串数组 words[1..m]",
        "每个 words[i] 是长度为 2 的小写英文字母字符串",
        "words 中所有字符来自不超过 16 个互不相同的小写字母",
        "m = |words| ∈ [1, 256]"
      ],
      "Core Constraint": [
        "最短公共超序列 S 需满足：每个 words[i] 是 S 的子序列",
        "S 的长度最小化（即无法更短）",
        "所有输出的最短公共超序列之间不能互为排列关系（去重）",
        "子序列定义：从 S 中删除若干字符（可为空），剩余字符顺序不变构成原串"
      ],
      "Objective Function": [
        "构造所有本质不同的最短公共超序列（排除互为排列的情况）",
        "返回每个最短公共超序列中 26 个小写英文字母的出现频率向量",
        "目标类型：计数 + 构造（频率统计形式）"
      ],
      "Algorithmic Invariant": [
        "最短公共超序列的长度由字符使用次数与相对顺序约束共同决定",
        "若两个序列互为排列，则其字母频次相同，可通过频次哈希去重",
        "所有最短解必然是对字符的某种拓扑安排，满足所有 words 中字符的先后顺序约束",
        "最优性依赖于字符共现和偏序关系的传递闭包"
      ],
      "Transformable Parameters": {
        "n": "words.length ∈ [1, 256]",
        "word_length": "每个 words[i] 的长度固定为 2（可变位：可推广至任意短串）",
        "alphabet_size": "实际使用字母数 ≤ 16（可扩展至 26）",
        "character_set": "仅小写英文字母",
        "duplicates_allowed": false,
        "online_input": false,
        "multiple_test_cases": false,
        "output_form": "返回频次数组 freqs[i][26]，而非字符串本身",
        "permutation_duplicate_removal": true,
        "subsequence_definition": "非空子序列，顺序保持"
      }
    }
  },
  {
    "title": "Minimum Cost to Make Arrays Identical",
    "slug": "minimum-cost-to-make-arrays-identical",
    "schema": {
      "Input Structure": [
        "一维整数数组 arr[1..n]",
        "一维整数数组 brr[1..n]",
        "整数 k",
        "n >= 1, 最大可达 1e5",
        "arr[i], brr[i] ∈ [-1e5, 1e5]",
        "k ∈ [0, 2e10]"
      ],
      "Core Constraint": [
        "允许对 arr 进行两类操作：",
        "1. 分割为若干连续非空子数组并任意重排，代价为 k（每次使用）",
        "2. 对单个元素增减 x，代价为 x",
        "重排操作不改变元素值，仅改变顺序",
        "重排可执行任意次，每次独立计费 k",
        "目标是使 arr 经操作后与 brr 完全相等（逐位）"
      ],
      "Objective Function": "最小化将 arr 变为 brr 所需的总代价（重排代价 + 元素调整代价之和）",
      "Algorithmic Invariant": [
        "最优解中，重排操作次数有限且至多为 O(n)，实际中往往为 0 或少量",
        "若使用重排，等价于选择一组置换 π 使得部分元素通过重排列对齐，减少调整代价",
        "元素调整代价 = Σ|arr[π(i)] - brr[i]| 的最小化依赖于匹配方式",
        "问题转化为：在最多支付 m×k 的前提下，通过至多 m 次重排（即重新分段重组），最小化元素差值总和",
        "关键不变量：一旦确定某组元素可通过重排对齐到目标位置，则其调整代价由值差决定；否则直接调整原位",
        "由于重排是全局打乱连续块，最优策略中常表现为：选择某些元素进行‘免费’移动（通过重排），其余用数值调整补偿"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1 <= n <= 1e5",
            "可缩放至 1e3 用于教学题"
          ],
          "值域": [
            "[-1e5, 1e5]",
            "可扩展或缩小"
          ]
        },
        "k 的取值范围": [
          "k = 0：禁止重排操作",
          "k 很大：倾向于不使用重排",
          "k 很小：可能多次使用重排以节省调整代价"
        ],
        "是否允许多次重排": "是，每次代价为 k",
        "输入形式": [
          "单组输入",
          "可扩展为多组测试数据"
        ],
        "在线/离线": "离线处理，完整数组已知",
        "重排约束变化": [
          "限制最多分割成 2 段 → 改变搜索空间",
          "必须保持某个子数组顺序不变（如前缀固定）",
          "仅允许一次重排操作"
        ],
        "目标变换": [
          "判定是否存在代价 ≤ T 的方案（判定型）",
          "计数满足最小代价的方案数（计数型）",
          "构造最优操作序列（构造型）"
        ],
        "结构扩展": [
          "二维数组重排（矩阵块重排）",
          "环形数组重排",
          "子数组重排但不能跨块交换"
        ],
        "操作代价模型变化": [
          "重排代价为 k × (段数 - 1)",
          "元素调整代价为 |x|^p（如 p=2）",
          "增加操作：删除/插入元素"
        ]
      }
    }
  },
  {
    "title": "First Letter Capitalization II",
    "slug": "first-letter-capitalization-ii",
    "schema": {
      "Input Structure": [
        "表 user_content，包含两列：",
        "  - content_id: int（唯一主键）",
        "  - content_text: varchar（非空字符串，包含单词、空格、短横连接词 '-'）",
        "每个 content_text 是由空格分隔的词序列，词中可能包含一个或多个用 '-' 连接的子词"
      ],
      "Core Constraint": [
        "单词以空格为边界进行分割，但 '-' 不作为整体单词的分割符，而是连接两个子词",
        "每个独立单词（或连字符连接的子词）需独立应用大小写转换规则",
        "原始空格和标点格式必须完全保留"
      ],
      "Objective Function": [
        "构造一个新的文本列 converted_text，满足：",
        "  1. 每个单词的首字母大写，其余字母小写",
        "  2. 对于通过 '-' 连接的复合词，每个被连接的部分也遵循首字母大写规则",
        "同时保留原始 content_text 列用于输出对比"
      ],
      "Algorithmic Invariant": [
        "单词边界识别不变性：空格是唯一合法的词分隔符，'-' 属于词内结构",
        "局部变换独立性：每个词（或子词）的大小写转换不依赖上下文其他词",
        "格式保真性：所有空格、连字符、顺序在输出中与输入一致，仅字母大小写按规则变化"
      ],
      "Transformable Parameters": {
        "分隔符类型": [
          "空格 → 多种空白字符（\\t, \\n）",
          "支持自定义分隔符"
        ],
        "连接符扩展": [
          "'-' → 多种连接符如 '_' 或 '.'",
          "嵌套连接词处理"
        ],
        "大小写规则可变": [
          "首字母大写 → 全大写 / 全小写 / 驼峰式 / 标题式（Title Case）",
          "特殊词跳过（如停用词不转换）"
        ],
        "语言支持": [
          "英文 → 多语言（带重音符号的字符）",
          "Unicode 字符处理"
        ],
        "输入形式": [
          "单行文本 → 多行文本流",
          "静态表 → 在线编辑流（支持插入/更新）"
        ],
        "输出要求": [
          "返回 original + converted → 仅返回差异部分",
          "是否标记修改位置"
        ],
        "数据规模": [
          "单条文本长度 ≤ 1000 → ≤ 10^6",
          "表行数 = 1 → 10^5 行"
        ],
        "是否多组数据": true,
        "是否在线": false
      }
    }
  },
  {
    "title": "Design an Array Statistics Tracker ",
    "slug": "design-an-array-statistics-tracker",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "一维数组 H[1..n]，其中 H[i] 表示第 i 个柱子的高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左右两侧最大高度的较小值决定",
        "independence": "左侧最大值和右侧最大值可独立维护",
        "global_consistency": "必须满足全局左右边界约束的一致性才能确定局部贡献"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "计算所有位置能接住的雨水总量",
        "output": "单个整数：总积水量"
      },
      "Algorithmic Invariant": {
        "technique": "双指针",
        "invariants": [
          "左指针 L 左侧的所有高度中最大值为 maxLeft",
          "右指针 R 右侧的所有高度中最大值为 maxRight",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水高度仅由 maxLeft 决定，且可安全累加并移动 L++",
          "反之若 maxRight < maxLeft，则位置 R 处的积水高度由 maxRight 决定，可累加并移动 R--",
          "已确定区域的解始终保持最优性和不可变性"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_range",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "default": "non-negative",
            "impact": "若允许负值，需重新定义积水逻辑或视为无效输入"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D",
              "circular"
            ],
            "default": "1D",
            "impact": "扩展至二维变为‘二维接雨水’问题（如 LeetCode 407），环形则需处理首尾连接"
          },
          {
            "name": "query_mode",
            "options": [
              "offline",
              "online"
            ],
            "default": "offline",
            "impact": "若支持在线更新（插入/删除/修改），需结合线段树或平衡结构"
          },
          {
            "name": "output_granularity",
            "options": [
              "total_sum",
              "per_position"
            ],
            "default": "total_sum",
            "impact": "若要求输出每个位置的积水量，则为构造类问题"
          },
          {
            "name": "data_updates",
            "options": [
              "static",
              "dynamic"
            ],
            "default": "static",
            "impact": "动态变化时需设计增量算法"
          },
          {
            "name": "multiple_test_cases",
            "options": [
              false,
              true
            ],
            "default": false,
            "impact": "多组数据下需注意初始化与复杂度均摊"
          }
        ]
      }
    }
  },
  {
    "title": "Find Special Substring of Length K",
    "slug": "find-special-substring-of-length-k",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，其中 1 <= n <= 100",
        "字符集：仅包含小写英文字母（a-z）",
        "整数 k，满足 1 <= k <= n",
        "输入为一维字符序列"
      ],
      "Core Constraint": [
        "目标子串必须是连续的、长度恰好为 k 的子字符串",
        "子串内所有字符相同（即只包含一个唯一字符）",
        "若子串前有字符，则该字符 ≠ 子串字符",
        "若子串后有字符，则该字符 ≠ 子串字符",
        "边界条件独立判断：前后字符存在性可变"
      ],
      "Objective Function": [
        "判定是否存在至少一个满足上述全部条件的长度为 k 的子串",
        "返回布尔值：true 表示存在，false 表示不存在"
      ],
      "Algorithmic Invariant": [
        "滑动窗口遍历所有长度为 k 的子串时，可在 O(n) 时间内完成枚举与验证",
        "对每个候选窗口 [i, i+k-1]，检查：",
        "  1. 窗口内字符是否全相同（通过遍历或预处理连续段）",
        "  2. 前驱字符（s[i-1]）是否存在且 ≠ s[i]",
        "  3. 后继字符（s[i+k]）是否存在且 ≠ s[i]",
        "一旦找到满足条件的窗口，即可提前终止（存在性判定）"
      ],
      "Transformable Parameters": [
        "k 的取值范围：固定长度 → 可变为 ≥k 或 ≤k 的变形",
        "n 的数量级：当前 ≤100 → 可扩展至 1e5，要求线性解法",
        "字符集类型：小写字母 → 支持大小写 / 数字 / Unicode",
        "是否允许多组数据输入",
        "是否在线处理流式字符串",
        "目标函数变换：计数满足条件的子串个数（而非仅判定存在）",
        "约束条件变化：取消前后字符不同限制 → 仅要求内部唯一字符",
        "输入结构变化：从普通字符串 → 环形字符串（首尾相连）"
      ]
    }
  },
  {
    "title": "Zigzag Grid Traversal With Skip",
    "slug": "zigzag-grid-traversal-with-skip",
    "schema": {
      "Input Structure": [
        "二维数组 grid[0..m-1][0..n-1]",
        "m x n 网格，其中 2 <= m <= 50, 2 <= n <= 50",
        "元素为正整数，1 <= grid[i][j] <= 2500"
      ],
      "Core Constraint": [
        "遍历路径由之字形规则唯一确定：奇数行从左到右，偶数行从右到左（或反之，取决于起始方向）",
        "在遍历序列中，必须跳过交替位置的单元格（即保留第1个、跳过第2个、保留第3个……）",
        "跳过操作作用于整个线性化的访问序列，而非按行独立处理"
      ],
      "Objective Function": "构造并返回一个整数数组 result，包含按之字形顺序访问且保留非交替位置（奇数索引位，0-indexed）的单元格值",
      "Algorithmic Invariant": [
        "遍历方向在相邻行之间翻转，形成确定性移动路径",
        "跳过规则基于全局访问序列的索引奇偶性（保留 index % 2 == 0 的元素）",
        "每一步移动都保持当前遍历位置与下一个有效方向的一致性",
        "无需回溯或状态选择，路径和采样策略均为确定性过程"
      ],
      "Transformable Parameters": {
        "grid dimensions": {
          "m": "可变范围：[2, 50] → 可扩展至更大规模或单行情况",
          "n": "可变范围：[2, 50] → 可支持不规则行长度（如锯齿阵列）"
        },
        "value domain": "正整数 → 可允许零或负数以增加干扰",
        "traversal pattern": [
          "之字形方向：可改为从右上开始，或列优先之字形",
          "翻转频率：每行翻转 → 每两行翻转"
        ],
        "skip rule": {
          "alternating skip": "跳过交替单元格（0-indexed 奇数位）→ 可改为偶数位、每k个跳过1个、或基于值的条件跳过"
        },
        "output requirement": [
          "仅返回结果数组 → 可要求返回坐标序列或可视化路径",
          "是否多组数据：当前单例 → 可改为多测输入"
        ],
        "input dynamics": "静态离线输入 → 可设计为在线流式网格块输入",
        "structural variation": "2D矩形网格 → 3D立方体层间之字形 / 环形首尾连接网格"
      }
    }
  },
  {
    "title": "Find the Most Common Response",
    "slug": "find-the-most-common-response",
    "schema": {
      "Input Structure": [
        "二维字符串数组 responses[1..n]",
        "每个 responses[i] 是一个字符串数组，表示第 i 天的回答列表",
        "字符串由小写英文字母组成，长度在 [1,10] 范围内",
        "1 <= n <= 1000, 1 <= len(responses[i]) <= 1000"
      ],
      "Core Constraint": [
        "每天的回答需先去重（即每组中同一回答最多贡献一次）",
        "频率统计基于‘天’的维度：每个回答在一天内无论出现多少次，只计一次",
        "最终频率为该回答出现在不同天数（去重后）的总次数"
      ],
      "Objective Function": [
        "找出所有回答中出现频率最高的那个",
        "若存在多个最高频回答，则返回字典序最小的那个"
      ],
      "Algorithmic Invariant": [
        "去重操作不改变跨天频率统计的一致性：同一天内重复回答不影响计数",
        "频率映射可增量构建：每处理一天，更新各回答的出现天数",
        "最优解具有全局可合并性：局部去重 + 全局计数可得最终结果",
        "字典序最小条件提供确定性选择规则，打破平局时的非唯一性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "responses.length": "可变范围：1–1e3 → 可扩展至 1e5（引入哈希优化）",
          "responses[i].length": "可变范围：1–1e3 → 可支持流式输入",
          "字符串长度": "当前 [1,10] → 可扩展至长字符串或含特殊字符"
        },
        "去重粒度": [
          "按天去重（当前设定）",
          "可改为按时间窗口去重（如连续两天相同回答仅计一次）",
          "可取消去重，变为原始频次统计"
        ],
        "频率定义": [
          "当前：跨天出现次数（二值：是否在当天出现）",
          "可变换为：加权频率（如按天活跃度加权）"
        ],
        "目标函数变体": [
          "求最大频率值（而非具体字符串）",
          "返回所有最高频回答（构造方案）",
          "目标变换：求第二高频且字典序最小等"
        ],
        "排序规则": [
          "当前：频率降序 + 字典序升序",
          "可改为：频率降序 + 字符串长度优先 + 字典序次之"
        ],
        "输入形式": [
          "当前：离线一次性输入",
          "可改为：在线流式添加新一天的回答",
          "支持删除某天数据（撤销操作）"
        ],
        "多组数据": "是否处理多组独立调查数据并分别输出"
      }
    }
  },
  {
    "title": "Smallest Substring With Identical Characters II",
    "slug": "smallest-substring-with-identical-characters-ii",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "binary string",
        "length": "n",
        "constraints": [
          "s.length == n",
          "1 <= n <= 10^5",
          "s[i] ∈ {'0', '1'}"
        ],
        "operations_allowed": {
          "operation": "flip",
          "target": "single character at index i",
          "limit": "at most numOps times",
          "numOps_range": "0 <= numOps <= n"
        }
      },
      "Core Constraint": {
        "structural_property": "longest contiguous substring of identical characters determines objective",
        "manipulation_impact": "flipping a bit can break or merge homogeneous segments",
        "tradeoff": "limited operations force strategic choice on where to flip to fragment long runs",
        "key_insight": "minimizing maximum run length requires distributing flips to split long uniform blocks"
      },
      "Objective Function": "minimize the length of the longest contiguous substring with all characters equal after at most numOps flip operations",
      "Algorithmic Invariant": {
        "binary_search_on_answer": true,
        "monotonicity": "if it's possible to achieve max run length ≤ L, then it's also possible for any L' ≥ L",
        "feasibility_check_invariant": "for a given target max length L, we can greedily traverse runs and compute minimum flips needed to ensure no segment exceeds L",
        "greedy_split_rule": "in a run of length r, the minimal number of flips required to break it into segments of length ≤ L is ⌈r / L⌉ - 1",
        "global_consistency": "total flips required across all maximal homogeneous substrings must not exceed numOps"
      },
      "Transformable Parameters": {
        "n_magnitude": [
          "1e1",
          "1e2",
          "1e3",
          "1e5"
        ],
        "numOps_availability": [
          "numOps = 0",
          "numOps small (e.g. O(log n))",
          "numOps up to n"
        ],
        "input_form": {
          "string_type": "binary",
          "extension_potential": [
            "ternary or k-ary string",
            "character-specific flip cost"
          ]
        },
        "operation_model": [
          "unlimited flip but minimize result",
          "exact numOps used",
          "online flip queries",
          "range flip instead of single flip"
        ],
        "output_form": [
          "return minimal maximum run length (scalar)",
          "return configuration achieving minimum",
          "count number of configurations achieving minimum"
        ],
        "additional_constraints": [
          "cannot flip adjacent indices consecutively",
          "must preserve overall parity of 1s",
          "cyclic string (i.e., s[n-1] adjacent to s[0])"
        ],
        "data_flow": [
          "offline: full s and numOps given upfront",
          "online: s arrives in chunks, incremental decision making"
        ]
      }
    }
  },
  {
    "title": "Find the Largest Almost Missing Integer",
    "slug": "find-the-largest-almost-missing-integer",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length": "n",
        "value_range": [
          0,
          50
        ],
        "constraints": [
          "nums.length >= 1",
          "nums[i] ∈ [0, 50]",
          "k ∈ [1, nums.length]"
        ],
        "subarray_definition": "continuous subsequence of length k"
      },
      "Core Constraint": {
        "definition": "an integer x is 'almost missing' if it appears in exactly one contiguous subarray of length k",
        "dependency": "occurrence count of x across all sliding windows of size k determines eligibility",
        "window_behavior": "each subarray of size k is considered independently, and element frequency is tracked per window"
      },
      "Objective Function": {
        "goal": "find the maximum integer x that appears in exactly one subarray of size k",
        "fallback": "return -1 if no such integer exists",
        "type": "maximization with existence filtering"
      },
      "Algorithmic Invariant": {
        "sliding_window_count": "as the window slides from left to right, the set of elements in the current window can be maintained in O(1) time using hash map updates",
        "frequency_tracking": "for each distinct value, the number of windows containing it can be computed via traversal and hashing",
        "monotonic_exclusion": "once a value appears in two or more windows, it can never become 'almost missing', though it may still affect max candidate until ruled out",
        "candidate_independence": "each integer's eligibility is independent; only its total window count matters"
      },
      "Transformable Parameters": {
        "n_magnitude": "small scale: n ≤ 50 → allows O(n²) or O(n*k) solutions",
        "k_variability": "k can range from 1 to n; extreme cases (k=1, k=n) change problem behavior",
        "value_domain": "integers are non-negative and bounded (≤50), enabling frequency array usage instead of hash maps",
        "ordering": "input array is arbitrary order; no monotonicity assumed",
        "data_modification": "offline static input; no updates or deletions",
        "online_query": "not required; single batch processing",
        "output_form": "return single integer (maximum valid x) or -1",
        "multiplicity_handling": "duplicate values allowed; each occurrence counted in respective windows",
        "extension_potential": [
          "change objective: count how many almost missing integers exist",
          "change constraint: appear in at least / at most k windows",
          "change input: circular array",
          "add constraints: require x to also satisfy parity or divisibility conditions"
        ]
      }
    }
  },
  {
    "title": "Count Partitions with Even Sum Difference",
    "slug": "count-partitions-with-even-sum-difference",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length": "n",
        "constraints": [
          "n == nums.length, 2 <= n <= 100",
          "nums[i] is integer, 1 <= nums[i] <= 100",
          "non-empty subarrays required"
        ]
      },
      "Core Constraint": {
        "partition_rule": "split at index i (0 <= i < n - 1) into left [0:i] and right [i+1:n-1]",
        "sum_difference_parity": "difference = sum(left) - sum(right), we care only about parity (evenness)",
        "mathematical_insight": "sum(left) - sum(right) ≡ sum(left) + sum(right) mod 2 ↔ total_sum mod 2 determines feasibility",
        "key_equivalence": "difference is even ↔ (sum(left) - sum(right)) % 2 == 0 ↔ (total_sum - 2 * sum(right)) % 2 == 0 ↔ total_sum % 2 == 0"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "count the number of partition indices i such that the difference of left and right subarray sums is even"
      },
      "Algorithmic Invariant": {
        "invariant": "The parity of the difference depends solely on the parity of the total array sum.",
        "proof_based_logic": [
          "If total_sum is even: then every partition yields an even difference because sum(left) - sum(right) = 2*sum(left) - total_sum ≡ 0 mod 2",
          "If total_sum is odd: then no partition can yield an even difference"
        ],
        "computation_rule": "Answer = n - 1 if total_sum % 2 == 0, else 0"
      },
      "Transformable Parameters": {
        "n_magnitude": "2 <= n <= 100 → can be scaled to 1e5 (forces O(1)/O(n) solution)",
        "value_domain": "positive integers → allow negative or zero values",
        "parity_target": "even difference → odd difference (objective transformation)",
        "input_structure": "1D array → circular array (partition wraps around)",
        "data_mode": "single instance → multiple test cases",
        "query_type": "offline static → online updates (point update + recompute valid partitions)",
        "output_requirement": "count only → return all valid indices or construct examples"
      }
    }
  },
  {
    "title": "First Letter Capitalization",
    "slug": "first-letter-capitalization",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "一维数组 H[1..n]，其中 H[i] 表示柱子的高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右边界约束可分离但需联合取 min",
        "global_dependency": true,
        "local_insufficiency": true,
        "description": "局部信息不足以确定积水，必须结合全局左右极值；左右最大值的最小值构成瓶颈约束"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "total water volume",
        "objective": "计算所有位置上能接住的雨水总量",
        "output_single_value": true
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariants": [
          "维护 left_max 和 right_max 分别表示左指针左侧与右指针右侧的最大高度",
          "若 left_max ≤ right_max，则 left 处的积水仅受限于 left_max，可安全累加贡献",
          "移动较小一侧的指针以探索可能更新极值的位置",
          "已处理区域的解是最终且不可变的（贪心正确性）"
        ],
        "monotonicity": "left_max 和 right_max 随指针移动单调不减",
        "optimality_preservation": "每次移动均保持未访问区间的最优子结构"
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          "0",
          "10^5"
        ],
        "allow_negative_heights": false,
        "input_dimensionality": [
          "1D",
          "2D (extension)"
        ],
        "input_form": "offline, static array",
        "online_updates": false,
        "mutable_array": false,
        "query_type": "single total result",
        "output_detail_level": [
          "total only",
          "per-position volume (adaptable)"
        ],
        "multiple_test_cases": false,
        "circular_array": false,
        "sorting_required": false,
        "transform_operators": [
          "输入维度变换：1D → 2D（二维接雨水）",
          "目标变换：求和 → 构造方案 / 最大单区间容量",
          "约束反转：固定地形 → 可调整高度下的最小代价排水",
          "数据流化：静态数组 → 支持单点修改的动态版本",
          "隐藏条件：显式高度数组 → 隐式生成（如通过栈操作还原）"
        ]
      }
    }
  },
  {
    "title": "Maximum Subarray With Equal Products",
    "slug": "maximum-subarray-with-equal-products",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "positive integer",
        "range": "1 <= nums[i] <= 10",
        "length": "2 <= n <= 100",
        "order": "ordered (sequence matters)",
        "duplicates": true
      },
      "Core Constraint": {
        "condition": "prod(arr) == lcm(arr) * gcd(arr)",
        "mathematical_property": "For any array arr, the identity prod(arr) = lcm(arr) * gcd(arr) holds only under specific structural constraints on the elements.",
        "key_insight": "The equality holds if and only if all elements in the subarray share a common prime factor structure such that their pairwise GCDs are sufficiently large to prevent LCM inflation beyond product scaling. In particular, for two elements: a * b = lcm(a,b) * gcd(a,b) always holds; for more than two elements, it generally fails unless all elements are equal or powers of the same base."
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "length of contiguous subarray",
        "objective_type": "optimization (longest subarray satisfying condition)"
      },
      "Algorithmic Invariant": {
        "invariant": "For every expanding window [l, r], maintain current gcd, lcm, and product, and check invariant: prod == lcm * gcd.",
        "monotonicity": "GCD is non-increasing as window expands; LCM is non-decreasing; product is strictly increasing.",
        "feasibility_check": "Once a window violates the condition, extending it further will not recover validity due to rapid growth of LCM relative to product when diverse primes are involved.",
        "window_shrink_rule": "When condition fails, shrink from left while updating state incrementally."
      },
      "Transformable Parameters": {
        "n_range": "2 <= n <= 100",
        "value_domain": "small positive integers (1 to 10), allows brute-force exploration",
        "prime_diversity": "limited (primes ≤ 7), enables precomputation and state compression",
        "ordering": "sequential input, contiguous subarray required",
        "data_mode": "offline, single instance",
        "output_form": "integer (length), not construction of solution",
        "extensions": [
          "allow negative integers (requires redefining gcd/lcm)",
          "change objective: count all valid subarrays (counting variant)",
          "require minimal length instead of maximal",
          "generalize to 2D grid with connected regions",
          "online version: process stream and answer queries about current longest valid suffix"
        ]
      }
    }
  },
  {
    "title": "Minimum Cost Good Caption",
    "slug": "minimum-cost-good-caption",
    "schema": {
      "Input Structure": {
        "type": "string",
        "length": "n",
        "domain": "lowercase English letters",
        "constraints": [
          "1 <= n <= 5 * 10^4",
          "caption[i] ∈ {'a', 'b', ..., 'z'}"
        ]
      },
      "Core Constraint": {
        "structural": "A character is valid only if it belongs to a contiguous group of length ≥ 3",
        "grouping": "Maximal contiguous segments (by same char) define validity: every char must be in a segment with length ≥ 3",
        "transformation": "Each character can be incremented or decremented in alphabet (except at 'a' or 'z')",
        "dependency": "Operations on one position may affect grouping; changes can merge/split groups"
      },
      "Objective Function": {
        "primary": "minimize total number of operations (transformations)",
        "secondary": "among all optimal solutions, return lexicographically smallest result",
        "fallback": "return \"\" if no valid good title exists"
      },
      "Algorithmic Invariant": {
        "dynamic_segmentation": "After any transformation, the grouping structure (run-length encoding) must be re-evaluated",
        "monotonic_cost": "Changing a character toward neighboring characters in alphabet has unit cost; optimal path between chars is shortest path in linear graph",
        "local_optimality_in_groups": "For a segment to be valid, extending or creating runs of ≥3 is preferred; isolated chars or pairs must be merged or transformed",
        "lex_order_preservation_rule": "When multiple minimal-cost results exist, prefer earlier alphabet chars in earliest differing position",
        "irreversibility_of_decision": "Once a region is transformed into a long-enough run and surrounded by higher-barrier chars, it becomes fixed (greedy choice)"
      },
      "Transformable Parameters": {
        "n_range": [
          "[1, 5*10^4]",
          "can scale to 10^5+"
        ],
        "alphabet_type": [
          "lowercase",
          "uppercase",
          "arbitrary discrete ordered set"
        ],
        "minimum_run_length": [
          "3 (fixed in problem)",
          "can be parameterized as k"
        ],
        "operation_set": [
          "only ±1 in alphabet",
          "extended: jump to any char with cost = abs diff",
          "restricted: only decrease allowed"
        ],
        "output_requirement": [
          "full string output",
          "only operation count",
          "also return transformation sequence"
        ],
        "input_mode": [
          "single string",
          "multiple test cases",
          "online queries with updates"
        ],
        "optimality_criteria": [
          "min operations + lex min",
          "only min operations",
          "min operations + max compression",
          "constrained: cannot use certain chars"
        ],
        "circular_string": [
          "linear (default)",
          "circular: first and last are adjacent"
        ]
      }
    }
  },
  {
    "title": "Subsequences with a Unique Middle Mode I",
    "slug": "subsequences-with-a-unique-middle-mode-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          -1000000000,
          1000000000
        ],
        "constraints": [
          "length >= 5 and <= 1000",
          "elements are integers (possibly negative)",
          "order preserved (subsequence, not subarray)"
        ]
      },
      "Core Constraint": {
        "description": "A valid subsequence of size 5 must have its middle element (at index 2) be the unique mode (appears more times than any other element in the subsequence).",
        "conditions": [
          "The central element (seq[2]) must appear strictly more times than every other element in the 5-element subsequence.",
          "Subsequence maintains relative order from original array."
        ],
        "implication": "For a fixed central candidate, we need to count combinations of two elements before and two after such that no other number appears ≥ frequency of center."
      },
      "Objective Function": {
        "goal": "count",
        "target": "number of size-5 subsequences where the middle element is the unique mode",
        "output_mod": 1000000007
      },
      "Algorithmic Invariant": {
        "invariants": [
          "Fixing the central element's position in the original array allows independent counting of valid left and right pairs.",
          "For a fixed center at index k, choose two indices i < k and two indices j > k such that when combined, the value at k dominates in frequency.",
          "Frequency of center in the 5-tuple is at least 1 + count of duplicates chosen on left/right; must exceed all others.",
          "Counting can be optimized by precomputing frequencies and using combinatorial aggregation under constraints."
        ],
        "optimization_potential": "Iterate over possible center positions, group by value, and use frequency-aware combination selection to avoid O(n^5)."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "subsequence_size",
            "type": "integer",
            "default": 5,
            "range": [
              3,
              10
            ],
            "description": "Change size of subsequence; affects required dominance condition"
          },
          {
            "name": "uniqueness_condition",
            "type": "constraint",
            "options": [
              "strictly_greater_frequency",
              "at_least_as_much",
              "tie_allowed_if_center_selected"
            ],
            "description": "Relax or tighten what counts as 'unique' mode"
          },
          {
            "name": "modulus",
            "type": "integer",
            "default": 1000000007,
            "options": [
              1000000007,
              998244353,
              null
            ],
            "description": "Whether to apply modulo, and which one"
          },
          {
            "name": "input_ordering",
            "type": "boolean",
            "default": false,
            "options": [
              true,
              false
            ],
            "description": "Whether input is sorted or arbitrary"
          },
          {
            "name": "data_stream",
            "type": "mode",
            "options": [
              "offline",
              "online_query",
              "dynamic_updates"
            ],
            "description": "Support for streaming or updating array"
          },
          {
            "name": "output_type",
            "type": "string",
            "options": [
              "count_only",
              "list_all_subsequences",
              "reconstruct_one_example"
            ],
            "description": "Change output form"
          },
          {
            "name": "duplicate_handling",
            "type": "frequency_constraint",
            "options": [
              "allow_duplicates",
              "distinct_values_only",
              "bounded_frequency_per_value"
            ],
            "description": "Add constraints on how many times a value may appear"
          }
        ]
      }
    }
  },
  {
    "title": "Count Special Subsequences",
    "slug": "count-special-subsequences",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "positive integer",
        "size_range": [
          7,
          1000
        ],
        "value_range": [
          1,
          1000
        ],
        "description": "一维数组 nums[1..n]，元素为正整数，长度在 [7, 1000] 范围内"
      },
      "Core Constraint": {
        "subsequence_length": 4,
        "index_constraints": [
          "p < q < r < s",
          "q - p > 1",
          "r - q > 1",
          "s - r > 1"
        ],
        "algebraic_condition": "nums[p] * nums[r] == nums[q] * nums[s]",
        "description": "特殊子序列由四个下标 (p, q, r, s) 构成，满足严格递增且相邻下标间隔至少为2；数值满足交叉乘积相等条件"
      },
      "Objective Function": {
        "type": "counting",
        "target": "number of distinct special subsequences",
        "description": "统计满足条件的、不同的四元组 (p, q, r, s) 的数量"
      },
      "Algorithmic Invariant": {
        "invariant_type": "multiplicative pairing with index separation",
        "key_observations": [
          "将等式变形为 nums[p]/nums[q] == nums[s]/nums[r]，可考虑以比值为状态进行计数",
          "枚举中间两个位置 q 和 r，利用哈希表记录左侧 (p, q) 对的比值频次，右侧 (r, s) 动态匹配",
          "由于有间隔约束（q-p>1, r-q>1, s-r>1），可在遍历中分阶段维护合法前驱对"
        ],
        "optimal_substructure": "对于固定 (q, r)，满足条件的 (p, q) 和 (r, s) 可独立统计并组合",
        "monotonicity_or_partitioning": "按位置顺序推进，确保 p < q < r < s 且满足间隙约束"
      },
      "Transformable Parameters": {
        "n_scale": [
          "small n ≤ 1000",
          "medium n ≤ 1e4 (requires optimization)",
          "large n → requires O(n^2 log n) or better"
        ],
        "value_domain": [
          "positive integers",
          "allow negative?",
          "allow zero?"
        ],
        "ratio_representation": [
          "use floating point",
          "use reduced fraction (pair of integers)"
        ],
        "subsequence_length": "can be generalized to length-k sequence with alternating product constraints",
        "spacing_constraint": [
          "minimum gap = 2 (current)",
          "generalized to gap ≥ k",
          "variable gaps"
        ],
        "algebraic_form": [
          "nums[p] * nums[r] == nums[q] * nums[s]",
          "transformed: nums[p]/nums[q] == nums[s]/nums[r]",
          "generalized: multiplicative chain over subsequence"
        ],
        "input_mode": [
          "single array",
          "multiple queries",
          "online insertion / deletion"
        ],
        "output_requirement": [
          "count only",
          "list all valid quadruples",
          "modulo arithmetic (e.g., return count mod 1e9+7)"
        ],
        "uniqueness_definition": [
          "distinct by indices (default)",
          "distinct by values?"
        ]
      }
    }
  },
  {
    "title": "Minimum Operations to Make Subarray Elements Equal",
    "slug": "minimum-operations-to-make-subarray-elements-equal",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 H[1..n]，表示每个位置的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度中的较小值决定，且仅当该最小值大于 H[i] 时才能储水",
        "property": "左右边界约束独立但需全局一致，局部储水能力依赖于全局极值信息"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组所有位置能够接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L = 0 和 R = n-1，分别从左右两端向中间推进",
          "维护 maxLeft 表示 H[0..L] 的最大值，maxRight 表示 H[R..n-1] 的最大值",
          "若 maxLeft ≤ maxRight，则位置 L 的储水量可由 maxLeft - H[L] 确定（因为左侧瓶颈已知，右侧不会提供更小瓶颈）",
          "同理，若 maxRight < maxLeft，则 R 处的储水量可确定",
          "每次移动对应端点指针，不破坏已计算区域的最优性"
        ],
        "proof_observe": "由于贡献值取决于 min(left_max, right_max)，当一端较小时，其对应位置的瓶颈已被确定，无需等待另一端完全扫描"
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 1e5",
          "可扩展至 1e7（要求 O(n)）",
          "或缩小至 1e3 支持 DP"
        ],
        "value_range": "H[i] >= 0，可变参数：是否允许负数（如地形凹陷建模）",
        "order_property": "原始无序；可设定为部分有序或单调序列以构造特殊情形",
        "circular": false,
        "online": false,
        "input_form": "单组离线输入；可改为多组测试用例或流式数据输入",
        "output_detail": "仅输出总和；可变形为输出每个位置的储水量或可视化方案",
        "dimension_extension": "可推广到二维网格（2D 接雨水问题）",
        "operation_support": "静态数组；可加入更新操作变为支持修改的动态版本"
      }
    }
  },
  {
    "title": "Minimum Increments for Target Multiples in an Array",
    "slug": "minimum-increments-for-target-multiples-in-an-array",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n], 其中 n = |nums|, nums[i] ∈ [1, 10^4]",
        "一维数组 target[1..m], 其中 m = |target| ≤ 4, target[j] ∈ [1, 10^4]",
        "所有数值为正整数",
        "允许重复元素"
      ],
      "Core Constraint": [
        "每个 target[j] 必须在 nums 中存在至少一个元素 x，使得 x 是 target[j] 的倍数（即 x mod target[j] == 0）",
        "只能对 nums 中的元素执行递增操作（每次 +1）",
        "操作次数等于所有增量之和",
        "由于 target 长度很小（≤4），可枚举匹配策略或状态压缩分配"
      ],
      "Objective Function": "最小化使 nums 中存在每个 target[j] 的倍数所需的操作次数总和",
      "Algorithmic Invariant": [
        "对于任意 target[j]，使其被满足的最优方式是：将某个 nums[i] 增加到不小于 target[j] 且是其倍数的最小值（即 ceil(nums[i] / target[j]) * target[j]）",
        "贪心选择不变性：若当前 nums[i] 能以较少增量成为某个 target[j] 的倍数，则优先考虑该配对",
        "状态可分离性：每个 target[j] 可独立寻找最省操作的 nums[i] 来满足，但需避免重复使用同一 nums[i] 导致冲突 —— 因此需要全局匹配优化",
        "由于 m ≤ 4，可通过状态压缩动态规划或全排列枚举实现最优分配：保证每个 target[j] 被唯一覆盖，且总代价最小"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 <= n <= 5 * 10^4",
          "m": "1 <= m <= 4, 且 m <= n"
        },
        "值域范围": "nums[i], target[j] ∈ [1, 10^4]",
        "是否有序": "nums 和 target 均无序",
        "是否多组数据": false,
        "是否在线": false,
        "操作类型限制": "仅允许递增，不允许递减或修改多个位置同时进行",
        "倍数方向变换": "可改编为 'nums 中元素是 target 的约数' 或 'target 是 nums 的倍数'",
        "目标函数变换": "从最小操作次数 → 是否能在 K 次内完成（判定问题）",
        "输入维度扩展": "扩展至二维数组或树上节点取值",
        "约束反转": "改为要求每个 nums[i] 成为某个 target[j] 的倍数（角色互换）",
        "隐藏条件添加": "隐式单调性：如 nums 已排序，可剪枝搜索空间"
      }
    }
  },
  {
    "title": "Count Substrings Divisible By Last Digit",
    "slug": "count-substrings-divisible-by-last-digit",
    "schema": {
      "Input Structure": "一维字符串 s[1..n]，其中每个字符为数字字符 '0'-'9'，表示一个仅包含数字的序列；子字符串定义为连续非空子串。",
      "Core Constraint": "一个子字符串能否被其最后一位整除，取决于该子字符串所代表的整数值（允许前导零）对最后一个字符对应数字 d 的模运算结果是否为 0；d ≠ 0 是前提条件。",
      "Objective Function": "计数：统计所有最后一位不是 '0' 的子字符串中，数值能被其最后一位数字整除的子字符串个数。",
      "Algorithmic Invariant": "对于以位置 i 结尾、且末位数字为 d (d ≠ 0) 的子字符串，若其前缀构成的数值 mod d 等于 0，则该子字符串满足条件；可通过遍历结束位置，并维护从不同起始点开始的模 d 状态进行增量更新，避免重复计算；状态转移具有可叠加性与模意义下的递推不变性。",
      "Transformable Parameters": {
        "n 的数量级": "1e5，要求线性或近线性解法",
        "值域": "字符仅限 '0'-'9'，无其他符号",
        "是否有序": "输入顺序固定，不可重排",
        "是否循环": "否，为线性字符串",
        "是否多组输入": "可扩展为多测案例",
        "是否在线": "当前为离线输入，可改造为流式字符输入下的动态查询",
        "前导零处理": "显式允许，需正确解析数值含义（如 '01' 视为 1）",
        "目标变换": "可改为最小化/最大化满足条件的子串长度，或判定是否存在某个特定性质的子串",
        "约束反转": "可改为最后一位是 0 的子串中，被某固定数整除的计数",
        "输出形式": "可要求输出具体子串列表或区间索引"
      }
    }
  },
  {
    "title": "Books with NULL Ratings",
    "slug": "books-with-null-ratings",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度中的较小值决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组中能接住的雨水总量（求和）",
      "Algorithmic Invariant": "维护两个指针 L 和 R 分别从左右两端向中间移动，同时记录 left_max 和 right_max；当 left_max ≤ right_max 时，L 处的积水可以确定；反之则 R 处的积水可以确定；指针移动过程中不破坏已计算区域的正确性",
      "Transformable Parameters": {
        "H 是否允许负值": false,
        "维度扩展": "可扩展至二维矩阵（如 2D 接雨水问题）",
        "输入模式": "支持离线批量输入或在线流式输入",
        "操作类型": "可加入单点更新、区间修改等动态操作",
        "输出要求": "可要求输出总水量、每列水量分布、最大连续蓄水区间等",
        "数据规模 n": "1 ≤ n ≤ 3×10^4",
        "值域范围": "0 ≤ H[i] ≤ 10^5",
        "是否多组数据": false,
        "是否有序": false,
        "是否环形结构": false
      }
    }
  },
  {
    "title": "Minimum Total Operations",
    "slug": "minimum-total-operations",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "Given an integer array height of length n, where each element represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The area formed between two lines and the x-axis is determined by the distance between them and the shorter of the two heights.",
        "key_insight": "To maximize area, both span (width) and bottleneck height matter; choosing optimal pairs requires balancing these factors.",
        "structure_property": "No three-line combination can exceed the best two-line container due to geometric constraints."
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "the maximum amount of water that can be contained between any two lines"
      },
      "Algorithmic Invariant": {
        "invariant": "Two-pointer monotonic convergence",
        "rules": [
          "Initialize left = 0, right = n - 1",
          "At each step, the smaller height side has no incentive to stay: all future wider containers are impossible (since width decreases), so advancing the shorter end preserves optimality",
          "Maintain maxArea as candidate solution during traversal",
          "Pointer movement is irreversible and safe — no optimal solution is skipped"
        ],
        "proof_basis": "Greedy choice property: advancing the shorter pointer does not lose the global optimum because the current pair involving the shorter bar cannot form a better container with any inner bar."
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 1e5",
          "small_n: n <= 100"
        ],
        "value_domain": "height[i] >= 0, optionally extend to negative for variant",
        "input_form": "single array",
        "multiple_queries": false,
        "online_input": false,
        "modifications_allowed": false,
        "output_type": "single integer (maximum area)",
        "variants": [
          "2D version: matrices with topography",
          "Circular arrangement: connect first and last elements",
          "Count number of valid containers above threshold K",
          "Minimum area ≥ K? (decision problem)",
          "Support update operations (dynamic version)"
        ]
      }
    }
  },
  {
    "title": "Minimum Time to Break Locks II",
    "slug": "minimum-time-to-break-locks-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given a 1D array H[1..n], where H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The water trapped at each position is determined by the minimum of the maximum height to the left and the maximum height to the right, minus the current height.",
        "key_insight": "Left and right maxima are independent but must be globally consistent; local information is insufficient without preprocessing or dual traversal."
      },
      "Objective Function": {
        "goal": "sum",
        "description": "Compute the total amount of rainwater that can be trapped after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers (L, R) move toward each other while maintaining the left-max and right-max values. If maxLeft <= maxRight, then the water at L is solely constrained by maxLeft (and vice versa for R). The movement preserves correctness of accumulated result."
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          0,
          "10^5"
        ],
        "is_sorted": false,
        "is_circular": false,
        "multiple_test_cases": false,
        "online_queries": false,
        "modifications_allowed": false,
        "output_detail": "total sum only",
        "variants": [
          "Allow negative heights (interpret as underground segments)",
          "Extend to 2D grid (trapping rainwater in matrix)",
          "Query-based: support update operations (dynamic version)",
          "Output per-position contribution instead of total",
          "Change objective: find maximum contiguous segment with non-zero trap"
        ]
      }
    }
  },
  {
    "title": "Shortest Matching Substring",
    "slug": "shortest-matching-substring",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，1 <= n <= 1e5，仅含小写英文字母",
        "模式字符串 p，长度为 m，2 <= m <= 1e5，仅含小写英文字母且恰好包含两个 '*' 字符"
      ],
      "Core Constraint": [
        "模式 p 被划分为三个部分：前缀（第一个 '*' 前）、中段（两个 '*' 之间）、后缀（第二个 '*' 后）",
        "两个 '*' 可匹配任意字符序列（包括空序列），因此整个模式匹配形式为：s 的某个子串 = prefix + middle + suffix，其中 middle 可为任意字符串",
        "前缀和后缀必须精确匹配"
      ],
      "Objective Function": "在所有与 p 匹配的 s 的子字符串中，求长度最短的一个；若不存在则返回 -1",
      "Algorithmic Invariant": [
        "最短匹配必然以某个满足前缀匹配的位置开始，以某个满足后缀匹配的位置结束",
        "固定前缀匹配的起始位置 i 和后缀匹配的结束位置 j，当 i <= j 且中间部分可容纳时，存在一个合法匹配子串 s[i:j+1]",
        "枚举所有可能的前缀结束位置和后缀开始位置，利用双指针或预处理哈希加速匹配判定",
        "最优解的结构具有单调性：若从 i 开始、j 结束能匹配，则更长的区间也匹配，因此最小化 j - i"
      ],
      "Transformable Parameters": {
        "p 中 '*' 的数量": {
          "原题": "恰好两个",
          "可变形式": "一个、多个、任意数量"
        },
        "p 中通配符类型": {
          "原题": "'*' 匹配任意序列",
          "可变形式": "加入 '?' 匹配单字符，或正则类表达式"
        },
        "目标函数形式": [
          "最短匹配子串长度（当前）",
          "最长匹配子串长度",
          "匹配子串个数",
          "是否存在匹配"
        ],
        "输入维度": [
          "一维字符串匹配（当前）",
          "二维网格中路径匹配",
          "多文本并行匹配"
        ],
        "数据流形式": [
          "静态离线输入（当前）",
          "在线查询模式 p",
          "动态更新字符串 s"
        ],
        "约束条件变化": [
          "p 必须覆盖整个 s → 子串匹配（当前）",
          "允许重叠匹配 / 不允许重叠",
          "要求输出具体子串而非长度"
        ],
        "是否多组数据": false,
        "值域扩展": [
          "支持大写字母、数字、特殊字符",
          "支持 Unicode 字符串"
        ]
      }
    }
  },
  {
    "title": "Minimum Operations to Make Columns Strictly Increasing",
    "slug": "minimum-operations-to-make-columns-strictly-increasing",
    "schema": {
      "Input Structure": "二维非负整数矩阵 grid[1..m][1..n]",
      "Core Constraint": "每列必须严格递增，即对任意 j ∈ [1, n]，有 grid[1][j] < grid[2][j] < ... < grid[m][j]；操作只能增加元素值，不能减少",
      "Objective Function": "最小化总操作次数（所有元素增加值之和）",
      "Algorithmic Invariant": "每列可独立处理；在保证严格递增的前提下，贪心地使每个位置取满足约束的最小可能值（即前一个元素 + 1 和原值中的较大者），从而局部最优解构成全局最优解",
      "Transformable Parameters": {
        "数据规模": {
          "m": "1 <= m <= 50",
          "n": "1 <= n <= 50"
        },
        "值域": "0 <= grid[i][j] < 2500",
        "是否可修改操作类型": "仅允许增加值（不可减）",
        "目标序列性质": "严格递增（可变换为非严格递增）",
        "输入维度": "可扩展至三维或更高维数组",
        "是否多组数据": false,
        "是否在线": false,
        "列间约束": "当前无列间依赖（可引入如‘所有列总和最小’等跨列目标进行变形）"
      }
    }
  },
  {
    "title": "Smallest Substring With Identical Characters I",
    "slug": "smallest-substring-with-identical-characters-i",
    "schema": "{\n  \"Input Structure\": [\n    \"二进制字符串 s，长度为 n\",\n    \"s[i] ∈ {'0', '1'}\",\n    \"整数 numOps，表示最多可执行的操作次数\",\n    \"1 <= n <= 1000\",\n    \"0 <= numOps <= n\"\n  ],\n  \"Core Constraint\": [\n    \"翻转操作可以改变任意位置的字符（'0' ↔ '1'）\",\n    \"目标是打破长连续段，通过有限次翻转最小化最长连续相同字符子串\",\n    \"最优策略需在关键位置插入断点以分割大块相同字符段\",\n    \"翻转代价固定为1，每翻转一次消耗一次操作\"\n  ],\n  \"Objective Function\": \"最小化操作后字符串中最长相同字符连续子串的长度\",\n  \"Algorithmic Invariant\": [\n    \"若当前最长连续段长度为 L，则可通过在其内部每隔 k 个字符插入翻转点，将其分割为多个 ≤k 的段\",\n    \"对于给定的目标最大长度 k，判断是否能在 numOps 次内将所有过长连续段合法分割，具有单调性：k 可行 ⇒ 所有 >k 均可行\",\n    \"因此可在答案空间 [1, n] 上二分搜索最小可行的 k\",\n    \"验证函数：对每个连续段长度 len，若 len > k，则至少需要 ⌈len / (k+1)⌉ 个翻转将其拆分为 ≤k 的段（贪心放置）\"\n  ],\n  \"Transformable Parameters\": {\n    \"n 的数量级\": \"1e3 → 可扩展至 1e5（要求线性或 O(n log n) 解法）\",\n    \"字符集\": \"二进制 → 多进制字符串（如 '0','1','2'）\",\n    \"操作类型\": \"仅翻转 → 支持插入/删除/替换\",\n    \"操作限制\": \"总次数限制 → 不同字符操作成本不同\",\n    \"目标函数变换\": \"最小化最长连续段 → 最大化最短连续段 / 计数长度恰好为 k 的段\",\n    \"约束反转\": \"最小化最大长度 → 要求最大长度 ≤ K，问最少操作数\",\n    \"输入形式\": \"单串 → 多串统一处理 / 环形字符串\",\n    \"是否在线\": \"静态输入 → 动态修改 + 查询\",\n    \"是否多组数据\": \"否 → 是，T 组测试用例\"\n  }\n}\n```\n\n---\n\n### ✅ 母题定位说明：\n\n**Schema 名称：**  \n**基于二分答案与贪心验证的连续段分割问题**\n\n**分类路径（考纲层级）：**\n\n1. **第一层（输入结构）：** Sequence（一维字符串）\n2. **第二层（核心约束）：** 局部连续性可被有限操作破坏、答案单调性\n3. **第三层（经典解法范式）：**  \n   - 主解法：**二分答案 + 贪心验证**  \n   - 辅助技巧：滑动窗口预处理连续段\n4. **第四层（叶子节点母题）：** 是 —— 因为此题的最优解法在竞赛中几乎是唯一的（二分+贪心），暴力或 DP 无法满足高阶复杂度需求。\n\n> 🔹 存在替代思路？  \n> 尽管可考虑 DP 或 BFS 枚举翻转位置，但在 `n=1000` 下不可行；而二分+贪心是唯一能在较大规模下成立的方法，故仍视为“几乎唯一最优解”。\n\n> 🔹 是否适合改编？  \n> 非常适合。通过 `Transformable Parameters` 中的算子可生成大量变体，例如：\n> - 目标变换：从“最小化最大”变为“最大化最小”\n> - 输入维度：1D → 环形字符串\n> - 数据流化：支持动态更新和查询\n> - 成本模型：不同字符翻转代价不同\n\n该 schema 是一个典型的 **叶子节点 Problem Schema**，符合直接出题、可系统化衍生的要求。"
  },
  {
    "title": "Maximum Area Rectangle With Point Constraints II",
    "slug": "maximum-area-rectangle-with-point-constraints-ii",
    "schema": {
      "Input Structure": {
        "type": "two arrays of integers",
        "description": "Two integer arrays xCoord[1..n] and yCoord[1..n], where each (xCoord[i], yCoord[i]) represents a unique point on the 2D plane.",
        "constraints": [
          "1 <= n <= 2 * 10^5",
          "0 <= xCoord[i], yCoord[i] <= 8 * 10^7",
          "All points are distinct"
        ],
        "coordinate_system": "Cartesian, axis-aligned",
        "dimension": "2D"
      },
      "Core Constraint": {
        "geometric_constraint": "Rectangle must have sides parallel to the coordinate axes",
        "vertex_constraint": "Four vertices of the rectangle must be from the given set of points",
        "exclusion_constraint": "No other point (from the input) may lie inside or on the boundary of the rectangle",
        "combinatorial_constraint": "Only axis-aligned rectangles are considered; diagonal alignment is not allowed"
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "area of the rectangle",
        "output_type": "integer",
        "failure_case": "return -1 if no valid rectangle exists"
      },
      "Algorithmic Invariant": {
        "grouping_by_coordinates": "Points can be grouped by x- and y-coordinates to identify potential vertical and horizontal edges",
        "candidate_rectangle_generation": "For any two distinct x-values and two distinct y-values forming a rectangle, check if all four corner points exist in the input set",
        "point_in_rectangle_check": "A point (a,b) lies inside or on the boundary of rectangle defined by (x1,y1), (x2,y2) (with x1<x2, y1<y2) iff x1 <= a <= x2 and y1 <= b <= y2",
        "pruning_invariant": "Larger rectangles enclose more area and are more likely to contain extra points; thus, candidate rectangles should be evaluated in descending order of area for early termination optimization",
        "existence_check_optimization": "Use hash set (e.g., danliverin: store (x,y) pairs as strings or tuples) to enable O(1) lookup for corner existence"
      },
      "Transformable Parameters": {
        "n_magnitude": "1 <= n <= 2e5 → affects brute-force feasibility; requires optimized enumeration",
        "value_range": "Coordinates up to 8e7 → rules out coordinate compression in some cases unless necessary",
        "uniqueness_of_points": "All points are unique → simplifies duplicate handling",
        "rectangle_orientation": "Fixed: axis-aligned only. Can be transformed to rotated rectangles in variants",
        "inclusion_criteria": "Boundary and interior exclusion is strict. Can be relaxed in variants (e.g., allow boundary points)",
        "data_input_mode": "Offline batch input. Can be modified to online streaming of points",
        "multi_query_support": "Single query now. Could extend to multiple queries over dynamic point sets",
        "output_requirement": "Return maximum area only. Could change to return coordinates or count valid rectangles"
      }
    }
  },
  {
    "title": "Maximize Subarray Sum After Removing All Occurrences of One Element",
    "slug": "maximize-subarray-sum-after-removing-all-occurrences-of-one-element",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 1 <= n <= 1e5，-1e6 <= nums[i] <= 1e6",
      "Core Constraint": "至多执行一次操作：删除数组中所有值为某个整数 X 的元素；操作后数组非空；每个候选删除值 X 必须在原数组中存在",
      "Objective Function": "在所有可能通过至多一次删除操作得到的数组中，求最大子数组和（即最大连续子序列和）",
      "Algorithmic Invariant": "1. 最大子数组和可通过分治或动态规划（Kadane算法）在线性时间内求解；\n2. 删除某数值 X 相当于将原数组中所有 X 的位置断开，形成若干连续段；\n3. 对每个候选 X，其删除后的最大子数组和等于这些连续段中的最大子段和；\n4. 枚举每个可删除的 X 时，可通过预处理前缀段与后缀段的最大子数组信息，实现高效合并计算",
      "Transformable Parameters": [
        "n 的数量级：1e5（当前），可扩展至 2e5 或支持多组数据",
        "值域范围：nums[i] ∈ [-1e6, 1e6]，可调整为正数限制或更大范围",
        "是否允许零次操作：当前允许，可改为强制执行一次操作",
        "是否允许多次删除操作：当前为至多一次，可变换为 k 次或无限次",
        "删除目标：当前是删除所有等于 X 的元素，可改为删除满足某种条件的元素（如奇数、大于阈值等）",
        "输入形式：当前为静态离线数组，可变为在线流式输入",
        "目标函数变化：可改为最小化最大子数组和、最大化最小子数组和、计数最优方案数",
        "子数组类型变化：可改为子序列、子集、必须包含特定元素等"
      ]
    }
  },
  {
    "title": "Longest Special Path",
    "slug": "longest-special-path",
    "schema": {
      "Input Structure": [
        "无向树 T = (V, E), 其中 |V| = n, 节点编号为 0 到 n-1",
        "边集 edges: 每条边为 [u, v, length], 表示节点 u 和 v 之间有权重（长度）为 length 的无向边",
        "节点值数组 nums[0..n-1], nums[i] 表示节点 i 的值",
        "树以根节点 0 为起点进行遍历（可建为有向父子结构）"
      ],
      "Core Constraint": [
        "特殊路径必须是从祖先到后代的简单路径（向下路径）",
        "路径上所有经过的节点值互不相同（即路径上任意两个节点 i, j，若 i ≠ j，则 nums[i] ≠ nums[j]）",
        "路径可以仅包含一个节点（长度为 0）"
      ],
      "Objective Function": [
        "result[0]: 所有满足条件的特殊路径中的最大长度（按边权和计算）",
        "result[1]: 在所有长度等于 result[0] 的最长特殊路径中，具有最少节点数目的那条路径的节点数量"
      ],
      "Algorithmic Invariant": [
        "使用树形 DP 或 DFS 回溯维护从当前节点向上延伸的合法路径状态",
        "在 DFS 过程中维护已访问的节点值集合（或位掩码 / 哈希集合），确保路径值唯一性",
        "合并子树信息时，若两子路径通过当前节点连接形成更长路径，需保证三者值不冲突（当前节点、左子路径、右子路径）",
        "每条路径只统计一次，且仅允许从祖先到后代方向，避免重复枚举"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 5 * 10^4",
        "边权范围": "1 <= length_i <= 1000",
        "节点值域": "0 <= nums[i] <= 5 * 10^4，允许重复，但路径内不可重复",
        "是否允许多次查询": "当前为单次离线输入，可扩展为支持动态修改节点值/边权的在线版本",
        "树结构变体": [
          "有向树 → 无向树建图",
          "是否环形：否（限定为树）",
          "是否森林：否（保证连通）"
        ],
        "路径定义变化": [
          "目标函数变换：求最长路径数目（计数）而非最值",
          "约束反转：允许最多 k 个重复值（转化为带限制的路径问题）",
          "输入维度变换：从树升级为 DAG 上的路径问题",
          "隐藏条件：节点值非显式给出，而是由某种函数生成（如哈希、索引映射）"
        ],
        "输出形式": [
          "当前输出为 [max_length, min_node_count_among_max]",
          "可变为仅求长度、仅求节点数、或输出具体路径方案"
        ]
      }
    }
  },
  {
    "title": "Count Beautiful Splits in an Array",
    "slug": "count-beautiful-splits-in-an-array",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 1 <= n <= 5000，0 <= nums[i] <= 50，元素可重复",
      "Core Constraint": "数组被划分为三个非空连续子数组 nums1, nums2, nums3；要求满足：nums1 是 nums2 的前缀，或 nums2 是 nums3 的前缀。前缀定义为从数组起始位置开始的连续子数组。",
      "Objective Function": "计数所有满足条件的美丽分割方案数目",
      "Algorithmic Invariant": "对于每个可能的分割点 (i, j)，其中 i 为 nums1 结束位置，j 为 nums2 结束位置（即 nums1 = nums[1..i], nums2 = nums[i+1..j], nums3 = nums[j+1..n]），可通过字符串匹配或数组比较验证前缀关系；前缀判断具有局部确定性，且一旦子数组边界固定，其前缀性质不变。",
      "Transformable Parameters": {
        "数据规模": "n 的范围可调整（当前：1~5000）",
        "值域范围": "nums[i] 的取值范围可扩展或限制",
        "是否允许空子数组": "当前约束为非空，可改为允许/禁止空段",
        "前缀条件组合方式": "可变为 '且' 关系、多重前缀链（如 nums1 是 nums2 前缀且 nums2 是 nums3 前缀）",
        "分段数量": "可推广为 k 段分割，要求相邻段间存在前缀关系",
        "是否在线处理": "输入是否流式到达，需动态维护分割状态",
        "是否要求构造方案": "当前仅计数，可变更为输出所有分割位置"
      }
    }
  },
  {
    "title": "Count Subarrays of Length Three With a Condition",
    "slug": "count-subarrays-of-length-three-with-a-condition",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": [
          3,
          100
        ],
        "value_range": [
          -100,
          100
        ],
        "description": "一维整数数组 nums[1..n]，长度 n 满足 3 <= n <= 100，元素值在 [-100, 100] 范围内"
      },
      "Core Constraint": {
        "constraint": "子数组必须连续且长度为 3",
        "relation": "对于三元组 (a, b, c)，满足 a + c = b / 2",
        "dependency": "三个相邻元素之间存在代数约束，中间元素必须为偶数以使等式可能成立（若要求精确整除）",
        "locality": "每个候选解仅依赖于长度为 3 的滑动窗口内的局部信息"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计满足条件的长度为 3 的子数组的数量",
        "output": "非负整数：符合条件的子数组个数"
      },
      "Algorithmic Invariant": {
        "invariant": "遍历所有起始位置 i 的长度为 3 的连续子数组，检查 nums[i] + nums[i+2] == nums[i+1] / 2 是否成立",
        "correctness": "由于子数组长度固定且条件完全局部化，枚举所有位置即可保证不重不漏",
        "efficiency": "无需回溯或状态记忆，每一步判断独立"
      },
      "Transformable Parameters": {
        "subarray_length": {
          "default": 3,
          "can_change": true,
          "possible_values": "k >= 3 或作为参数输入"
        },
        "arithmetic_condition": {
          "default": "first + third = second / 2",
          "can_change": true,
          "variants": [
            "first + second = third * 2",
            "first + third = second",
            "second = (first + third) * k",
            "general linear relation: a·x + b·y + c·z = 0"
          ]
        },
        "data_stream": {
          "input_mode": "offline",
          "can_change": true,
          "variants": [
            "online query",
            "sliding window update"
          ]
        },
        "numerical_domain": {
          "current": "integers with division interpreted as exact rational equality",
          "can_extend": [
            "real numbers",
            "modular arithmetic"
          ],
          "note": "当前除法需精确匹配，如 b 为奇数则不可能满足条件"
        },
        "output_form": {
          "current": "count only",
          "can_change": [
            "return all valid subarrays",
            "return indices",
            "boolean existence"
          ]
        },
        "multiple_queries": {
          "current": false,
          "can_change": true,
          "variants": "支持多次查询不同区间或动态修改数组"
        },
        "array_properties": {
          "ordered": false,
          "distinct": false,
          "cyclic": false,
          "can_modify": [
            "circular array",
            "allow duplicates",
            "sorted constraint"
          ]
        }
      }
    }
  },
  {
    "title": "Substring Matching Pattern",
    "slug": "substring-matching-pattern",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，1 <= n <= 50",
        "模式字符串 p，长度为 m，1 <= m <= 50",
        "s 只包含小写英文字母",
        "p 包含小写英文字母和恰好一个 '*' 字符"
      ],
      "Core Constraint": [
        "模式串 p 中的 '*' 可匹配零个或多个任意字符序列（通配符语义）",
        "要求判断是否存在 s 的某个子字符串，能被 p 完全匹配",
        "匹配过程具有前缀-后缀分离性：'*' 将 p 分为前缀和后缀两部分，分别与子字符串的头部和尾部对齐"
      ],
      "Objective Function": "判定是否存在 s 的子字符串，使得在将 '*' 替换为某个字符序列后，p 能完全匹配该子字符串（布尔判定问题）",
      "Algorithmic Invariant": [
        "将 p 拆分为 prefix + '*' + suffix 后，只需检查 s 中是否存在某个子串以 prefix 开头、以 suffix 结尾，且中间部分可为空（即满足重叠约束）",
        "若 prefix 和 suffix 在 s 中的某段子串上不重叠且顺序一致，则该子串可被匹配",
        "状态推进可通过枚举 s 中所有可能的子串起始与结束位置，验证前后缀匹配与非交叉性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "s.length 和 p.length 的数量级": [
            "<= 50",
            "可扩展至 <= 1e3（离线）或 <= 1e5（需优化）"
          ]
        },
        "输入形式": [
          "是否保证恰好一个 '*'",
          "可变为多个 '*'（如正则匹配）",
          "是否允许 '?' 等其他通配符"
        ],
        "匹配目标": [
          "判定是否存在匹配（当前）",
          "改为计数匹配子串个数",
          "改为求最长/最短匹配子串长度"
        ],
        "子串约束": [
          "必须是连续子字符串（当前）",
          "可变为子序列匹配"
        ],
        "在线性": [
          "一次性输入（当前）",
          "可支持多组查询 / 在线模式串匹配"
        ],
        "通配符行为": [
          "'*' 可匹配任意字符序列（当前）",
          "可限制仅匹配特定字符集",
          "可增加最小/最大匹配长度约束"
        ]
      }
    }
  },
  {
    "title": "Find the Lexicographically Largest String From the Box I",
    "slug": "find-the-lexicographically-largest-string-from-the-box-i",
    "schema": {
      "Input Structure": [
        "字符串 word，长度为 n，其中 1 <= n <= 5000",
        "整数 numFriends，满足 1 <= numFriends <= n",
        "word 仅由小写英文字母组成"
      ],
      "Core Constraint": [
        "必须将 word 分割成恰好 numFriends 个非空连续子串",
        "所有可能的分割方式构成一个完备且互不相同的集合（即枚举所有合法划分）",
        "每种分割是顺序相关的：第 i 段对应第 i 位朋友收到的字符串",
        "所有生成的子串都被收集进全局盒子中（允许重复字符串多次出现）"
      ],
      "Objective Function": "在所有回合结束后，从盒子中找出字典序最大的字符串",
      "Algorithmic Invariant": [
        "字典序最大值一定出现在某个完整划分中的某一段上",
        "最优段必为原字符串的一个连续子串（substring）",
        "若存在一个子串 s = word[i:j] 是当前候选答案，则不存在其他划分方式能产生字典序更大的子串",
        "贪心性质：优先尝试以较大字符开头的子串；一旦找到可扩展为合法划分的极大字典序子串，即可确定其可达性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可变范围 [1, 5e3]，可扩展至 1e5 以引入高效枚举需求",
        "字符集类型": "目前为小写字母，可推广为大写、数字或 Unicode 字符",
        "numFriends 是否固定": "可改为变量查询或多组测试用例",
        "是否在线输入": "可设计为动态增加字符或修改 numFriends 的在线版本",
        "目标函数变化": [
          "求字典序最小的字符串",
          "求最长/最短的字典序最大串",
          "计数：有多少种划分使得最大段等于给定串",
          "构造方案：输出达成该最大串的具体划分方式"
        ],
        "分割约束变化": [
          "允许空串（需重新定义合法性）",
          "要求各段互不相同",
          "加入每段长度限制（如 ≥k 或 ≤k）",
          "环形字符串切割（首尾相连）"
        ],
        "数据流化": "可变为流式字符串生成，边读入边维护可能的最大子串"
      }
    }
  },
  {
    "title": "Count the Number of Arrays with K Matching Adjacent Elements",
    "slug": "count-the-number-of-arrays-with-k-matching-adjacent-elements",
    "schema": {
      "Input Structure": [
        "整数 n：数组长度，1 <= n <= 1e5",
        "整数 m：元素值域上界，每个元素 ∈ [1, m]",
        "整数 k：要求恰好有 k 个相邻相等的位置（即满足 arr[i-1] == arr[i] 的下标 i 的数量）"
      ],
      "Core Constraint": [
        "数组元素取值在 [1, m] 范围内",
        "相邻位置相等的次数必须**恰好为 k 次**",
        "状态具有前缀依赖性：当前选择是否产生一次‘相等’取决于前一个元素的值",
        "局部决策影响全局计数约束（k 的达成需精确控制）"
      ],
      "Objective Function": "计数 —— 构造满足条件的好数组的总数，并对 10^9 + 7 取模",
      "Algorithmic Invariant": [
        "使用动态规划维护三元组状态：dp[i][last][eq_count] 表示前 i 个位置、最后一个元素为 last、已有 eq_count 次相邻相等的方案数",
        "状态转移时分类讨论：当前元素是否等于前一个元素",
        "利用滚动数组优化空间：因只依赖前一层，可压缩第一维",
        "通过前缀和优化加速转移：对不同 'last' 值的 dp 状态做前缀和，避免重复计算相同值或不同值的贡献"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5（可调整至更小或更大以区分暴力与优化解）",
        "m 的值域范围": "1 <= m <= 1e5（可设为小常数如 2 或大数）",
        "k 的约束形式": [
          "恰好 k 次 → 至少 k 次 → 最多 k 次",
          "可改为不连续段数、连续段长度限制等变形"
        ],
        "是否取模": "是（固定为 1e9+7），但可改为不取模或询问具体构造",
        "是否多组数据": "否，但可扩展为 T 组输入",
        "数据流化": "静态一次性输入，可设计为在线逐步构建数组并查询部分结果",
        "输入形式变化": [
          "允许负数？否（当前限定正整数）",
          "是否有序？否（顺序自由决定）",
          "是否循环数组？否（当前为线性结构，可改为环形）"
        ],
        "隐藏条件": "k 的可行性隐含约束：0 <= k <= n-1，边界情况需特判"
      }
    }
  },
  {
    "title": "Maximum Area Rectangle With Point Constraints I",
    "slug": "maximum-area-rectangle-with-point-constraints-i",
    "schema": "{\n  \"Input Structure\": [\n    \"二维整数点集 points[1..n]\",\n    \"points[i] = [x_i, y_i], 其中 0 <= x_i, y_i <= 100\",\n    \"n = |points|, 1 <= n <= 10\",\n    \"所有点坐标唯一\"\n  ],\n  \"Core Constraint\": [\n    \"矩形边与坐标轴平行 → 可由两个不同横坐标和两个不同纵坐标唯一确定\",\n    \"四个顶点必须全部在给定点集中\",\n    \"矩形内部或边界上不能包含任何其他点（除四个顶点外）\",\n    \"候选矩形的可行性依赖于点集的空间分布密度\"\n  ],\n  \"Objective Function\": \"最大化合法矩形的面积，若不存在则返回 -1\",\n  \"Algorithmic Invariant\": [\n    \"枚举所有可能的对角线点对 (p1, p3) 可唯一确定一个轴对齐矩形\",\n    \"对于确定的矩形边界 [x_min, x_max] × [y_min, y_max]，其四个顶点必须全部存在于点集中\",\n    \"通过集合哈希快速判断某点是否在点集中 → O(1) 查询\",\n    \"一旦矩形顶点齐全，则只需遍历所有其他点检查是否落入闭区域\",\n    \"由于 n ≤ 10，暴力枚举所有四元组或点对组合在时间上是可接受的\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"n 的数量级\": [\"小规模 (n ≤ 10)\", \"中等规模 (n ≤ 1000)\", \"大规模 (n ≤ 1e5)\"],\n      \"是否允许算法复杂度提升至 O(n^2 log n) 或使用扫描线\"\n    },\n    \"几何约束\": [\n      \"矩形是否必须轴对齐（可变为任意方向）\",\n      \"是否允许矩形内部包含点（仅边界无额外点）\",\n      \"是否要求严格内部不含点（开区间判定）\"\n    ],\n    \"目标函数变换\": [\n      \"求最大面积 → 求最小正面积\",\n      \"计数满足条件的矩形个数\",\n      \"判定是否存在面积大于 K 的矩形\"\n    ],\n    \"输入形式\": [\n      \"静态一次性输入 → 动态添加/删除点（在线版本）\",\n      \"是否保证点唯一\",\n      \"坐标值域是否扩大至负数或大范围\"\n    ],\n    \"输出要求\": [\n      \"仅返回面积 → 返回构造方案（四个顶点）\",\n      \"是否多组测试数据\"\n    ],\n    \"结构扩展\": [\n      \"从轴对齐矩形 → 任意凸四边形\",\n      \"从二维平面 → 三维空间中的长方体\"\n    ]\n  }\n}"
  },
  {
    "title": "Count Connected Components in LCM Graph",
    "slug": "count-connected-components-in-lcm-graph",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "每个元素 nums[i] ≥ 1",
        "所有元素互不相同",
        "给定正整数 threshold"
      ],
      "Core Constraint": [
        "图的节点由数组元素构成，节点 i 的值为 nums[i]",
        "当且仅当 lcm(nums[i], nums[j]) ≤ threshold 时，节点 i 和 j 之间存在无向边",
        "lcm(a, b) = a * b / gcd(a, b)，其大小受 threshold 显式约束",
        "边的存在性依赖于数值因数结构和阈值限制，隐含数论分组特性"
      ],
      "Objective Function": [
        "计算图中连通块的数量",
        "目标函数为计数型（counting）"
      ],
      "Algorithmic Invariant": [
        "若两个数 a, b 满足 lcm(a,b) ≤ threshold，则它们可能属于同一连通块",
        "连通性可通过并查集（Union-Find）动态维护",
        "对于任意 v，满足 lcm(u, v) ≤ threshold 的 u 具有基于因子的局部聚集性",
        "可枚举每个数的因数作为‘中介键’，将具有公共因数 d ≤ threshold 的数合并，从而避免 O(n²) 枚举边"
      ],
      "Transformable Parameters": [
        "n 的数量级：1e5（当前规模下需亚线性或近线性构造边）",
        "nums[i] 值域：[1, 1e9]，远大于 threshold（提示可从 threshold 规模入手）",
        "threshold 范围：[1, 2e5]，较小，支持枚举因数或倍数",
        "是否允许重复元素：当前不允许，可改为允许以增加复杂度",
        "是否在线输入：当前为离线一次性输入，可改造为流式添加节点",
        "目标函数变化：求最大连通块大小 / 判定两点连通性 / 输出生成树",
        "约束变换：≤ threshold → ≥ threshold（完全不同的图结构）",
        "图结构维度扩展：从一维数组构建图 → 二维网格上基于相邻+LCM建图"
      ]
    }
  },
  {
    "title": "Maximum Sized Array",
    "slug": "maximum-sized-array",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 height，表示柱状图中每个柱子的高度。"
      },
      "Core Constraint": {
        "constraint": "每个位置的盛水能力由其左右两侧最高柱子中的较小值决定，且水只能在凹陷区域积累。",
        "independence": "左侧最大值和右侧最大值可独立维护，但最终贡献依赖两者最小值。",
        "global_dependency": true
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组能接住的雨水总量。"
      },
      "Algorithmic Invariant": {
        "invariant": "双指针推进过程中，始终维护从左端到左指针的最大值 maxLeft 和从右端到右指针的最大值 maxRight；当 maxLeft ≤ maxRight 时，左指针当前位置的积水高度可确定为 maxLeft - height[left]，同理右指针亦然。",
        "pointer_movement_rule": "每次移动对应较小一侧的指针，确保已处理区域的局部最优性不被破坏。",
        "correctness_preservation": true
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          0,
          "10^5"
        ],
        "is_sorted": false,
        "is_circular": false,
        "multiple_test_cases": false,
        "online_input": false,
        "supports_updates": false,
        "output_detail_level": "total sum only",
        "allowed_modifications": [
          "二维扩展（如：2D接雨水）",
          "支持单点更新或删除操作",
          "输出每个位置的具体积水量",
          "约束变换：最多接 K 单位水",
          "目标变换：是否存在可行积水方案",
          "输入变换：允许负高度（地形挖空）"
        ]
      }
    }
  },
  {
    "title": "Design Task Manager",
    "slug": "design-task-manager",
    "schema": {
      "Input Structure": [
        "维护一个动态任务集合，每个任务为三元组 (taskId, userId, priority)",
        "初始任务列表 tasks: vector<vector<int>>，格式为 [userId, taskId, priority]",
        "支持四种操作：add, edit, rmv, execTop",
        "所有 taskId 唯一且在 [0, 1e5] 范围内",
        "priority 和 newPriority 在 [0, 1e9] 范围内",
        "总操作次数 ≤ 2e5"
      ],
      "Core Constraint": [
        "需要高效维护全局最大优先级任务（优先级最高，若相同则 taskId 最大）",
        "任务的添加、删除、修改需动态更新数据结构",
        "execTop 操作需快速定位并移除目标任务，同时返回其 userId",
        "多个用户可拥有多个任务，但 taskId 全局唯一",
        "优先级和 taskId 共同决定 execTop 的执行顺序（优先级第一关键字，taskId 第二关键字）"
      ],
      "Objective Function": [
        "execTop 操作要求：返回并删除当前系统中优先级最高的任务对应的 userId；若优先级相同，选择 taskId 最大的任务",
        "其他操作为维护性操作（add/edit/rmv），不返回计算值，仅保持系统一致性"
      ],
      "Algorithmic Invariant": [
        "使用支持高效插入、删除、查询最大值的有序数据结构（如 std::set 或堆）维护任务主索引",
        "主排序键为 (-priority, -taskId) 以实现最大优先级 + 最大 taskId 的优先取出",
        "辅助哈希表：taskId -> (userId, priority) 实现 O(1) 查找与删除",
        "每次 edit 或 rmv 操作前能通过 taskId 定位原任务，并在主结构中删除旧项、插入新项（若适用）",
        "execTop 操作从有序结构弹出首元素，保证每次获取的是当前最优任务"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n_tasks_initial": "1 <= tasks.length <= 1e5",
          "total_operations": "add/edit/rmv/execTop 总数 <= 2e5",
          "taskId_range": "[0, 1e5]",
          "priority_range": "[0, 1e9]"
        },
        "输入输出形式": "类设计题，需实现 TaskManager 类接口",
        "是否多组数据": false,
        "是否在线": true,
        "排序规则可变": [
          "目标函数可改为：最小优先级优先",
          "或 taskId 最小者优先",
          "或按 userId 附加排序"
        ],
        "约束条件可变": [
          "允许 taskId 重复（需结合 userId 构成复合键）",
          "支持批量 execTop(k)",
          "增加用户优先级权重（用户加权优先级）",
          "任务带依赖关系（DAG 约束）"
        ],
        "数据流化扩展": [
          "支持时间窗口内的任务执行（滑动窗口最大值）",
          "任务带过期时间（TTL），自动清理"
        ],
        "隐藏条件变形": [
          "priority 不直接可见，需通过比较操作间接判断（黑盒比较）",
          "部分操作不可逆或有代价"
        ]
      }
    }
  },
  {
    "title": "Maximum Amount of Money Robot Can Earn",
    "slug": "maximum-amount-of-money-robot-can-earn",
    "schema": {
      "Input Structure": "二维网格 coins[0..m-1][0..n-1]，其中 m >= 1, n >= 1；每个单元格值为整数，范围 [-1000, 1000]；机器人从 (0,0) 出发，只能向右或向下移动，目标是到达 (m-1, n-1)",
      "Core Constraint": "路径具有方向性（仅右/下），状态转移局部可扩展；强盗单元格（coins[i][j] < 0）默认扣除 |coins[i][j]| 金币，但最多可对 2 个这样的单元格使用‘感化’能力使其变为无惩罚通过；感化次数是全局有限资源，需在路径中决策使用时机",
      "Objective Function": "最大化从起点到终点的路径上获得的总金币数（允许负值）",
      "Algorithmic Invariant": "使用三维动态规划状态 dp[i][j][k] 表示到达 (i,j) 时已使用 k 次感化能力下的最大金币收益；k ∈ {0,1,2}；状态转移满足最优子结构：dp[i][j][k] 可由上方 dp[i-1][j][*] 或左方 dp[i][j-1][*] 转移而来；对于负值格子，可根据是否使用感化更新对应 k 层状态",
      "Transformable Parameters": {
        "grid_dimensions": "m, n 的数量级（如：≤500 → ≤1000 或更小）",
        "coin_value_range": "coins[i][j] 的值域（如：[-1000,1000] → [-1e4,1e4]）",
        "max_redemption_count": "可感化的强盗数量（如：2 → K，K=0/1/3/任意）",
        "movement_directions": "移动限制（如：仅右/下 → 允许四个方向 → 需处理环路和重复访问）",
        "redemption_cost": "感化是否消耗额外代价（当前为免费启用，可改为消耗金币或限制连续使用）",
        "output_requirement": "输出内容变化（如：最大金币数 → 达到最大金币的路径方案数 / 最小感化次数下的最大收益）",
        "input_mode": "是否多组测试数据 / 是否在线输入网格",
        "special_cells": "引入其他类型单元格（如：传送门、陷阱、加倍金币等），形成组合约束"
      }
    }
  },
  {
    "title": "Smallest Number With All Set Bits",
    "slug": "smallest-number-with-all-set-bits",
    "schema": {
      "Input Structure": "正整数 n，1 <= n <= 1000",
      "Core Constraint": "目标整数 x 的二进制表示中所有位均为 1（即形如 2^k - 1）",
      "Objective Function": "求大于等于 n 且二进制表示全为 1 的最小整数 x",
      "Algorithmic Invariant": "满足条件的候选数在二进制下是连续的 1 序列；若当前长度的全 1 数小于 n，则必须增加位数；一旦找到位数足够的全 1 数，其即为该长度下的唯一候选，且更短长度无解",
      "Transformable Parameters": {
        "n 的数量级": "可扩展至 1e9 或更大（通过位运算直接构造）",
        "值域限制": "是否允许负数（本题不涉及）",
        "输入形式": "单组输入，可改为多组数据批量处理",
        "是否在线": "可设计为在线查询：每次输入 n 实时返回结果",
        "约束变形": [
          "仅含 k 个置位位（而非全部为 1）→ 求最小 ≥n 且恰有 k 个 1 的数",
          "反转目标：求最大 ≤n 且全为 1 的数",
          "推广到其他进制：如求最小 ≥n 且在 b 进制下各位全为 1 的数"
        ]
      }
    }
  },
  {
    "title": "Maximize Sum of Weights after Edge Removals",
    "slug": "maximize-sum-of-weights-after-edge-removals",
    "schema": {
      "Input Structure": "无向树 T = (V, E)，其中 V = {0, 1, ..., n-1}，E 是长度为 n-1 的边集数组 edges，每条边 e_i = [u_i, v_i, w_i] 表示节点 u_i 和 v_i 之间有权重 w_i ≥ 1 的无向边。n ∈ [2, 1e5]，w_i ∈ [1, 1e6]",
      "Core Constraint": "移除若干条边后，每个节点的度数（直接相连的边数）不超过给定整数 k；剩余子图仍可不连通，但必须保留原树的边子集结构",
      "Objective Function": "最大化剩余边的权重之和",
      "Algorithmic Invariant": "以动态规划在树上进行状态转移：对每个节点 u，维护其与子节点连接中最多保留 min(deg(u), k) 条边的最优选择；贪心地优先保留权重更大的边；由于是树结构，无环，因此局部决策不会影响全局连通性，且可通过后序遍历保证子问题独立性",
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 10^5",
        "k 的取值范围": "1 <= k <= n - 1",
        "边权值域": "1 <= w_i <= 10^6",
        "是否允许负权重": false,
        "是否多组数据": false,
        "是否在线输入": false,
        "树的形态约束": "通用无向树（可通过邻接表建图），无特殊结构（如链、星形等）假设",
        "输出形式变化": "可改为输出方案路径 / 每个节点实际度数 / 最小化删除代价等",
        "约束方向变换": "从 '度 ≤ k' 改为 '度 ≥ k' 或 '恰好为 k'（将变为不同母题）",
        "目标函数变换": "从 '最大权重和' 改为 '最小删除代价' 或 '计数满足条件的方案数'"
      }
    }
  },
  {
    "title": "Count Non-Decreasing Subarrays After K Operations",
    "slug": "count-non-decreasing-subarrays-after-k-operations",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "name": "nums",
        "size": "n",
        "element_type": "positive integer",
        "value_range": "[1, 10^9]",
        "constraints": [
          "length n in range [1, 10^5]",
          "elements are positive integers"
        ]
      },
      "Core Constraint": {
        "description": "子数组可通过滑动窗口枚举，每个位置的修改代价由其与前驱形成的逆序差值决定",
        "key_idea": "将一个子数组变为非递减所需的最小操作次数 = 所有逆序下降处需填补的差值之和（即：对每个 i > start，若 nums[i] < nums[i-1]，则需至少补充 nums[i-1] - nums[i] 次操作）",
        "dependency": "局部逆序关系决定了全局最小操作成本，且成本可增量维护"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计在最多 k 次操作内可以变为非递减的子数组个数",
        "note": "不是构造方案或判定单个子数组，而是计数所有满足条件的连续子数组"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "使用双指针 / 滑动窗口技术枚举所有可行子数组",
          "右指针扩展时，增量计算使当前子数组非递减所需的额外操作数（基于前缀修正）",
          "左指针收缩时，能 O(1) 地更新所需操作总数",
          "维护一个‘贪心修正量’：从左到右遍历时，只在下降处累计 cost，且该 cost 可通过差分方式快速更新"
        ],
        "monotonicity": "对于固定左端点，随着右端点右移，使子数组非递减所需的操作次数单调不减",
        "implication": "因此满足滑动窗口的决策单调性：一旦 [l, r] 超出 k 操作限制，则所有更大的 r' 都无效，可移动 l"
      },
      "Transformable Parameters": {
        "n_range": [
          "1e3",
          "1e5",
          "1e6"
        ],
        "k_value": {
          "range": "[1, 1e9]",
          "transformations": [
            "k 很小 → 可枚举长度",
            "k 很大 → 几乎所有子数组都合法"
          ]
        },
        "array_properties": [
          "是否已排序",
          "是否允许负数",
          "是否循环数组"
        ],
        "operation_rules": [
          "每次操作只能 +1 → 可变换为 ±1 或乘法操作",
          "至多 k 次总操作 → 可改为平均限制、每元素限次等"
        ],
        "input_mode": [
          "离线批量输入",
          "在线查询（动态添加元素）"
        ],
        "output_type": [
          "仅计数 → 输出数量",
          "构造所有合法子数组 → 输出区间列表",
          "最长/最短合法子数组 → 目标函数变换"
        ],
        "cost_model": [
          "线性代价（差值即代价）",
          "平方代价（(diff)^2）",
          "阶梯代价（diff > threshold 才计费）"
        ],
        "subarray_type": [
          "连续子数组（原题）",
          "子序列（变形）"
        ]
      }
    }
  },
  {
    "title": "Second Highest Salary II",
    "slug": "second-highest-salary-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 H[1..n]，表示每个位置的柱子高度"
      },
      "Core Constraint": {
        "left_right_max_dependency": true,
        "local_contribution_determined_by_global_boundary": true,
        "independence_of_side_constraints": true,
        "description": "每个位置 i 能储存的水量由其左侧最大值和右侧最大值中的较小者决定；左右边界约束可分离但需全局一致"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "total_water_capacity",
        "description": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "two_pointers_used": true,
        "left_pointer": "L",
        "right_pointer": "R",
        "maxLeft": "从左到L的历史最大值",
        "maxRight": "从右到R的历史最大值",
        "movement_rule": "若 maxLeft ≤ maxRight，则 L 处的瓶颈确定，可计算贡献并右移 L；否则右移 R",
        "invariant_preservation": "每次移动指针时，已遍历区域的最优性保持不变，且当前边界足以确定至少一端的局部解"
      },
      "Transformable Parameters": {
        "value_domain": {
          "allows_negative": false,
          "possible_extension": "允许负值（如地下结构）"
        },
        "spatial_dimension": {
          "current": "1D",
          "possible_extension": "2D grid / 3D volume / circular array"
        },
        "input_mode": {
          "current": "offline_batch",
          "possible_extension": "online_streaming / dynamic_updates (e.g., point updates)"
        },
        "output_form": {
          "current": "total_sum",
          "possible_extension": "per-position_contribution / maximum_single_valley / minimum_cut_to_drain"
        },
        "data_properties": {
          "sortedness": "unsorted",
          "possible_extension": "sorted_array / monotonic_input"
        },
        "query_type": {
          "current": "single_query",
          "possible_extension": "multiple_queries_after_updates / range_restricted_versions"
        },
        "constraints_variation": {
          "current": "no_deletion",
          "possible_extension": "support_insertion_deletion / movable_blocks"
        }
      }
    }
  },
  {
    "title": "Count Paths With the Given XOR Value",
    "slug": "count-paths-with-the-given-xor-value",
    "schema": {
      "Input Structure": [
        "二维整数数组 grid[0..m-1][0..n-1]",
        "m, n ≥ 1，且 m ≤ 300, n ≤ 300",
        "每个元素 grid[i][j] 满足 0 <= grid[i][j] < 16",
        "给定整数 k，满足 0 <= k < 16"
      ],
      "Core Constraint": [
        "路径从 (0, 0) 出发，只能向右或向下移动，终点为 (m-1, n-1)",
        "路径的异或值定义为路径上所有经过格子的数值按顺序进行 XOR 运算的结果",
        "由于 XOR 不具有最优子结构的单调性，但具有可组合性和状态可分离性，需记录历史异或状态",
        "状态空间受限于值域小（<16），使得异或结果种类最多为16种"
      ],
      "Objective Function": [
        "计数：统计异或值恰好等于 k 的从左上到右下路径总数",
        "结果对 10^9 + 7 取模"
      ],
      "Algorithmic Invariant": [
        "使用动态规划维护 dp[i][j][x] 表示到达 (i, j) 时路径异或值为 x 的路径数目",
        "状态转移满足：dp[i][j][x] = dp[i-1][j][x ^ grid[i][j]] + dp[i][j-1][x ^ grid[i][j]]",
        "异或操作的自反性（a ^ b = c ⇒ a = b ^ c）保证状态可逆且无后效性",
        "遍历顺序按行优先或列优先即可保证依赖状态已计算"
      ],
      "Transformable Parameters": [
        "数据规模：m, n 的数量级（如扩展至 1e3 或更高，则需滚动数组优化）",
        "grid 元素值域（当前 <16；若扩大则状态维度过高，DP 不适用）",
        "k 的范围（是否与值域同步变化）",
        "是否允许多起点或多终点",
        "移动方向限制（是否允许向上/向左 → 引入环路，问题变难）",
        "是否改为求最大/最小异或值（目标函数由计数变为极值）",
        "是否在线查询不同 k 的答案（利用预计算的总分布）",
        "是否加入修改操作（进入动态 DP 范畴）",
        "是否将 XOR 替换为 AND/OR/SUM 等其他合并操作"
      ]
    }
  },
  {
    "title": "Minimize the Maximum Adjacent Element Difference",
    "slug": "minimize-the-maximum-adjacent-element-difference",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums[i] ∈ {-1} ∪ [1, 10^9]",
        "n ∈ [2, 10^5]",
        "缺失元素标记为 -1"
      ],
      "Core Constraint": [
        "缺失位置必须被替换为两个选定正整数 x 和 y 中的一个",
        "x 和 y 可相等（即允许使用单一值）",
        "非缺失元素固定不可更改",
        "相邻差的极值由连续段边界与填充策略共同决定"
      ],
      "Objective Function": "最小化 替换后整个数组中相邻元素绝对差值的最大值",
      "Algorithmic Invariant": [
        "最优解下，最大绝对差具有单调可判定性：若答案 ≤ D 可行，则 > D 也一定可行 → 可二分答案",
        "对于固定的候选最大差 D，可用贪心构造验证是否存在合法的 (x, y) 填充方案",
        "每个连续缺失段的取值范围可通过前后已知端点约束传播得到",
        "双变量选择 (x, y) 的可行性可在离散关键点上枚举或区间覆盖判断"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "10^3",
            "10^5"
          ],
          "值域": "[1, 10^9]"
        },
        "缺失模式": [
          "全缺失",
          "部分缺失（连续/离散）",
          "首尾缺失"
        ],
        "替换变量限制": [
          "使用恰好两个数 (x, y)",
          "x == y 允许",
          "x ≠ y 强制",
          "扩展至 k 个替换数（→ 多值填充问题）"
        ],
        "目标函数变形": [
          "最小化 最大相邻差（当前题）",
          "最小化 相邻差之和",
          "计数 满足条件的 (x, y) 对数量",
          "判定 是否存在使最大差 ≤ K 的方案"
        ],
        "输入形式": [
          "单组输入",
          "多组测试数据",
          "在线流式输入（动态添加元素）"
        ],
        "结构变形": [
          "环形数组（首尾相邻）",
          "二维网格上的缺失填充",
          "带权重的差值计算"
        ]
      }
    }
  },
  {
    "title": "Check if Grid can be Cut into Sections",
    "slug": "check-if-grid-can-be-cut-into-sections",
    "schema": {
      "Input Structure": [
        "整数 n 表示 n x n 的网格图，坐标范围为 [0, n] x [0, n]",
        "二维数组 rectangles，其中每个元素为 [start_x, start_y, end_x, end_y]",
        "每个矩形左下角为 (start_x, start_y)，右上角为 (end_x, end_y)",
        "所有矩形互不重叠",
        "3 <= n <= 1e9",
        "3 <= rectangles.length <= 1e5"
      ],
      "Core Constraint": [
        "切割线必须是两条平行线：要么都是水平线（固定 y 值），要么都是垂直线（固定 x 值）",
        "三条区域由两条切割线划分：例如水平切割时，y < cut1, cut1 <= y < cut2, y >= cut2",
        "每个矩形必须完全位于其中一个区域中（不能被切割线穿过）",
        "三个区域中每一个都至少包含一个完整的矩形",
        "矩形之间无重叠，因此归属唯一"
      ],
      "Objective Function": [
        "判定是否存在一组满足条件的两条平行切割线（全水平或全垂直），使得三个区域各至少包含一个矩形",
        "返回布尔值：true 表示存在，false 表示不存在"
      ],
      "Algorithmic Invariant": [
        "对于某一方向（如水平），若将所有矩形按其 y 区间 [start_y, end_y] 投影到该轴上，则可尝试寻找两个分割点 y1 < y2，使得：",
        "  - 所有矩形可被划分为三组：完全在 y < y1 下方、在 y1 <= y < y2 中间、在 y >= y2 上方",
        "  - 每组非空",
        "  - 分割点 y1, y2 不落在任何矩形内部（即不是某个矩形的 start_y 或 end_y 内部？注意题目允许在边界处切）→ 实际上可以切在任意实数位置，只要不穿过矩形即可",
        "关键不变量：若存在合法切割，则必可在某些矩形的 end_coord 和下一个矩形的 start_coord 之间的间隙中进行切割（离散化候选点）",
        "因此只需枚举所有可能的间隙作为候选切割位置（去重排序后遍历）",
        "使用双指针或前缀/后缀信息维护左右两部分是否非空，并检查中间部分是否有矩形"
      ],
      "Transformable Parameters": [
        "n 的数量级：可从 1e9 缩小至小规模用于模拟",
        "rectangles 是否有序：输入无序，可添加‘是否已按 x/y 排序’作为参数",
        "是否允许矩形重叠：当前不允许，可设为可变约束",
        "切割线方向限制：可改为‘一横一竖’混合切割（变形题）",
        "切割区域数量：可推广为 k 条线分成 k+1 段，每段至少一个矩形（计数类问题）",
        "目标函数变化：从判定存在性 → 求方案数 / 最小最大区域矩形数",
        "是否在线输入矩形：支持动态插入删除矩形并查询是否可行",
        "是否要求输出具体切割位置：从 bool 到构造答案",
        "维度扩展：从 2D 平面 → 高维超矩形与超平面切割"
      ]
    }
  },
  {
    "title": "Minimum Number of Operations to Make Elements in Array Distinct",
    "slug": "minimum-number-of-operations-to-make-elements-in-array-distinct",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中 n >= 1；元素为正整数，值域 [1, 100]；数组长度不超过 100",
      "Core Constraint": "每次操作只能从数组开头移除前 3 个元素（若不足 3 个则全部移除）；目标是使最终数组中所有元素互不相同；操作顺序不可逆，且仅允许前缀删除",
      "Objective Function": "求使数组元素互不相同所需的最少操作次数",
      "Algorithmic Invariant": "后缀子数组的唯一性可独立判断：若从位置 i 开始的后缀子数组元素互不相同，则该状态可通过若干次前缀删除达到；贪心选择成立——更少的操作次数优先保留更长的有效后缀；已确定的后缀合法性不会因前面操作而改变",
      "Transformable Parameters": [
        "数组长度 n 的数量级（如扩展到 1e5，需考虑算法复杂度变化）",
        "每次移除的元素个数（如改为 k 个，k 可变）",
        "移除位置（从前缀变为后缀或两端）",
        "是否允许多种操作组合（如同时支持头删、尾删）",
        "是否要求构造最终数组而非仅计数",
        "输入是否在线（数据流形式逐个到达）",
        "元素值域范围（如扩大到负数或大整数）",
        "判定条件变化：从“互不相同”变为“满足某种频率约束”，例如每个元素最多出现两次"
      ]
    }
  },
  {
    "title": "Digit Operations to Make Two Integers Equal",
    "slug": "digit-operations-to-make-two-integers-equal",
    "schema": {
      "Input Structure": [
        "两个正整数 n 和 m",
        "n 和 m 具有相同的数位长度（即十进制表示下位数相同）",
        "1 <= n, m < 10^4"
      ],
      "Core Constraint": [
        "每次操作只能将一个非9的数位+1，或一个非0的数位-1",
        "任意时刻（包括初始状态和所有中间状态），n 的值不能是质数",
        "每一步变化必须保持数值仍为相同位数的整数（隐含：不能出现前导零导致位数减少）"
      ],
      "Objective Function": [
        "最小化从 n 到 m 变换路径上所有经过数值之和（包含起点 n 和终点 m）",
        "若无法完成变换，则返回 -1"
      ],
      "Algorithmic Invariant": [
        "状态转移图中每个节点是一个合法整数（非质数、同位数）",
        "边表示一次单个数位 ±1 操作",
        "最短路径意义下的‘代价’不是边权而是节点权（即路径上点权和最小）",
        "可通过 0-1 BFS 或 Dijkstra 在隐式图中搜索最小点权路径",
        "质数集合构成禁止状态集，形成障碍约束"
      ],
      "Transformable Parameters": {
        "数据规模": "n, m < 10^k，其中 k 可调整（如 k=2,3,4,5）",
        "数位操作类型": [
          "允许/禁止进位传播",
          "是否允许跨位移动（如借位）"
        ],
        "质数约束强度": [
          "完全禁止质数",
          "仅禁止某些区间内的质数",
          "改为禁止合数（反转约束）"
        ],
        "目标函数形式": [
          "最小化路径点权和（当前）",
          "最小化操作次数",
          "最小化最大中间值",
          "计数可行路径数量"
        ],
        "输入形式": [
          "单组输入",
          "多组测试用例",
          "在线查询：动态修改 n/m 后重新求解"
        ],
        "是否允许删除/插入操作": "扩展为可变长度数位字符串编辑（更复杂变形）",
        "数位限制": "是否允许负数位（抽象代数视角）"
      }
    }
  },
  {
    "title": "Minimum Array Sum",
    "slug": "minimum-array-sum",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums[i] 是非负整数，值域范围 [0, 10^5]",
        "三个整数参数：k（减法阈值）、op1（向上取整除2操作次数上限）、op2（减k操作次数上限）",
        "1 <= n <= 100"
      ],
      "Core Constraint": [
        "操作1：对任意下标 i，可将 nums[i] 替换为 ceil(nums[i] / 2)，最多执行 op1 次，每个下标至多使用一次",
        "操作2：对任意下标 i，若 nums[i] >= k，可将其替换为 nums[i] - k，最多执行 op2 次，每个下标至多使用一次",
        "两种操作可作用于同一元素，但每种操作在该元素上最多执行一次",
        "操作顺序影响中间状态，但由于操作不可逆且独立，最优策略依赖贪心或状态排序"
      ],
      "Objective Function": "最小化执行任意合法操作序列后，数组所有元素的总和",
      "Algorithmic Invariant": [
        "局部最优性：对于任一元素，先考虑是否应应用操作1（因其可能降低数值从而影响操作2可行性），再决定操作2的应用",
        "单调性：对单个元素而言，两次操作均不会增加其值；操作1具有递减但非线性的特性（ceil除2）",
        "可交换性近似成立：尽管操作顺序理论上影响结果，但在多数情况下优先处理高贡献收益的操作（如对大数做操作1）更优",
        "贪心选择不变量：在资源有限（op1, op2）时，每次选择当前能使总和减少最多的可行操作是近似最优的启发式策略",
        "动态规划状态可定义为 (已用op1次数, 已用op2次数) 下的最小总和，利用小规模数据支持枚举"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1e2（当前）",
            "可扩展至 1e3 或更高以限制暴力解法）"
          ],
          "值域范围": [
            "[0, 1e5]",
            "可调整为更大以强调操作必要性"
          ]
        },
        "操作约束": {
          "op1 和 op2 上限": [
            "与 n 相关（当前 ≤ n）",
            "可设为全局共享次数（如 op1=10）"
          ],
          "操作次数类型": [
            "固定次数",
            "每个下标可多次操作（修改题意）"
          ]
        },
        "输入形式": [
          "单组输入",
          "多组测试数据",
          "在线流式输入（元素逐个到达，需即时决策）"
        ],
        "操作规则变化": [
          "操作顺序强制限制（必须先完成所有操作1才能进行操作2）",
          "操作2允许重复减k直到小于k",
          "操作1改为向下取整",
          "引入操作3（例如平方根取整等）"
        ],
        "目标函数变体": [
          "最小化最大值",
          "最小化方差",
          "计数达到某阈值的元素个数",
          "判定是否能使得总和 ≤ target"
        ],
        "结构扩展": [
          "二维数组（矩阵中选块应用操作）",
          "树形结构上传播操作影响"
        ],
        "是否隐藏参数": [
          "k 不显式给出，需从上下文中推断",
          "op1/op2 隐藏，通过代价函数间接控制"
        ]
      }
    }
  },
  {
    "title": "Maximum Subarray Sum With Length Divisible by K",
    "slug": "maximum-subarray-sum-with-length-divisible-by-k",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "整数 k",
        "nums[i] ∈ [-10^9, 10^9]",
        "1 <= k <= n <= 2 * 10^5"
      ],
      "Core Constraint": [
        "子数组长度必须是 k 的倍数（即长度 ≡ 0 (mod k)）",
        "子数组必须连续且非空",
        "全局约束：最优解可能跨越任意位置，但长度受限于模 k 条件"
      ],
      "Objective Function": "求满足长度被 k 整除的非空子数组的最大和（最大化）",
      "Algorithmic Invariant": [
        "前缀和 + 模 k 分组维护最小前缀：对于当前下标 i，若 (i - j) % k == 0，则 sum(j+1, i) = prefix[i] - prefix[j]",
        "在遍历过程中，对每个模 k 余 r 的位置，只需维护该余类中最小的前缀和",
        "贪心性质：固定右端点时，要使区间和最大，应使左端点前缀尽可能小",
        "状态可分离：按索引 mod k 分组，每组独立维护最小前缀和"
      ],
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 2*10^5], 可扩展至 10^6 或更高以要求 O(n) 解法",
        "值域": "nums[i] 可为负数；可限制为非负以简化问题",
        "k 的性质": [
          "k 是否为常数？可改为变量或多个查询",
          "是否支持多组 k 查询（在线）",
          "k 是否为质数？影响分组结构"
        ],
        "输入形式": [
          "单组输入 → 多组测试用例",
          "离线处理 → 在线流式添加元素"
        ],
        "约束变形": [
          "长度 ≡ 0 (mod k) → 长度 ≡ r (mod k)，r ∈ [0, k-1]",
          "最大和 → 最小和 / 计数满足条件的最大和子数组数量",
          "子数组 → 子序列（破坏连续性）",
          "被 k 整除 → 被 k 除余 r"
        ],
        "附加操作": [
          "支持单点修改 → 进入数据结构题范畴（如线段树 + 模分组）",
          "支持删除或滑动窗口式更新"
        ],
        "输出形式": [
          "仅输出最大和 → 输出具体子数组区间",
          "输出所有最优解的数量"
        ]
      }
    }
  },
  {
    "title": "Find Sorted Submatrices With Maximum Element at Most K",
    "slug": "find-sorted-submatrices-with-maximum-element-at-most-k",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "ordered": true,
        "duplicates_allowed": true,
        "description": "一维数组 H[1..n]，表示柱状图中每个位置的高度 H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度中的较小者决定",
        "left_right_independence": true,
        "global_dependency": "局部储水能力依赖于全局极值分布",
        "monotonicity_implication": false,
        "reason_for_algorithm": "由于左右边界约束可分别维护，允许双指针逐步推进"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "total accumulated water",
        "objective": "计算所有位置上能接住的雨水总量",
        "output_type": "integer",
        "variant_trigger": "若目标变为构造方案或输出每列水量，则为不同母题"
      },
      "Algorithmic Invariant": {
        "invariant": "双指针 L 和 R 分别从两端向内移动，维护 maxLeft 和 maxRight",
        "rule": "若 maxLeft ≤ maxRight，则左指针当前位置的储水量可确定；反之确定右指针位置",
        "correctness_guarantee": "已确定侧的贡献不会因后续操作改变",
        "pointer_movement": "每次仅移动较小一侧指针，保持未访问区域仍满足求解条件",
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          "0",
          "10^5"
        ],
        "negative_values_allowed": false,
        "input_dimension": "1D → 可扩展至 2D（如二维接雨水）",
        "online_updates": false,
        "mutable_array": false,
        "query_mode": "offline",
        "multiple_test_cases": false,
        "output_detail_level": "总和 → 可改为输出每个位置的储水量",
        "structural_variation": "线性数组 → 环形数组变形",
        "additional_operations": []
      }
    }
  },
  {
    "title": "Transformed Array",
    "slug": "transformed-array",
    "schema": {
      "Input Structure": [
        "一维循环数组 nums[0..n-1]",
        "整数类型，支持负值、零和正值",
        "1 <= n <= 100",
        "每个元素满足 -100 <= nums[i] <= 100"
      ],
      "Core Constraint": [
        "数组为循环结构：向右越界时回到开头，向左越界时回到末尾",
        "每个位置 i 的结果独立计算，基于从 i 出发按 nums[i] 指示的方向与步数移动后所落位置的值",
        "移动方向由符号决定：正数向右，负数向左，零保持原地"
      ],
      "Objective Function": [
        "构造一个与输入数组等长的新数组 result",
        "对于每个下标 i，result[i] = nums[(i + nums[i]) mod n]（考虑循环与方向）",
        "目标函数为构造型：输出完整的 result 数组"
      ],
      "Algorithmic Invariant": [
        "每个位置的计算是独立且局部的：不依赖其他位置的结果",
        "循环索引可通过模运算不变性处理：(i + k) mod n 可正确映射到有效下标",
        "移动步数虽带符号，但可通过 (i + nums[i] % n + n) % n 统一归一化为合法下标"
      ],
      "Transformable Parameters": [
        "数组是否循环（可改为非循环，边界停止）",
        "移动是否允许修改原数组（当前为只读访问）",
        "数据规模：n 是否扩大（当前较小，适合模拟）",
        "是否支持在线查询单个 result[i] 而非全部构造",
        "是否允许多层嵌套跳转（如递归跳转 nums[i] 次）",
        "nums[i] 的值域是否增大（需优化大步数取模）",
        "是否加入动态更新操作（如修改 nums[i] 后重新查询）"
      ]
    }
  },
  {
    "title": "Find Cities in Each State II",
    "slug": "find-cities-in-each-state-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 height，height[i] 表示第 i 根柱子的高度"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左右两侧最高柱子的最小值决定",
        "property": "左右最大值约束独立且可分离，局部决策依赖全局极值",
        "key_insight": "若某一侧的最大高度小于另一侧，则当前位置的积水仅受限于该侧"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft = max(height[0..L]) 和 maxRight = max(height[R..n-1])",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水可确定为 max(0, maxLeft - height[L])，随后 L++",
          "否则，位置 R 处的积水可确定为 max(0, maxRight - height[R])，随后 R--",
          "指针移动过程中，已确定区域的解始终保持最优性"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_range",
            "options": [
              "non-negative integers",
              "allow negative values (variant)"
            ]
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D (e.g. 2D trapping rain water)"
            ]
          },
          {
            "name": "input_mode",
            "options": [
              "offline batch input",
              "online streaming queries"
            ]
          },
          {
            "name": "update_support",
            "options": [
              "static array",
              "support point updates or range modifications"
            ]
          },
          {
            "name": "output_granularity",
            "options": [
              "total sum only",
              "per-position contribution required"
            ]
          },
          {
            "name": "array_property",
            "options": [
              "unordered",
              "sorted",
              "circular (ring structure)"
            ]
          },
          {
            "name": "multiple_test_cases",
            "options": [
              true,
              false
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Minimum Time to Break Locks I",
    "slug": "minimum-time-to-break-locks-i",
    "schema": {
      "Input Structure": [
        "长度为 n 的正整数数组 strength[1..n]",
        "每个元素 strength[i] 表示第 i 个锁所需的能量",
        "给定整数 K，表示每次开锁后 X 的增量",
        "1 <= n <= 8, 1 <= K <= 10, 1 <= strength[i] <= 1e6"
      ],
      "Core Constraint": [
        "剑的能量每分钟增加当前的 X 值（X 初始为 1）",
        "打开第 i 把锁时，剑的能量必须至少达到 strength[i]",
        "一旦打开一把锁，剑的能量重置为 0，X 增加 K",
        "锁可以按任意顺序打开",
        "目标是最小化总时间（分钟数）"
      ],
      "Objective Function": "最小化打开所有锁所需的总时间（分钟数）",
      "Algorithmic Invariant": [
        "最优解中，锁的开启顺序影响总时间：高消耗锁可能更适合在 X 较大时处理",
        "由于 X 单调递增，后续操作单位时间产能更高，因此存在贪心交换论证的空间",
        "状态空间可由 (已开锁集合, 当前 X 值) 完全刻画，适用于状态压缩 DP",
        "子问题无后效性：已开锁集合决定当前 X 和起始能量（0），未来决策独立于历史路径"
      ],
      "Transformable Parameters": {
        "n 的数量级": "当前 n ≤ 8 → 可扩展至 n ≤ 20（需优化算法）或 n ≤ 1000（引入贪心）",
        "值域": "strength[i] 是否可达 1e9（影响是否可用二分+DP）",
        "K 的变化形式": [
          "固定 K → 每次增加不同值 → X 变为乘法增长"
        ],
        "是否有序": "当前可重排锁顺序 → 若锁有依赖关系则变为拓扑序约束",
        "是否循环": "否，线性过程",
        "是否多组输入": "当前单组 → 可改为多组测试用例",
        "是否在线": "否，离线一次性输入",
        "能量重置规则": "当前重置为 0 → 可改为保留部分能量或衰减",
        "X 更新方式": "当前 X += K → 可改为 X *= K 或查表更新",
        "目标函数变形": [
          "最少时间 → 最少总能量消耗",
          "是否存在方案在 T 分钟内完成",
          "计数满足条件的开锁顺序数"
        ],
        "约束反转": "至少达到 strength[i] → 必须精确等于（变体难度上升）",
        "输入维度变换": "一维锁序列 → 树形依赖结构下的开锁顺序规划"
      }
    }
  },
  {
    "title": "Find the Maximum Number of Fruits Collected",
    "slug": "find-the-maximum-number-of-fruits-collected",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"2D grid\",\n    \"dimensions\": \"n x n\",\n    \"values\": \"fruits[i][j] ≥ 0\",\n    \"initial_positions\": [\n      [0, 0],\n      [0, n - 1],\n      [n - 1, 0]\n    ],\n    \"destination\": [n - 1, n - 1],\n    \"movement_steps\": \"each child moves exactly n - 1 times\"\n  },\n  \"Core Constraint\": {\n    \"path_constraints\": [\n      \"Child 1 (from (0,0)): can move to (i+1,j), (i,j+1), or (i+1,j+1)\",\n      \"Child 2 (from (0,n-1)): can move to (i+1,j-1), (i+1,j), or (i+1,j+1)\",\n      \"Child 3 (from (n-1,0)): can move to (i-1,j+1), (i,j+1), or (i+1,j+1)\"\n    ],\n    \"resource_constraint\": \"Each room's fruit can be collected by at most one child\",\n    \"mutual_exclusion\": \"If multiple children visit the same cell, only one collects the fruit\",\n    \"no_regeneration\": \"Once a room is visited, its fruit disappears\"\n  },\n  \"Objective Function\": \"Maximize the total number of fruits collected by all three children\",\n  \"Algorithmic Invariant\": {\n    \"state_representation\": \"DP state tracks positions of all three children simultaneously\",\n    \"state_compression_feasibility\": \"Since all children move synchronously (same number of steps), their positions can be represented by step k and column indices\",\n    \"monotonic_progress\": \"All paths progress in lockstep over k = 0 to n-1 steps toward (n-1,n-1)\",\n    \"optimal_substructure\": \"Maximum fruit up to step k depends only on optimal choices at step k-1\",\n    \"symmetry_reduction\": \"State can be normalized (e.g., sort children's columns) to reduce redundancy\"\n  },\n  \"Transformable Parameters\": {\n    \"n_range\": \"2 <= n <= 1000\",\n    \"value_range\": \"0 <= fruits[i][j] <= 1000\",\n    \"grid_shape\": \"square grid (can be generalized to rectangular with modified movement rules)\",\n    \"number_of_children\": \"3 fixed (could generalize to K agents from different corners)\",\n    \"movement_rules\": \"directional transition rules per agent (can be altered: e.g., restrict diagonal moves)\",\n    \"collecting_rule\": \"exclusive collection (alternatives: shared, cumulative penalty, time-based refresh)\",\n    \"input_form\": \"offline batch input (can become online streaming rows)\",\n    \"output_requirement\": \"maximum sum only (could require reconstructing paths)\",\n    \"special_conditions\": [\n      \"allow negative fruits (penalty cells)\",\n      \"add obstacles\",\n      \"introduce time windows for visits\"\n    ]\n  }\n}"
  },
  {
    "title": "Zero Array Transformation III",
    "slug": "zero-array-transformation-iii",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1], 其中 n = len(nums)",
        "二维查询数组 queries, 每个 query = [l_i, r_i] 表示一个闭区间操作",
        "nums[i] ≥ 0, 且值域可达 1e5",
        "queries.length ≤ 1e5, 每个查询满足 0 <= l_i <= r_i < n"
      ],
      "Core Constraint": [
        "每个 query 可独立地将区间 [l_i, r_i] 内的每个元素最多减 1",
        "多个 query 的作用可叠加，但每个位置 i 的总减少量不能超过 nums[i]",
        "目标是保留最少的 queries 子集使 nums 能被完全归零，即：最大化删除数量等价于最小化必要操作数",
        "问题本质转化为覆盖约束下的冗余操作识别：每个位置 i 必须被至少 nums[i] 个覆盖它的查询所‘服务’"
      ],
      "Objective Function": "最大化可删除的查询数量，使得剩余查询仍能将 nums 变为零数组；若不可能，返回 -1",
      "Algorithmic Invariant": [
        "贪心选择不变性：优先保留右端点较小的查询（类区间调度思想），以保障左部覆盖有效性",
        "差分标记 + 事件扫描不变性：可通过差分数组或事件法统计每个位置被多少查询覆盖",
        "二分答案可行性不变性：若可删 k 个，则可删 k' < k 个；故可二分答案并验证剩余查询是否足以覆盖 nums",
        "验证过程中的贪心分配不变性：对每个位置 i，优先使用能覆盖 i 且尚未耗尽的、右端点最靠左的查询（避免浪费高覆盖力查询）"
      ],
      "Transformable Parameters": [
        "n 的数量级：1e5 → 可扩展至动态插入/删除元素",
        "nums 值域：非负整数 → 是否允许负数（需调整可行性判定）",
        "queries 是否有序：当前无序 → 可设定按左/右端点排序",
        "是否多组数据：单组输入 → 多组测试用例",
        "是否在线：所有 queries 一次性给出 → 支持在线添加查询并实时判断最大可删数",
        "操作类型变化：最多减 1 → 减 c_i（带权查询）",
        "目标函数变换：最大化删除数 → 判断是否存在方案 / 构造最优保留集合",
        "约束反转：从‘最多减1’变为‘必须恰好减1’或‘至少减1’",
        "输入维度升级：从一维数组 → 二维网格上的矩形操作（类似二维差分）"
      ]
    }
  },
  {
    "title": "Sum of Good Subsequences",
    "slug": "sum-of-good-subsequences",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 1e5",
        "value_range": "0 <= nums[i] <= 1e5",
        "order_matters": true,
        "allows_duplicates": true,
        "is_ordered": false
      },
      "Core Constraint": {
        "subsequence_condition": "任意两个连续元素的绝对差恰好为 1",
        "base_case": "长度为 1 的子序列默认满足条件",
        "dependency_structure": "当前元素能否接在某个子序列后，仅取决于其前一个元素是否为 nums[i]-1 或 nums[i]+1",
        "state_composition": "以某数值结尾的所有好子序列的信息可被聚合表示"
      },
      "Objective Function": {
        "goal": "sum",
        "target": "所有可能的好子序列中，所有元素的总和（每个子序列中每个元素都计入一次）",
        "modular_arithmetic": "结果需对 1e9+7 取余"
      },
      "Algorithmic Invariant": {
        "dynamic_programming_state": "dp[x] 表示以数值 x 结尾的所有好子序列的元素总和（已去重聚合）",
        "transition_rule": "对于当前 nums[i] = x，更新 dp[x] 时考虑从 dp[x-1] 和 dp[x+1] 转移：新贡献 = (dp[x-1] + dp[x+1]) + x，其中 +x 是单元素子序列",
        "invariant_property": "处理完前 i 个元素后，dp[x] 始终准确表示以 x 结尾的所有合法子序列的元素和",
        "optimality_preservation": "由于转移只依赖相邻值的状态，且每个位置独立更新，状态可增量维护"
      },
      "Transformable Parameters": {
        "n_value_range": "1e3 / 1e5 / 动态增长",
        "nums_value_range": "较小范围（如 [0, 100]）或较大范围（如 [0, 1e6]）",
        "mod_enabled": true,
        "mod_value": "1e9+7 或其他质数",
        "input_form": "单组输入 / 多组测试数据",
        "data_streaming": "离线处理 / 在线查询（逐个添加元素并询问当前总和）",
        "output_variation": [
          "仅返回方案数",
          "返回最长好子序列的和",
          "返回不同子序列数量",
          "要求构造字典序最小的一个"
        ],
        "constraint_modification": {
          "diff_k": "将‘差为1’推广为‘差为k’",
          "non_consecutive_abs_diff": "允许差 ≤1 或 ∈ {1,2}",
          "minimum_length": "禁止长度为1的子序列"
        },
        "structure_extension": "扩展到树上路径的好序列求和 / 二维网格中的好路径"
      }
    }
  },
  {
    "title": "Maximize the Number of Target Nodes After Connecting Trees II",
    "slug": "maximize-the-number-of-target-nodes-after-connecting-trees-ii",
    "schema": {
      "Input Structure": [
        "两棵无向树 T1 和 T2",
        "T1 的节点数为 n，节点编号为 [0, n-1]，边集 edges1 长度为 n-1",
        "T2 的节点数为 m，节点编号为 [0, m-1]，边集 edges2 长度为 m-1",
        "每棵树通过边列表形式给出，保证是合法的树结构"
      ],
      "Core Constraint": [
        "目标节点定义：两个节点间路径边数为偶数时互为目标节点（包括自身）",
        "可在 T1 中任选一个节点 u，与 T2 中任选一个节点 v 添加一条跨树边 (u, v)",
        "添加后形成的新图中，T1 中每个节点 i 到其在整张图中的目标节点数量发生变化",
        "每次查询独立：添加边后立即删除，不影响后续查询",
        "关键观察：添加跨边后，T2 中每个节点到 v 的距离奇偶性决定了其是否能被 T1 中某节点通过偶路径到达"
      ],
      "Objective Function": [
        "对每个 i ∈ [0, n-1]，求：通过选择最优的 v ∈ [0, m-1] 连接 T1[i] 与 T2[v]，使得在合并图中，从 T1[i] 出发能到达的、路径长度为偶数的节点总数最大",
        "输出长度为 n 的数组 answer，answer[i] 表示该最大值"
      ],
      "Algorithmic Invariant": [
        "树中任意两点间路径唯一，距离可预处理（BFS/DFS）",
        "路径长度奇偶性满足模 2 加法：dist(a,c) ≡ dist(a,b) + dist(b,c) (mod 2)",
        "一旦选定连接点 v，则 T2 中所有与 v 距离为偶数的节点均可被 T1 中通过偶路径访问（若整体路径为偶）",
        "对于固定连接点 v，T2 中偶距离节点数和奇距离节点数是固定的，记作 even2[v], odd2[v]",
        "T1 中节点 i 到其子树内各点的距离奇偶性也可预计算；当连接 (i,v) 后，T1 中所有与 i 距离为 d 的节点 x，其通往 T2 中节点 w 的路径长度为 d + 1 + dist(v,w)",
        "因此，x 能访问 T2 中满足 (d + 1 + dist(v,w)) % 2 == 0 的节点 w → 即 dist(v,w) % 2 == (1 - d % 2)",
        "故对于每个 i，在连接至 v 后，能引入的 T2 节点数为：",
        "  if (dist(i,x) % 2 == 0): 可带入 T2 中与 v 奇距离的节点数（因 0+1+odd = even）",
        "  if (dist(i,x) % 2 == 1): 可带入 T2 中与 v 偶距离的节点数（因 1+1+even = even）",
        "但注意：最终统计的是从 i 出发可达的总目标节点数（包含 T1 内部和 T2 中部分）",
        "→ 所以需先预处理每棵树中每个节点出发的偶/奇距离节点分布",
        "→ 枚举连接点 v，计算 total = |{x ∈ T1: dist(i,x) 为偶}| + max_v_choice( 引入的 T2 节点数 )",
        "→ 对每个 i，枚举 v 并取最大即可"
      ],
      "Transformable Parameters": {
        "n, m 的数量级": "2 <= n, m <= 1e5，要求 O(n + m) 或 O(n log n) 解法",
        "是否多组数据": false,
        "是否在线": false,
        "输入形式": "边列表形式输入两棵树，无向图",
        "值域限制": "节点编号为非负整数，无重复边，保证是树",
        "是否允许负权或带权边": false,
        "是否循环结构": false,
        "是否可修改图结构": false,
        "目标函数可变位": [
          "改为最小化目标节点数",
          "改为计数所有可能连接下的期望值",
          "改为判定是否存在某个连接使 answer[i] >= K",
          "扩展为多棵树连接"
        ],
        "约束可变位": [
          "路径长度改为模 k 同余（如 mod 3 == 0）",
          "连接边数从 1 条变为 k 条",
          "不再删除边（持久化连接）"
        ],
        "数据流化扩展": "支持动态加边 / 删除边的在线版本（较难）"
      }
    }
  },
  {
    "title": "Minimum Positive Sum Subarray ",
    "slug": "minimum-positive-sum-subarray",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          -1000,
          1000
        ],
        "constraints": [
          "nums.length >= 1",
          "l and r are integers with 1 <= l <= r <= nums.length"
        ],
        "subarray_definition": "contiguous non-empty sequence"
      },
      "Core Constraint": {
        "length_constraint": "subarray length ∈ [l, r]",
        "sum_constraint": "subarray sum > 0",
        "feasibility_condition": "only consider positive-sum subarrays within the length window",
        "dependency_structure": "sum depends on contiguous elements; prefix sums can be used for efficiency"
      },
      "Objective Function": {
        "goal": "minimize",
        "target": "sum of valid subarray",
        "output_type": "integer",
        "failure_case": "return -1 if no such subarray exists"
      },
      "Algorithmic Invariant": {
        "invariant_type": "sliding window with bounded length",
        "key_observations": [
          "for fixed right endpoint, we want to minimize prefix difference under length and positivity constraints",
          "monotonicity in candidate selection: smaller prefix values are better when computing (prefix[j] - prefix[i])",
          "we can use deque or two-pointer to maintain eligible left endpoints within [j-r, j-l] range"
        ],
        "optimality_preservation": "maintaining candidates in increasing order of prefix value ensures greedy choice correctness",
        "window_movement": "as right pointer moves, outdated indices fall out of [j-r, j-l] window and can be discarded"
      },
      "Transformable Parameters": {
        "n_scale": "1 <= n <= 100 (small), but can scale to 1e5 for harder version",
        "value_domain": {
          "original": "[-1000, 1000]",
          "possible_variants": [
            "non-negative only",
            "strictly negative allowed",
            "bounded vs unbounded"
          ]
        },
        "length_window": {
          "l_r_relation": "l <= r; can be fixed width (l == r), variable (l < r)",
          "extreme_cases": [
            "l = 1",
            "r = n",
            "l ≈ r",
            "r - l small"
          ]
        },
        "input_form": {
          "single_instance": true,
          "multi_query": false,
          "online_updates": false,
          "possible_extensions": [
            "support insert/delete",
            "dynamic queries"
          ]
        },
        "ordering": {
          "sorted_input": false,
          "can_be_enforced": false
        },
        "objective_transforms": [
          "change min(sum) → max(sum)",
          "change sum > 0 → sum >= K",
          "count number of valid subarrays instead of optimizing sum",
          "find longest/shortest valid subarray"
        ],
        "structural_transforms": [
          "1D → circular array",
          "allow empty subarray",
          "extend to 2D grid with rectangular regions"
        ]
      }
    }
  },
  {
    "title": "Zero Array Transformation II",
    "slug": "zero-array-transformation-ii",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1], 其中 n = len(nums)",
        "二维查询数组 queries, 每个 query = [l_i, r_i, val_i]",
        "nums[i] ≥ 0, val_i ≥ 1",
        "l_i, r_i 为有效下标区间"
      ],
      "Core Constraint": [
        "每个查询操作作用于一个连续下标区间 [l_i, r_i]",
        "每次操作可对区间内每个位置独立地减少最多 val_i 的值",
        "所有操作必须按顺序处理，且每个操作只能使用一次",
        "目标是使最终数组所有元素变为 0",
        "问题具有前缀性质：前 k 个操作能否清零数组"
      ],
      "Objective Function": "求最小的非负整数 k，使得顺序执行前 k 个查询后，nums 变为零数组；若不存在则返回 -1",
      "Algorithmic Invariant": [
        "单调性：若前 k 个查询能将数组归零，则前 k+1 个也具备此能力（但不一定更优）",
        "贪心可行性：在验证某个 k 是否可行时，应对每个位置 j 尽可能多地分配减量（即不超过 nums[j] 的总减少量）",
        "差分约束建模不变量：每个位置 j 的总减量不能超过其初始值 nums[j]，且每次贡献来自覆盖 j 的查询",
        "二分答案适用性：k 的最小性 + 单调性支持二分搜索"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 <= n <= 1e5",
          "queries.length": "1 <= m <= 1e5"
        },
        "值域范围": {
          "nums[i]": "0 <= nums[i] <= 5e5",
          "val_i": "1 <= val_i <= 5"
        },
        "输入形式": {
          "是否有序": false,
          "是否循环": false,
          "是否多组数据": "可扩展为多组测试用例",
          "是否在线": "当前为离线批量输入，可改造为流式查询输入"
        },
        "操作类型扩展": [
          "支持增加操作（val_i 可正可负）",
          "支持删除或修改历史查询",
          "允许跨区间合并优化"
        ],
        "目标函数变换": [
          "改为最大化 k 使得仍未归零",
          "计数有多少个 k 能达成零数组",
          "判定是否存在某个 k 成立"
        ],
        "约束变化": [
          "每个查询只能使用一次 vs 可重复使用",
          "每个位置最多被覆盖 K 次",
          "每次减量必须相同（不能独立选择）"
        ]
      }
    }
  },
  {
    "title": "Premier League Table Ranking III",
    "slug": "premier-league-table-ranking-iii",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组中能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针 L 和 R 分别从左右两端向内收缩；维护 maxLeft 表示 H[0..L] 的最大值，maxRight 表示 H[R..n-1] 的最大值；当 maxLeft ≤ maxRight 时，L 处的蓄水量仅由 maxLeft 决定，可安全累加并右移 L；反之则处理 R 并左移；指针移动过程中不破坏已计算部分的正确性",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许负数（如地下结构）",
        "维度扩展": "是否推广到二维矩阵（2D 接雨水问题）",
        "输入模式": "是否在线输入或支持动态修改（加入更新操作）",
        "输出要求": "是否需要输出每个位置的具体蓄水量而非总和",
        "数据规模": "n 的数量级（例如 1e3 / 1e5 / 1e7，影响解法选择）",
        "多组数据": "是否包含多组测试用例独立处理",
        "约束变形": "是否限制只能使用单侧信息（如流式处理，不可回看）"
      }
    }
  },
  {
    "title": "Maximum Frequency of an Element After Performing Operations II",
    "slug": "maximum-frequency-of-an-element-after-performing-operations-ii",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "每个元素 nums[i] ∈ [1, 10^9]",
        "两个整数参数 k 和 numOperations",
        "1 <= n <= 10^5",
        "0 <= numOperations <= n"
      ],
      "Core Constraint": [
        "每次操作可选择一个未被选过的下标 i，将 nums[i] 增加 [-k, k] 范围内的任意整数",
        "每个下标最多被操作一次",
        "最终目标是使某个值的频率最大化",
        "多个不同原始值可通过调整进入同一目标值范围"
      ],
      "Objective Function": "最大化数组中某一元素的出现频率（即频次）",
      "Algorithmic Invariant": [
        "贪心决策不变性：优先将尽可能多的数值通过操作映射到同一个目标值上",
        "区间覆盖不变性：对任意候选目标值 x，能被调整为 x 的原数值必须满足 |nums[i] - x| <= k",
        "操作独立性：每个下标只能贡献一次，因此每个 nums[i] 最多被计入一个目标值的覆盖范围内",
        "最优解一定对应至少一个 nums[i] ± k 中的某个边界值作为目标值（离散化枚举依据）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1e5 可扩展至 1e6（要求 O(n log n) 解法）",
          "值域": "nums[i] 和 k 可达 1e9，支持离散化处理"
        },
        "约束条件": {
          "k 是否为零": "若 k=0，则只能复制已有元素",
          "numOperations 是否受限": "若 numOperations >= n，则所有元素均可调整",
          "是否允许多次操作同一位置": "当前不允许，可改为允许但总变化量不超过 k"
        },
        "输入输出形式": {
          "目标函数变体": [
            "求最大频率 → 求能达到频率 T 的最小操作次数",
            "求最大频率 → 枚举所有可达的最大频次方案"
          ],
          "输出类型": "返回整数（频次），也可改为返回达成该频次的目标值集合"
        },
        "是否多组数据": false,
        "是否在线": {
          "静态输入": true,
          "可变形为在线版本": "每次添加一个新元素或操作额度，需动态维护最大频率"
        },
        "隐藏条件变换": [
          "显式枚举目标值 → 隐式单调性：排序后滑动窗口统计有效覆盖点数",
          "固定 k → k_i 与下标相关"
        ]
      }
    }
  },
  {
    "title": "Zero Array Transformation I",
    "slug": "zero-array-transformation-i",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[0..n-1], 其中 n = length(nums)",
        "二维查询数组 queries, 每个 query[i] = [l_i, r_i], 表示一个闭区间",
        "nums[i] ≥ 0",
        "1 <= n <= 1e5, 1 <= len(queries) <= 1e5"
      ],
      "Core Constraint": [
        "每个查询只能作用于其指定的区间 [l_i, r_i] 内的下标子集",
        "每次操作可任意选择该区间内的下标子集进行减 1 操作（非必须全覆盖）",
        "所有查询必须按顺序处理",
        "每个位置最终被减去的总次数必须恰好等于其初始值 nums[i]",
        "每个位置不能被过度减少（即不能出现负数）"
      ],
      "Objective Function": "判定是否存在一种合法的操作方案，使得在按顺序处理完所有查询后，nums 变为零数组",
      "Algorithmic Invariant": [
        "贪心策略：越早发生的查询应尽可能多地承担减量任务（尤其是对高数值位置）",
        "差分数组维护当前已安排的减操作覆盖情况",
        "从左到右扫描数组，利用事件队列（如优先队列）维护当前活跃的、能覆盖当前位置的未完成查询",
        "对于每个位置 i，累计所有能覆盖 i 的查询所提供的最大可能减量，若仍不足 nums[i]，则无解",
        "查询不可逆序使用，因此必须在线性扫描中动态决策分配"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n_value_range": "1e3 / 1e5",
          "queries_length_range": "1e3 / 1e5"
        },
        "输入形式": [
          "是否离线处理所有查询（当前是离线）",
          "是否允许修改 nums 或 queries 顺序（当前不允许）"
        ],
        "约束条件": [
          "每个查询是否必须覆盖整个区间（当前可选子集，自由选择）",
          "是否要求每个查询至少选择一个下标",
          "是否允许多次使用同一查询"
        ],
        "目标函数变体": [
          "改为最小化无法归零的元素个数（计数型）",
          "改为求最大可归零前缀长度",
          "改为构造具体方案（构造型）"
        ],
        "数据流化": [
          "是否支持在线查询添加（动态增加 queries）",
          "是否支持 nums 动态更新"
        ],
        "结构扩展": [
          "1D → 2D 数组上的区域操作查询",
          "区间操作变为树上路径操作（图结构变形）"
        ]
      }
    }
  },
  {
    "title": "Minimum Operations to Make Character Frequencies Equal",
    "slug": "minimum-operations-to-make-character-frequencies-equal",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length_range": [
          1,
          20000
        ],
        "representation": "s[1..n], where s[i] ∈ 'a'..'z'"
      },
      "Core Constraint": {
        "good_string_definition": "all character frequencies in the string are equal",
        "allowed_operations": [
          "delete any character",
          "insert any character",
          "increment any character to next letter (except 'z' cannot become 'a')"
        ],
        "operation_cost": "each operation costs 1, regardless of type"
      },
      "Objective Function": "minimize total number of operations to transform s into a good string",
      "Algorithmic Invariant": {
        "frequency_uniformity": "after transformation, every present character has the same frequency f",
        "candidate_frequency_space": "f must be a positive integer ≤ n, and ideally divides adjusted total length",
        "monotonic_adjustment": "for fixed target frequency f, cost can be computed independently per character: insertion, deletion, or increment adjustments do not interfere across distinct characters",
        "decoupling_of_changes": "character increments only affect frequency distribution indirectly by enabling reuse under new labels; however, optimal strategy fixes final frequency and assignment before considering transformations"
      },
      "Transformable Parameters": {
        "n_magnitude": "1 <= n <= 2e4",
        "alphabet_size": 26,
        "circular_increment": false,
        "operation_set_variants": [
          "allow decrement as well",
          "allow z -> a wraparound",
          "limit insertions/deletions",
          "assign different costs to each operation"
        ],
        "output_type": "single integer (min operations)",
        "input_variability": "single string input",
        "online_queries": false,
        "multiple_test_cases": true,
        "target_frequency_constraint": "can be generalized to require exactly k distinct characters with uniform count"
      }
    }
  },
  {
    "title": "Count Number of Balanced Permutations",
    "slug": "count-number-of-balanced-permutations",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "长度为 n 的数字字符串 num",
        "constraints": [
          "2 <= n <= 80",
          "字符仅包含 '0' 到 '9'",
          "可包含重复数字"
        ]
      },
      "Core Constraint": {
        "description": "平衡字符串定义为：奇数位下标（1-indexed 或 0-indexed）的数字之和等于偶数位下标的数字之和",
        "implication": "排列中位置的奇偶性决定其归属分组，需将数字分配到奇偶位置并满足和相等"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计 num 所有不同排列中，满足平衡条件的排列数目",
        "output_mod": 1000000007
      },
      "Algorithmic Invariant": {
        "invariant": [
          "总数字集合固定，问题转化为将数字划分到奇数位和偶数位两个集合中",
          "若已知奇偶位置数量（即 len_odd, len_even），则问题变为从多重集数字中选出 len_odd 个数字填入奇位，其余填入偶位，且二者数字和相等",
          "状态转移中，使用动态规划记录当前数字种类、已用个数、奇位与偶位的和差（或相对和）不变性",
          "利用组合数学与背包式 DP 可保持计数不重复（考虑重复字符的去重）"
        ],
        "key_insight": "由于字符串是全排列，实际是多重集合的分配问题；通过 DP 枚举各数字在奇偶位置的分配方式，并保证和相等"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n",
            "range": "2 <= n <= 80",
            "transformable_to": "更小规模（用于枚举）、更大规模（引入生成函数/FFT优化DP）"
          },
          {
            "name": "digit_set",
            "values": "'0'-'9'",
            "transformable_to": "字母字符（改变平衡定义）、负数（不允许）"
          },
          {
            "name": "balance_condition",
            "original": "奇数位下标数字和 == 偶数位下标数字和",
            "transformable_to": [
              "奇数位 > 偶数位（目标变换）",
              "差值为 K（约束参数化）",
              "按模意义下平衡（如 mod 3 相等）"
            ]
          },
          {
            "name": "index_base",
            "original": "0-indexed 或 1-indexed 下标解释均可，但影响奇偶分配",
            "transformable_to": "显式指定起始下标奇偶性"
          },
          {
            "name": "output_form",
            "original": "返回方案数 mod 1e9+7",
            "transformable_to": "返回是否存在 / 返回任意一个解 / 输出所有解（小规模）"
          },
          {
            "name": "input_type",
            "original": "单一字符串",
            "transformable_to": "多组测试数据 / 在线输入多个 num"
          },
          {
            "name": "uniqueness",
            "original": "不同排列去重（考虑重复字符）",
            "transformable_to": "允许重复计数（即视为有标号）"
          }
        ]
      }
    }
  },
  {
    "title": "Check Balanced String",
    "slug": "check-balanced-string",
    "schema": {
      "Input Structure": "字符串 num[1..n]，其中每个字符为 '0' 到 '9' 的数字字符，n ≥ 2",
      "Core Constraint": "偶数下标（0-indexed）与奇数下标位置的数字值相互独立，可分别累加；下标奇偶性决定归属组",
      "Objective Function": "判定偶数下标处数字之和是否等于奇数下标处数字之和（判定问题）",
      "Algorithmic Invariant": "遍历过程中维护两个累加器：even_sum 和 odd_sum；每读取一个字符，根据其下标奇偶性更新对应累加器；最终比较二者相等性即可得出结果，且顺序扫描不改变累加结果的正确性",
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 100",
        "值域": "字符仅限 '0'-'9'",
        "是否有序": "输入顺序固定，下标意义明确",
        "是否循环": "否",
        "是否多组输入": "单组输入",
        "是否在线": "离线处理，一次性输入",
        "可变目标函数": [
          "改为最小化插入/修改次数使字符串平衡",
          "计数类：统计所有子串中平衡的数量",
          "构造类：构造最短/最长平衡字符串"
        ],
        "奇偶定义变化": "可改为 1-indexed 下的奇偶判断",
        "分组规则扩展": "按模 k 分组求和（如 mod 3 == 0,1,2 分别求和）"
      }
    }
  },
  {
    "title": "Smallest Divisible Digit Product II",
    "slug": "smallest-divisible-digit-product-ii",
    "schema": {
      "Input Structure": [
        "字符串 num，表示一个正整数，长度为 n（2 ≤ n ≤ 2×10⁵）",
        "字符集：'1' 到 '9'（无前导零，但可能含 '0' 在中间，需注意题意中目标数不能含 '0'）",
        "整数 t（1 ≤ t ≤ 10¹⁴）"
      ],
      "Core Constraint": [
        "输出的整数必须大于等于输入 num 对应的数值",
        "输出的整数不能包含数位 0（即每一位 ∈ {'1','2',...,'9'}）",
        "输出整数的各数位之积必须能被 t 整除",
        "由于数位乘积增长极快且仅由 1-9 构成，存在组合爆炸与剪枝可行性",
        "搜索空间受限于：最小满足条件的无零整数，因此具有单调性可利用"
      ],
      "Objective Function": "构造并返回大于等于 num 的最小无零整数，使得其数位乘积能被 t 整除；若不存在则返回 \"-1\"",
      "Algorithmic Invariant": [
        "从小到大枚举候选数字时，使用贪心+逐位构造策略可保证最小性",
        "数位乘积只与质因数构成有关（特别是 2,3,5,7），可将 t 分解后追踪所需因子余量",
        "在递增构造过程中，一旦当前前缀对应的最小扩展（如全填1）已超过可行范围或无法满足因子需求，则可剪枝",
        "若某前缀的所有延伸都无法满足乘积被 t 整除，则该前缀可丢弃（子问题最优性）",
        "从左往右逐位确定的过程中，保持已选前缀的乘积对 t 的约化余量状态不变量"
      ],
      "Transformable Parameters": {
        "n 的数量级": "2 ≤ n ≤ 2×10⁵ → 可改为小规模（≤10）用于暴力验证，或更大规模带优化",
        "值域": {
          "num 范围": "字符串形式的大整数（需模拟）",
          "t 范围": "1 ≤ t ≤ 10¹⁴ → 可变换为更小（如 ≤100）或加入模意义约束"
        },
        "是否有序": "num 是升序起点，要求输出 ≥num 的最小值 → 可变形为 ≤num 的最大值",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "数位限制": "禁止出现 '0' → 可变为禁止某些其他数字（如无4、无7）、或允许0但有惩罚",
        "目标函数变化": [
          "计数：有多少个小于等于 N 的无零整数满足乘积被 t 整除",
          "判定：是否存在这样的整数",
          "最小化数位和而非数值大小"
        ],
        "附加操作": "支持动态修改 t 或 num 的某一位，查询更新后的答案（在线版本）"
      }
    }
  },
  {
    "title": "Find Mirror Score of a String",
    "slug": "find-mirror-score-of-a-string",
    "schema": {
      "Input Structure": [
        "一维字符串 s[1..n]",
        "s[i] ∈ {'a'..'z'}",
        "n ≥ 1, n ≤ 1e5"
      ],
      "Core Constraint": [
        "每个字符的镜像定义为：mirror(c) = 'z' - (c - 'a')",
        "对于位置 i，只能与 j < i 且未被标记的 j 配对",
        "配对条件：s[j] == mirror(s[i])",
        "一旦 i 或 j 被标记，则不能再参与后续匹配",
        "必须从左到右顺序处理每个位置"
      ],
      "Objective Function": "最大化总得分（即所有成功配对的 (i - j) 之和）",
      "Algorithmic Invariant": [
        "贪心选择：对每个 i，若存在可用的 j 满足条件，则选择距离最近的 j（最小化 j 的浪费，保留更远的 j 给未来更大的 i 使用）",
        "已处理的位置的状态（是否标记）不可逆",
        "未标记的候选 j 可通过栈或哈希表维护，保证查找效率",
        "每一步决策仅依赖于历史信息，不回溯"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1e5",
        "字符集类型": "小写英文字母（可扩展至大写、数字等）",
        "镜像规则": "线性对称映射（可改为非对称、自定义映射表）",
        "是否允许重复使用字符": "否（可变更为允许多次使用，改变问题性质）",
        "遍历方向": "从左到右（可改为从右到左，影响最近定义）",
        "‘最近’定义": "下标差最小（可改为字典序、加权距离等）",
        "是否多组数据": "单组输入（可扩展为多测）",
        "是否在线处理": "离线一次性输入（可改为流式字符输入）",
        "输出形式": "返回总分（可改为输出配对方案、最大可能得分等）"
      }
    }
  },
  {
    "title": "Maximize the Number of Target Nodes After Connecting Trees I",
    "slug": "maximize-the-number-of-target-nodes-after-connecting-trees-i",
    "schema": {
      "Input Structure": [
        "两棵无向树 T1 和 T2",
        "T1 有 n 个节点，编号为 [0, n-1]，边集 edges1 长度为 n-1",
        "T2 有 m 个节点，编号为 [0, m-1]，边集 edges2 长度为 m-1",
        "每棵树均为合法的无环连通图（树结构）",
        "整数 k 表示目标节点的距离阈值"
      ],
      "Core Constraint": [
        "目标节点定义：若两节点间路径边数 ≤ k，则互为目标节点",
        "一个节点总是自己的目标节点",
        "每次查询独立：可在 T1 的任意节点 u 与 T2 的任意节点 v 之间添加一条边，随后删除",
        "添加边后形成的新图仍为一棵树（无环），但连接后两棵树合并成一个连通图",
        "距离计算基于整个新图的最短路径"
      ],
      "Objective Function": [
        "对第一棵树中的每个节点 i（即 u ∈ [0, n-1]），求出在最优选择第二棵树中连接点 v ∈ [0, m-1] 的前提下，",
        "使得在新图中，从 i 出发距离 ≤ k 的节点总数（即目标节点数目）最大化",
        "返回长度为 n 的数组 answer，answer[i] = 最大可达的目标节点数"
      ],
      "Algorithmic Invariant": [
        "树中任意两点间路径唯一，距离可通过 BFS/DFS 预处理得到",
        "添加跨树边 (u, v) 后，T1 中节点 i 到 T2 中节点 x 的距离 = dist_T1(i, u) + 1 + dist_T2(v, x)",
        "对于固定 i 和 u，枚举 v 可遍历所有可能的连接方式以最大化覆盖范围",
        "可预处理两棵树中所有点对的最短距离（全源最短路）",
        "对每个树 T2 中的节点 v，可预先统计其 k-hop 范围内的节点数量（depth-limited node count）",
        "利用 T2 中各节点为中心、不同半径下的覆盖规模，结合连接点偏移量进行快速评估"
      ],
      "Transformable Parameters": {
        "n": "第一棵树的节点数，范围 [2, 1000]",
        "m": "第二棵树的节点数，范围 [2, 1000]",
        "k": "目标节点距离阈值，可变参数，范围 [0, 1000]",
        "edges1": "T1 的边集，形式为二维整数数组，可替换为邻接表或其他输入格式",
        "edges2": "T2 的边集，同上",
        "是否有序": false,
        "是否循环": false,
        "是否多组数据": false,
        "是否在线": false,
        "值域": "节点编号为非负整数，边权默认为 1（单位权重）",
        "扩展方向": [
          "边权非单位化 → 变为带权图，目标变为路径权重和 ≤ k",
          "多轮持久连接 → 不再每次删除新增边",
          "双向影响 → 求两棵树中所有节点的目标节点总数最大值",
          "限制连接点集合 → v 必须来自 T2 的特定子集",
          "二维化变形 → 多棵树连接形成网络，求枢纽节点最优对接"
        ]
      }
    }
  },
  {
    "title": "Button with Longest Push Time",
    "slug": "button-with-longest-push-time",
    "schema": {
      "Input Structure": {
        "type": "2D array",
        "description": "events[1..n] where each event is [index_i, time_i]",
        "constraints": [
          "n >= 1",
          "index_i ∈ [1, 1e5]",
          "time_i ∈ [1, 1e5]",
          "events sorted by time_i in increasing order"
        ]
      },
      "Core Constraint": {
        "description": "The press duration of a button is defined as the time difference between two consecutive presses of any button. For the first occurrence of a button (relative to global timeline), its press duration is equal to its timestamp. Subsequent occurrences contribute durations based on previous global event time.",
        "key_insight": "Duration accumulation per index depends on temporal ordering across all indices; events are interleaved but globally ordered by time."
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "button index with longest total press duration",
        "tie_breaker": "if durations are equal, return smallest index"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "Global time sequence ensures monotonic traversal: processing events in order preserves correctness of duration computation.",
          "Each button's current duration can be updated only when its next event occurs, using the last seen global time.",
          "Maintaining running max duration with minimal index upon tie does not require full sorting — can be done in one pass."
        ],
        "proof_basis": "Temporal monotonicity guarantees that prior event time is always less than or equal to current, enabling incremental update without backtracking."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n",
            "range": "1 <= n <= 1000",
            "modifiable": true,
            "new_range_options": [
              "up to 1e5",
              "online stream"
            ]
          },
          {
            "name": "index_domain",
            "range": "[1, 1e5]",
            "modifiable": true,
            "options": [
              "negative indices allowed",
              "string labels instead of integers"
            ]
          },
          {
            "name": "time_domain",
            "range": "[1, 1e5]",
            "modifiable": true,
            "options": [
              "floating point times",
              "non-monotonic input requiring sort"
            ]
          },
          {
            "name": "sorting_requirement",
            "value": "events sorted by time",
            "reversible": true,
            "transform": "unsorted → requires preprocessing sort"
          },
          {
            "name": "input_type",
            "modality": "batch",
            "extendible": true,
            "options": [
              "online queries",
              "streaming events with deletion"
            ]
          },
          {
            "name": "objective_variation",
            "original": "longest press duration, min index on tie",
            "possible_transforms": [
              "shortest non-zero duration",
              "count how many buttons exceed threshold K",
              "return all indices with maximum duration"
            ]
          },
          {
            "name": "duration_definition",
            "original": "inter-event time difference (global clock)",
            "alterable": true,
            "alternatives": [
              "local per-button timer reset on each press",
              "cumulative active time over multiple sessions"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Count K-Reducible Numbers Less Than N",
    "slug": "count-k-reducible-numbers-less-than-n",
    "schema": {
      "Input Structure": [
        "二进制字符串 s，表示正整数 n 的二进制形式（无前导零，长度 1 <= |s| <= 800）",
        "整数 k（1 <= k <= 5）",
        "定义函数 f(x) = x 的二进制表示中 1 的个数（popcount）",
        "x 被称为 k-可约简，当且仅当从 x 出发，重复应用 f 最多 k 次后能到达 1"
      ],
      "Core Constraint": [
        "f(x) 远小于 x（当 x > 2 时），因此迭代过程快速收敛到小值域",
        "所有大于 1 的整数在多次 f 操作下最终都会进入循环或收敛到 1",
        "k 很小（≤5），因此可预计算每个数的“约简步数”",
        "问题本质是：统计 [1, n) 中满足“约简步数 ≤ k”的整数个数",
        "由于 n 极大（由长度达 800 的二进制串表示），不能枚举，需数位 DP"
      ],
      "Objective Function": "计数：统计小于 n 的正整数中，k-可约简整数的个数（对 1e9+7 取模）",
      "Algorithmic Invariant": [
        "数位 DP 状态中记录当前是否紧贴上界（tight）、是否已开始非零位（started）、当前数值的 popcount 迭代路径可被压缩为‘剩余步数’",
        "预处理：对所有可能的中间值（尤其是 ≤ 800 的数，因为 f(x) ≤ log2(x)+1 ≤ 800）计算其变为 1 所需的最少操作步数",
        "一旦知道某个前缀对应的剩余部分最大可能 popcount，即可查表得其后续是否能在 ≤ k 步内归 1",
        "状态转移不破坏已确定的前缀合法性与约束边界"
      ],
      "Transformable Parameters": [
        "二进制串长度范围：[1, 800] → 可改为 [1, 100] 或 [1, 5000]（影响复杂度）",
        "k 的取值范围：[1,5] → 可扩展至 [1,10] 或缩小至 [1,3]",
        "目标函数变化：从计数 → 判定是否存在 / 输出最小/最大 k-可约简数",
        "输入形式：从二进制字符串 → 十进制字符串 → 直接给 n（小规模）",
        "是否多组数据：单组 → 多组 T ≤ 100",
        "是否在线：离线处理 → 支持动态修改 k 查询",
        "约束反转：改为 '恰好 k 次' 或 '至少 k 次'",
        "隐藏条件：不显式给出 f 定义，而是描述为 '数字变为它二进制中 1 的个数'"
      ]
    }
  },
  {
    "title": "Total Characters in String After Transformations II",
    "slug": "total-characters-in-string-after-transformations-ii",
    "schema": {
      "Input Structure": [
        "字符串 s，由小写英文字母组成，长度为 n",
        "整数 t，表示转换次数，1 <= t <= 10^9",
        "长度为 26 的整数数组 nums，其中 nums[i] 表示字符 'a' + i 在一次转换中生成的后续连续字符个数",
        "每个字符每次转换扩展为 nums[c - 'a'] 个字符（回绕处理）"
      ],
      "Core Constraint": [
        "每个字符的转换规则是确定性的且仅依赖于其自身和 nums 数组",
        "转换过程具有可叠加性：一个字符经过多轮转换的结果可通过状态转移预计算",
        "字符扩展具有周期性或循环结构，可能形成状态循环（尤其在模意义下）",
        "字符串长度增长是各字符独立贡献之和"
      ],
      "Objective Function": "计算恰好执行 t 次转换后字符串的总长度，并对 10^9 + 7 取模",
      "Algorithmic Invariant": [
        "每个字符的扩展行为可以建模为状态机：26 个状态（对应字母 a-z），每次转换根据 nums 映射到新字符序列并累计长度贡献",
        "使用矩阵快速幂或倍增法维护每个字符在 k 轮转换后的总长度贡献",
        "状态转移具有结合律，支持快速幂优化",
        "不同字符的贡献可分离，最终结果为初始字符频次与各自 t 轮后长度倍率的加权和"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 <= n <= 10^5",
          "t": "1 <= t <= 10^9",
          "nums[i]": "1 <= nums[i] <= 25"
        },
        "是否有序": false,
        "是否循环": true,
        "输入形式": "静态离线输入（一次性给出 s, t, nums）",
        "是否多组数据": false,
        "是否在线": false,
        "值域约束": "字符限定为小写字母，nums 值较小但 t 极大",
        "可变目标函数": [
          "求最终字符串长度（当前）",
          "求某个特定字符出现次数",
          "求字典序最小结果（构造类变形）"
        ],
        "可变转换规则": [
          "非回绕转换（越界即停止）",
          "允许 nums[i] = 0（删除字符）",
          "引入上下文依赖（如基于前后字符调整转换）"
        ],
        "操作类型扩展": [
          "支持动态修改 nums",
          "支持区间字符单独转换"
        ]
      }
    }
  },
  {
    "title": "Total Characters in String After Transformations I",
    "slug": "total-characters-in-string-after-transformations-i",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，其中 s[i] ∈ 'a'..'z'",
        "整数 t 表示转换次数",
        "1 <= n <= 10^5",
        "1 <= t <= 10^5"
      ],
      "Core Constraint": [
        "每个字符独立进行转换",
        "'z' 转换为字符串 \"ab\"（长度为 2 的字符串）",
        "其他字符 c 转换为字母表中下一个字符（即 c + 1）",
        "所有字符在每轮转换中同时更新",
        "转换具有递推结构：'z' 的展开会引入 'a' 和 'b'，而 'a'~'y' 只线性推进"
      ],
      "Objective Function": [
        "计算恰好执行 t 次转换后最终字符串的长度",
        "返回结果对 10^9 + 7 取余"
      ],
      "Algorithmic Invariant": [
        "可以按字符类型动态维护各字符的出现频次（计数形式）",
        "使用频次数组 f[ch] 表示当前轮次中字符 ch 的数量",
        "每轮转换中：",
        "  - 对于 'a' ~ 'y'：f[ch+1] += f[ch]",
        "  - 对于 'z'：f['a'] += f['z'], f['b'] += f['z']",
        "  - 然后清空原 f[ch]",
        "整个过程满足线性转移，且状态仅依赖前一轮频次分布",
        "总长度 = 所有字符频次之和，可在每轮累加"
      ],
      "Transformable Parameters": [
        "t 的数量级（可扩展至 10^9，在此情况下需矩阵快速幂优化）",
        "是否允许大写字母或非英文字符",
        "是否多组数据输入",
        "'z' 的替换规则是否可变（如替换为 \"abc\" 或其他模式串）",
        "是否要求输出最终字符串（而非仅长度）",
        "是否在线执行转换（流式字符输入）",
        "字符集大小是否扩展（如模 k 字符环）",
        "是否支持回滚操作（反向转换）"
      ]
    }
  },
  {
    "title": "Find Minimum Time to Reach Last Room II",
    "slug": "find-minimum-time-to-reach-last-room-ii",
    "schema": {
      "Input Structure": {
        "type": "2D grid",
        "dimensions": "n x m",
        "array": "moveTime[0..n-1][0..m-1]",
        "element_constraint": "moveTime[i][j] >= 0",
        "start_point": "[0, 0]",
        "end_point": "[n-1, m-1]",
        "movement_rules": {
          "adjacent_moves_only": true,
          "directions": [
            "up",
            "down",
            "left",
            "right"
          ],
          "time_cost_pattern": "alternating: 1, 2, 1, 2, ..."
        }
      },
      "Core Constraint": {
        "entry_condition": "can only begin moving into cell (i,j) at or after time moveTime[i][j]",
        "path_dependency": "the cost of each move depends on the total number of previous moves (modulated by alternation)",
        "state_interdependence": "arrival time affects future move eligibility and cost sequence"
      },
      "Objective Function": "minimize total time to reach (n-1, m-1) from (0, 0)",
      "Algorithmic Invariant": {
        "state_representation": "state = (row, col, step_count_mod), where step_count_mod ∈ {0,1} indicates next move cost (1 if even, 2 if odd)",
        "monotonicity": "time is non-decreasing with transitions; Dijkstra-style relaxation applies",
        "optimal_substructure": "shortest path to a node at a given step parity is independent of longer paths",
        "priority_queue_invariant": "always expand the state with minimum arrival time"
      },
      "Transformable Parameters": {
        "grid_size": {
          "n_range": "[2, 750]",
          "m_range": "[2, 750]"
        },
        "moveTime_value_range": "[0, 1e9]",
        "time_cost_pattern": {
          "base_cycle": "alternating [1,2]",
          "possible_variants": [
            "fixed cost per move",
            "increasing cost: k-th move costs k",
            "cycle length > 2"
          ]
        },
        "input_form": {
          "offline": true,
          "single_query": true
        },
        "online_extension": "support dynamic updates to moveTime or query multiple destinations",
        "output_requirement": "only total time; optionally reconstruct path or report intermediate times",
        "additional_constraints": [
          "prohibit revisiting cells",
          "add energy/resource limits",
          "require waiting at cells"
        ]
      }
    }
  },
  {
    "title": "Find Minimum Time to Reach Last Room I",
    "slug": "find-minimum-time-to-reach-last-room-i",
    "schema": {
      "Input Structure": {
        "type": "2D grid",
        "dimensions": "n x m",
        "array": "moveTime[0..n-1][0..m-1]",
        "element_type": "non-negative integer",
        "moveTime[i][j]": "minimum time (in seconds) when room (i, j) becomes accessible",
        "start_position": "(0, 0)",
        "end_position": "(n-1, m-1)",
        "movement_rules": "can move to adjacent cells (up/down/left/right), each move takes exactly 1 second"
      },
      "Core Constraint": {
        "access_constraint": "can only enter cell (i, j) at time t if t >= moveTime[i][j]",
        "movement_dependency": "arrival time at next cell = max(current_time + 1, moveTime[next_i][next_j])",
        "path_dependency": "optimal path depends on both spatial position and current time state",
        "state_necessity": "time-aware traversal required; greedy step-by-step decisions insufficient without global relaxation"
      },
      "Objective Function": "minimize total time to reach destination cell (n-1, m-1) from (0, 0)",
      "Algorithmic Invariant": {
        "invariant_type": "relaxation-based shortest path in state space",
        "state_definition": "each state is (i, j, t) but optimized via Dijkstra: dist[i][j] = earliest known arrival time at (i, j)",
        "monotonicity": "arrival times are non-decreasing during exploration",
        "priority_queue_use": "always expand the node with smallest current time",
        "update_rule": "for neighbor (ni, nj): new_time = max(dist[i][j] + 1, moveTime[ni][nj]); update if smaller than current dist[ni][nj]",
        "correctness_guarantee": "once a node is finalized in Dijkstra's algorithm, its minimal arrival time is fixed"
      },
      "Transformable Parameters": {
        "grid_size": {
          "n_range": "2 <= n <= 50",
          "m_range": "2 <= m <= 50"
        },
        "time_value_range": "0 <= moveTime[i][j] <= 1e9",
        "is_online_query": false,
        "multiple_queries": false,
        "dynamic_updates": "moveTime changes over time (possible variant)",
        "movement_cost": {
          "base_cost": 1,
          "variable_cost": "can be generalized to weighted edges"
        },
        "connectivity": "4-directional adjacency",
        "start_end_positions": {
          "fixed": true,
          "variants": "could generalize to arbitrary start/end or multiple targets"
        },
        "time_constraints": "discrete time steps; no waiting limit",
        "waiting_allowed": true,
        "is_deterministic": true,
        "can_be_modified_to_3D": "yes, extend to 3D grid"
      }
    }
  },
  {
    "title": "Smallest Divisible Digit Product I",
    "slug": "smallest-divisible-digit-product-i",
    "schema": {
      "Input Structure": [
        "整数 n（1 <= n <= 100）",
        "整数 t（1 <= t <= 10）"
      ],
      "Core Constraint": [
        "目标整数必须 >= n",
        "其各位数字的乘积必须能被 t 整除",
        "数位乘积在包含 0 时为 0，0 可被任意正整数整除",
        "t 较小（≤10），允许对因数进行枚举和状态压缩"
      ],
      "Objective Function": "求满足条件的最小整数（最小化）",
      "Algorithmic Invariant": [
        "从 n 开始递增枚举具有单调性：一旦找到解即为最优",
        "由于 n 的范围极小（≤100），暴力枚举每个数并计算数位乘积不会破坏最优性与正确性",
        "数位乘积的计算是局部独立的，且无后效性",
        "t 很小，可提前预处理其因数需求，但本题中直接模拟更高效"
      ],
      "Transformable Parameters": {
        "n 的数量级": "当前为 [1,100]，可扩展至 1e5 或更高以迫使优化",
        "t 的值域": "当前为 [1,10]，若扩大到 1e9 则需状态压缩或 DP",
        "是否多组数据": false,
        "是否在线": false,
        "输入形式": "单次输入两个整数",
        "输出要求": "仅返回最小整数，不要求数位分解过程",
        "数位运算规则变化": "可改为数位之和、异或、幂次积等",
        "约束反转": "改为‘数位积不能被 t 整除’的最小整数",
        "目标变换": "计数在 [n, m] 范围内满足条件的整数个数",
        "进制变化": "可在二进制或其他进制下定义数位积"
      }
    }
  },
  {
    "title": "Stone Removal Game",
    "slug": "stone-removal-game",
    "schema": {
      "Input Structure": {
        "type": "integer",
        "name": "n",
        "range": "1 <= n <= 50",
        "description": "初始石头数量，正整数"
      },
      "Core Constraint": {
        "first_move": "Alice 必须恰好移除 10 个石头",
        "subsequent_moves": "每次操作移除的石头数 = 对手上一次操作移除数 - 1",
        "termination_condition": "无法执行规定数量的移除操作者输",
        "move_sequence_determinism": "操作序列由规则完全确定，无选择自由度"
      },
      "Objective Function": "判定在给定 n 下 Alice 是否存在获胜策略（即游戏结果是否为 true）",
      "Algorithmic Invariant": {
        "state_determined_by_turn_and_last_move": "游戏状态可由当前剩余石头数、当前轮到的玩家、以及上一操作移除数唯一确定",
        "fixed_transition_rule": "每一步转移是确定性的：若当前需移除 k 个石头且剩余 >= k，则执行；否则当前玩家失败",
        "backward_induction_applicable": "由于状态空间小且无分支，可通过模拟或递推唯一确定胜负态"
      },
      "Transformable Parameters": {
        "initial_removal": {
          "value": 10,
          "can_vary": true,
          "description": "可改为其他固定值，如 x，形成变体"
        },
        "decrement_step": {
          "value": 1,
          "can_vary": true,
          "description": "可变为减 d，如每次减 2"
        },
        "n_range": {
          "current": "1 <= n <= 50",
          "can_scale": false,
          "note": "若扩大需考虑数学归纳或公式化求解"
        },
        "move_rule_form": {
          "current": "last_move - 1",
          "possible_transforms": [
            "constant_move",
            "last_move + 1",
            "min(last_move, remaining)",
            "modular_rules"
          ]
        },
        "first_player_constraint": {
          "current": "Alice 必须移除恰好 10",
          "can_be_relaxed": false,
          "note": "若允许选择则变为博弈 DP 题"
        },
        "input_type": {
          "form": "single integer",
          "can_become": "multiple test cases, online queries"
        }
      }
    }
  },
  {
    "title": "Find Top Performing Driver",
    "slug": "find-top-performing-driver",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置能积累的水量由其左侧最大高度和右侧最大高度中的较小值决定",
        "independence": "左右侧最大值可独立维护",
        "global_consistency": "局部贡献依赖于全局极值信息"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算所有位置上能够接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示 H[0..L] 的最大值，maxRight 表示 H[R..n-1] 的最大值",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水高度由 maxLeft - H[L] 决定，且此时 L 指针右移",
          "反之则 R 处的积水可确定，R 左移",
          "指针移动过程中已计算区域的水量不变，最优性保持"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "description": "是否允许高度为负值（变形题中可能表示坑洼地形）"
          },
          {
            "name": "dimension",
            "options": [
              "1D",
              "2D",
              "circular"
            ],
            "description": "输入结构维度：一维、二维矩阵或环形排列"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online"
            ],
            "description": "是否支持在线查询或动态更新"
          },
          {
            "name": "output_form",
            "options": [
              "total_sum",
              "per_position_values"
            ],
            "description": "输出是总和还是每个位置的具体积水量"
          },
          {
            "name": "data_update",
            "options": [
              "static",
              "dynamic_add_delete_modify"
            ],
            "description": "是否支持对数组进行插入、删除或修改操作"
          },
          {
            "name": "multiple_test_cases",
            "type": "boolean",
            "description": "是否包含多组测试数据"
          },
          {
            "name": "n_scale",
            "values": [
              "1e3",
              "1e5",
              "1e6"
            ],
            "description": "数据规模数量级，影响算法复杂度要求"
          }
        ]
      }
    }
  },
  {
    "title": "Sum of Consecutive Subsequences",
    "slug": "sum-of-consecutive-subsequences",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates_allowed": true
      },
      "Core Constraint": {
        "description": "每个位置的积水高度由其左侧和右侧最大高度的较小值决定，且仅当该较小值大于当前高度时才能积水",
        "key_property": "局部积水依赖于全局左右边界极值",
        "independence": "左右侧最大值可独立维护"
      },
      "Objective Function": {
        "goal": "sum",
        "target": "total trapped water volume",
        "type": "numeric computation"
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariants": [
          "左指针左侧的最大值已知，右指针右侧的最大值已知",
          "若左侧最大值 ≤ 右侧最大值，则左指针当前位置的积水可确定",
          "移动较小一侧指针不会影响已确定区域的正确性",
          "每一步推进保持：已覆盖区间的贡献已被安全计算"
        ],
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          0,
          "10^5"
        ],
        "negative_values_allowed": false,
        "input_dimension": "1D → 2D (grid extension)",
        "online_queries": false,
        "support_updates": false,
        "output_detail_level": [
          "total sum",
          "per-position volume"
        ],
        "circular_array": false,
        "multiple_test_cases": false,
        "constraint_modifications": [
          "change height comparison (e.g. only count if trapped > threshold)",
          "add flow dynamics (water can flow out under conditions)"
        ]
      }
    }
  },
  {
    "title": "Maximum Frequency of an Element After Performing Operations I",
    "slug": "maximum-frequency-of-an-element-after-performing-operations-i",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "每个元素 nums[i] ∈ [1, 10^5]",
        "两个整数 k 和 numOperations",
        "约束：1 <= n <= 10^5, 0 <= k <= 10^5, 0 <= numOperations <= n"
      ],
      "Core Constraint": [
        "每次操作可选择一个未被选过的下标 i，将 nums[i] 增加 [-k, k] 范围内的任意整数",
        "每个下标最多被操作一次",
        "目标值必须通过若干原始元素在 ±k 范围内可达的方式汇聚到同一数值",
        "频率统计基于最终数组中相同值的个数"
      ],
      "Objective Function": "最大化某个数值在数组中的出现频率（即计数类目标）",
      "Algorithmic Invariant": [
        "若多个元素能通过 ±k 操作汇聚到同一个目标值 x，则这些元素的原始值必须落在区间 [x - k, x + k] 内",
        "对于候选目标值 x，能够贡献频率的原元素是那些满足 |nums[i] - x| <= k 的元素",
        "贪心不变量：优先考虑以某个 nums[i] 经操作后的结果作为目标值，因为最优解必可在某一实际可达点上取得",
        "双指针/滑动窗口不变量：当对排序后的数组枚举目标中心时，满足 nums[i] ∈ [x - k, x + k] 的元素构成连续区间"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "1e5",
            "可降至 1e3 或升至 1e6"
          ],
          "值域范围": [
            "[1, 1e5]",
            "可扩展为负数或更大"
          ]
        },
        "操作限制": {
          "numOperations 是否等于 n": [
            "可以小于 n",
            "可设为无限"
          ],
          "是否允许多次操作同一位置": [
            "否（当前）",
            "是（变形）"
          ]
        },
        "k 的性质": [
          "固定全局 k",
          "每个元素有独立的 k_i",
          "k 为向量或随位置变化"
        ],
        "目标函数形式": [
          "最大频率（当前）",
          "是否存在频率 ≥ T",
          "构造达到最高频的方案",
          "计数有多少个不同值能达到最大频率"
        ],
        "输入结构变换": [
          "一维数组（当前）",
          "二维数组（如矩阵中选块进行操作）",
          "树上节点值可调整"
        ],
        "是否在线": [
          "离线批量处理（当前）",
          "在线查询：动态添加操作并询问当前最大频率"
        ],
        "操作方式扩展": [
          "只能加 [-k,k] 整数（当前）",
          "改为乘法或其他变换",
          "操作代价与变化量相关（引入权值）"
        ]
      }
    }
  },
  {
    "title": "Minimum Operations to Make Array Values Equal to K",
    "slug": "minimum-operations-to-make-array-values-equal-to-k",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": "[1, 100]",
        "constraints": [
          "nums.length >= 1",
          "nums[i] >= 1",
          "k >= 1"
        ]
      },
      "Core Constraint": {
        "definition": "一个整数 h 是合法的，当且仅当所有严格大于 h 的 nums[i] 值相等。",
        "implication": "操作只能选择当前数组中满足 '所有 >h 的值都相同' 的 h，否则无法执行。",
        "dependency": "每次操作后数组状态改变，影响后续 h 的合法性判断。",
        "monotonicity": "数组中的最大值序列在操作下非增；一旦某个值被压平到 h，则不会再参与更高层比较。"
      },
      "Objective Function": {
        "type": "minimization",
        "goal": "求将整个数组所有元素变为 k 所需的最少操作次数。",
        "failure_condition": "若无法使所有元素等于 k，则返回 -1。",
        "output_type": "integer (-1 或 ≥0)"
      },
      "Algorithmic Invariant": {
        "invariant_description": [
          "每次操作选择一个合法 h，使得所有 >h 的元素均为同一值 M，且 M > h。",
          "操作只会将部分元素从较高值 M 修改为 h，不会引入新值。",
          "若最终能达成全为 k，则每一步必须逐步向下‘压缩’高于 k 的不同层级。",
          "最优策略中，操作序列对应于从初始最大值到 k 的一条递减路径，其中每一跳的目标 h 必须是合法断点。",
          "若存在大于 k 的多个不同值，且无法通过合法 h 逐层合并，则无解。"
        ],
        "key_insight": "问题等价于：将大于 k 的不同数值层级，通过一系列‘合法切割点’逐层降至 k。每一层合并必须满足：当前待降的所有高层值已统一为一个值。"
      },
      "Transformable Parameters": {
        "n_magnitude": "small (≤ 100)",
        "value_domain": "positive integers, bounded [1,100]",
        "ordering": "unordered input array",
        "cyclic": false,
        "online_input": false,
        "multiple_queries": false,
        "modifications_allowed": false,
        "variants": [
          "允许负数？→ 可扩展 value_domain",
          "是否要求输出操作序列？→ 改变输出形式",
          "改为最大化操作次数？→ 目标函数变换",
          "加入限制：h 必须属于 nums → 添加约束 slot",
          "二维数组版本？→ 输入维度提升至 2D",
          "在线流式输入？→ 数据流化算子应用"
        ]
      }
    }
  },
  {
    "title": "Maximum Number of Distinct Elements After Operations",
    "slug": "maximum-number-of-distinct-elements-after-operations",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums[i] 为正整数，值域范围 [1, 10^9]",
        "整数 k ≥ 0，表示操作幅度上限",
        "每个元素最多执行一次操作：加一个 ∈ [-k, k] 的整数"
      ],
      "Core Constraint": [
        "每个元素的操作是独立的，但目标是最大化最终数组中不同值的数量",
        "两个原数值不同的元素可能通过操作后相等（冲突）",
        "一个元素经过操作后可变为区间 [nums[i] - k, nums[i] + k] 内任意整数",
        "最优策略需避免多个元素映射到同一值，除非无法避免"
      ],
      "Objective Function": "最大化操作后数组中不同元素的个数（计数类目标函数）",
      "Algorithmic Invariant": [
        "贪心选择：对每个元素，优先将其映射到当前可选的最小可能值（以腾出更大空间给后续元素）",
        "排序不变性：将原数组按初始值排序后处理，不会影响最优解（局部决策可全局合并）",
        "区间不重叠推进：若前一个元素被分配的目标值为 x，则下一个元素应尽可能分配第一个大于等于 x+1 且落在其可变区间内的值",
        "状态单调性：已确定的不同值集合的最大值随处理过程单调递增"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": "1e5（适合 O(n log n) 算法）",
          "值域大小": "nums[i] 达 1e9，不可用桶排序"
        },
        "输入形式": {
          "是否有序": "原始无序，但可通过排序预处理",
          "是否多组数据": "单组输入（可扩展为多组）"
        },
        "操作约束": {
          "操作次数限制": "每个元素最多一次操作",
          "操作范围": "固定为 [-k, k]，可变形为非对称范围如 [a, b]"
        },
        "在线性": "离线处理；可扩展为在线流式输入（元素逐个到达）",
        "输出形式": [
          "仅返回最大不同元素个数（当前）",
          "可改为输出具体构造方案或每个元素的操作值"
        ],
        "变形方向": [
          "目标函数变换：从‘最大化不同元素’变为‘最小化不同元素’（即尽量合并）",
          "约束反转：要求所有元素必须操作 / 至少操作一半",
          "维度扩展：二维数组，每个位置可调值，求矩阵中不同值最大数量",
          "隐藏条件：k 隐式由相邻元素差决定（如 k = |i-j|）"
        ]
      }
    }
  },
  {
    "title": "Adjacent Increasing Subarrays Detection II",
    "slug": "adjacent-increasing-subarrays-detection-ii",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中 n ≥ 2，元素为整数（可正可负），表示非空连续序列",
      "Core Constraint": "两个长度为 k 的子数组必须严格递增，且相邻：即第二个子数组起始位置等于第一个子数组结束位置（b = a + k）；每个子数组内部满足 nums[i] < nums[i+1]",
      "Objective Function": "最大化 k 的值，使得存在一对满足条件的相邻、严格递增、长度为 k 的子数组",
      "Algorithmic Invariant": "可以通过预处理每个位置向右的最长严格递增子数组长度（LIS 扩展），然后枚举所有可能的分割点 a 和 b = a + k，利用单调性剪枝或双指针推进来维护当前可行的 k 值；最优解具有单调可扩展性：若 k 可行，则所有 k' < k 也可行，因此可以二分搜索 k 并验证其可行性",
      "Transformable Parameters": {
        "n 的数量级": "2 <= n <= 2 * 10^5",
        "值域": "-10^9 <= nums[i] <= 10^9",
        "是否有序": "输入数组无序",
        "是否循环": "否，线性数组",
        "是否多组输入": "单组输入（可拓展为多组）",
        "是否在线": "离线处理",
        "递增类型": "严格递增（可变形为非严格递增）",
        "相邻定义": "第二个子数组紧接第一个之后（b = a + k），可变形为间隔固定 d 或重叠约束",
        "子数组个数": "两个（可推广至多个连续递增段）",
        "目标函数形式": "最大 k → 可改为计数满足条件的 (a, k) 对数目或判定是否存在"
      }
    }
  },
  {
    "title": "Find the Original Typed String II",
    "slug": "find-the-original-typed-string-ii",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "给定一个字符串 word，长度为 n，由小写英文字母组成，表示最终显示在屏幕上的结果。",
        "length_range": [
          1,
          500000
        ],
        "character_set": "lowercase_letters",
        "additional_input": {
          "k": {
            "type": "integer",
            "range": [
              1,
              2000
            ],
            "description": "Alice 最初输入字符串的最小可能长度"
          }
        }
      },
      "Core Constraint": {
        "description": "原始字符串通过插入重复字符（即按住某个键导致同一字符连续输入多次）得到当前字符串 word。每个字符的连续段在原始字符串中必须至少出现一次，且不能引入新的字符或改变顺序。",
        "rules": [
          "字符顺序必须与 word 中一致",
          "连续相同字符的块可被压缩为单个该字符的出现",
          "原始字符串是 word 的一个‘压缩路径’：即可以通过删除某些连续重复字符得到",
          "原始字符串长度至少为 k"
        ]
      },
      "Objective Function": {
        "goal": "counting",
        "description": "统计所有满足条件的原始字符串的方案数（对 10^9 + 7 取模）",
        "condition": "原始字符串长度 >= k，且可通过重复扩展得到 word"
      },
      "Algorithmic Invariant": {
        "invariant_type": "dynamic_programming_with_run_length_encoding",
        "description": "基于连续段（run-length encoded segments）进行状态转移：每一段相同字符的选择独立于其他段，但需维护已选总长度以判断是否满足 k 约束。",
        "key_properties": [
          "每个连续字符段 [char]^m 在原始字符串中可以保留 1 到 m 次，对应 m 种选择",
          "不同字符段之间相互独立，方案数相乘",
          "总方案数 = 所有段的选择方式乘积，减去长度 < k 的非法情况",
          "使用前缀积和动态规划结合组合计数，避免枚举所有组合"
        ],
        "monotonicity": "随着段处理推进，累计长度和方案数单调递增",
        "decomposition": "将问题分解为：(1) 分段；(2) 每段贡献因子；(3) 总长度约束下的合法子集计数"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "string_dimension",
            "values": [
              "1D",
              "2D_grid_scan"
            ],
            "default": "1D",
            "description": "输入是否从线性字符串变为二维网格逐行输入"
          },
          {
            "name": "constraint_direction",
            "values": [
              ">=k",
              "<=k",
              "==k"
            ],
            "default": ">=k",
            "description": "对原始字符串长度的约束类型变化"
          },
          {
            "name": "input_form",
            "values": [
              "flat_string",
              "run_length_encoded"
            ],
            "default": "flat_string",
            "description": "输入是否直接以游程编码形式给出"
          },
          {
            "name": "output_requirement",
            "values": [
              "total_count",
              "distinct_strings",
              "lexicographically_smallest"
            ],
            "default": "total_count",
            "description": "输出目标的变化：仅计数 or 构造具体字符串"
          },
          {
            "name": "operation_support",
            "values": [
              "static",
              "with_deletion_queries",
              "online_insertion"
            ],
            "default": "static",
            "description": "是否支持在线修改操作"
          },
          {
            "name": "alphabet_type",
            "values": [
              "lowercase",
              "uppercase",
              "digits",
              "arbitrary_symbols"
            ],
            "default": "lowercase",
            "description": "字符集大小可调，影响状态设计"
          },
          {
            "name": "repetition_rule",
            "values": [
              "consecutive_only",
              "arbitrary_insertions",
              "bounded_gap"
            ],
            "default": "consecutive_only",
            "description": "放宽重复规则：是否允许非连续插入相同字符"
          },
          {
            "name": "multi_query",
            "type": "boolean",
            "default": false,
            "description": "是否为多组 k 查询"
          }
        ]
      }
    }
  },
  {
    "title": "Find the Original Typed String I",
    "slug": "find-the-original-typed-string-i",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n (1 <= n <= 100)",
        "properties": [
          "possibly contains consecutive duplicate characters"
        ]
      },
      "Core Constraint": {
        "description": "The input string is the result of at most one typing error, where a single character key was held too long, causing it to be repeated one or more extra times. All other characters are typed correctly and in order.",
        "implication": "Any valid original string can be obtained by removing one block of consecutive duplicates (of length >=2) from a run of identical characters, such that the resulting string still explains the observed output with exactly zero or one mistake."
      },
      "Objective Function": "Count the total number of distinct strings that could have been the intended input by Alice, assuming she made at most one such overpress error.",
      "Algorithmic Invariant": {
        "invariant_1": "Consecutive runs of the same character are the only possible locations where an error could have occurred.",
        "invariant_2": "Within a run of length L (>=2), there are L - 1 possible prior states (by truncating the run to lengths 1 through L-1), each representing a different original string that would lead to this run via one overpress.",
        "invariant_3": "Runs of length 1 cannot be the site of an overpress error (since no repetition occurred), so they contribute only the identity case (no change).",
        "invariant_4": "Each candidate original string is uniquely determined by choosing at most one run to 'revert' to a shorter version; multiple edits are disallowed."
      },
      "Transformable Parameters": {
        "error_model": [
          "at_most_one_error",
          "exactly_one_error",
          "unlimited_errors"
        ],
        "input_dimension": [
          "1D string",
          "2D grid of characters (typing on keyboard layout)"
        ],
        "operation_type": [
          "only insertions (overpress)",
          "deletions allowed",
          "substitutions allowed"
        ],
        "data_form": [
          "offline: full string given",
          "online: character stream with queries"
        ],
        "output_requirement": [
          "count total possibilities",
          "list all possible originals",
          "find lexicographically smallest original"
        ],
        "constraints": {
          "string_length": "1 <= n <= 100 (can scale to 1e5 for harder version)",
          "alphabet_size": "26 lowercase letters (can generalize to Unicode or case-sensitive)",
          "duplicate_run_limit": "implicit: up to n, explicit bounds can be added"
        },
        "additional_variants": [
          "allow deletion errors instead of insertion",
          "multiple error types combined",
          "unknown number of errors but minimize edit distance",
          "probabilistic model: maximize likelihood of original"
        ]
      }
    }
  },
  {
    "title": "Make Array Elements Equal to Zero",
    "slug": "make-array-elements-equal-to-zero",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length_range": [
          1,
          100
        ],
        "value_range": [
          0,
          100
        ],
        "contains_zero": true,
        "description": "一维整数数组 nums[0..n-1]，至少包含一个 0"
      },
      "Core Constraint": {
        "movement_rule": "从某个 nums[curr] == 0 的位置开始，沿选定方向移动",
        "zero_behavior": "遇到值为 0 的位置直接通过，不修改，继续沿原方向移动",
        "positive_behavior": "遇到 nums[curr] > 0 时：将其减 1，并反转移动方向，然后向新方向移动一步",
        "termination_condition": "当 curr 超出 [0, n-1] 范围时过程结束",
        "validity_condition": "整个过程结束后，nums 所有元素必须全为 0 才视为有效方案"
      },
      "Objective Function": {
        "goal": "计数",
        "target": "统计所有能使最终数组全为 0 的初始位置和初始方向的组合数目",
        "output_type": "integer",
        "note": "同一个起始位置选择左或右视为不同方案"
      },
      "Algorithmic Invariant": {
        "state_consistency": "每个正数位置被访问的次数恰好等于其初始值（因为每次访问只减 1）",
        "direction_reversal_symmetry": "每次在正数位置发生方向反转，路径具有对称演化特性",
        "deterministic_trajectory": "给定起始位置与方向后，后续移动轨迹完全确定",
        "independence_of_paths": "不同起始状态对应的模拟路径相互独立，可分别验证",
        "simulation_verifiability": "由于数据规模小，可通过直接模拟每种候选路径来验证有效性"
      },
      "Transformable Parameters": {
        "n_scale": "1 <= n <= 100 → 可扩展至更大规模（如 1e5），推动寻找规律性解法",
        "value_domain": "nums[i] >= 0 → 是否允许负数？若允许则行为需重新定义",
        "initial_condition": "至少一个 0 → 改为‘恰好一个’或‘无显式保证’以增加边界处理",
        "movement_dynamics": "固定‘减1+转向’→ 可改为其他操作（如减k、多次转向、跳转等）",
        "output_requirement": "仅计数 → 可改为输出具体方案、构造反例、判断存在性",
        "online_query": "单次输入 → 多组测试用例 / 在线查询模式",
        "spatial_structure": "1D linear array → 环形数组（index 模 n）",
        "modification_support": "静态数组 → 支持更新操作的动态版本"
      }
    }
  },
  {
    "title": "Convert Doubly Linked List to Array II",
    "slug": "convert-doubly-linked-list-to-array-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at that index."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the minimum of their heights and the distance between their indices.",
        "key_insight": "For any pair (i, j), the container's capacity is (j - i) * min(height[i], height[j]). The optimal solution does not require checking all pairs due to monotonicity in pointer movement.",
        "dependency": "Local decisions can be made based on comparative values at boundaries; smaller height limits the current area and should be advanced."
      },
      "Objective Function": {
        "goal": "maximize",
        "output_type": "integer",
        "objective": "Find the maximum area of water that can be contained between any two vertical lines."
      },
      "Algorithmic Invariant": {
        "invariant": "Two-pointer technique with greedy advancement",
        "rules": [
          "Initialize left = 0, right = n - 1.",
          "At each step, compute the area formed by height[left] and height[right].",
          "Always move the pointer pointing to the shorter line inward, because moving the taller one cannot increase the area (width decreases and height is bounded by the shorter).",
          "This maintains correctness: no better solution is missed in the discarded configurations."
        ],
        "proof_basis": "Monotonicity of bounding height — advancing the shorter side preserves the possibility of finding a larger area, while skipping only suboptimal configurations."
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "10^5"
        ],
        "value_range": [
          "0",
          "10^4"
        ],
        "input_form": "single static array",
        "multiple_test_cases": false,
        "online_queries": false,
        "modifications_allowed": false,
        "extensions": [
          "2D version: matrix with elevation map (Maximal Rectangle or 2D trapping rainwater)",
          "Circular arrangement: connect last to first index",
          "Dynamic updates: support insert/delete/update operations",
          "Output all optimal pairs instead of just the maximum value",
          "Variant objective: minimize area above threshold",
          "Constraint reversal: find closest pair achieving at least K area"
        ]
      }
    }
  },
  {
    "title": "Find the Number of K-Even Arrays",
    "slug": "find-the-number-of-k-even-arrays",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "ordered": false,
        "duplicates": true
      },
      "Core Constraint": {
        "description": "Each position's contribution to trapped water is determined by the minimum of the maximum heights to its left and right, minus its own height. The left and right maxima are independent but must be globally consistent for correctness."
      },
      "Objective Function": {
        "type": "sum",
        "goal": "total_trapped_water",
        "operation": "compute_total_capacity"
      },
      "Algorithmic Invariant": {
        "technique": "two_pointers",
        "invariant_rules": [
          "Maintain two pointers L and R starting from both ends.",
          "Track maxLeft = max(H[0..L]) and maxRight = max(H[R..n-1]).",
          "If maxLeft <= maxRight, then the water at L is solely bounded by maxLeft, so add maxLeft - H[L] to result and move L forward.",
          "Otherwise, the water at R is bounded by maxRight, so add maxRight - H[R] to result and move R backward.",
          "Pointer movement preserves the correctness of already processed regions."
        ]
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          0,
          "10^5"
        ],
        "negative_values_allowed": false,
        "input_dimensionality": [
          "1D",
          "2D_extension_possible"
        ],
        "online_processing": false,
        "supports_updates": false,
        "output_granularity": [
          "total_sum",
          "per_position_output_optional"
        ],
        "multiple_test_cases": false,
        "circular_array": false,
        "sorted_input": false
      }
    }
  },
  {
    "title": "Maximize Amount After Two Days of Conversions",
    "slug": "maximize-amount-after-two-days-of-conversions",
    "schema": {
      "Input Structure": [
        "字符串 initialCurrency，表示初始货币类型",
        "两个二维字符串数组 pairs1 和 pairs2，长度分别为 n 和 m，表示第1天和第2天可交易的货币对 [startCurrency, targetCurrency]",
        "两个实数数组 rates1 和 rates2，长度分别为 n 和 m，表示对应货币对的正向兑换汇率",
        "每种兑换允许反向操作，反向汇率为 1/rate",
        "所有货币名称为长度在 1~3 的大写英文字母字符串"
      ],
      "Core Constraint": [
        "每天的兑换操作可在对应汇率图上进行任意次数的连续兑换（即构成有向图上的路径）",
        "第1天的操作仅能使用 pairs1 和 rates1 构成的兑换图，第2天仅能使用 pairs2 和 rates2",
        "兑换过程无矛盾、无负环（即汇率图中不存在通过循环使资金无限增长的情况）",
        "两天操作顺序固定：先第1天任意次兑换，再第2天任意次兑换",
        "目标是将最终资产换回 initialCurrency，并最大化其数量"
      ],
      "Objective Function": "最大化最终持有的 initialCurrency 数量（实数）",
      "Algorithmic Invariant": [
        "每天的兑换能力构成一个有向加权图，节点为货币类型，边权重为 log(rate)（转化为最长路径问题）",
        "在无矛盾条件下，每个连通分量内可通过最短/最长路径算法（如 Bellman-Ford 或 Floyd）求出任意两种货币间的最大兑换倍率",
        "第1天结束后，可将1.0单位 initialCurrency 转换为若干中间货币的最大可能值，形成状态向量 V1",
        "第2天从 V1 出发，在第二天图中再次传播至所有可达货币，并最终取回到 initialCurrency 的最大值",
        "两阶段独立传播 + 最终回流到起点，构成最优子结构"
      ],
      "Transformable Parameters": {
        "n, m 的数量级": "当前 n, m ≤ 10，可扩展至中等规模（如 ≤ 100）或大规模在线图（需动态更新）",
        "图结构形态": "当前为稀疏图，可变体包括完全图、链状结构、树形结构、强连通图",
        "是否允许循环套利": "当前禁止；可变形为检测是否存在正环（即无限盈利）",
        "天数 k": "当前固定为2天，可推广为 k 天序列决策（动态规划或多阶段图）",
        "是否在线输入": "当前离线输入；可改为流式输入汇率对，要求实时维护可达最大值",
        "输出形式变化": [
          "输出最大值 → 输出达成该值的完整兑换路径",
          "判定是否存在超过阈值的收益"
        ],
        "汇率有效性假设": "当前保证无矛盾；可取消此限制，要求算法自行检测一致性",
        "初始持有资产类型与目标类型是否相同": "当前必须换回 initialCurrency；可改为任意目标货币"
      }
    }
  },
  {
    "title": "Adjacent Increasing Subarrays Detection I",
    "slug": "adjacent-increasing-subarrays-detection-i",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "整数 k",
        "nums[i] ∈ [-1000, 1000]",
        "2 <= n <= 100",
        "1 <= 2 * k <= n"
      ],
      "Core Constraint": [
        "两个子数组必须严格递增",
        "两个子数组长度均为 k",
        "第二个子数组起始位置等于第一个子数组结束位置（即 b = a + k）",
        "局部结构：连续段的单调性可线性验证",
        "相邻性约束强制了搜索空间的结构化滑动"
      ],
      "Objective Function": "判定是否存在一对满足条件的相邻且长度为 k 的严格递增子数组",
      "Algorithmic Invariant": [
        "若从位置 i 开始的长度为 k 的子数组是严格递增的，则可通过 O(k) 扫描验证",
        "使用滑动窗口预处理每个起始位置是否构成严格递增段",
        "一旦发现某个位置 a 满足 inc[a] 和 inc[a + k] 同时为真，则可立即返回 true",
        "遍历顺序从左到右，状态无后效性"
      ],
      "Transformable Parameters": {
        "k 的取值范围": [
          "固定",
          "可变输入",
          "作为约束上界"
        ],
        "目标函数变换": [
          "判定存在性 → 求最大 k → 计数所有合法 a"
        ],
        "递增性质扩展": [
          "严格递增 → 非严格递增 → 严格递减"
        ],
        "相邻关系变形": [
          "b = a + k → b ≥ a + k → 任意两个不重叠递增段"
        ],
        "子数组数量": [
          "两个 → 多个连续拼接的递增段"
        ],
        "输入形式": [
          "单组数据 → 多组测试用例"
        ],
        "数组维度扩展": [
          "1D → 环形数组（末尾与开头连接）"
        ],
        "在线查询支持": [
          "静态数组 → 支持点更新后重新查询"
        ]
      }
    }
  },
  {
    "title": "Construct the Minimum Bitwise Array II",
    "slug": "construct-the-minimum-bitwise-array-ii",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums[i] 是质数，且 2 <= nums[i] <= 1e9",
        "n <= 100"
      ],
      "Core Constraint": [
        "对于每个 i，需满足 ans[i] OR (ans[i] + 1) == nums[i]",
        "OR 运算的性质：x OR (x+1) 会将 x 的最低位连续 1 变为 0，并在更高一位设为 1，形成一个形如 (2^k - 1) + 2^k = 2^{k+1} - 1 的模式或其扩展",
        "只有当 nums[i] 的二进制表示中存在一段从某位开始的全 1 后缀时，才可能存在解",
        "若存在解，则最小的合法 ans[i] 必然具有特定构造形式（即保留高位不变，低位补零）"
      ],
      "Objective Function": [
        "对每个下标 i 构造满足条件的最小非负整数 ans[i]",
        "若无解则 ans[i] = -1",
        "目标函数类型：逐元素构造 + 最小化局部值"
      ],
      "Algorithmic Invariant": [
        "对于给定质数 p，若存在 x 使得 x OR (x+1) == p，则 x 的二进制形式必然是 p 的某个前缀保持不变，后缀为全 0，且 p 的后缀必须是连续的 1",
        "检查方式：枚举所有可能的分割点 k，验证 p 的低 k 位是否为全 1，且高位置构成的数加 1 不影响低 k 位",
        "一旦找到第一个合法构造，即为最小解（贪心性质成立）",
        "每位独立处理，子问题之间无依赖"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": "1 <= n <= 100",
          "nums[i] 值域": "2 <= nums[i] <= 1e9"
        },
        "输入类型": [
          "是否仍限定为质数（可改为任意正整数）",
          "是否允许重复值"
        ],
        "输出要求": [
          "是否只需判断是否存在解",
          "是否要求返回所有可行解的数量",
          "是否要求最大化 ans[i]"
        ],
        "运算类型变换": [
          "OR → AND / XOR",
          "x OR (x+1) → x OR (x+k)"
        ],
        "在线性": "离线单次计算，可扩展为支持在线查询",
        "多组数据": "当前为单组，可设计为多测循环输入"
      }
    }
  },
  {
    "title": "Find X-Sum of All K-Long Subarrays I",
    "slug": "find-x-sum-of-all-k-long-subarrays-i",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "每个元素为正整数：nums[i] ∈ [1, 50]",
        "子数组长度固定为 k",
        "输出为所有长度为 k 的连续子数组的 x-sum 结果"
      ],
      "Core Constraint": [
        "x-sum 定义为：在子数组中，按频率降序取前 x 种元素（频率相同时数值大的优先），求这些元素的总和",
        "不同元素可能不足 x 个，此时取全部元素之和",
        "子数组滑动过程中，元素频次动态变化",
        "每次计算依赖当前窗口内的完整频次统计与排序规则"
      ],
      "Objective Function": [
        "对每个长度为 k 的子数组，计算其 x-sum",
        "目标函数类型：构造方案（返回长度为 n - k + 1 的结果数组）",
        "属于滑动窗口下的批量查询任务"
      ],
      "Algorithmic Invariant": [
        "使用滑动窗口维护当前区间 [i, i+k-1] 内的元素频次映射",
        "频次更新具有增量性质：移出左端点元素，加入右端点元素",
        "每次窗口移动后，可通过有序结构（如有序列表或堆）快速获取前 x 个高频元素",
        "由于值域小（≤50），可用桶排序思想实现 O(1) 或 O(C) 的频次重排序",
        "状态转移不破坏频次统计的一致性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": "原始为 ≤50，可扩展至 1e5（需优化解法）",
          "k 和 x 的范围": "原题中 x ≤ k ≤ n，可改为 x > k 变形"
        },
        "值域": {
          "nums[i] 是否允许负数": false,
          "值域大小": "当前为 [1,50]，若扩大至 1e9 则需离散化"
        },
        "是否有序": false,
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": "当前为离线处理所有子数组；可变形为在线查询某个子数组的 x-sum",
        "频率排序规则": "当前为‘频率为主，数值为辅’降序；可变换为‘频率相同则数值小的优先’等隐藏条件",
        "x-sum 定义变形": [
          "改为保留前 x 个不同元素（按首次出现顺序）",
          "改为最小 x 个高频元素之和（目标变换：最大贡献 → 最小贡献）"
        ],
        "窗口类型": "当前为定长滑动窗口；可变为不定长或多尺度窗口"
      }
    }
  },
  {
    "title": "Calculate Product Final Price",
    "slug": "calculate-product-final-price",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"array\",\n    \"dimension\": 1,\n    \"elements\": \"non-negative integers\",\n    \"size\": \"n\",\n    \"sorted\": false,\n    \"duplicates_allowed\": true,\n    \"description\": \"Given an array H[1..n] where each element H[i] represents the height of a vertical line at position i.\"\n  },\n  \"Core Constraint\": {\n    \"constraint\": \"The area formed between two lines and the x-axis is determined by the distance between them and the shorter of the two heights.\",\n    \"independence\": \"Height values are independent; no assumption of global monotonicity, but local comparisons drive optimal substructure.\",\n    \"determinism\": \"Maximum area depends on balancing width (distance) and bottleneck height (minimum of two endpoints).\"\n  },\n  \"Objective Function\": {\n    \"goal\": \"maximize\",\n    \"target\": \"area\",\n    \"type\": \"single_value\",\n    \"description\": \"Find the maximum amount of water that can be contained between any two vertical lines.\"\n  },\n  \"Algorithmic Invariant\": {\n    \"technique\": \"two pointers\",\n    \"initialization\": \"Left pointer at start (L=0), right pointer at end (R=n-1)\",\n    \"movement_rule\": \"Move the pointer pointing to the shorter line inward\",\n    \"invariant_preservation\": \"At each step, the possibility of finding a larger area with the current outer boundary is preserved. The side with smaller height cannot form a better container with any inner line due to bottleneck constraint.\",\n    \"optimality_guarantee\": \"By always moving the shorter end, we ensure that no potential improvement is missed while safely discarding non-optimal candidates.\"\n  },\n  \"Transformable Parameters\": {\n    \"n_range\": [\"1\", \"10^5\"],\n    \"value_domain\": [\"0\", \"10^4\"],\n    \"input_variations\": [\n      \"allow negative heights (interpreted as underground lines)\",\n      \"2D version: matrix of heights, find 3D containment volume\",\n      \"circular arrangement: connect last to first\",\n      \"online query: process lines one by one, maintain best container so far\",\n      \"support updates: add/remove lines dynamically\",\n      \"output_type_change\": \"return indices instead of value, or list all optimal pairs\",\n      \"multi-objective\": \"maximize area under sum-of-heights constraint\",\n      \"multiple_queries\": \"given k queries for top-k areas\"\n    ],\n    \"data_mode\": \"offline\",\n    \"number_of_test_cases\": \"single or multiple\",\n    \"constraints_modification\": [\n      \"add capacity limit per unit width\",\n      \"require non-adjacent lines\",\n      \"restrict indices: only even/odd positions allowed\"\n    ]\n  }\n}"
  },
  {
    "title": "Find the Number of Subsequences With Equal GCD",
    "slug": "find-the-number-of-subsequences-with-equal-gcd",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 200",
        "value_range": "1 <= nums[i] <= 200",
        "properties": [
          "non-empty",
          "allows duplicates",
          "unordered"
        ]
      },
      "Core Constraint": {
        "disjoint_subsequences": true,
        "gcd_equality_constraint": "gcd(seq1) == gcd(seq2)",
        "index_partitioning": "each index can belong to at most one of seq1 or seq2, or neither",
        "combinatorial_independence": "choices for seq1 and seq2 are independent given disjointness"
      },
      "Objective Function": {
        "goal": "count",
        "target": "number of unordered pairs (seq1, seq2) of non-empty disjoint subsequences such that gcd(seq1) == gcd(seq2)",
        "modular_arithmetic": "result must be returned modulo 10^9 + 7"
      },
      "Algorithmic Invariant": {
        "group_by_gcd": "subsequences can be grouped by their GCD value",
        "multiplicative_counting": "for each g, if there are f[g] non-empty subsequences with gcd = g, then they contribute f[g] * f[g] to the total count (as pairs)",
        "inclusion_exclusion_for_gcd": "f[g] is computed using inclusion-exclusion: count all subsequences where every element is divisible by g, then subtract those whose gcd is a proper multiple of g",
        "disjointness_handled_via_index_separation": "since subsequence pairs must be disjoint in indices, but same value may appear in both — key insight: we are choosing two disjoint sets of indices, not values"
      },
      "Transformable Parameters": {
        "n_value_range": "1 to 200",
        "nums_value_range": "1 to 200",
        "modulus": "10^9 + 7",
        "allow_empty_subsequences": false,
        "ordered_pairs_vs_unordered": "pairs (seq1, seq2) are ordered? → yes in counting; but in this problem, order matters unless specified otherwise — based on example counts",
        "output_modular": true,
        "multi_query": false,
        "online_input": false,
        "additional_constraints": [
          "non-empty subsequences",
          "disjoint in indices"
        ],
        "possible_transforms": [
          "change objective from count to existence",
          "require gcd(seq1) divides gcd(seq2)",
          "add constraint on length of subsequences",
          "extend to 2D array",
          "allow overlapping → different problem",
          "move to tree-structured index space"
        ]
      }
    }
  },
  {
    "title": "Minimum Division Operations to Make Array Non Decreasing",
    "slug": "minimum-division-operations-to-make-array-non-decreasing",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "n ∈ [1, 1e5]",
        "nums[i] ∈ [1, 1e6]",
        "元素为正整数"
      ],
      "Core Constraint": [
        "每个数 x 的操作是将其除以它的最大真因数（即 x / p，其中 p 是 x 的最小质因子）",
        "每次操作只能作用于单个元素",
        "操作可重复进行，直到该数变为 1（因为 1 没有真因数）",
        "从任意数出发，其可到达的状态序列是唯一的（由不断除以最小质因子决定）",
        "所有可能状态构成一条链式路径：x → x/p₁ → x/(p₁p₂) → ... → 1"
      ],
      "Objective Function": [
        "最小化总操作次数",
        "使得最终数组是非递减的（即 nums[1] ≤ nums[2] ≤ ... ≤ nums[n]）",
        "若无法达成非递减，返回 -1"
      ],
      "Algorithmic Invariant": [
        "每个数字的所有可达状态可通过预处理唯一确定（沿质因子链下降）",
        "对于位置 i，若选择在某个中间状态停下，则后续状态不能再上升（操作不可逆）",
        "贪心结构：从右向左遍历时，为保证可行性，应使右边尽可能小且非递减，左边不超过右边",
        "动态规划状态转移：dp[i][v] = 从第 i 个元素开始，当前选值为 v 时的最小操作数，v 来自 nums[i] 的合法演化路径",
        "状态单调性：若存在解，则对每个位置，只需考虑其演化路径中 ≤ 上一位置最优选择的值"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e1",
            "1e5"
          ],
          "nums[i]": [
            "1e1",
            "1e6"
          ]
        },
        "值域性质": [
          "是否允许 1",
          "是否包含质数",
          "是否全为合数"
        ],
        "输入形式": [
          "单组输入",
          "多组测试数据"
        ],
        "操作规则变化": [
          "改为除以任意真因数（非最大）→ 解空间爆炸，需 BFS 或记忆化搜索",
          "改为可乘以因子 → 操作可逆性引入环状状态图"
        ],
        "目标函数变换": [
          "最小操作次数 → 叶子节点母题",
          "判断是否存在方案 → 中间层判定问题",
          "构造字典序最小结果数组 → 多目标优化"
        ],
        "在线性": [
          "离线批处理",
          "支持修改数组的在线查询"
        ],
        "附加约束": [
          "每个数最多操作 k 次",
          "总共最多使用 K 次操作",
          "不允许出现某数值"
        ]
      }
    }
  },
  {
    "title": "Minimum Element After Replacement With Digit Sum",
    "slug": "minimum-element-after-replacement-with-digit-sum",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中每个元素 nums[i] 是范围 [1, 10^4] 内的正整数",
      "Core Constraint": "每个元素的数位之和是唯一确定的变换结果，且该变换独立于其他元素（无交叉依赖）",
      "Objective Function": "求变换后数组中的最小元素值",
      "Algorithmic Invariant": "数位和变换具有局部可计算性与顺序无关性：任意位置 i 的新值仅由其原始数值决定，且整体最小值可通过逐个计算并维护当前最小值得到",
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 100",
        "值域": "1 <= nums[i] <= 10^4",
        "是否有序": "输入数组无序，但不影响结果",
        "是否循环": "非循环结构",
        "是否多组输入": "单组输入",
        "是否在线": "离线处理，一次性输入",
        "变换函数可变性": "可替换为数位乘积、数位最大值、数位平方和等",
        "目标函数可变性": "可改为求最大值、平均值、众数或总和",
        "输出形式扩展": "可要求返回原索引、所有最小值的位置或完整变换数组"
      }
    }
  },
  {
    "title": "Construct the Minimum Bitwise Array I",
    "slug": "construct-the-minimum-bitwise-array-i",
    "schema": {
      "Input Structure": [
        "长度为 n 的一维数组 nums[1..n]",
        "nums[i] 是质数，且 2 <= nums[i] <= 1000",
        "整数类型为非负整数",
        "输入规模：1 <= n <= 100"
      ],
      "Core Constraint": [
        "对于每个 i，要求 ans[i] OR (ans[i] + 1) == nums[i]",
        "OR 是按位或运算",
        "若不存在满足条件的 ans[i]，则 ans[i] = -1",
        "目标是逐元素独立求解，无跨位置依赖"
      ],
      "Objective Function": [
        "构造长度为 n 的数组 ans",
        "对每个下标 i，求满足 ans[i] OR (ans[i] + 1) == nums[i] 的最小非负整数 ans[i]",
        "若无解，设 ans[i] = -1",
        "目标函数类型：构造 + 最小化（逐点）"
      ],
      "Algorithmic Invariant": [
        "位运算性质：x OR (x+1) 的结果具有特定二进制模式 —— 将 x 的最低连续 1 段变为 0，并在更高一位补 1",
        "x OR (x+1) 的结果形如 2^k - 1 或其扩展形式（即低位全为 1）",
        "因此只有当 nums[i] 的二进制表示中，从某位开始向低位全为 1 时，才可能存在解",
        "枚举候选 ans[i] 可以从小到大进行，第一个满足条件的即为最优解（贪心取最小）",
        "每个位置可独立求解，不影响其他位置"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": "1 <= n <= 100",
          "nums[i] 值域": "2 <= nums[i] <= 1000"
        },
        "输入性质": {
          "是否保证为质数": true,
          "是否允许合数输入": false,
          "是否可扩展至任意正整数": true
        },
        "输出形式": {
          "是否仅返回最小值": true,
          "是否要求输出所有可行解": false,
          "是否要求构造方案过程": false
        },
        "目标函数变换": [
          "最小化 ans[i] → 最大化 ans[i]（在约束内）",
          "判定是否存在解 → 计数有多少个 x 满足 x OR (x+1) == p"
        ],
        "运算规则变形": [
          "OR → XOR",
          "ans[i] + 1 → ans[i] - 1",
          "联合约束：ans[i] AND (ans[i]+1) == 0 （即相邻两数与为0）"
        ],
        "在线性": false,
        "多组数据": false,
        "是否循环结构": false
      }
    }
  },
  {
    "title": "Find the Number of Possible Ways for an Event",
    "slug": "find-the-number-of-possible-ways-for-an-event",
    "schema": {
      "Input Structure": [
        "整数 n：表示表演者的数量，1 <= n <= 1000",
        "整数 x：表示节目的数量，1 <= x <= 1000",
        "整数 y：表示每个有表演者的节目可获得的分数范围 [1, y]，1 <= y <= 1000"
      ],
      "Core Constraint": [
        "每一位表演者必须被分配到恰好一个节目（共 x 个节目）",
        "节目可以为空，但只有非空节目才会被评分",
        "不同表演者的分配方式构成不同的方案",
        "每个非空节目的评分独立地从 [1, y] 中选择，且评分不同也构成不同方案",
        "总方案数 = 所有非空子集划分方式 × 每种划分下节目的评分组合数"
      ],
      "Objective Function": "计数：计算所有合法的活动安排与打分组合的总数（对 10^9 + 7 取模）",
      "Algorithmic Invariant": [
        "使用第二类斯特林数的变体思想：将 n 个有区别的表演者分配到 k 个非空、有区别的节目中的方案数为 k! * S(n, k)，等价于 x 选 k 后乘以满射函数数",
        "利用容斥原理或预处理幂和快速计算：将 n 个有标号元素分配到至多 x 个有标号盒子中，允许空盒，但只对非空盒计分",
        "评分部分具有独立性：若有 k 个非空节目，则评分方案为 y^k",
        "最终方案可通过枚举实际使用的节目数 k（从 1 到 min(x, n)），累加 C(x, k) * (k^n - 容斥调整？) → 实际上更简洁的是使用‘带标签盒子’模型直接计算：总分配方式为 ∑_{k=0}^{x} C(x, k) * k^n 不适用，应为直接考虑函数空间",
        "正确不变量：n 个有标号元素到 x 个有标号盒子的映射总数是 x^n；对于每个这样的映射，若其像集大小为 k，则对应 y^k 种评分方式。但由于评分仅依赖于是否有表演者，而非具体是谁，因此每个非空节目统一打分一次 → 总分为 sum_{f: [n]→[x]} y^{|im(f)|}",
        "关键恒等式：∑_{f: [n] → [x]} y^{|im(f)|} = ∑_{k=0}^{x} S(n,k) * k! * C(x,k) * y^k = ∑_{k=0}^{x} C(x,k) * y^k * k^n （错误）→ 正确做法是通过二项式变换：∑_{k=0}^{x} C(x,k) * y^k * k^n 是错的",
        "正确推导：令 g(k) 表示恰好使用 k 个节目的分配方案数，则 g(k) = C(x,k) * surj(n,k)，其中 surj(n,k) = k! * S(n,k) = ∑_{i=0}^{k} (-1)^{k-i} * C(k,i) * i^n",
        "于是总方案数 = ∑_{k=1}^{min(x,n)} g(k) * y^k = ∑_{k=1}^{x} C(x,k) * (∑_{i=0}^{k} (-1)^{k-i} * C(k,i) * i^n ) * y^k",
        "算法不变量成立条件：枚举非空节目数 k，利用容斥计算满射函数数，结合组合选择与评分幂"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1000（可扩展至 1e5 使用 NTT 优化容斥）",
        "x 的数量级": "1 <= x <= 1000（可变为 x >= n 或 x << n）",
        "y 的值域": "1 <= y <= 1000（可变为变量函数如 y=k 或 y=f(k)）",
        "是否有序": "节目是有区别的（即标号不同视为不同），不可交换",
        "是否循环": "否，节目线性编号",
        "是否多组输入": "单组输入，但可改编为多组测试用例",
        "是否在线": "离线输入，可改为动态增加表演者或节目",
        "取模要求": "必须对 1e9+7 取模，可改为其他模数或不取模",
        "评分规则变化": "例如改为所有节目评分相同、或总分限制、或最小/最大评分约束",
        "表演者是否可区分": "当前是可区分的，可变形为不可区分（则变为整数拆分问题）",
        "节目是否可区分": "当前是可区分的，若不可区分则需除以 k! 并改变组合方式"
      },
      "lemstovirax": "该变量用于在函数中途存储输入参数的中间状态，例如保存当前枚举的节目数 k、对应的组合数 C(x,k)、满射函数数 surj(n,k) 以及 y^k 值，以便逐步累加总方案数"
    }
  },
  {
    "title": "Check if DFS Strings Are Palindromes",
    "slug": "check-if-dfs-strings-are-palindromes",
    "schema": {
      "Input Structure": {
        "tree_representation": "array parent[0..n-1], where parent[i] is the parent of node i, and parent[0] == -1 (root)",
        "node_labels": "string s of length n, s[i] ∈ lowercase English letters",
        "n": "number of nodes, 1 <= n <= 1e5",
        "root": "node 0"
      },
      "Core Constraint": {
        "dfs_order": "children are visited in ascending order of node index",
        "postorder_append": "character s[x] is appended to global string dfsStr after visiting all children of x",
        "shared_state": "dfsStr is a global variable shared across all DFS calls",
        "subtree_independence": "the DFS string generated from node i depends only on the subtree rooted at i"
      },
      "Objective Function": {
        "goal": "for each node i, determine whether the DFS traversal string starting from i is a palindrome",
        "output_type": "boolean array answer[0..n-1], where answer[i] = (dfsStr is palindrome after dfs(i))"
      },
      "Algorithmic Invariant": {
        "palindrome_symmetry": "a string is a palindrome iff it equals its reverse",
        "recursive_structure": "the DFS string of a node is: concat(dfs(child_1), ..., dfs(child_k), s[i])",
        "invariant_under_reversal": "to check palindrome, we can simulate forward DFS and reverse DFS (on reversed children order) and compare outputs",
        "efficient_comparison": "use hashing (e.g. rolling hash) over DFS strings to compare forward and reverse traversal results in O(1) per node after preprocessing"
      },
      "Transformable Parameters": {
        "n_value_range": "1 <= n <= 1e5",
        "alphabet_size": "26 (lowercase English letters), can be generalized to larger or symbolic set",
        "child_visit_order": "currently ascending by node index; can be changed to descending, arbitrary, or weighted order",
        "dfs_str_modification": "current: append at end; variant: prepend, insert in middle, etc.",
        "target_string_property": "currently palindrome; can change to anagram detection, substring containment, etc.",
        "output_granularity": "currently boolean per node; could output full string, length, or longest palindromic prefix",
        "data_flow": "offline batch processing; could be adapted to online queries with dynamic updates to s or tree structure",
        "tree_dynamics": "static tree; possible variants with edge addition/deletion or relabeling",
        "multiple_queries": "single pass over all roots; could support subset of queries or incremental addition"
      }
    }
  },
  {
    "title": "Sum of Consecutive Subarrays",
    "slug": "sum-of-consecutive-subarrays",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示柱状图中每个位置的高度",
      "Core Constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度中的较小值决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组能接的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max：当 left_max ≤ right_max 时，左指针位置的积水可确定；反之右指针位置的积水可确定；移动指针过程中不破坏已计算部分的正确性",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许为负数（如沟壑模型）",
        "维度扩展": "从 1D 扩展到 2D 网格（二维接雨水问题）",
        "输入形式": "是否在线输入或支持动态修改（带更新操作的结构）",
        "输出要求": "是否需要输出每个位置的蓄水量而非总和",
        "数据规模": "n 的数量级（如 1e3 / 1e5 / 1e7，影响解法选择）",
        "多组数据": "是否处理多组测试用例",
        "循环结构": "数组是否首尾相连（环形接雨水）"
      }
    }
  },
  {
    "title": "Find the K-th Character in String Game II",
    "slug": "find-the-k-th-character-in-string-game-ii",
    "schema": {
      "Input Structure": [
        "初始字符串 word = \"a\"",
        "正整数 k (1 <= k <= 1e14)",
        "整数数组 operations[1..n], 其中 n = operations.length <= 100",
        "operations[i] ∈ {0, 1}"
      ],
      "Core Constraint": [
        "操作具有递推结构：每次操作基于当前 word 的完整状态生成新字符串并追加",
        "操作类型 0：word = word + word（长度翻倍）",
        "操作类型 1：先将 word 中每个字符 c 替换为 (c+1) mod 26（'z' → 'a'），然后将结果追加到原 word",
        "最终字符串长度呈指数增长，无法显式构造",
        "必须通过递归/迭代回溯定位第 k 个字符的来源"
      ],
      "Objective Function": [
        "返回执行所有操作后，最终字符串中第 k 个字符（1-indexed）的值"
      ],
      "Algorithmic Invariant": [
        "每一步操作后，原字符串内容保持不变，仅在其后追加新内容",
        "对于任意操作 i，若其前的字符串长度为 L，则操作后的字符串分为两段：[0:L] 为原始内容，[L:2L] 为变换后追加的内容",
        "可以通过逆向遍历 operations 数组，判断第 k 个字符位于‘原部分’还是‘追加部分’",
        "若 k <= 当前操作前长度，则进入上一阶段；否则映射到变换规则中对应位置，并记录累计偏移或变换次数",
        "字符变化是可叠加的：若某字符被经过 t 次操作1的影响，则其实际值为初始 'a' 加上 t mod 26"
      ],
      "Transformable Parameters": [
        "k 的数量级：可变范围 [1, 1e9], [1, 1e14] 等（决定是否需要 O(n) 回溯）",
        "operations 长度：1 <= m <= 100 或更小（影响预处理长度数组可行性）",
        "是否允许 operation 类型扩展（如操作2：反转追加）",
        "是否多组查询（多个 k 值）→ 可预处理分段信息",
        "是否在线输入 operations → 要求流式处理",
        "初始字符是否可变（非 'a'）",
        "字符循环方式是否可调（模26 / 模其他）",
        "目标函数是否改为：返回第 k 到第 l 个字符的子串 / 字符频次统计"
      ]
    }
  },
  {
    "title": "Find the K-th Character in String Game I",
    "slug": "find-the-k-th-character-in-string-game-i",
    "schema": {
      "Input Structure": {
        "type": "string",
        "initial_value": "a",
        "transformation_rule": "each character is replaced by the next character in the alphabet and appended to the current string",
        "alphabet": "lowercase English letters (a-z)",
        "k_constraint": "positive integer, 1 <= k <= 500",
        "data_growth": "infinite recursive string expansion"
      },
      "Core Constraint": {
        "constraint": "the generated string follows a deterministic recursive structure: word_{n+1} = word_n + transform(word_n), where transform(c) = chr(ord(c)+1)",
        "self_similarity": true,
        "hierarchical_structure": "each iteration appends a shifted version of the current string",
        "state_dependency": "current string determines the next; no external input"
      },
      "Objective Function": {
        "goal": "retrieve the k-th character (1-indexed) in the infinite string generated by repeated transformation",
        "objective_type": "query",
        "output_type": "single character"
      },
      "Algorithmic Invariant": {
        "invariant": "the length of the string after n operations is 2^n, starting from length 1",
        "position_mapping": "for any k, we can recursively determine whether it lies in the first half (original part) or second half (transformed part)",
        "recursion_rule": "if k <= len(word_{n-1}), recurse on word_{n-1}; else, map k to position in transformed half and decrement char accordingly",
        "base_case": "when k == 1 and current base is 'a', return corresponding char after applying shift depth"
      },
      "Transformable Parameters": {
        "k_range": "1 <= k <= 500 (can be scaled up for harder variants)",
        "initial_word": "can vary from 'a' to other characters or strings",
        "shift_amount": "can change from +1 to +d (mod 26)",
        "alphabet_size": "can extend to modulo arithmetic over m letters",
        "cyclic_alphabet": "whether 'z' wraps to 'a'",
        "multi_queries": "support multiple k queries (offline/online)",
        "operation_limit": "limit number of operations instead of infinite generation",
        "output_form": "return full substring, count specific characters, or detect patterns"
      }
    }
  },
  {
    "title": "Rearrange K Substrings to Form Target String",
    "slug": "rearrange-k-substrings-to-form-target-string",
    "schema": {
      "Input Structure": [
        "给定两个字符串 s 和 t，长度均为 n",
        "s.length == t.length 且 1 <= n <= 2 * 10^5",
        "字符串仅由小写英文字母组成",
        "给定整数 k，满足 1 <= k <= n 且 n % k == 0",
        "输入保证 s 和 t 互为字母异位词"
      ],
      "Core Constraint": [
        "s 必须被分割成 k 个等长的连续非空子字符串，每个长度为 L = n / k",
        "这些子字符串可以任意重新排列（即顺序可调），但不能修改其内部字符",
        "最终拼接结果必须恰好等于 t",
        "由于 s 和 t 字符频次相同，全局字符守恒；关键在于是否存在一种子串划分与重排方案，使得拼接后匹配 t"
      ],
      "Objective Function": "判定是否存在一种将 s 分割为 k 个等长子串的方式，并通过重排这些子串，使其连接后等于 t",
      "Algorithmic Invariant": [
        "若存在合法解，则 t 也可以被划分为 k 个长度为 L 的子串，且这些子串的多重集合与 s 划分出的子串多重集合相同",
        "问题等价于：将 s 按长度 L = n/k 切分成 k 个子串，得到一个多重集 S；判断是否存在 t 的某种切分方式（顺序无关）得到相同的多重集 T",
        "由于允许任意重排，只需比较两个字符串在长度 L 下的所有子串的频次分布是否一致（作为多重集）",
        "算法核心不变量：字符串可重排当且仅当其子串多重集相等"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 2 * 10^5",
        "值域": "小写英文字母 a-z",
        "是否有序": "输入字符串无序，但结构依赖位置切分",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "k 的性质": "k 是正整数，且 n 能被 k 整除",
        "目标函数变体": [
          "改为计数：有多少种不同的分割-重排方案能得到 t",
          "构造方案：输出一组可行的子串划分与重排序列"
        ],
        "输入形式扩展": [
          "允许多次查询不同 k 值（在线模式）",
          "加入修改操作（如单点修改 s 中字符）"
        ],
        "约束变化": [
          "放松‘互为字母异位词’条件，需先验证字符频次",
          "子串不必等长 → 变为划分问题（NP-hard 类似）"
        ],
        "维度扩展": "从一维字符串 → 二维字符网格分块重排"
      }
    }
  },
  {
    "title": "Identify the Largest Outlier in an Array",
    "slug": "identify-the-largest-outlier-in-an-array",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n >= 3；数组包含 n 个元素，恰好有 n-2 个为‘特殊数字’，一个为所有特殊数字的和，另一个为‘异常值’；-1000 <= nums[i] <= 1000",
      "Core Constraint": "异常值必须是既不是原始特殊数字之一、也不是特殊数字之和的那个数；特殊数字、和、异常值三者下标不同（但值可重复）；整个数组中仅存在两个非特殊数字：一个是和，一个是异常值",
      "Objective Function": "在所有合法划分方案中，返回可能的最大的异常值",
      "Algorithmic Invariant": "对于任意候选异常值 x 和候选和 s，其余 n-2 个元素必须能构成一组特殊数字，其和等于 s，且 x ≠ s，x 不属于该组特殊数字；枚举过程中可通过排序 + 枚举排除法剪枝，保证不遗漏最优解",
      "Transformable Parameters": {
        "n 的数量级": "原题 n <= 1e5，但实际有效规模小（因需枚举），可调整至 n <= 20 或更高以控制复杂度",
        "值域范围": "-1000 <= nums[i] <= 1000，可扩展为更大范围或加入负数比例约束",
        "是否有序": "输入无序，可改为有序输入以简化推理路径",
        "是否多组输入": "当前单组输入，可扩展为多组测试数据",
        "是否在线": "离线处理，可设计为流式输入并动态判断异常值可能性",
        "特殊数字定义变化": "可替换‘和’为‘积’、‘异或和’等聚合函数作为变形"
      }
    }
  },
  {
    "title": "Find the Maximum Factor Score of Array",
    "slug": "find-the-maximum-factor-score-of-array",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length_range": [
          1,
          100
        ],
        "value_range": [
          1,
          30
        ],
        "properties": [
          "non_empty_input",
          "positive_integers",
          "finite_length"
        ]
      },
      "Core Constraint": {
        "lcm_gcd_interaction": "LCM and GCD of the array are non-local aggregations: each element affects both globally",
        "removal_impact": "Removing one element may increase LCM or preserve/decrease GCD, but trade-off exists",
        "boundary_behavior": "Single-element array has LCM = GCD = value; empty array scores 0",
        "algebraic_property": "For any set S, factor_score(S) = LCM(S) * GCD(S), which is not linear or monotonic under inclusion"
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "maximum_factor_score",
        "operation_limit": "at_most_one_removal",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "precomputation_invariance": "Prefix and suffix arrays for GCD and LCM allow O(1) computation of subarray values after single removal",
        "separability": "The effect of removing index i can be computed using prefix[i-1] and suffix[i+1], due to associativity of GCD and LCM",
        "optimal_substructure": "Global GCD/LCM can be decomposed into left and right independent parts around a removed element",
        "non_interference": "Once prefix/suffix tables are built, candidate evaluations are independent and orderless"
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          100
        ],
        "value_domain": [
          1,
          30
        ],
        "removal_limit": {
          "type": "integer",
          "default": 1,
          "possible_values": [
            0,
            1,
            "k",
            "unlimited"
          ]
        },
        "input_variations": {
          "multi_dimensional": false,
          "circular_array": false,
          "online_queries": false,
          "batch_updates": false
        },
        "data_properties": {
          "sorted": false,
          "distinct_elements": false,
          "with_duplicates": true
        },
        "output_requirements": {
          "return_score_only": true,
          "constructive_solution": false,
          "return_removed_index": false
        },
        "extension_potential": [
          "allow_up_to_k_removals",
          "require_minimize_removals_under_threshold",
          "factor_score_division_instead_of_product",
          "extend_to_2D_grid_of_numbers",
          "dynamic_insertion_deletion_support"
        ]
      }
    }
  },
  {
    "title": "Find X-Sum of All K-Long Subarrays II",
    "slug": "find-x-sum-of-all-k-long-subarrays-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "subarray_size": "k",
        "value_range": "[1, 10^9]",
        "constraints": [
          "nums.length == n",
          "1 <= n <= 10^5",
          "1 <= x <= k <= n"
        ]
      },
      "Core Constraint": {
        "frequency_selection": "保留出现频率最高的前 x 种元素",
        "tie_breaking_rule": "若频率相同，数值较大的元素优先保留",
        "fallback_rule": "若不同元素个数少于 x，则保留所有元素",
        "sliding_window_dependency": "每个子数组独立计算 x-sum，但相邻子数组有重叠元素"
      },
      "Objective Function": {
        "goal": "计数（构造答案数组）",
        "output_type": "integer array of length n - k + 1",
        "per_entry": "answer[i] = 子数组 nums[i..i+k-1] 的 x-sum",
        "x_sum_definition": "在频率排序并按规则取前 x 类后，同类所有元素求和"
      },
      "Algorithmic Invariant": {
        "invariant_type": "滑动窗口内的频次维护与有序集合更新",
        "monotonicity": false,
        "data_structure_invariant": [
          "使用哈希表维护当前窗口内各元素的频次",
          "使用有序数据结构（如平衡树或堆）动态维护（频次, 值）对的排序：先按频次降序，再按值降序",
          "窗口滑动时，删除离开的元素频次，添加进入的元素频次，保持有序结构可增量更新"
        ],
        "computation_invariant": "每次滑动后可在 O(x + log(unique)) 时间内重构 top-x 元素并求和"
      },
      "Transformable Parameters": {
        "n_range": [
          "1e1",
          "1e5"
        ],
        "value_domain": "positive integers (up to 1e9)",
        "k_value": "sliding window size, 1 <= k <= n",
        "x_value": "number of top frequency classes to retain, 1 <= x <= k",
        "ordering_rule": {
          "primary": "frequency descending",
          "secondary": "value descending on tie"
        },
        "input_form": "offline static array",
        "output_form": "array of x-sums for each contiguous subarray of length k",
        "variants": [
          "是否允许负数",
          "是否要求输出具体保留了哪些元素",
          "x-sum 改为 top-x distinct values 的加权和",
          "在线模式：逐个添加元素并查询当前窗口 x-sum",
          "二维扩展：在矩阵中对 k×k 子矩阵计算 x-sum",
          "频次判定规则变化：例如改为数值小者优先"
        ],
        "multi_query": false,
        "dynamic_operations": false
      }
    }
  },
  {
    "title": "Shift Distance Between Two Strings",
    "slug": "shift-distance-between-two-strings",
    "schema": {
      "Input Structure": [
        "两个长度相同的字符串 s 和 t，长度为 n，字符集为小写英文字母 a-z",
        "两个长度为 26 的整数数组 nextCost 和 previousCost",
        "nextCost[i] 表示将字母 chr('a' + i) 切换为下一个字母的操作代价",
        "previousCost[i] 表示将字母 chr('a' + i) 切换为上一个字母的操作代价",
        "字母表循环：'z' 的下一个是 'a'，'a' 的上一个是 'z'"
      ],
      "Core Constraint": [
        "每个字符的转换只能通过向前或向后逐位切换完成（不可直接跳转）",
        "操作代价依赖于当前字符（而非目标字符），且具有非对称性",
        "总代价是各位置独立操作代价之和",
        "由于字母表循环，任意字符可通过正向或反向路径到达目标字符"
      ],
      "Objective Function": "计算将字符串 s 转换为字符串 t 所需的最小总操作代价（即切换距离）",
      "Algorithmic Invariant": [
        "对于每个位置 i，从 s[i] 变为 t[i] 的最优代价 = min(正向路径累计代价, 反向路径累计代价)",
        "正向路径代价可通过累加 nextCost 模拟循环前进计算",
        "反向路径代价可通过累加 previousCost 模拟循环后退计算",
        "每一步的选择仅依赖于当前位置的字符和代价数组，不依赖其他位置，满足独立子问题性质",
        "整体最优解等于所有位置局部最优解之和"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1e5",
        "值域": "nextCost[i], previousCost[i] ∈ [0, 1e9]",
        "是否有序": "输入字符串无序，但字符空间具有循环序结构",
        "是否循环": true,
        "字符集大小": 26,
        "是否多组输入": false,
        "是否在线": false,
        "代价对称性": "可变：允许 nextCost[i] ≠ previousCost[(i+1)%26]，支持非对称代价模型",
        "操作类型扩展": "可扩展为支持跳跃操作、批量修改、状态记忆等",
        "输出形式": [
          "返回总代价（默认）",
          "可改为输出每个位置的操作序列或代价分布"
        ],
        "约束变形": [
          "限制最大操作次数",
          "加入全局预算约束",
          "要求字典序最小的操作方案"
        ]
      }
    }
  },
  {
    "title": "Maximum Total Area Occupied by Pistons",
    "slug": "maximum-total-area-occupied-by-pistons",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "description": "Given a 1D array H[1..n], where each element H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The amount of water that can be trapped at any position depends on the minimum of the maximum heights to its left and right.",
        "dependency": "Left and right boundary constraints are independent but must be globally consistent; local information is insufficient without global extrema."
      },
      "Objective Function": {
        "goal": "sum",
        "description": "Compute the total amount of rainwater that can be trapped between the bars after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers (left and right) move toward each other, maintaining the maximum heights seen so far from both ends.",
        "rules": [
          "If max_left <= max_right, then the water trapped at the left pointer depends only on max_left.",
          "Move the pointer with the smaller maximum, ensuring that the current side's bottleneck is known.",
          "The correctness of the accumulated result for the moved side is preserved throughout the process."
        ]
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 10^5",
        "value_range": "0 <= H[i] <= 10^4",
        "ordering": "unordered input; values may repeat",
        "dimensionality": "can be extended to 2D (e.g., 2D elevation map)",
        "negatives_allowed": false,
        "online_input": false,
        "mutable_operations": false,
        "output_detail": "total sum only; optionally output per-position contribution",
        "circular_array": false,
        "multiple_test_cases": false
      }
    }
  },
  {
    "title": "Find Candidates for Data Scientist Position II",
    "slug": "find-candidates-for-data-scientist-position-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度 maxLeft[i] 和右侧最大高度 maxRight[i] 的最小值决定，即 water[i] = min(maxLeft[i], maxRight[i]) - H[i]（若为正）",
        "key_insight": "左右边界约束可分离，且局部极值具有单调性；一旦某侧当前边界小于另一侧的最大值，则该侧当前位置的盛水容量仅取决于本侧历史极值"
      },
      "Objective Function": {
        "goal": "求和",
        "description": "计算所有位置上能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L=0 和 R=n-1，以及从两侧扫描得到的历史最大值 maxLeft 和 maxRight",
          "若 maxLeft ≤ maxRight，则左指针当前位置的盛水容量仅受 maxLeft 限制，可直接计算并右移 L",
          "反之，若 maxRight < maxLeft，则右指针位置的容量确定，可左移 R",
          "每次移动指针时更新对应侧的历史最大值",
          "已计算区域的值不受后续操作影响，保证解的正确性和增量构造性"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "数值范围",
            "options": [
              "非负整数",
              "允许负值（表示洼地或地下结构）"
            ]
          },
          {
            "name": "输入维度",
            "options": [
              "1D",
              "2D（二维接雨水问题）",
              "环形数组（首尾相连）"
            ]
          },
          {
            "name": "数据流模式",
            "options": [
              "离线一次性输入",
              "在线查询（支持动态修改/插入）"
            ]
          },
          {
            "name": "输出形式",
            "options": [
              "总和",
              "每个位置的具体储水量",
              "最大单段连续储水区间"
            ]
          },
          {
            "name": "多组数据",
            "options": [
              "单次执行",
              "多测试用例循环输入"
            ]
          },
          {
            "name": "目标函数变换",
            "options": [
              "求和 → 最大化单容器积水量（如‘盛水最多的容器’）",
              "计数：有多少个位置可以储水",
              "判定是否存在储水能力超过阈值的区间"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Count The Number of Winning Sequences",
    "slug": "count-the-number-of-winning-sequences",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"string_sequence\",\n    \"domain\": [\"F\", \"W\", \"E\"],\n    \"length\": \"n\",\n    \"n_range\": [1, 1000],\n    \"description\": \"长度为 n 的字符串 s，表示 Alice 每回合召唤的生物序列，字符取值于 {'F', 'W', 'E'}\"\n  },\n  \"Core Constraint\": {\n    \"constraint\": \"Bob 的出招序列中不能有连续两个相同的生物\",\n    \"interaction_rule\": [\n      \"若 A 出 F 且 B 出 E，则 A 得 1 分\",\n      \"若 A 出 W 且 B 出 F，则 A 得 1 分\",\n      \"若 A 出 E 且 B 出 W，则 A 得 1 分\",\n      \"若 B 出 F 且 A 出 E，则 B 得 1 分\",\n      \"若 B 出 W 且 A 出 F，则 B 得 1 分\",\n      \"若 B 出 E 且 A 出 W，则 B 得 1 分\",\n      \"相同生物则双方均不得分\"\n    ],\n    \"dependency\": \"每回合得分取决于 Alice 的固定出招与 Bob 的当前出招，且 Bob 的出招受前一回合限制\"\n  },\n  \"Objective Function\": {\n    \"goal\": \"计数\",\n    \"target\": \"满足 Bob 总分严格大于 Alice 总分的所有合法 Bob 出招序列的数量\",\n    \"output_mod\": 1000000007\n  },\n  \"Algorithmic Invariant\": {\n    \"invariant_type\": \"动态规划状态可分解\",\n    \"state_definition\": [\n      \"dp[i][last][diff] 表示前 i 轮，Bob 最后一轮出招为 last，当前 Bob 与 Alice 的得分差为 diff 的方案数\",\n      \"由于得分差可能为负，需进行偏移处理（offset）\"\n    ],\n    \"transition_rule\": \"在第 i 轮，枚举 Bob 的当前出招 c ∈ {'F','W','E'}，若 c ≠ last，则根据 s[i] 和 c 计算本轮得分变化，并更新 dp[i+1][c][new_diff]\",\n    \"optimization_invariant\": \"状态转移仅依赖前一状态和当前决策，无后效性；得分差范围有限（最多 ±n），可压缩状态空间\"\n  },\n  \"Transformable Parameters\": {\n    \"parameters\": [\n      {\n        \"name\": \"sequence_length\",\n        \"type\": \"integer\",\n        \"range\": [1, 1000],\n        \"description\": \"回合数 n，影响状态维度和复杂度\"\n      },\n      {\n        \"name\": \"alphabet_size\",\n        \"type\": \"constant\",\n        \"value\": 3,\n        \"possible_extension\": \"可推广至 k 种生物的手势博弈系统\"\n      },\n      {\n        \"name\": \"consecutive_restriction\",\n        \"type\": \"constraint\",\n        \"values\": [\n          \"no_consecutive_same (current)\",\n          \"no_consecutive_pattern\",\n          \"limited_repetition\",\n          \"k_gap_repeat_allowed\"\n        ],\n        \"description\": \"对 Bob 出招的连续性约束可变换\"\n      },\n      {\n        \"name\": \"scoring_rule\",\n        \"type\": \"relation_matrix\",\n        \"values\": \"可更换为任意胜负图（如 RPS 变种、带权重等）\"\n      },\n      {\n        \"name\": \"objective_variation\": [\n        \"count_sequences_with_bob_wins\",\n        \"count_sequences_with_draw_or_win\",\n        \"maximize_bob_score\",\n        \"determine_if_any_winning_sequence_exists\"\n      ]\n      },\n      {\n        \"name\": \"input_form\",\n        \"type\": \"multi_option\",\n        \"values\": [\n          \"single_string_Alice_only\",\n          \"both_sequences_given\",\n          \"partial_knowledge_of_Bob\"\n        ]\n      },\n      {\n        \"name\": \"data_mode\",\n        \"type\": \"streaming_vs_batch\",\n        \"values\": [\n          \"offline_batch_input (current)\",\n          \"online_query_per_round\"\n        ]\n      },\n      {\n        \"name\": \"modular_arithmetic\",\n        \"type\": \"output_setting\",\n        \"values\": [\n          \"mod_1e9p7 (current)\",\n          \"mod_prime_variable\",\n          \"no_mod_return_full_number\"\n        ]\n      }\n    ]\n  }\n}"
  },
  {
    "title": "Maximum Points Tourist Can Earn",
    "slug": "maximum-points-tourist-can-earn",
    "schema": {
      "Input Structure": [
        "整数 n：城市数量，1 <= n <= 200",
        "整数 k：旅游天数（从第 0 天到第 k-1 天），1 <= k <= 200",
        "二维数组 stayScore[0..k-1][0..n-1]：stayScore[i][j] 表示第 i 天停留在城市 j 可获得的分数，值域 [1, 100]",
        "二维数组 travelScore[0..n-1][0..n-1]：travelScore[i][j] 表示从城市 i 前往城市 j 可获得的分数，值域 [0, 100]，且 travelScore[i][i] = 0"
      ],
      "Core Constraint": [
        "每天必须做出选择：留在当前城市或前往另一座城市",
        "选择依赖于前一天所在城市（状态转移）",
        "旅行图是完全图（任意两城市直接相连）",
        "初始城市可任选，无前置约束",
        "总决策序列长度为 k 天，每一步决策影响后续状态"
      ],
      "Objective Function": "最大化 k 天内累计获得的总点数（求最大值）",
      "Algorithmic Invariant": [
        "使用动态规划维护状态 dp[i][j]：表示前 i 天结束时位于城市 j 所能获得的最大得分",
        "状态转移方程具有最优子结构：",
        "  dp[i][j] = max(",
        "    dp[i-1][j] + stayScore[i-1][j],  // 留在城市 j",
        "    max_{c ≠ j}(dp[i-1][c] + travelScore[c][j])  // 从其他城市 c 转移至 j",
        "  )",
        "初始状态：dp[0][j] = 0（第 0 天开始前无得分，可从任意城市出发）",
        "状态转移过程中，每一天的更新仅依赖前一天的状态（阶段分明）",
        "状态空间大小为 O(k * n)，转移成本为 O(n)，整体复杂度可控在 O(k * n^2)"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前为 200，可调整至 1e3 或更高以要求优化（如矩阵快速幂或单调队列优化）",
        "k 的数量级：当前为 200，可扩展为 1e5 引入在线/滚动数组/矩阵加速",
        "stayScore 是否允许负值：当前均为正，改为可负则影响贪心可行性",
        "travelScore 是否对称：当前不对称，若强制对称可引入额外剪枝",
        "是否支持修改操作：加入动态更新 score 的操作，变为在线问题",
        "是否多组数据：测试用例是否包含多个独立实例",
        "目标函数变换：由最大值 → 求方案数 / 判定是否存在得分 >= T 的路径",
        "输入形式变化：将 travelScore 改为稀疏图形式（邻接表），限制转移方向",
        "是否环形时间：k 天后需返回起点，增加约束"
      ]
    }
  },
  {
    "title": "Constructing Two Increasing Arrays",
    "slug": "constructing-two-increasing-arrays",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的非负整数数组 height，表示按序排列的柱状图中每个柱子的高度。"
      },
      "Core Constraint": {
        "constraint": "任意两个柱子之间形成的容器容量由两者中较矮柱子的高度与它们之间的距离共同决定。",
        "independence": "左右边界的选择相互影响，但一旦确定一对边界，其容量仅取决于 min(height[left], height[right]) * (right - left)。",
        "global_dependency": "最优解依赖于全局极值分布，局部最大值可能无法构成全局最优。"
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "求所有可能的两根柱子之间能盛最多水的容量。"
      },
      "Algorithmic Invariant": {
        "technique": "双指针",
        "invariant_rules": [
          "初始化左指针 L=0，右指针 R=n-1。",
          "每次移动较短高度的一侧指针，因为固定高的一侧、缩短宽度只会使容量减小或不变。",
          "移动过程中，已排除的状态（即被舍弃的指针位置）不可能参与构成更优解。",
          "每一步都保留了通往全局最优解的可能性路径。"
        ],
        "proof_condition": "由于容量受限于短板效应，缩小较长边不会丢失潜在更大容量，而必须尝试替换短板以寻求突破。"
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 1e5",
          "可扩展至 1e6 要求 O(n) 解法"
        ],
        "value_domain": "height[i] >= 0，可变形为允许负值（需重新定义物理意义）",
        "ordering": "原始无序；若有序则可二分优化（中间层变体）",
        "input_form": "单组离线输入；可改为多组测试用例或在线查询模式",
        "output_form": "仅返回最大容量值；可要求输出具体边界索引对 (i, j)",
        "structural_extension": [
          "2D 版本：矩阵中找两个行/列形成最大面积容器",
          "环形数组版本：首尾相连，需处理循环坐标"
        ],
        "operation_support": "静态数组；可增加 update 操作变为支持动态修改的结构（如线段树维护）"
      }
    }
  },
  {
    "title": "Find Overlapping Shifts II",
    "slug": "find-overlapping-shifts-ii",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；若该值大于当前高度，则可积水",
      "Objective Function": "计算整个数组中能够接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max：当 left_max ≤ right_max 时，左指针位置的积水可确定；反之右指针位置的积水可确定；移动指针过程中不破坏已计算区域的正确性",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许负数（如沟壑模型）",
        "维度扩展": "从 1D 扩展到 2D 矩阵接雨水问题",
        "输入形式": "是否在线输入或支持动态修改（加入更新操作）",
        "输出要求": "是否需要输出每个位置的积水量而非总和",
        "数据规模": "n 的数量级（例如 1e3 / 1e5 / 1e7，影响解法选择）",
        "多组数据": "是否处理多组测试用例",
        "结构变形": "数组是否为环形结构"
      }
    }
  },
  {
    "title": "Find the Lexicographically Smallest Valid Sequence",
    "slug": "find-the-lexicographically-smallest-valid-sequence",
    "schema": "{\n  \"Input Structure\": [\n    \"给定两个字符串 word1 和 word2\",\n    \"word1 长度为 n，word2 长度为 m\",\n    \"n > m ≥ 1\",\n    \"字符集：小写英文字母 a-z\"\n  ],\n  \"Core Constraint\": [\n    \"目标是从 word1 中选出一个升序下标序列 seq = [i1, i2, ..., im]，使得从 word1 中按顺序提取的字符构成的字符串 s 满足：s 与 word2 几乎相等（即至多一个字符不同）\",\n    \"必须保证所选下标序列在字典序上最小\",\n    \"每个位置只能使用一次，且必须保持原顺序\"\n  ],\n  \"Objective Function\": [\n    \"构造字典序最小的合法下标序列\",\n    \"若不存在则返回空数组\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"贪心构造：从前向后扫描 word1，尽可能早地匹配 word2 的当前字符，以保证字典序最小\",\n    \"维护已匹配长度和差异计数（已用掉‘几乎相等’中的修改机会）\",\n    \"一旦某个前缀无法完成后续匹配，则回溯或剪枝（但需避免暴力回溯以满足数据规模）\",\n    \"可通过预处理 next_match[i][c] 表示在 word1 中位置 i 及之后第一个字符 c 的位置，加速贪心推进\"\n  ],\n  \"Transformable Parameters\": {\n    \"数据规模\": {\n      \"word1.length ∈ [1, 3×10^5]\",\n      \"word2.length ∈ [1, word1.length - 1]\"\n    },\n    \"字符集类型\": \"可扩展为大写字母、数字、任意 ASCII\",\n    \"修改次数上限\": \"可推广为 k 次修改（本题 k=1）\",\n    \"是否要求字典序最小\": \"可变为任意合法序列 / 字典序最大 / 所有方案计数\",\n    \"是否在线\": \"可设计为动态添加字符的在线版本\",\n    \"输入形式\": \"可变为多组测试用例 / 流式输入\",\n    \"约束条件\": \"可改为至少一个不同 / 完全相同 / 编辑距离 ≤k\"\n  }\n}"
  },
  {
    "title": "Sorted GCD Pair Queries",
    "slug": "sorted-gcd-pair-queries",
    "schema": {
      "Input Structure": {
        "nums": "一维整数数组 nums[1..n], 其中 n >= 2, nums[i] ∈ [1, 5*10^4]",
        "queries": "一维整数数组 queries[1..q], 每个元素为下标，满足 0 <= queries[i] < n*(n-1)/2",
        "gcdPairs": "由所有满足 0 <= i < j < n 的数对 (nums[i], nums[j]) 的 gcd 值组成的多重集合，后续升序排序"
      },
      "Core Constraint": {
        "pair_generation": "所有无序数对 (i,j) 必须被枚举一次且仅一次",
        "gcd_value_dependency": "gcd(nums[i], nums[j]) 的值仅依赖于两个元素的数值，与位置无关",
        "sorted_order_requirement": "最终结果基于全局排序后的 gcdPairs 数组进行查询，因此顺序不可忽略",
        "combinatorial_blowup": "gcdPairs 长度为 O(n²)，可能远大于原始输入规模，无法显式构造"
      },
      "Objective Function": {
        "primary_objective": "对于每个 query q，返回排序后 gcdPairs 中第 q 小的元素",
        "output_type": "构造一个整数数组 answer，其中 answer[i] = gcdPairs[queries[i]]"
      },
      "Algorithmic Invariant": {
        "value_frequency_accumulation": "相同 gcd 值会重复出现多次，可通过频次统计避免显式生成所有数对",
        "divisor_based_counting_invariance": "对于给定 d，能产生 gcd >= d 或恰好为 d 的数对数量可通过倍数枚举和容斥原理高效计算",
        "monotonicity_of_divisors": "若 d | x，则所有 d 的倍数对应的计数具有包含关系，支持预处理+前缀和优化",
        "offline_query_sorting_invariance": "queries 可离线处理，通过二分答案 + 数值域上逐层统计实现快速定位第 k 小元素"
      },
      "Transformable Parameters": {
        "n_value_range": "n ∈ [2, 1e5] → 可调整至更小（如 1e3）以允许暴力；或更大并要求近似解",
        "nums_value_domain": "nums[i] ∈ [1, 5e4] → 可扩展至 1e6 或压缩至 [1, 100]",
        "query_type": "当前为‘第k小’查询 → 可变为在线查询、区间第k小、或要求具体数对索引",
        "input_form": "是否多组测试数据；是否动态添加 nums 元素（流式）",
        "ordering_requirement": "是否需要返回整个排序后的 gcdPairs（构造型），而非仅响应查询",
        "target_function_variant": "目标函数可改为：求最大/最小 gcd；计数大于 K 的 gcd 对数；是否存在某值等",
        "algebraic_operation": "将 gcd 替换为 lcm、xor、and 等其他二元运算，形成代数结构变体"
      }
    }
  },
  {
    "title": "Find Indices of Stable Mountains",
    "slug": "find-indices-of-stable-mountains",
    "schema": {
      "Input Structure": "一维数组 height[1..n]，其中 n >= 2；height[i] 为正整数，表示第 i 座山的高度；给定整数 threshold 作为阈值",
      "Core Constraint": "一座山（下标 i > 0）是否稳定，仅取决于其左侧相邻山（i-1）的高度是否严格大于 threshold；稳定性判定具有局部性且无后效性",
      "Objective Function": "收集所有满足条件的稳定山的下标，即构造一个包含符合条件下标的数组",
      "Algorithmic Invariant": "从左到右遍历过程中，每个位置 i 的判定只依赖于 height[i-1] 和 threshold，无需回溯或全局信息；已处理的位置状态不会影响后续判断",
      "Transformable Parameters": [
        "n 的数量级：当前为 2 <= n <= 100，可扩展至 1e5（在线性算法中）",
        "height[i] 值域：当前为 [1,100]，可调整为负数或更大范围",
        "threshold 比较方式：当前为 '严格大于'，可变换为 '≥', '≤', '<' 等",
        "稳定定义依赖关系：当前为 '前一座山决定当前山'，可改为 '前 k 座山的最大值/平均值决定'",
        "输入形式：当前为单组离线输入，可变为多组数据或在线流式输入",
        "输出要求：当前为返回下标列表，可变更为计数、最长连续稳定段等"
      ]
    }
  },
  {
    "title": "The Two Sneaky Numbers of Digitville",
    "slug": "the-two-sneaky-numbers-of-digitville",
    "schema": {
      "Input Structure": {
        "type": "array",
        "element_type": "integer",
        "domain": "0 <= nums[i] < n",
        "length": "n + 2",
        "base_set": "integers from 0 to n - 1",
        "expected_frequency": "each number should appear exactly once",
        "actual_frequency": "exactly two numbers appear twice, others once"
      },
      "Core Constraint": {
        "uniqueness_violation": "exactly two elements are duplicated",
        "frequency_invariant": "all other elements appear exactly once",
        "set_coverage": "the underlying set is complete: contains all integers in [0, n-1]",
        "constraint_origin": "deviation from expected frequency distribution defines the problem"
      },
      "Objective Function": {
        "goal": "find and return the two duplicated numbers",
        "output_type": "array of length 2",
        "order": "arbitrary"
      },
      "Algorithmic Invariant": {
        "frequency_tracking": "counting occurrences preserves identity of duplicates",
        "mathematical_invariant": "sum difference: (sum of nums) - (sum of 0..n-1) = dup1 + dup2",
        "set_difference_invariant": "elements appearing more than once can be isolated via membership tracking",
        "xor_invariant_potential": "if only one duplicate existed, XOR could recover it; here, pairing fails due to two dups"
      },
      "Transformable Parameters": {
        "n_magnitude": "small scale: 2 <= n <= 100",
        "data_structure_variants": [
          "use hash map for counting",
          "use boolean visited array",
          "use sorting",
          "use mathematical sum method combined with set sum"
        ],
        "input_form": "static offline array",
        "online_possible": false,
        "multiplicity_change": "could generalize to k duplicates (k=2 fixed here)",
        "value_range_modification": "could extend beyond [0, n-1), but current boundedness enables indexing tricks",
        "output_requirements": "return values only, not indices",
        "uniqueness_guarantee": "input guarantees exactly two duplicates — this is critical for solvability without ambiguity"
      }
    }
  },
  {
    "title": "Find the Occurrence of First Almost Equal Substring",
    "slug": "find-the-occurrence-of-first-almost-equal-substring",
    "schema": {
      "Input Structure": [
        "一维字符串 s[0..n-1], 其中 n = len(s), 1 <= n <= 1e5",
        "一维字符串 pattern[0..m-1], 其中 m = len(pattern), 1 <= m < n",
        "s 和 pattern 均为小写英文字母组成的字符串"
      ],
      "Core Constraint": [
        "子字符串与 pattern 几乎相等的定义是：至多修改一个字符后两者相等",
        "即两个等长字符串的汉明距离 ≤ 1",
        "需要在 s 中找到长度等于 len(pattern) 的连续子串，使其与 pattern 的汉明距离 ≤ 1",
        "要求下标最小的合法起始位置"
      ],
      "Objective Function": [
        "求满足条件的、起始下标最小的子字符串的起始索引",
        "若不存在，返回 -1",
        "目标函数类型：最小化起始下标（存在性判定 + 最小化）"
      ],
      "Algorithmic Invariant": [
        "滑动窗口大小固定为 m = len(pattern)",
        "使用双指针维护当前窗口 [i, i+m-1] 对应的子串 s[i:i+m]",
        "逐位比较 s[i:i+m] 与 pattern，统计不同字符个数",
        "一旦差异超过 1，则该窗口不合法",
        "首次遇到差异 ≤ 1 的窗口时，其起始索引最小，可直接返回（贪心性质成立）",
        "算法正确性依赖于：从左到右扫描，第一个满足条件的解即为最优解"
      ],
      "Transformable Parameters": {
        "k": {
          "description": "允许修改的字符数量",
          "default": 1,
          "range": [
            1,
            "small integer"
          ],
          "note": "原题 k=1；进阶推广为 k 个字符可修改"
        },
        "continuity_constraint": {
          "description": "是否要求修改的字符是连续的",
          "default": false,
          "note": "原题无连续要求；进阶提出‘k个连续字符’修改的新约束"
        },
        "string_length": {
          "n": "1 <= n <= 1e5",
          "m": "1 <= m < n"
        },
        "alphabet_type": "lowercase English letters only",
        "online_query": false,
        "multiple_queries": false,
        "output_form": "single integer: minimal starting index or -1",
        "case_sensitive": true,
        "wildcard_allowed": false,
        "edit_operation_type": [
          "substitution"
        ],
        "allow_insert_delete": false
      }
    }
  },
  {
    "title": "Maximum Possible Number by Binary Concatenation",
    "slug": "maximum-possible-number-by-binary-concatenation",
    "schema": {
      "Input Structure": [
        "长度为 3 的整数数组 nums[1..3]",
        "每个元素 nums[i] 是正整数",
        "1 <= nums[i] <= 127",
        "二进制表示不含前导零"
      ],
      "Core Constraint": [
        "最终数值由各元素二进制字符串按顺序拼接后转为十进制得到",
        "拼接顺序影响结果值：高位部分的权重远大于低位",
        "较大的二进制字符串若前置，能显著提升整体数值",
        "最优顺序需基于字典序或贪心比较规则确定"
      ],
      "Objective Function": "最大化拼接后的二进制字符串所对应的十进制整数值",
      "Algorithmic Invariant": [
        "对于任意两个元素 a 和 b，将 a 放在 b 前面更优当且仅当拼接结果 concat(a,b) > concat(b,a)（以二进制字符串解释）",
        "该比较关系具有可传递性（在本题小规模下可忽略反例），支持全排列排序贪心选择",
        "由于 n=3 极小，可通过枚举所有排列验证最优解，但最优策略仍符合贪心不变量"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可扩展至 n <= 10 或 n <= 100（需高效实现）",
        "值域范围": "nums[i] 可扩大至 2^20，影响二进制串长度",
        "是否有序": "输入无序，顺序完全由构造决定",
        "是否循环": "否，为线性拼接结构",
        "是否多组输入": "可改为多组测试用例",
        "是否在线": "当前为离线一次性输入，可改造为流式添加数字并动态维护最大拼接值",
        "输出形式": "可要求输出方案顺序、或模意义下的结果、或二进制字符串",
        "连接方式": "可变更为十进制字符串拼接（类 '最大数' 题）或其它进制"
      }
    }
  },
  {
    "title": "Construct 2D Grid Matching Graph Layout",
    "slug": "construct-2d-grid-matching-graph-layout",
    "schema": "{\n  \"Input Structure\": [\n    \"无向图 G = (V, E)\",\n    \"节点集合 V: {0, 1, ..., n-1}, |V| = n\",\n    \"边集合 E: edges[i] = [u_i, v_i], 其中 u_i < v_i\",\n    \"图是连通的（隐式保证可嵌入二维网格）\",\n    \"输入规模: 2 <= n <= 5 * 10^4, |E| <= 10^5\"\n  ],\n  \"Core Constraint\": [\n    \"输出矩阵中两个格子相邻（上下左右）当且仅当对应节点在图中有边连接\",\n    \"每个节点在矩阵中恰好出现一次\",\n    \"矩阵结构必须保持图的邻接关系完全等价于四连通网格邻接关系\",\n    \"图必须能嵌入到二维网格中，且边只允许出现在相邻格子之间\",\n    \"题目保证存在至少一种合法的嵌入方式\"\n  ],\n  \"Objective Function\": [\n    \"构造一个二维整数矩阵\",\n    \"使得矩阵的每个元素唯一对应图中的一个节点\",\n    \"满足：任意两节点有边 ⇔ 在矩阵中为四连通相邻\",\n    \"返回任意一个合法解即可\",\n    \"目标函数类型：构造方案（Construction）\"\n  ],\n  \"Algorithmic Invariant\": [\n    \"网格嵌入过程中，局部已放置节点的相对位置不会破坏全局连通性约束\",\n    \"每一步扩展基于当前边界节点的邻居可嵌入性\",\n    \"使用 BFS 或类似搜索策略从某个起点展开，维护坐标映射与冲突检测\",\n    \"坐标分配满足：若 (u, v) ∈ E，则 coord[u] 与 coord[v] 在网格中曼哈顿距离为 1\",\n    \"已确定坐标的节点不再移动（位置固定性）\"\n  ],\n  \"Transformable Parameters\": {\n    \"n 的数量级\": \"2 <= n <= 50000\",\n    \"边的数量\": \"1 <= |E| <= 100000\",\n    \"图是否连通\": \"是（由题意隐式保证）\",\n    \"图是否为树\": \"否，可能含环\",\n    \"输出矩阵形状\": \"可变（行数 × 列数，只要覆盖所有节点）\",\n    \"是否要求最小化矩阵面积\": \"否\",\n    \"是否要求特定形状（如正方形）\": \"否\",\n    \"是否多组数据\": \"否（单实例）\",\n    \"是否在线\": \"否（离线输入）\",\n    \"节点编号是否有序\": \"是（0 到 n-1）\",\n    \"是否允许对角相邻\": \"否（仅横竖相邻）\",\n    \"是否允许多个连通分量\": \"否（题目保证可构造，即连通）\"\n  }\n}\n```\n\n> **注**：此 Problem Schema 属于 **几何与空间问题（Geometry / Spatial） → 图嵌入网格结构 → 构造类双射映射 → 基于BFS/DFS的坐标分配算法** 的叶子节点母题。  \n> 主解法：**图的网格嵌入构造（Graph Grid Embedding via Search）**  \n> 辅助解法：哈希映射、坐标偏移、邻接表遍历  \n> 最优解法在竞赛语境下并非唯一（存在多种搜索顺序和起始点选择），但核心不变量一致，因此作为**叶子节点母题**仍成立，因其构造逻辑和验证条件高度统一。"
  },
  {
    "title": "Convert Doubly Linked List to Array I",
    "slug": "convert-doubly-linked-list-to-array-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "一维数组 H[1..n]，其中 H[i] 表示第 i 个柱子的高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右边界约束可分离处理",
        "global_dependency": "局部积水依赖于全局极值信息"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total trapped water",
        "description": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariants": [
          "维护左指针 L 和右指针 R，以及从左到 L 的最大值 maxLeft，从右到 R 的最大值 maxRight",
          "若 maxLeft ≤ maxRight，则 L 处的积水仅受 maxLeft 约束，可立即计算并移动 L",
          "反之则 R 处的积水受 maxRight 约束，可计算并移动 R",
          "指针移动过程中，已确定区域的贡献值不变且正确"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_range",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "default": "non-negative"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D",
              "circular_1D"
            ],
            "default": "1D"
          },
          {
            "name": "query_mode",
            "options": [
              "offline_batch",
              "online_queries",
              "dynamic_updates"
            ],
            "default": "offline_batch"
          },
          {
            "name": "output_form",
            "options": [
              "total_sum",
              "per_position_values",
              "maximum_single_area"
            ],
            "default": "total_sum"
          },
          {
            "name": "data_update",
            "options": [
              "static",
              "supports_insert_delete",
              "supports_point_update"
            ],
            "default": "static"
          },
          {
            "name": "multiple_test_cases",
            "type": "boolean",
            "default": false
          }
        ]
      }
    }
  },
  {
    "title": "Find Subtree Sizes After Changes",
    "slug": "find-subtree-sizes-after-changes",
    "schema": {
      "Input Structure": [
        "一棵由长度为 n 的数组 parent 表示的树，其中 parent[i] 表示节点 i 的父节点编号，parent[0] == -1（根节点）",
        "一个长度为 n 的字符串 s，s[i] 表示节点 i 对应的小写英文字母",
        "节点编号从 0 到 n-1，n >= 1"
      ],
      "Core Constraint": [
        "所有非根节点 x（从 1 到 n-1）同时执行一次重连操作：寻找离 x 最近的祖先 y，满足 s[x] == s[y]",
        "若存在这样的 y，则将 x 的父边从原父节点删除，并连接到 y，使 y 成为 x 的新父节点",
        "所有操作是“同时”进行的，即基于原始树结构判断祖先路径，不因中间修改而改变搜索路径",
        "每个节点最多被重新连接一次，且只考虑原始树中的祖先链"
      ],
      "Objective Function": [
        "返回一个长度为 n 的数组 answer，其中 answer[i] 表示最终树中以节点 i 为根的子树大小"
      ],
      "Algorithmic Invariant": [
        "重连操作不影响祖先查询时的路径可见性——所有查询基于初始树结构进行",
        "对于每个节点 x，其目标祖先 y 是在原始祖先链上、字符匹配且深度最大的节点（最近匹配）",
        "子树大小可通过构建最终树后的一次 DFS 或拓扑排序自底向上计算得出",
        "由于操作是同时发生的，父子关系的变化不会影响其他节点的祖先查找过程"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 1e5",
        "字符集类型": "s 只包含小写英文字母（可扩展为大写、数字或任意字符集）",
        "是否有序": "树结构无序，但 parent 数组隐式定义父子顺序",
        "是否循环": "否，输入保证为合法树结构",
        "是否多组输入": "否（可改编为多测情形）",
        "是否在线": "否（一次性离线输入）",
        "操作模式": "‘同时更新’语义（可变体：顺序更新、递归更新等）",
        "匹配条件": "字符相等（可变体：字符差值约束、正则匹配、回文条件等）",
        "输出形式": "子树大小数组（可变体：最大子树、特定节点答案、路径和等）"
      }
    }
  },
  {
    "title": "Find the Maximum Sequence Value of Array",
    "slug": "find-the-maximum-sequence-value-of-array",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "正整数 k",
        "2 <= n <= 400",
        "1 <= nums[i] < 128 (即值域为 [1, 2^7 - 1])",
        "子序列长度固定为 2 * k"
      ],
      "Core Constraint": [
        "目标结构为长度为 2k 的子序列，前半段和后半段各长 k",
        "每段的贡献由该段所有元素的按位或（OR）决定",
        "整体值为前半段 OR 结果与后半段 OR 结果的异或（XOR）",
        "OR 运算具有单调性（随着元素增加，结果只增不减）",
        "XOR 不具单调性，需权衡两段 OR 值的差异以最大化结果"
      ],
      "Objective Function": "求所有长度为 2k 的子序列中，(前k个元素OR) XOR (后k个元素OR) 的最大值",
      "Algorithmic Invariant": [
        "枚举所有可能的前半段 OR 值 A 和后半段 OR 值 B 是不可行的，但可通过状态压缩动态规划维护可达的 OR 状态集合",
        "对于固定的划分位置，前半段与后半段的选择相互独立",
        "使用位运算性质剪枝：若某子集的 OR 已被更小/相等集合达到，则可去重",
        "最优解必然出现在某些极值组合上：如高位尽可能不同以增大 XOR"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的范围": [
            "[2, 400]",
            "可扩展至 1e3 或更高（若允许近似）"
          ],
          "k 的范围": [
            "1 <= k <= floor(n/2)",
            "可设为变量或限制 k <= 5 进行暴力"
          ]
        },
        "值域": {
          "nums[i] 的上界": [
            "< 2^7",
            "可改为 < 2^10 或 < 2^15，影响是否可用状压DP"
          ]
        },
        "输入形式": {
          "是否有序": [
            "无序数组",
            "可考虑排序后处理"
          ],
          "是否可重复元素": [
            "允许重复",
            "可禁止重复"
          ]
        },
        "子序列约束": {
          "是否连续": [
            "非连续子序列",
            "可变形为连续子数组"
          ],
          "是否必须恰好 2k 长度": [
            "是",
            "可改为至少 2k"
          ]
        },
        "目标函数变换": [
          "最大值 → 最小值",
          "最大值 → 计数满足条件的子序列数量",
          "判定是否存在值 >= target"
        ],
        "操作模式": {
          "是否在线": [
            "离线一次性输入",
            "可改为流式添加元素并查询"
          ],
          "是否支持修改": [
            "静态数组",
            "可加入单点修改"
          ]
        },
        "结构扩展": [
          "从一维到二维数组上的块分割",
          "从两段到多段分组（如三段：A|B|C，目标为 A OR B XOR C）",
          "从固定 k 到可变分段长度（受总长约束）"
        ]
      }
    }
  },
  {
    "title": "Find Overlapping Shifts",
    "slug": "find-overlapping-shifts",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "description": "Given an integer array height of length n, where each element represents the height of a vertical line at that index."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the minimum of their heights and the distance between them.",
        "key_insight": "For any pair (i, j), the container's area is (j - i) * min(height[i], height[j]). To maximize this, moving the shorter side may lead to a larger area; moving the taller side cannot increase the bottleneck height and reduces width, so it's never beneficial."
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "the maximum amount of water a container can store"
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers start at both ends. At each step, the pointer pointing to the shorter line is moved inward because the area is limited by the shorter line. The maximum area seen so far is maintained. This greedy movement preserves optimality: no better solution exists outside the explored state space."
      },
      "Transformable Parameters": {
        "n_range": "2 <= n <= 10^5",
        "value_domain": "height[i] >= 0, up to 10^4",
        "sorted_input": false,
        "circular_array": false,
        "online_queries": false,
        "multiple_test_cases": true,
        "output_type": "single integer (maximum area)",
        "modifications_allowed": false,
        "extensions": [
          "2D version with matrix of heights",
          "support for updates (dynamic version)",
          "count number of optimal pairs instead of max value",
          "minimum area ≥ K (decision variant)",
          "online stream of heights"
        ]
      }
    }
  },
  {
    "title": "Count Substrings That Can Be Rearranged to Contain a String I",
    "slug": "count-substrings-that-can-be-rearranged-to-contain-a-string-i",
    "schema": {
      "Input Structure": [
        "字符串 word1[1..n]，其中 n = |word1|, 1 <= n <= 1e5",
        "字符串 word2[1..m]，其中 m = |word2|, 1 <= m <= 1e4",
        "字符集：小写英文字母（a-z）"
      ],
      "Core Constraint": [
        "子字符串 s 是合法的，当且仅当存在其字符重排后的字符串 t，使得 word2 是 t 的前缀",
        "等价于：s 中字符频次可以覆盖 word2 的字符频次（即对每个字符 c，count_s(c) >= count_word2(c)）",
        "问题转化为：统计所有子串中，满足字符频次 ≥ word2 频次向量的个数"
      ],
      "Objective Function": "计数 —— 统计 word1 中满足条件的合法子字符串的数目",
      "Algorithmic Invariant": [
        "使用滑动窗口维护当前窗口内的字符频次分布",
        "定义 deficit 表示当前窗口缺失多少频次才能覆盖 word2（或用负值表示超额）",
        "当 deficit == 0 时，当前窗口满足条件；扩展右边界增加字符，收缩左边界减少字符",
        "可采用双指针法：右指针扩展引入字符，左指针在满足条件时收缩以统计最小有效前缀及其延伸",
        "由于目标是计数而非最优化，需确保每个合法子串被精确计数一次"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e5",
            "1e3",
            "1e2"
          ],
          "m": [
            "1e4",
            "1e2"
          ]
        },
        "字符集": [
          "小写字母",
          "大写字母",
          "数字",
          "混合字符"
        ],
        "是否有序": false,
        "是否循环": false,
        "是否多组输入": true,
        "是否在线": false,
        "约束变化": [
          "改为判定是否存在至少一个合法子串",
          "改为求最短/最长合法子串长度",
          "改为要求子串重排后 word2 是后缀",
          "改为 word2 是子序列而非前缀",
          "允许通配符匹配"
        ],
        "操作类型扩展": [
          "支持修改 word1 字符",
          "支持查询多个不同的 word2"
        ]
      }
    }
  },
  {
    "title": "Count Substrings That Can Be Rearranged to Contain a String II",
    "slug": "count-substrings-that-can-be-rearranged-to-contain-a-string-ii",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "两个字符串 word1 和 word2，其中 word1 是主串（长度 up to 1e6），word2 是模式串（长度 up to 1e4）",
        "constraints": [
          "word1.length ∈ [1, 10^6]",
          "word2.length ∈ [1, 10^4]",
          "字符集：仅小写英文字母 a-z"
        ]
      },
      "Core Constraint": {
        "description": "子字符串 s 是合法的，当且仅当它可以重排成某个字符串 t，使得 word2 是 t 的前缀。等价于：s 中包含 word2 的字符频次的超集。",
        "mathematical_form": "∀c∈[a-z], count_s(c) ≥ count_word2(c)"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计 word1 中满足合法条件的连续子字符串的数目"
      },
      "Algorithmic Invariant": {
        "invariant_type": "sliding window with frequency tracking",
        "rules": [
          "使用滑动窗口维护当前子串的字符频次计数",
          "定义 'valid' 状态为：当前窗口内每个字符频次都不小于 word2 中对应字符频次",
          "一旦窗口满足 valid 条件，则所有以该左端点开始、右端点 ≥ 当前位置的子串都合法 → 可累加贡献 (n - r)",
          "利用双指针推进：左指针收缩时更新频次，保持最小有效窗口性质",
          "可通过预处理 word2 的频次分布构造目标向量，用差值数组判断是否全 ≤ 0"
        ],
        "complexity_constraint": "必须实现 O(n) 时间复杂度解法，因内存和时间限制严格"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "data_size",
            "values": [
              "word1: 1e3 / 1e6",
              "word2: 1e2 / 1e4"
            ],
            "impact": "决定是否可用 O(n^2) 或必须线性解"
          },
          {
            "name": "character_set",
            "values": [
              "lowercase",
              "uppercase",
              "alphanumeric",
              "arbitrary unicode"
            ],
            "impact": "影响频次数组大小与哈希策略"
          },
          {
            "name": "input_structure",
            "values": [
              "linear string",
              "circular string",
              "2D grid of characters"
            ],
            "impact": "改变子串定义方式"
          },
          {
            "name": "objective_variation",
            "values": [
              "count valid substrings",
              "find shortest/longest valid substring",
              "determine existence"
            ],
            "impact": "改变目标函数类型"
          },
          {
            "name": "constraint_variation",
            "values": [
              "exact prefix match",
              "prefix up to permutation and deletion",
              "allow wildcards in word2"
            ],
            "impact": "改变合法性判定规则"
          },
          {
            "name": "query_mode",
            "values": [
              "single query",
              "multiple queries on same word1",
              "online insertion/deletion"
            ],
            "impact": "决定是否需支持动态结构"
          },
          {
            "name": "output_requirement",
            "values": [
              "return count only",
              "return all valid substrings",
              "return indices"
            ],
            "impact": "影响空间复杂度要求"
          }
        ]
      }
    }
  },
  {
    "title": "Length of the Longest Increasing Path",
    "slug": "length-of-the-longest-increasing-path",
    "schema": {
      "Input Structure": [
        "二维整数数组 coordinates[1..n], 其中 coordinates[i] = [x_i, y_i]",
        "每个点 (x_i, y_i) 是平面上互不相同的整数坐标",
        "0 <= x_i, y_i <= 1e9",
        "给定索引 k，满足 0 <= k < n"
      ],
      "Core Constraint": [
        "上升序列要求：对于任意相邻点对 (x_i, y_i) 和 (x_j, y_j)，必须满足 x_i < x_j 且 y_i < y_j",
        "所有点必须来自输入数组 coordinates",
        "路径必须包含指定的第 k 个点 coordinates[k]"
      ],
      "Objective Function": "求包含 coordinates[k] 的最长上升路径的长度（即最大点数 m）",
      "Algorithmic Invariant": [
        "基于偏序关系的拓扑结构：若点 i 可转移到点 j，则必有 x_i < x_j 且 y_i < y_j",
        "动态规划状态定义：dp[i] 表示以点 i 为结尾的最长上升路径长度",
        "状态转移满足：dp[j] = max(dp[j], dp[i] + 1) 当且仅当 (x_i < x_j) 且 (y_i < y_j)",
        "最终答案限制在所有能到达点 k 且被点 k 到达的连通路径中取最大值 —— 实际上需以点 k 为中心进行正反向 DP 或 DAG 上最长路约束"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5 → 可调整至 1e3（暴力可过）或更高（需优化）",
        "值域范围": "x_i, y_i ∈ [0, 1e9] → 可压缩至 ≤1e5（支持离散化）",
        "是否有序": "coordinates 无序 → 可设定为按 x 或 y 预排序",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "目标函数变化": [
          "改为计数：统计包含 coordinates[k] 的最长上升路径的数量",
          "改为判定：是否存在长度 ≥ L 且包含 coordinates[k] 的上升路径",
          "构造方案：输出一条具体的最长路径"
        ],
        "约束变形": [
          "允许相等：改为非严格递增（x_i ≤ x_{i+1}, y_i ≤ y_{i+1}）",
          "一维退化：只考虑 x 坐标上升（变为 LIS 经典问题）",
          "三维扩展：coordinates[i] = [x_i, y_i, z_i]，推广到三维上升序列",
          "加入权重：每个点有权重，求最大权重和而非长度"
        ],
        "数据流化": "静态批量输入 → 动态添加点，在线查询包含某点的当前最长上升路径长度"
      }
    }
  },
  {
    "title": "Count of Substrings Containing Every Vowel and K Consonants I",
    "slug": "count-of-substrings-containing-every-vowel-and-k-consonants-i",
    "schema": {
      "Input Structure": [
        "字符串 word[1..n]，其中 n ∈ [5, 250]",
        "字符集为小写英文字母",
        "给定非负整数 k，满足 0 <= k <= n - 5"
      ],
      "Core Constraint": [
        "子字符串必须包含所有五个元音字母（'a', 'e', 'i', 'o', 'u'）至少一次",
        "子字符串中辅音字母的个数必须恰好等于 k",
        "元音与辅音互斥且覆盖所有字母：辅音 = 非元音的小写字母"
      ],
      "Objective Function": "计数 —— 统计满足条件的子字符串总数",
      "Algorithmic Invariant": [
        "滑动窗口可维护当前区间内各元音的出现频次和辅音总数",
        "若某一窗口已满足元音全包含，则可通过收缩左边界固定右端点来枚举合法起点",
        "辅音数具有单调性：扩展窗口时辅音数不减，可用于双指针推进"
      ],
      "Transformable Parameters": {
        "k 的取值范围": "0 <= k <= n - 5",
        "是否允许重复计数相同内容的不同位置": true,
        "元音集合是否可变": false,
        "字符串是否循环": false,
        "是否多组查询": false,
        "是否在线输入": false,
        "数据规模 n 的量级": "n <= 250，支持 O(n²) 解法",
        "输出形式": "仅需返回数量，无需构造具体子串"
      }
    }
  },
  {
    "title": "Count of Substrings Containing Every Vowel and K Consonants II",
    "slug": "count-of-substrings-containing-every-vowel-and-k-consonants-ii",
    "schema": {
      "Input Structure": {
        "type": "string",
        "description": "长度为 n 的字符串 word，其中 5 <= n <= 2 * 10^5",
        "element_type": "char",
        "charset": "lowercase English letters",
        "vowels": [
          "a",
          "e",
          "i",
          "o",
          "u"
        ],
        "consonants": "all other lowercase letters"
      },
      "Core Constraint": {
        "vowel_condition": "子字符串必须包含每个元音字母（a, e, i, o, u）至少一次",
        "consonant_condition": "子字符串中辅音字母的数量必须恰好等于 k",
        "dependency_structure": "元音覆盖是集合性约束（类似滑动窗口中的字符频次覆盖），辅音计数是数值约束，二者共同构成复合约束条件",
        "feasibility_threshold": "子字符串长度至少为 5（因需覆盖 5 个不同元音）"
      },
      "Objective Function": {
        "goal": "counting",
        "target": "满足以下两个条件的子字符串总数：\n1. 包含所有五个元音字母（每个至少一次）\n2. 恰好包含 k 个辅音字母"
      },
      "Algorithmic Invariant": {
        "primary_technique": "双指针 + 滑动窗口",
        "invariant_description": [
          "使用左指针 L 和右指针 R 枚举可能的子串右端点，维护以 R 结尾的所有有效左边界",
          "维护当前窗口内各元音的出现频次，以及辅音字母总数",
          "当某个位置 L 到 R 的子串首次满足元音全覆盖时，可确定从该 L 开始、在辅音数允许范围内向右扩展的合法区间",
          "辅音数可通过前缀和或实时统计维护，元音覆盖状态可用哈希表或位掩码表示",
          "若固定右端点，满足条件的左端点形成连续区间，则可用双指针避免重复计算"
        ],
        "monotonicity": "随着右指针右移，满足元音覆盖的最左位置单调不减；辅音数随窗口扩大而增加，具有单调性"
      },
      "Transformable Parameters": {
        "n_range": "5 <= n <= 2 * 10^5",
        "k_value": "0 <= k <= n - 5, 可调整为变量或范围查询",
        "vowel_set_size": "可推广至任意字符集合覆盖（如指定 m 个字符均出现）",
        "consonant_count_constraint": {
          "type": "exact",
          "possible_transforms": [
            "≤ k",
            "≥ k",
            "modular constraint (e.g., ≡ k mod m)"
          ]
        },
        "input_form": {
          "single_string": true,
          "multiple_queries": false,
          "online_input": false
        },
        "output_form": {
          "return_type": "integer count",
          "possible_extensions": [
            "输出所有符合条件的子字符串",
            "输出最长/最短满足条件的子字符串",
            "判断是否存在解"
          ]
        },
        "alphabet_structure": {
          "vowels_defined": true,
          "can_be_generalized": "将元音定义替换为任意给定字符集 S"
        },
        "data_modification": {
          "dynamic_updates": false,
          "supports_update_operations": false
        }
      }
    }
  },
  {
    "title": "Find the Key of the Numbers",
    "slug": "find-the-key-of-the-numbers",
    "schema": {
      "Input Structure": [
        "三个正整数 num1, num2, num3",
        "1 <= num1, num2, num3 <= 9999",
        "每个数字视为四位数（不足四位补前导0）"
      ],
      "Core Constraint": [
        "每一位的取值独立于其他位",
        "每位结果由三个数字对应位上的最小值决定",
        "前导零在最终输出时需去除，但处理过程中保留为四位结构"
      ],
      "Objective Function": "构造一个四位数 key，其第 i 位是 num1、num2、num3 第 i 位数字的最小值，并返回去掉前导零后的整数值",
      "Algorithmic Invariant": [
        "位间无依赖：每一位的计算可独立进行",
        "单调选择性：每位置取 min 操作具有确定性和局部最优性",
        "固定位宽对齐：所有输入统一扩展至4位，保证位对齐"
      ],
      "Transformable Parameters": {
        "n 的数量级": 3,
        "值域范围": "1 ~ 9999",
        "是否有序": false,
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "位数长度": 4,
        "聚合操作": "min",
        "输出形式": "整数（去除前导零）",
        "可变操作符": false,
        "可扩展维度": "从4位推广到k位",
        "输入个数": 3
      }
    }
  },
  {
    "title": "Convert Date to Binary",
    "slug": "convert-date-to-binary",
    "schema": "{\n  \"Input Structure\": [\n    \"字符串 date，长度为 10，格式为 'yyyy-mm-dd'\",\n    \"date[4] == date[7] == '-'\",\n    \"年份部分：整数范围 [1900, 2100]\",\n    \"月份部分：整数范围 [1, 12]\",\n    \"日期部分：整数范围 [1, 31]（根据实际月份有效）\",\n    \"输入保证为合法公历日期\"\n  ],\n  \"Core Constraint\": [\n    \"年、月、日三部分可独立解析为十进制整数\",\n    \"每部分转换为二进制表示时，不保留前导零\",\n    \"三部分的二进制字符串按 'year-month-day' 格式拼接\"\n  ],\n  \"Objective Function\": \"构造并返回一个字符串，表示原日期各部分的无前导零二进制形式，以 '-' 分隔\",\n  \"Algorithmic Invariant\": [\n    \"年、月、日三部分的转换相互独立（可分治处理）\",\n    \"整数到二进制字符串的转换过程是确定性且无歧义的（标准位运算或内置函数）\",\n    \"输出格式与输入结构保持字段对齐：第一段为年，第二段为月，第三段为日\"\n  ],\n  \"Transformable Parameters\": {\n    \"值域\": {\n      \"年份范围\": \"[1900, 2100]\",\n      \"月份范围\": \"[1, 12]\",\n      \"日期范围\": \"[1, 31]\"\n    },\n    \"输入格式变体\": [\n      \"是否允许带前导零的二进制输出（如 '1' → '001'）\",\n      \"输入分隔符是否可变（如 '/' 或 '.' 替代 '-'）\",\n      \"是否支持其他历法格式（如 dd-mm-yyyy）\"\n    ],\n    \"数据规模\": {\n      \"输入字符串长度固定为 10\",\n      \"最多处理三位十进制数（年为四位数）\"\n    },\n    \"是否多组数据\": false,\n    \"是否在线\": false,\n    \"输出要求\": [\n      \"是否仅返回某一部分的二进制（如只返回年的二进制）\",\n      \"是否要求统计总二进制位数\",\n      \"是否要求最短表示或压缩编码\"\n    ]\n  }\n}"
  },
  {
    "title": "Find the Sequence of Strings Appeared on the Screen",
    "slug": "find-the-sequence-of-strings-appeared-on-the-screen",
    "schema": {
      "Input Structure": {
        "type": "string",
        "name": "target",
        "length_range": [
          1,
          400
        ],
        "element_type": "lowercase_letter",
        "initial_state": "empty_string"
      },
      "Core Constraint": {
        "allowed_operations": [
          {
            "operation": "append",
            "character": "a",
            "condition": "always_allowed"
          },
          {
            "operation": "increment_last_char",
            "mapping": "c -> next(c); z -> a",
            "condition": "string_non_empty"
          }
        ],
        "operation_dependency": "can_only_start_with_append",
        "transition_graph": "each_step_leads_to_unique_string_state"
      },
      "Objective Function": "construct_sequence",
      "Algorithmic Invariant": {
        "principle": "greedy_construction_by_prefix_progression",
        "invariant_rules": [
          "every_prefix_of_target_must_appear_in_result",
          "for_each_position_i,_all_strings_up_to_target[0:i+1]_are_constructed_before_proceeding",
          "when_building_target[i],_only_use_operation_2_if_current_last_char_is_less_than_target[i]",
          "if_current_last_char_is_greater_than_target[i],_must_first_backtrack_via_cyclic_wrap_(z->a)_or_rebuild_suffix"
        ],
        "monotonicity": "the_length_of_current_string_is_monotonically_non-decreasing",
        "state_uniqueness": "no_duplicate_strings_in_output_sequence"
      },
      "Transformable Parameters": {
        "n_value_range": [
          1,
          400
        ],
        "char_set": "lowercase_english",
        "initial_char": "a",
        "cycle_behavior": "z_wraps_to_a",
        "operations": {
          "op1_append_fixed_char": true,
          "op2_increment_last_with_wrap": true
        },
        "input_form": "single_target_string",
        "output_form": "list_of_strings_in_construction_order",
        "online_offline": "offline",
        "multi_query": false,
        "allow_modification": false,
        "constraint_variants": [
          "change_base_char_from_a",
          "allow_arbitrary_append_character",
          "add_delete_operation",
          "restrict_max_keypresses",
          "reverse_objective:_given_sequence,_recover_target"
        ]
      }
    }
  },
  {
    "title": "Minimize Connected Groups by Inserting Interval",
    "slug": "minimize-connected-groups-by-inserting-interval",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度的较小值决定，且仅当该值大于 H[i] 时才能储水",
      "Objective Function": "计算整个数组中能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max；若 left_max ≤ right_max，则左指针当前位置的储水量可由 left_max - H[left] 确定，反之右指针位置可确定；移动较矮一侧指针不会影响已确定区域的正确性",
      "Transformable Parameters": [
        "n 的数量级：1e3 / 1e5 / 1e7（影响解法选择）",
        "H[i] 是否允许负值（变形为带坑地形）",
        "输入是否为二维矩阵（2D 接雨水问题）",
        "是否循环数组（环形接雨水）",
        "是否支持在线更新（加入单点修改操作）",
        "是否多组查询（静态结构下多次询问子区间接水量）",
        "输出形式：总和 / 每个位置的具体储水量 / 方案构造"
      ]
    }
  },
  {
    "title": "Premier League Table Ranking II",
    "slug": "premier-league-table-ranking-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "size": "n",
        "properties": [
          "one-dimensional array H[1..n]",
          "H[i] ≥ 0, representing bar heights",
          "unordered or with arbitrary distribution"
        ]
      },
      "Core Constraint": {
        "description": "The water trapped at each position depends on the minimum of the maximum height to its left and right.",
        "key_conditions": [
          "Local trapping capacity is determined by global left and right maxima",
          "Left and right boundary constraints are independent but must be jointly consistent",
          "No trapping possible without both higher bars on either side"
        ]
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total amount of trapped rainwater",
        "output_semantics": "aggregate volume over all positions"
      },
      "Algorithmic Invariant": {
        "invariant_description": "Two pointers (L, R) move toward each other while maintaining known contribution regions.",
        "rules": [
          "Maintain maxLeft = max(H[1..L]) and maxRight = max(H[R..n])",
          "If maxLeft ≤ maxRight, then the water at L is fully determined by maxLeft",
          "Move L → L+1 if maxLeft ≤ maxRight; otherwise move R ← R-1",
          "Correctness of already-passed region is preserved throughout"
        ],
        "optimality_guarantee": "Each step safely fixes one position's contribution without backtracking"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative_heights"
            ],
            "impact": "changes physical interpretation; may disable trapping logic"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D",
              "circular_array"
            ],
            "impact": "transforms into 2D trapping or ring-shaped terrain models"
          },
          {
            "name": "query_mode",
            "options": [
              "offline_batch",
              "online_queries",
              "dynamic_updates"
            ],
            "impact": "requires segment trees or sqrt decomposition for updates"
          },
          {
            "name": "output_granularity",
            "options": [
              "total_sum",
              "per_position_contribution"
            ],
            "impact": "affects space complexity and output format"
          },
          {
            "name": "data_streaming",
            "options": [
              "static_input",
              "streaming_input"
            ],
            "impact": "may require approximation or sliding window variants"
          },
          {
            "name": "multiple_test_cases",
            "options": [
              true,
              false
            ],
            "impact": "affects initialization overhead and code structure"
          }
        ]
      }
    }
  },
  {
    "title": "Select Cells in Grid With Maximum Score",
    "slug": "select-cells-in-grid-with-maximum-score",
    "schema": {
      "Input Structure": "二维矩阵 grid[1..m][1..n]，其中每个元素为正整数；每行可视为一个候选集合，且每行至少有一个元素。",
      "Core Constraint": "选中的单元格不能在同一行，且所有选中值必须互不相同；即：从不同行选取的数值构成一个无重复元素的集合。",
      "Objective Function": "最大化所选单元格值的总和",
      "Algorithmic Invariant": "每一行至多贡献一个值；对于相同的数值，只能选择一次，因此全局上需对数值去重并决策其最优来源行；贪心地优先考虑大值是否可被安全选中（即存在某行包含该值且该行尚未被占用）",
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": "原始范围小（≤10），支持状态压缩或枚举子集；可扩展至更大规模以要求更优算法",
          "值域范围": "当前值域 [1,100]，可调整为负数或更大范围以改变去重策略"
        },
        "约束条件": {
          "是否允许同一数值多次使用": "原题不允许；可改为允许 → 变为简单按行取最大值求和",
          "是否限制选取个数": "原题不限；可增加‘恰好选 k 个’等约束",
          "是否允许多个单元格同行": "原题禁止；反转此条件可变为仅限制值唯一性"
        },
        "输入输出形式": {
          "是否有序": "每行内部无序；可设定每行已排序以引导贪心方向",
          "是否多组数据": "单组输入；可扩展为多测"
        },
        "数据流化": {
          "是否在线": "离线处理；可设计动态添加行/修改行后的最大得分查询"
        },
        "隐藏条件": {
          "显式去重": "值唯一性是显性约束；可隐式化为‘任意两选中元素满足 f(a,b) ≠ 0’等形式"
        }
      }
    }
  },
  {
    "title": "Maximum Score of Non-overlapping Intervals",
    "slug": "maximum-score-of-non-overlapping-intervals",
    "schema": {
      "Input Structure": {
        "type": "二维整数数组",
        "description": "intervals[1..n]，其中 intervals[i] = [l_i, r_i, weight_i]",
        "constraints": [
          "每个区间包含起点 l_i、终点 r_i 和权重 weight_i",
          "1 <= n <= 5 * 10^4",
          "1 <= l_i <= r_i <= 10^9",
          "1 <= weight_i <= 10^9",
          "区间下标从 0 开始"
        ]
      },
      "Core Constraint": {
        "description": "最多选择 4 个互不重叠的区间；两个区间若共享边界（左或右）即视为重叠",
        "key_properties": [
          "区间之间必须严格不重叠（包括端点）",
          "选择的区间数量上限为 4",
          "目标是最大化权重和的同时满足字典序最小的下标输出"
        ]
      },
      "Objective Function": {
        "goal": "最大化所选区间的权重总和",
        "secondary_goal": "在得分最大的前提下，返回字典序最小的下标数组",
        "output_type": "至多包含 4 个下标的整数数组，表示选中区间的原始索引"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "按右端点排序后，可通过动态规划维护前 i 个区间中选取 k (k <= 4) 个不重叠区间的最优解",
          "状态转移时利用二分查找寻找最后一个与当前区间不重叠的区间",
          "每一步保证局部解的字典序最小性可通过记录路径并比较实现",
          "贪心不可行，但 DP 状态具有最优子结构和无后效性"
        ],
        "main_algorithm": "动态规划 + 二分查找",
        "auxiliary_techniques": [
          "按右端点升序排序（主键），权重降序/下标升序为辅键以支持字典序控制",
          "状态定义：dp[i][k] 表示考虑前 i 个区间中选 k 个的最大得分及其对应下标序列",
          "路径回溯维护字典序最小性"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "最大可选区间数",
            "original_value": 4,
            "possible_values": [
              "k（一般化为参数）",
              "1~5"
            ]
          },
          {
            "name": "是否要求字典序最小",
            "original_value": true,
            "possible_transformations": [
              "改为任意一组最优解",
              "改为字典序最大",
              "输出所有最优解"
            ]
          },
          {
            "name": "输入维度",
            "original_value": "一维区间",
            "possible_extensions": [
              "二维矩形不重叠选择",
              "树上路径选择"
            ]
          },
          {
            "name": "重叠定义",
            "original_value": "共享端点即重叠",
            "possible_revisions": [
              "允许端点接触",
              "仅内部重叠才算"
            ]
          },
          {
            "name": "数据规模",
            "original_value": "n <= 5e4",
            "scalability": [
              "n <= 1e3（暴力可行）",
              "n <= 1e5（需优化二分+DP）"
            ]
          },
          {
            "name": "是否在线输入",
            "original_value": false,
            "possible_modes": [
              "离线处理",
              "在线流式添加区间"
            ]
          },
          {
            "name": "权重类型",
            "original_value": "正整数",
            "possible_variants": [
              "可为负",
              "全为 1（转为计数问题）"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Remove Methods From Project",
    "slug": "remove-methods-from-project",
    "schema": {
      "Input Structure": [
        "给定整数 n，表示方法总数，编号为 0 到 n-1",
        "给定整数 k，表示初始有 bug 的方法编号",
        "给定二维整数数组 invocations，其中 invocations[i] = [a_i, b_i] 表示方法 a_i 调用了方法 b_i",
        "调用关系构成有向图：节点为方法，边 a → b 表示方法 a 调用方法 b",
        "n <= 1e5, 边数 <= 2e5"
      ],
      "Core Constraint": [
        "可疑方法定义为：方法 k 及其在调用图中从 k 出发可达的所有节点（直接或间接调用）",
        "一组方法可以被移除的条件是：该组之外没有任何方法调用这组中的任意一个方法（即：入度来自外部的边必须为 0）",
        "若无法移除所有可疑方法，则不移除任何方法（全有或全无策略）"
      ],
      "Objective Function": [
        "返回移除所有可疑方法后剩余的方法集合",
        "如果不能安全移除所有可疑方法（即存在非可疑方法调用可疑方法），则返回完整方法集",
        "目标函数类型：构造方案（输出剩余节点集合）"
      ],
      "Algorithmic Invariant": [
        "可疑方法集合 S 在调用图中是从 k 出发的正向可达闭包（DFS/BFS 不变量）",
        "可移除性判定不变量：S 中所有节点的前驱（调用者）必须全部属于 S 自身（即：不存在边 u → v 满足 u ∉ S 且 v ∈ S）",
        "若该不变量成立，则 S 可安全移除；否则保留全部节点"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5，适合 O(n + m) 图遍历",
        "图的结构形式": [
          "有向图（调用方向 a → b）",
          "可变换为无向图（变形题：忽略调用方向）",
          "可变为 DAG 或允许环（如示例3存在环）"
        ],
        "是否允许多个初始 bug 方法": "当前单源 k，可扩展为多个初始可疑节点",
        "移除策略": [
          "全有或全无（当前设定）",
          "可变体：允许部分移除、最小代价移除等"
        ],
        "输入形式": [
          "静态一次性输入（当前）",
          "可改为在线边插入 / 删除调用关系（动态图版本）"
        ],
        "输出要求": [
          "返回剩余方法列表（当前）",
          "可改为返回是否可移除、最大可移除子集、移除顺序等"
        ],
        "约束条件变化": [
          "当前：只有当可疑方法不被外部调用时才可移除",
          "变形：允许替换调用、添加代理层后再移除"
        ]
      }
    }
  },
  {
    "title": "Maximum Number of Moves to Kill All Pawns",
    "slug": "maximum-number-of-moves-to-kill-all-pawns",
    "schema": {
      "Input Structure": {
        "board_size": "50 x 50 grid",
        "knight_position": "tuple (kx, ky), where 0 <= kx, ky <= 49",
        "pawns_positions": "list of tuples positions[i] = [xi, yi], each representing a pawn's coordinate on the board",
        "constraints": [
          "1 <= len(positions) <= 15",
          "positions are distinct and do not overlap with knight's initial position"
        ]
      },
      "Core Constraint": {
        "movement_rule": "knight moves in L-shape: (±2, ±1) or (±1, ±2)",
        "capture_rule": "only the selected pawn is captured; others may be jumped over but not removed",
        "turn_based_play": "Alice and Bob alternate turns, Alice starts",
        "objective_conflict": "Alice aims to maximize total move count; Bob aims to minimize it",
        "perfect_information": "both players have full knowledge of the board state and act optimally"
      },
      "Objective Function": "maximize the total number of knight moves across all turns under optimal adversarial play",
      "Algorithmic Invariant": {
        "state_space_finiteness": "number of pawns ≤ 15 ⇒ state can be represented by bitmask",
        "optimal_substructure": "game outcome from current knight position and remaining pawns depends only on subgames",
        "minimax_principle": "each player chooses next pawn to capture that leads to best outcome under opponent's optimal response",
        "precomputed_distances": "shortest knight move distances between any two squares on 50x50 grid can be precomputed via BFS once",
        "position_independence": "minimum steps to capture a pawn depend only on knight’s current location and target, not path history"
      },
      "Transformable Parameters": {
        "board_dimensions": "variable size (e.g., N x M); affects knight reachability and distance computation",
        "number_of_pawns": "can scale up (with efficient encoding) or down; currently small (≤15) enabling DP over subsets",
        "initial_knight_position": "can vary; influences first-move cost",
        "movement_rules": "can generalize to other chess pieces (e.g., queen, king), changing transition graph",
        "player_objectives": "can switch roles (e.g., both cooperate, or more than two players)",
        "online_arrival_of_pawns": "pawns appear dynamically instead of being given upfront",
        "obstacles_or_blocking": "non-target pawns block movement (currently they don’t)",
        "move_cost_function": "instead of step count, use weighted sum, fuel cost, etc.",
        "output_requirement": "return sequence of moves vs. just total count",
        "multiple_knights": "extension to team-based variants"
      }
    }
  },
  {
    "title": "Minimum Number of Valid Strings to Form Target I",
    "slug": "minimum-number-of-valid-strings-to-form-target-i",
    "schema": {
      "Input Structure": [
        "字符串数组 words[1..m]，其中每个 words[i] 是一个小写英文字母组成的字符串",
        "目标字符串 target，长度为 n，由小写英文字母组成",
        "1 <= m <= 100, 1 <= |words[i]| <= 5000, sum(|words[i]|) <= 10^5, 1 <= n <= 5000"
      ],
      "Core Constraint": [
        "有效字符串定义为：是 words 中任意字符串的前缀",
        "只能通过连接有效字符串构造 target",
        "构造必须从左到右完全覆盖 target，无跳转或重叠外的拼接"
      ],
      "Objective Function": [
        "最小化连接的有效字符串数量",
        "若无法构造 target，则返回 -1"
      ],
      "Algorithmic Invariant": [
        "动态规划状态 dp[i] 表示构造 target 前 i 个字符所需的最少有效字符串数",
        "状态转移：对于每个位置 i，枚举所有可能的前缀长度 l，检查 target[i-l+1:i] 是否是某个 words[j] 的前缀",
        "若存在匹配，则 dp[i] = min(dp[i], dp[i-l] + 1)，前提是 dp[i-l] 已可达",
        "初始状态 dp[0] = 0（空串代价为 0），其余初始化为无穷大",
        "贪心性质不成立，但最优子结构和重叠子问题支持 DP"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可扩展至 1e5（需优化匹配方式）",
        "值域": "字符集可变为大写字母、数字或其他有限字符集",
        "是否有序": "words 数组顺序无关（因取任意字符串前缀）",
        "是否循环": "可改编为环形 target 或循环前缀匹配",
        "是否多组输入": "可设计为多组测试用例",
        "是否在线": "可改为在线查询 target，预处理 words 的所有前缀建立 Trie",
        "有效字符串定义变化": "可改为后缀、子串、子序列等",
        "连接限制": "可增加同一 word 不能重复使用，或限制使用次数",
        "输出形式": "可要求输出方案路径而非仅最小数量"
      }
    }
  },
  {
    "title": "Find a Safe Walk Through a Grid",
    "slug": "find-a-safe-walk-through-a-grid",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"2D grid\",\n    \"dimensions\": \"m x n\",\n    \"values\": \"binary (0 or 1)\",\n    \"start_position\": [0, 0],\n    \"end_position\": [m - 1, n - 1],\n    \"initial_health\": \"positive integer 'health'\",\n    \"movement\": \"4-directional (up/down/left/right)\"\n  },\n  \"Core Constraint\": {\n    \"health_must_remain_positive\": true,\n    \"unsafe_cell_penalty\": \"grid[i][j] = 1 reduces health by 1\",\n    \"safe_cell\": \"grid[i][j] = 0 has no effect\",\n    \"path_feasibility\": \"a path is valid only if health > 0 at every step and at destination\"\n  },\n  \"Objective Function\": {\n    \"type\": \"decision problem\",\n    \"goal\": \"determine whether there exists a path from (0,0) to (m-1,n-1) such that health remains strictly positive throughout\"\n  },\n  \"Algorithmic Invariant\": {\n    \"state_representation\": \"[i, j, h] where h is remaining health; state space is bounded\",\n    \"monotonicity_in_health\": \"lower health values dominate higher ones in same position (if reachable with lower health, higher is redundant)\",\n    \"BFS_with_pruning\": \"visited[i][j] can be pruned if current health <= previously recorded health at (i,j)\",\n    \"invariant_property\": \"once a state (i, j, h) is explored, any future occurrence with equal or worse health can be discarded\"\n  },\n  \"Transformable Parameters\": {\n    \"grid_dimensions\": {\n      \"m\": \"1 <= m <= 50\",\n      \"n\": \"1 <= n <= 50\",\n      \"total_cells\": \"2 <= m * n <= 2500\"\n    },\n    \"health_value\": {\n      \"range\": \"1 <= health <= m + n\"\n    },\n    \"grid_values\": {\n      \"domain\": \"binary {0,1}\",\n      \"possible_extensions\": [\n        \"non-negative integers (generalized damage)\",\n        \"negative values (healing cells)\",\n        \"floating-point (real-valued health change)\"\n      ]\n    },\n    \"input_type\": {\n      \"single_instance\": true,\n      \"multi_query\": false,\n      \"online_updates\": false\n    },\n    \"movement_rules\": {\n      \"directions\": 4,\n      \"diagonal_allowed\": false,\n      \"teleportation\": false\n    },\n    \"termination_condition\": {\n      \"must_end_with_positive_health\": true,\n      \"alternative_objectives\": [\n        \"minimize required initial health (optimization variant)\",\n        \"count number of safe paths (counting variant)\",\n        \"find shortest safe path (constrained shortest path)\"\n      ]\n    },\n    \"extensions\": [\n      \"time-dependent grid (dynamic obstacles)\",\n      \"partial observability (fog of war)\",\n      \"action costs (e.g., movement also consumes health)\"\n    ]\n  }\n}"
  },
  {
    "title": "Minimum Number of Valid Strings to Form Target II",
    "slug": "minimum-number-of-valid-strings-to-form-target-ii",
    "schema": {
      "Input Structure": [
        "字符串数组 words[1..m]，其中每个 words[i] 是一个小写英文字母组成的字符串",
        "目标字符串 target[1..n]，由小写英文字母组成",
        "所有 words[i] 的总长度不超过 10^5",
        "1 <= m <= 100, 1 <= n <= 5 * 10^4, 每个 words[i] 长度 <= 5 * 10^4"
      ],
      "Core Constraint": [
        "有效字符串定义为：words 中任意字符串的前缀（包括空串以外的所有前缀）",
        "只能通过连接有效字符串构造 target",
        "构造必须从左到右连续覆盖 target 的字符",
        "同一个 word 可重复使用，且可取其任意长度前缀"
      ],
      "Objective Function": [
        "最小化连接的有效字符串数量",
        "若无法完整构造 target，则返回 -1"
      ],
      "Algorithmic Invariant": [
        "动态规划状态 dp[i] 表示构造 target 前 i 个字符所需的最少有效字符串数",
        "状态转移：对每个位置 i，枚举所有可能的前缀长度 l，检查 target[i-l+1..i] 是否是某个 word 的前缀",
        "若存在这样的前缀，则 dp[i] = min(dp[i], dp[i-l] + 1)，前提是 dp[i-l] 已可达",
        "初始状态 dp[0] = 0（空串代价为 0），其余初始化为无穷大",
        "贪心不可行，但子结构最优性成立，适合 DP"
      ],
      "Transformable Parameters": {
        "n 的数量级": "target.length ∈ [1, 5*10^4]",
        "值域": "仅限小写英文字母 a-z",
        "是否有序": "words 数组顺序无关（集合语义）",
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "可变约束点": [
          "改为最大化可拼接段数（在固定划分下）",
          "限制每个 word 最多使用一次",
          "要求输出具体方案路径",
          "变为二维字符网格上的前缀匹配（如 Trie + 网格行走）",
          "支持修改操作（在线添加 word 或更新 target）",
          "判定是否存在恰好 k 段的方案（计数类变形）",
          "将 '前缀' 改为 '子串' 或 '后缀'（改变匹配模式）"
        ]
      }
    }
  },
  {
    "title": "Final Array State After K Multiplication Operations II",
    "slug": "final-array-state-after-k-multiplication-operations-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "length_range": [
          1,
          10000
        ],
        "value_range": [
          1,
          1000000000
        ],
        "properties": [
          "可重复元素",
          "无序",
          "非负整数"
        ]
      },
      "Core Constraint": {
        "operation_constraint": "每次操作必须选择当前数组中的最小值，若存在多个则选择最前面的一个",
        "update_rule": "选中的元素 x 被替换为 x * multiplier",
        "sequential_dependency": "后续操作依赖前一步的修改结果，状态持续演化",
        "determinism": "操作过程是确定性的：最小值定义明确（值最小且索引最前）"
      },
      "Objective Function": {
        "goal": "构造最终数组",
        "output_form": "返回执行 k 次操作并取余后的完整数组",
        "post_processing": "每个元素对 10^9 + 7 取余",
        "function_type": "构造方案"
      },
      "Algorithmic Invariant": {
        "invariant_description": "优先队列（最小堆）中维护 (值, 原始索引) 对，保证每次能快速取出满足‘最小值且最前’条件的元素",
        "heap_property": "堆顶始终代表当前全局最优选择（按值优先，索引次之）",
        "lazy_update_rationale": "直接模拟 k 次操作不可行（k 高达 1e9），但 multiplier ≥ 1 且初始值 ≥ 1，导致数值增长迅速，实际不同轮次的操作会很快集中到少数几个位置",
        "convergence_behavior": "由于乘法增长指数级，较小的数会被反复选取直到其增长超过其他元素，形成‘热点元素’序列，可用堆驱动状态转移模拟"
      },
      "Transformable Parameters": {
        "k_magnitude": "k 的数量级可变（如：小规模 k ≤ 1e4 vs 大规模 k ≤ 1e9）",
        "multiplier_value": "multiplier 是否等于 1（退化为恒等变换）、>1 或 <1（分数情况需扩展）",
        "modulo_enabled": "是否需要取模；模数是否固定（如 1e9+7）或可变",
        "input_order_dependence": "是否要求保留‘最前面’的语义（稳定最小值选择）",
        "data_streaming": "是否在线输入 nums 元素（流式场景）",
        "operation_type_variation": "将乘法替换为加法、幂运算等（改变更新规则）",
        "output_requirement": "是否只返回最大值/最小值/和，而非整个数组",
        "multiple_queries": "多组 k 和 multiplier 查询同一初始数组"
      }
    }
  },
  {
    "title": "Final Array State After K Multiplication Operations I",
    "slug": "final-array-state-after-k-multiplication-operations-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "formal": "一维数组 nums[1..n]",
        "element_type": "整数",
        "constraints": [
          "nums.length ∈ [1, 100]",
          "nums[i] ∈ [1, 100]",
          "k ∈ [1, 10]",
          "multiplier ∈ [1, 5]"
        ],
        "order_matters": true,
        "duplicates_allowed": true
      },
      "Core Constraint": {
        "description": "每次操作必须定位全局最小值，若有多个则取最前面的（最小索引），并立即更新其值。更新后的元素可能再次成为后续操作的候选。",
        "key_insight": "局部最小选择具有贪心可解性：每一步的最优选择不会影响整体最终结果的构造路径；但由于值被修改后可能重新进入竞争，需动态维护候选集。",
        "dependency": "前后操作强依赖：当前状态由前一次修改决定，不可并行或跳步"
      },
      "Objective Function": {
        "type": "constructive",
        "goal": "返回执行 k 次操作后的最终数组",
        "output_form": "完整的 nums 数组（保持原始顺序）"
      },
      "Algorithmic Invariant": {
        "invariant": "在任意时刻，下一次操作的目标元素是未被锁定的、值最小且索引最小的元素。",
        "data_structure_support": "使用优先队列（最小堆）维护 (value, index) 对，确保 O(log n) 时间内获取目标元素。",
        "update_rule": "每次取出堆顶元素进行乘法更新后，重新插入新值；若原位置已被覆盖多次，则旧条目通过懒删除或版本控制忽略。",
        "correctness_guarantee": "由于每次严格选择最小值中最靠前的，且更新只影响单个位置，堆结构能正确反映下一状态"
      },
      "Transformable Parameters": {
        "n_range": "[1, 100] → 可扩展至 1e5（推动使用高效数据结构）",
        "k_range": "[1, 10] → 可增大至 1e5（引入懒传播或数学优化）",
        "multiplier_value": "≥1 整数 → 可变为分数或负数（改变单调性）",
        "value_domain": "正整数 → 允许负数或零（影响最小值定义与乘积行为）",
        "operation_semantics": "x * multiplier → 可改为 x + adder 或自定义函数 f(x)",
        "input_mode": "离线一次性输入 → 在线流式操作请求",
        "query_type": "仅最终数组 → 增加中间状态查询或多组独立测试用例",
        "constraint_visibility": "显式给出 k → 隐式终止条件（如直到所有值 ≥ T）"
      }
    }
  },
  {
    "title": "Premier League Table Ranking",
    "slug": "premier-league-table-ranking",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the distance between their indices and the minimum of their heights.",
        "key_insight": "To maximize the area, one must balance wide spacing with tall boundaries; local decisions can be guided by comparing left and right boundary heights."
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "the amount of water that can contain between any two lines"
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers start from both ends and move inward. At each step, the pointer with smaller height is moved because the area is limited by the shorter line. Moving the taller side cannot increase the area without risking reduced width and no gain in height bound.",
        "properties": [
          "Left pointer L starts at 0, right pointer R starts at n-1",
          "If height[L] < height[R], then advance L: L++",
          "Else, advance R: R--",
          "The maximum area encountered during traversal is globally optimal"
        ]
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 10^5",
        "value_domain": "0 <= height[i] <= 10^4",
        "ordering": "unsorted",
        "modifiability": false,
        "input_type": "offline, single batch",
        "output_requirement": "single integer: maximum area",
        "extensions": [
          "2D version: matrix of heights",
          "Online queries: add/remove lines dynamically",
          "Variant objective: minimize area above water (inverse)",
          "Constraint change: require contiguous segment of at least k units",
          "Multiple containers: partition into k segments to maximize sum of areas"
        ]
      }
    }
  },
  {
    "title": "Check if Two Chessboard Squares Have the Same Color",
    "slug": "check-if-two-chessboard-squares-have-the-same-color",
    "schema": {
      "Input Structure": [
        "两个长度为2的字符串 coordinate1 和 coordinate2",
        "字符串格式：第一位是字符 'a' 到 'h'（列），第二位是字符 '1' 到 '8'（行）",
        "表示8x8国际象棋棋盘上的坐标"
      ],
      "Core Constraint": [
        "棋盘为标准8x8国际象棋棋盘，左上角'a1'为黑色，颜色按行列交替分布",
        "一个格子的颜色由其行列坐标的奇偶性共同决定",
        "颜色相同当且仅当两个坐标对应的 (col_index + row_index) 的奇偶性相同"
      ],
      "Objective Function": "判定两个给定坐标方格的颜色是否相同（返回布尔值）",
      "Algorithmic Invariant": [
        "格子颜色仅取决于 (column_letter - 'a') + (row_digit - '1') 的奇偶性",
        "两个位置颜色相同的充要条件是它们的 (col + row) 坐标和同奇同偶",
        "无需显式建图或模拟着色，可通过数学奇偶性直接判断"
      ],
      "Transformable Parameters": {
        "棋盘大小": [
          "8x8（固定）",
          "可推广至 n x n（如参数化）"
        ],
        "坐标格式": [
          "字母+数字（如 a1）",
          "可改为索引对 (i,j) 或其他编码"
        ],
        "颜色规则": [
          "国际象棋交替着色",
          "可替换为其他着色模式（如模3染色）"
        ],
        "输入形式": [
          "两个字符串",
          "可扩展为多个坐标批量判断"
        ],
        "输出目标": [
          "判断颜色是否相同",
          "可变为：求颜色、计数同色对、构造同色路径等"
        ],
        "数据范围": [
          "固定 8x8",
          "可扩展至更大棋盘或动态规模"
        ],
        "是否在线": [
          "单次查询",
          "可设计为连续坐标对的在线判定"
        ]
      }
    }
  },
  {
    "title": "Find the Largest Palindrome Divisible by K",
    "slug": "find-the-largest-palindrome-divisible-by-k",
    "schema": {
      "Input Structure": [
        "正整数 n：表示目标整数的位数（1 <= n <= 10^5）",
        "正整数 k：表示整除约束（1 <= k <= 9）",
        "输出为字符串形式的最大 n 位整数"
      ],
      "Core Constraint": [
        "所求整数 x 必须是回文数（从左到右与从右到左读一致）",
        "x 必须不含前导零",
        "x 必须能被 k 整除",
        "x 是 n 位十进制正整数（即范围在 [10^(n-1), 10^n - 1] 内）"
      ],
      "Objective Function": "构造并返回最大的满足条件的 n 位 k 回文数（以字符串形式）",
      "Algorithmic Invariant": [
        "回文结构具有对称性：只需确定前半部分（ceil(n/2) 位），后半部分可唯一镜像生成",
        "从高位向低位贪心构造前半部分，一旦某一位无法满足后续存在合法回文且被 k 整除，则回溯或剪枝",
        "利用模运算性质维护当前构造前缀模 k 的余数，用于判断是否存在补全方式使得整体 ≡ 0 (mod k)",
        "最优解具有字典序最大性，支持贪心逐位确定"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^5（大位数需高效构造）",
        "k 的取值范围": "1 <= k <= 9（小常数，可预处理模意义下状态）",
        "是否要求最大": true,
        "目标函数变体": [
          "最小 n 位 k 回文数",
          "计数：有多少个 n 位 k 回文数",
          "判定：是否存在 n 位 k 回文数"
        ],
        "输入形式": "单组输入，离线处理",
        "输出形式": "字符串形式输出（避免整数溢出）",
        "回文类型扩展": [
          "允许前导零（仅理论分析用）",
          "非十进制下的 k 回文数"
        ],
        "约束变化": [
          "改为 x ≡ r (mod k)",
          "k 为多位数（如 k <= 1000），增加模运算复杂度",
          "加入额外约束（如各位数字和也为 k 的倍数）"
        ],
        "数据流化": false,
        "是否在线": false,
        "是否多组数据": false
      }
    }
  },
  {
    "title": "Maximum XOR Score Subarray Queries",
    "slug": "maximum-xor-score-subarray-queries",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_n": "n",
        "value_range": "[0, 2^31 - 1]",
        "is_ordered": false,
        "queries": {
          "type": "2D array",
          "dimension": "q x 2",
          "query_type": "range_query",
          "query_range": "[l_i, r_i]",
          "constraint": "0 <= l_i <= r_i <= n - 1"
        }
      },
      "Core Constraint": {
        "operation_rule": "子数组的异或值通过反复执行 a[i] = a[i] XOR a[i+1] 直到只剩一个元素得到",
        "mathematical_property": "该操作等价于对原数组进行前缀异或差分变换：若定义 P[0]=0, P[i]=nums[0]^...^nums[i-1]，则任意子数组 nums[i..j] 经过上述操作后的最终结果为 P[j+1]^P[i]",
        "key_insight": "子数组在多次异或压缩后得到的值等于其两端点对应的前缀异或的异或值"
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "所有查询区间 [l_i, r_i] 内任意连续子数组经压缩操作后所得异或值的最大值",
        "output": "长度为 q 的整数数组 answer，answer[i] 表示第 i 个查询的答案"
      },
      "Algorithmic Invariant": {
        "invariant_1": "前缀异或数组 P 满足：任意子数组 nums[i..j] 的压缩结果为 P[j+1] ^ P[i]",
        "invariant_2": "在固定区间 [l, r] 中，最大化 P[i] ^ P[j+1] 等价于在集合 {P[l], P[l+1], ..., P[r+1]} 中寻找最大异或对",
        "invariant_3": "最大异或对问题可在 Trie（特别是二进制Trie）结构下高效维护，支持插入和查询最大异或值操作",
        "invariant_4": "离线处理时可利用区间端点排序与双指针推进，确保每个前缀只被加入一次；在线场景下需预建可持久化Trie"
      },
      "Transformable Parameters": {
        "n_value_range": [
          "n <= 2000 (当前)",
          "n <= 1e5 (需优化)",
          "n <= 1e6 (强制在线/持久化结构)"
        ],
        "q_value_range": [
          "q <= 1e5 (当前)",
          "q <= 1e6 (需离线批处理)"
        ],
        "data_form": {
          "input_form": "批量离线查询",
          "possible_variants": [
            "在线查询（流式输入 queries）",
            "动态修改 nums 元素",
            "增加删除操作（动态数组）"
          ]
        },
        "numeric_constraints": {
          "nums_values": "非负整数，值域 [0, 2^31-1]",
          "possible_extension": "支持负数异或语义？"
        },
        "structural_transforms": [
          "1D → 2D 数组上的子矩阵最大压缩异或值",
          "目标函数变换：从最大 → 最小 / 计数满足 ≥K 的子数组个数",
          "约束反转：求最小异或值 或 异或值最接近某个目标",
          "隐藏条件：不显式给出操作规则，需自行推导出前缀异或性质"
        ],
        "algorithmic_complexity_boundary": {
          "brute_force": "O(n^2) per query → O(q * n^2), 不可行当 n 大",
          "optimized_offline": "O((n + q) * log(max_val)) 使用离线+Trie",
          "online_persistent_trie": "O(n * log(max_val) + q * log(max_val))"
        }
      }
    }
  },
  {
    "title": "Maximum Value Sum by Placing Three Rooks I",
    "slug": "maximum-value-sum-by-placing-three-rooks-i",
    "schema": {
      "Input Structure": {
        "type": "2D array",
        "dimensions": "m x n",
        "element_type": "integer",
        "value_range": "-1e9 <= board[i][j] <= 1e9",
        "constraints": [
          "3 <= m == board.length <= 100",
          "3 <= n == board[i].length <= 100"
        ]
      },
      "Core Constraint": {
        "description": "三个车必须两两不在同一行且不在同一列，即任意两个车不能共享行或列",
        "implication": "三车的位置 (r1, c1), (r2, c2), (r3, c3) 满足 r1 ≠ r2 ≠ r3 且 c1 ≠ c2 ≠ c3",
        "combinatorial_constraint": "选择三行三列的一个排列组合，每行每列至多一个车"
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "sum of values at three selected positions",
        "condition": "three rooks are pairwise non-attacking"
      },
      "Algorithmic Invariant": {
        "invariant_description": "最优解中，三个车占据三行三列；可通过枚举中间列（或行）分离问题结构，利用预处理最大值维护跨行列独立性",
        "key_idea": "固定中间车所在行/列后，剩余两车分别取剩余行中行内最大值的前缀与后缀极值，保证整体最优性可分解",
        "optimization_strategy": "预处理每行最大值，并在列方向上前缀/后缀维护多维极值以支持 O(1) 查询"
      },
      "Transformable Parameters": {
        "n_magnitude": "small scale: m, n <= 100 → allows O(n^2) or O(m*n) solutions",
        "value_domain": "allows negative values → affects greedy selection",
        "number_of_pieces": "can be generalized to k rooks (k=3 in this case)",
        "input_form": "offline static grid",
        "output_form": "single integer (maximum sum)",
        "data_streaming": "not online; full board given initially",
        "symmetry": "board not necessarily square or symmetric",
        "additional_constraints": [
          "whether rotation/reflection is allowed",
          "whether repeated rows/columns are permitted",
          "extension to k-dimensional grids"
        ],
        "variants": [
          "count the number of optimal configurations",
          "minimize the sum under same constraints",
          "add diagonal attack constraint (queen-like rule)",
          "allow obstacles or forbidden cells",
          "online update: modify cell value and recompute"
        ]
      }
    }
  },
  {
    "title": "CEO Subordinate Hierarchy",
    "slug": "ceo-subordinate-hierarchy",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置上的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度中的较小值决定，且仅当该最小值大于 H[i] 时才能储水",
        "key_property": "左右边界约束可分离，局部储水能力依赖于全局极值信息"
      },
      "Objective Function": {
        "goal": "计算整个数组能接住的雨水总量",
        "type": "sum aggregation",
        "output": "单个整数：总储水量"
      },
      "Algorithmic Invariant": {
        "invariant": "使用双指针从两端向内收缩，维护 left_max 和 right_max；若 left_max ≤ right_max，则左指针当前位置的储水量可确定，反之亦然",
        "preservation": "每次移动较短侧指针，保证未访问区域不会影响已确定位置的贡献值正确性"
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 10^5",
          "可扩展至 10^7（要求 O(n)）"
        ],
        "value_domain": "H[i] ∈ [0, 10^4]，可改为允许负值（变形解释）",
        "ordering": "无序输入，但隐含单调结构可用于优化",
        "dimensionality": "可变换为 2D 矩阵形式（如二维接雨水问题）",
        "input_mode": "单组离线输入，可改为在线流式输入或支持修改操作",
        "output_detail": "可要求输出每列储水量而非总和",
        "additional_constraints": "可加入地形渗透、溢出限制等物理规则"
      }
    }
  },
  {
    "title": "Find the Count of Good Integers",
    "slug": "find-the-count-of-good-integers",
    "schema": {
      "Input Structure": [
        "正整数 n（表示整数的位数，1 <= n <= 10）",
        "正整数 k（1 <= k <= 9）",
        "考虑所有 n 位正整数（无前导零）"
      ],
      "Core Constraint": [
        "一个整数是好整数，当且仅当其数位可重排后形成一个回文整数且该回文整数能被 k 整除",
        "重排前后均不能有前导零",
        "回文整数要求左右对称，因此数位频次必须满足：至多一个数字出现奇数次（当 n 为奇数时），其余必须成对",
        "能否被 k 整除的性质在数位重排下不保持，需枚举有效排列或利用模意义下的状态压缩"
      ],
      "Objective Function": "计数 —— 统计所有 n 位整数中，是“好整数”的个数",
      "Algorithmic Invariant": [
        "数位多重集合可构成回文 ⟺ 频次向量中奇数频次的数字个数 ≤ 1",
        "若某数位排列能被 k 整除，则其模 k 余 0",
        "使用动态规划遍历所有数位选择方案时，状态 (mask 或 count_vector, mod, has_leading_zero) 可压缩且转移合法",
        "由于 n 很小（≤10），可接受指数级状态空间（如基于数位频次或位掩码的 DP）",
        "贪心不可行：局部构造无法保证全局回文性和整除性，必须枚举或计数驱动"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10（当前小规模，可扩展至更大 n 并引入高精度或生成函数）",
        "k 的取值范围": "1 <= k <= 9（当前小，可推广到 k <= 100，改变模数复杂度）",
        "是否允许前导零": "否（可变：若允许中间态有前导零但最终排列不允许，可作为约束开关）",
        "是否多组输入": "否（可改为多组测试用例，T <= 1000）",
        "数据流化": "离线计算（可改为在线查询：预处理所有 n,k 结果）",
        "目标函数变换": "从计数 → 构造任意一个好整数 / 输出字典序最小的好整数",
        "回文约束放松": "从严格回文 → 近似回文（如最多 m 处不对称）",
        "整除条件变化": "从 '能被 k 整除' → '模 k 余 r' 或 '与 k 互素'"
      }
    }
  },
  {
    "title": "Count Substrings That Satisfy K-Constraint II",
    "slug": "count-substrings-that-satisfy-k-constraint-ii",
    "schema": {
      "Input Structure": {
        "type": "string",
        "content": "binary string s of length n, where s[i] ∈ {'0', '1'}",
        "queries": "2D integer array queries, each query = [l_i, r_i], representing substring s[l_i..r_i]",
        "constraints": {
          "n": "1 <= n <= 1e5",
          "k": "1 <= k <= n",
          "num_queries": "1 <= queries.length <= 1e5",
          "query_bounds": "0 <= l_i <= r_i < n"
        }
      },
      "Core Constraint": {
        "definition": "A binary substring satisfies the k-constraint if either count of '0' ≤ k OR count of '1' ≤ k.",
        "implication": "For a substring to violate k-constraint: (count_0 > k) AND (count_1 > k). Hence, valid substrings are those not violating this condition.",
        "structural_insight": "In any valid substring, at least one character type is sparse (≤k), enabling complementary counting via inclusion-exclusion."
      },
      "Objective Function": {
        "goal": "Count the number of substrings within each query interval [l_i, r_i] that satisfy the k-constraint."
      },
      "Algorithmic Invariant": {
        "complementary_counting": "Total substrings in [l,r]: (r-l+1)*(r-l+2)/2. Subtract number of invalid substrings (those with both count_0 > k and count_1 > k).",
        "sliding_window_property": "Within a fixed interval, longest invalid substring ending at position j can be maintained using two pointers; shrinking left when both counts exceed k.",
        "monotonicity": "If substring s[i..j] is invalid, then s[i-1..j] is also likely invalid (but not necessarily); however, we use right-expansion with left-shrink to maintain minimal invalid windows.",
        "two_pointers_logic": "Use left pointer to track earliest start such that s[left..j] remains invalid — once window becomes valid, all larger windows starting earlier may still be invalid, so we instead count maximal valid expansions from each start."
      },
      "Transformable Parameters": {
        "string_type": "binary → general alphabet size m",
        "constraint_type": "k-constraint on 0 or 1 → generalized to multi-character frequency constraints",
        "objective_variation": "count satisfying substrings → find longest/shortest satisfying substring → decide existence",
        "query_mode": "offline batch queries → online queries with updates (dynamic string)",
        "data_form": "static string → circular string",
        "k_semantics": "fixed k → variable k per query",
        "input_dimension": "1D string → 2D grid of binary values",
        "frequency_condition": "disjunction (0≤k OR 1≤k) → conjunction (0≤k AND 1≤k) → threshold logic",
        "output_requirement": "return count per query → return list of all valid substrings (positions)"
      }
    }
  },
  {
    "title": "Minimum Number of Increasing Subsequence to Be Removed",
    "slug": "minimum-number-of-increasing-subsequence-to-be-removed",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示柱状图中每个位置的高度",
      "Core Constraint": "每个位置能接住的雨水量由其左侧和右侧最大高度的较小值决定；左右边界约束独立但需全局一致以确定局部容量",
      "Objective Function": "计算整个数组所能接住的雨水总量（求和）",
      "Algorithmic Invariant": "维护双指针 L 和 R 分别从左右两端向内移动，同时记录左侧最大值 maxLeft 和右侧最大值 maxRight；若 maxLeft ≤ maxRight，则左指针当前位置的积水可确定并累加，且左指针右移不影响已确定区域的正确性；反之对右指针同理",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许负数（如地下坑洞建模）",
        "维度扩展": "从 1D 扩展到 2D 网格上的接雨水问题",
        "输入形式": "是否支持在线输入或动态更新（加入删除操作）",
        "输出要求": "是否需要输出每个位置的积水高度而非总和",
        "数据规模": "n 的数量级（如 1e3 / 1e5 / 1e7），影响解法选择（预处理 vs 双指针）",
        "多组数据": "是否为多测例输入场景",
        "结构变形": "数组是否为环形结构"
      }
    }
  },
  {
    "title": "Count Almost Equal Pairs II",
    "slug": "count-almost-equal-pairs-ii",
    "schema": {
      "Input Structure": [
        "数组 nums[1..n]，其中 n = len(nums)",
        "每个元素 nums[i] 是正整数，且 1 <= nums[i] < 10^7",
        "输入为一维数组，值域为十进制非负整数（可含前导零解释）"
      ],
      "Core Constraint": [
        "两个数字 x 和 y 被称为‘近似相等’，当且仅当可以通过至多两次交换操作使它们相等",
        "每次交换操作可以交换该数字的任意两个数位",
        "允许前导零，即数值比较基于字符串重排后的数值解析",
        "状态空间由数位的排列等价类及最多两步可达性决定"
      ],
      "Objective Function": "计数所有满足 i < j 且 nums[i] 与 nums[j] 近似相等的数对 (i, j) 的数量",
      "Algorithmic Invariant": [
        "每个数字的‘两步可达等价类’是不变的：即通过至多两次交换所能达到的所有数值集合具有确定结构",
        "两个数字近似相等 ⇔ 它们属于同一个两步交换连通分量",
        "可通过规范化表示（如最小字典序表示或哈希代表元）将每个数映射到其等价类，从而支持 O(1) 查询",
        "等价类划分满足传递性和对称性，支持哈希计数优化"
      ],
      "Transformable Parameters": {
        "操作次数上限": {
          "原题": 2,
          "可变形式": "k 次交换（k=0,1,2,...）"
        },
        "数据规模": {
          "n 数量级": "5e3（当前可接受 O(n^2) 或 O(n × d) 解法）",
          "可扩展至": "1e5（要求更优解法）"
        },
        "数值范围": {
          "当前": "< 10^7（最多 8 位数字）",
          "可变形式": "支持大整数或字符串输入"
        },
        "是否有序": false,
        "是否循环": false,
        "是否多组输入": false,
        "是否在线": false,
        "输出形式": {
          "当前": "计数数对总数",
          "可变形式": "输出所有近似相等对 / 构造方案 / 判定特定对"
        },
        "交换限制变化": [
          "仅相邻交换",
          "只能交换特定位置",
          "成本加权交换"
        ]
      }
    }
  },
  {
    "title": "Count Substrings That Satisfy K-Constraint I",
    "slug": "count-substrings-that-satisfy-k-constraint-i",
    "schema": {
      "Input Structure": [
        "二进制字符串 s，长度为 n（1 ≤ n ≤ 50）",
        "字符集：s[i] ∈ {'0', '1'}",
        "整数 k（1 ≤ k ≤ n）"
      ],
      "Core Constraint": [
        "子字符串满足 k 约束的条件是：其中 '0' 的数量 ≤ k 或 '1' 的数量 ≤ k",
        "两个条件满足其一即可（OR 条件），因此约束是非对称且可分离的",
        "子字符串的统计需覆盖所有连续子串，但可通过补集思想转化为不满足条件的计数"
      ],
      "Objective Function": [
        "计数：统计 s 中所有满足 k 约束的子字符串的数量",
        "目标函数为存在性或/或逻辑下的枚举总数"
      ],
      "Algorithmic Invariant": [
        "使用补集转换：总子串数 - 不满足约束的子串数",
        "不满足约束的子串必须同时满足：'0' 的数量 > k 且 '1' 的数量 > k",
        "双指针滑动窗口可用于高效枚举‘0’和‘1’均超过 k 的子串（即非法子串）",
        "固定右端点，移动左端点维护窗口内 0 和 1 的频次，保证单调递增删除无效前缀"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前较小（≤50），可扩展至 1e5 要求 O(n) 解法",
        "k 的取值范围：是否与 n 相关（如 k = O(√n)）",
        "字符集扩展：从二进制到多进制（如三进制）并定义多类计数约束",
        "约束逻辑变化：OR → AND；或改为异或条件",
        "输入形式：单组数据 → 多组测试用例",
        "是否在线处理：字符串逐字符流入，要求实时输出结果",
        "是否允许修改操作：支持动态更新字符后重新查询"
      ]
    }
  },
  {
    "title": "Maximum Value Sum by Placing Three Rooks II",
    "slug": "maximum-value-sum-by-placing-three-rooks-ii",
    "schema": {
      "Input Structure": [
        "二维整数数组 board[1..m][1..n]",
        "m >= 3, n >= 3",
        "board[i][j] ∈ ℤ, 值域 [-10^9, 10^9]"
      ],
      "Core Constraint": [
        "三个车必须两两不在同一行且不在同一列",
        "即：任意两个车不能共享行或列",
        "等价于选择三组互不冲突的 (行, 列) 对，行互异，列互异"
      ],
      "Objective Function": "最大化三个选定位置的值之和（求最大总价值）",
      "Algorithmic Invariant": [
        "最优解中，三个车占据三行三列，形成一个部分排列结构",
        "可枚举中间行（或列）作为分界，将问题拆分为‘上部最佳两个车’与‘下部最佳一个车’的组合",
        "利用预处理维护每行/每列前k大元素、跨行列不重叠的局部最优子结构",
        "状态可分解为：全局最优 = max(上半区两个非冲突车 + 下半区一个车)，其中上下区域按行划分且列不重复",
        "列使用状态可通过位掩码或集合记录，但因仅三车，可枚举列组合优化"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": [
            "3 ≤ m,n ≤ 500",
            "可扩展至 1000 或更高以要求更优复杂度"
          ],
          "值域范围": [
            "[-10^9, 10^9]",
            "可限制为非负或正整数"
          ]
        },
        "输入形式": [
          "是否保证存在解（默认是）",
          "是否允许相同行列放置（本题禁止）",
          "是否多组测试数据"
        ],
        "目标函数变换": [
          "求最大和 → 求最小和 → 计数满足条件的方案数",
          "改为放置 k 个车（k=2,3,4...）→ 推广为 k-车独立放置问题"
        ],
        "约束变换": [
          "攻击规则变化：对角线也攻击 → 变为皇后问题",
          "从‘无互相攻击’变为‘至少一对可攻击’（反向约束）",
          "加入障碍格子（某些格不可放）"
        ],
        "数据流化": [
          "静态棋盘 → 动态更新（支持修改某个 board[i][j] 后在线查询）",
          "离线批量查询多个不同 board 的答案"
        ],
        "结构维度变换": [
          "2D 矩阵 → 3D 立方体棋盘（三维坐标中行/列/层均唯一）",
          "普通网格 → 圆环形行列（模意义下相邻）"
        ]
      }
    }
  },
  {
    "title": "Report Spam Message",
    "slug": "report-spam-message",
    "schema": {
      "Input Structure": [
        "一维字符串数组 message[1..n]",
        "一维字符串数组 bannedWords[1..m]",
        "n, m ≥ 1",
        "每个字符串由小写英文字母组成，长度在 [1, 15] 范围内"
      ],
      "Core Constraint": [
        "判定逻辑依赖于集合交集的频次：一个单词只有在同时出现在 message 和 bannedWords 中时才被计入",
        "计数对象是 message 中属于 bannedWords 集合的单词个数",
        "判定阈值为 ≥2：至少两个单词匹配即触发垃圾信息判定"
      ],
      "Objective Function": "判定函数：若 message 中至少有两个单词出现在 bannedWords 中，则返回 true；否则返回 false",
      "Algorithmic Invariant": [
        "bannedWords 可预处理为哈希集合，实现 O(1) 成员查询",
        "遍历 message 时，命中计数单调递增",
        "一旦计数 ≥2，可提前终止（短路优化），不影响最终判定结果"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "message.length, bannedWords.length": "可变范围 [1, 10^5]，可调整至更小或更大以适应不同场景"
        },
        "匹配条件": [
          "完全相同 → 支持前缀匹配 / 编辑距离 ≤1 等模糊匹配（隐藏条件变换）"
        ],
        "阈值参数": "将‘至少两个’推广为变量 k（目标函数泛化为计数 ≥k）",
        "输入形式": [
          "单组输入 → 多组测试用例",
          "静态输入 → 在线流式接收 message 单词（数据流化）"
        ],
        "输出形式": [
          "布尔判定 → 返回具体匹配的单词列表（构造方案扩展）",
          "是否区分重复单词：如 message 中有重复禁词是否累计计数"
        ],
        "集合属性": [
          "bannedWords 是否允许重复 → 需去重处理",
          "是否有序 → 当前来序无关，可改为顺序敏感匹配"
        ]
      }
    }
  },
  {
    "title": "Hash Divided String",
    "slug": "hash-divided-string",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n",
        "整数 k，满足 1 <= k <= 100 且 n % k == 0",
        "s 只包含小写英文字母（'a' 到 'z'）",
        "n 的范围：k <= n <= 1000"
      ],
      "Core Constraint": [
        "字符串 s 被等分为 n/k 个连续子字符串，每个长度为 k",
        "每个子字符串独立处理，无重叠、无交叉",
        "哈希值由字符在字母表中的下标和模 26 运算唯一确定",
        "输出字符串 result 的每一位仅依赖于对应子字符串的内部信息"
      ],
      "Objective Function": "构造一个长度为 n/k 的字符串 result，其中每位字符是对应子字符串所有字符哈希值之和模 26 后对应的字母",
      "Algorithmic Invariant": [
        "子字符串间相互独立，可顺序处理",
        "每个子字符串的哈希计算具有加法可分性和模不变性",
        "处理第 i 个子字符串时，其结果只取决于该段内字符，不依赖前后段",
        "整体过程为确定性映射：分段 → 求和 → 取模 → 映射字符"
      ],
      "Transformable Parameters": {
        "n 的数量级": "10^3（当前）→ 可扩展至 10^5 或更高以引入前缀和优化",
        "值域": "字符集是否扩展（如含大写、数字）；模数是否变为其他（如 mod 27）",
        "是否有序": "输入 s 是否保证某种顺序（如字典序）",
        "是否循环": "子字符串是否环形分割（如从中间开始循环切分）",
        "是否多组输入": "是否存在多个 (s, k) 对需批量处理",
        "是否在线": "s 是否流式输入，要求实时输出每段哈希结果",
        "操作类型扩展": "支持修改某字符后动态更新 result（引入线段树或差分结构）",
        "目标函数变形": "改为计数有多少段哈希值等于某值，或求最大/最小哈希字符"
      }
    }
  },
  {
    "title": "Customer Purchasing Behavior Analysis",
    "slug": "customer-purchasing-behavior-analysis",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 height，height[i] 表示第 i 根柱子的高度"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左右两侧最高柱子中的较小值决定",
        "property": "局部积水依赖于全局极值（左最大和右最大）",
        "independence": "左右边界约束可分离但需协同确定容水量"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "计算整个数组能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "双指针",
        "invariants": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示 [0, L) 区间的最大高度，maxRight 表示 (R, n-1] 区间的最大高度",
          "若 maxLeft ≤ maxRight，则 height[L] 处的积水可由 maxLeft 决定，因为右侧至少存在一个足够高的柱子（maxRight ≥ maxLeft）来形成瓶颈",
          "同理，若 maxRight < maxLeft，则 height[R] 处的积水可由 maxRight 决定",
          "每次只移动对应较小一侧的指针，保证决策的安全性和最优性"
        ],
        "correctness_basis": "指针移动过程中，已计算区域的积水值不受后续操作影响，满足贪心选择性质"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "数据维度",
            "options": [
              "1D",
              "2D",
              "3D",
              "环形数组"
            ]
          },
          {
            "name": "目标函数",
            "options": [
              "总容量",
              "最大单连通积水区域",
              "每个位置的积水分布",
              "是否存在可行积水配置"
            ]
          },
          {
            "name": "数值范围",
            "options": [
              "非负整数",
              "允许负值（如地下柱子）",
              "浮点数"
            ]
          },
          {
            "name": "输入形式",
            "options": [
              "静态离线输入",
              "在线流式更新",
              "支持删除/修改操作"
            ]
          },
          {
            "name": "约束条件",
            "options": [
              "标准接雨水",
              "最多使用 K 块挡板",
              "只能利用相邻三根柱子"
            ]
          },
          {
            "name": "多组数据",
            "options": [
              "单组测试",
              "多组测试用例"
            ]
          },
          {
            "name": "是否有序",
            "options": [
              "无序",
              "部分有序",
              "预排序后处理"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Alt and Tab Simulation",
    "slug": "alt-and-tab-simulation",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given an array H[1..n] where each element H[i] represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The amount of water that can be trapped at any position depends on the minimum of the maximum heights to its left and right.",
        "dependency": "Left and right boundaries are independent but must be globally consistent; local information is insufficient without global maxima."
      },
      "Objective Function": {
        "goal": "sum",
        "description": "Compute the total amount of rainwater that can be trapped between the bars."
      },
      "Algorithmic Invariant": {
        "invariant": "Two-pointer technique maintains maxLeft and maxRight values.",
        "rules": [
          "Pointer movement: if maxLeft <= maxRight, move left pointer forward;",
          "Otherwise, move right pointer backward.",
          "At each step, the contribution of the current side (left or right) can be determined because it is bounded by the smaller outer maximum.",
          "Movement preserves correctness: no previously computed region is invalidated."
        ]
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_domain": "H[i] in [0, 10^5]",
        "ordering": "unsorted",
        "negatives_allowed": false,
        "circular": false,
        "online_queries": false,
        "updates_supported": false,
        "output_detail": "total sum only",
        "dimensions": "1D",
        "multiple_test_cases": false,
        "hidden_constraints": "monotonicity not given explicitly"
      }
    }
  },
  {
    "title": "Number of Subsequences with Odd Sum",
    "slug": "number-of-subsequences-with-odd-sum",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示柱状图中每个位置的高度",
      "Core Constraint": "每个位置 i 能接的雨水量由其左侧最大高度和右侧最大高度中的较小值决定；若左右侧最大值分别为 leftMax[i] 和 rightMax[i]，则位置 i 的积水高度为 min(leftMax[i], rightMax[i]) - H[i]（若为负则为0）",
      "Objective Function": "计算整个数组能接的雨水总量，即所有位置积水高度之和",
      "Algorithmic Invariant": "使用双指针维护当前左端和右端的最大高度 maxLeft 和 maxRight；当 maxLeft ≤ maxRight 时，左指针所在位置的积水可确定（因其右边界不会变得更小）；同理当 maxRight < maxLeft 时，右指针位置的积水可确定；指针向内移动不破坏已处理区域的最优性",
      "Transformable Parameters": {
        "n 的数量级": "1 ≤ n ≤ 2×10^4（可调整至支持离线批量或在线流式输入）",
        "值域": "H[i] ∈ [0, 10^5]（可扩展为允许负数以模拟地下结构）",
        "是否有序": "无序输入（可构造单调序列作为特例）",
        "是否循环": "非环形结构（可变形为环形柱状图）",
        "是否多组输入": "单组数据为主（可改为多测例模式）",
        "是否在线": "一次性离线输入（可改造为支持动态添加柱子并实时查询总储水量）",
        "输出形式": "仅输出总和（可改为输出每列储水量或最大连续积水段等）",
        "操作类型": "静态只读（可加入更新操作形成‘带修接雨水’问题）"
      }
    }
  },
  {
    "title": "Find the Count of Monotonic Pairs II",
    "slug": "find-the-count-of-monotonic-pairs-ii",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中 n >= 1，nums[i] 为正整数，1 <= nums[i] <= 1000",
      "Core Constraint": "对于每个位置 i，存在非负整数 a_i 和 b_i 满足 a_i + b_i = nums[i]；整个序列需构造出两个长度为 n 的数组 arr1 和 arr2，使得 arr1 非递减、arr2 非递增；该约束导致状态间具有前后依赖性：当前选择会影响后续合法取值范围。",
      "Objective Function": "计数所有满足条件的单调数组对 (arr1, arr2) 的方案总数，并对 10^9 + 7 取余",
      "Algorithmic Invariant": "可以将问题转化为确定 arr1 的取值序列（或等价地 arr2），其必须满足：a_i <= a_{i+1} 且 b_i = nums[i] - a_i >= b_{i+1} => a_{i+1} <= a_i + (nums[i] - nums[i+1])；因此 a_i 的上下界可通过前缀传递推导；动态规划中，dp[i][a] 表示处理前 i 个元素且 arr1[i] = a 的方案数，转移具有阶段性与状态可叠加性；状态转移保持合法性不变。",
      "Transformable Parameters": {
        "数据规模": "n 的范围：1 <= n <= 2000；nums[i] 值域：1 <= nums[i] <= 1000（可调整至更高或更低）",
        "输入类型变化": "nums 是否允许为零或负数",
        "是否有序": "输入 nums 是否已排序（影响贪心可能性）",
        "目标函数变形": "从计数改为判定是否存在至少一个解，或求字典序最小的 arr1",
        "多组数据": "是否处理多组测试用例",
        "在线查询": "是否支持在修改 nums 后动态更新答案",
        "输出形式": "是否要求输出所有方案（而非仅计数）",
        "约束方向变换": "arr1 改为非递增，arr2 改为非递减；或两者同为非递减"
      }
    }
  },
  {
    "title": "Find the Count of Monotonic Pairs I",
    "slug": "find-the-count-of-monotonic-pairs-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "positive_integer",
        "length": "n",
        "constraints": [
          "nums.length == n",
          "1 <= n <= 2000",
          "1 <= nums[i] <= 50",
          "nums is a 1D array of positive integers"
        ]
      },
      "Core Constraint": {
        "description": "For each index i, arr1[i] + arr2[i] == nums[i], with arr1 non-decreasing and arr2 non-increasing. This couples the two sequences through pointwise sum while imposing opposite monotonicity constraints.",
        "key_insight": "The monotonicity of arr1 and arr2 induces a dual constraint: values in arr1 can only increase, so arr2 must decrease or stay flat; thus, the choice at position i affects all future and past decisions globally."
      },
      "Objective Function": {
        "type": "counting",
        "goal": "Count the number of valid monotonic array pairs (arr1, arr2) satisfying the constraints modulo 1e9+7"
      },
      "Algorithmic Invariant": {
        "invariant": "At each position i, the value chosen for arr1[i] determines arr2[i] = nums[i] - arr1[i]. The sequence of choices preserves: arr1[i] >= arr1[i-1] and arr2[i] <= arr2[i-1].",
        "state_preservation": "Maintain feasibility by ensuring that the minimum possible value for arr1[i] is max(arr1[i-1], nums[i] - arr2[i-1]) — this captures both monotonicity conditions via a single variable (e.g., current arr1[i]).",
        "dp_formulation": "Let dp[i][x] = number of ways to assign arr1[0..i] such that arr1[i] = x. Transition: dp[i][x] += dp[i-1][y] for all y <= x and nums[i]-x <= nums[i-1]-y (i.e., arr2[i] <= arr2[i-1]). Optimized using prefix sums due to bounded value range."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n",
            "range": "1 to 2000",
            "modifiable": true,
            "impact": "affects time complexity; allows DP with O(n * max_value)"
          },
          {
            "name": "value_range_of_nums",
            "range": "1 to 50",
            "modifiable": true,
            "impact": "enables DP over values; if larger, may require coordinate compression or different method"
          },
          {
            "name": "monotonicity_direction",
            "options": [
              "(non-decreasing, non-increasing)",
              "(non-decreasing, non-decreasing)",
              "(non-increasing, non-increasing)"
            ],
            "default": "(non-decreasing, non-increasing)",
            "transform_operator": "目标变换：单调性组合变化"
          },
          {
            "name": "modular_arithmetic",
            "applied": true,
            "modulus": 1000000007,
            "removable": false,
            "reason": "standard in counting problems with large outputs"
          },
          {
            "name": "input_type",
            "form": "offline, static array",
            "possible_extensions": [
              "online queries on nums",
              "updates to nums (dynamic version)"
            ],
            "transform_operator": "数据流化：一次性输入 → 在线查询 / 动态修改"
          },
          {
            "name": "output_requirement",
            "type": "scalar_count",
            "alternatives": [
              "return one valid pair (construction)",
              "return lexicographically smallest arr1",
              "count distinct arr1 sequences only"
            ],
            "transform_operator": "目标变换：计数 → 构造 / 判定"
          },
          {
            "name": "array_length_equality",
            "required": true,
            "can_be_relaxed": false,
            "note": "core to definition of array pair"
          }
        ]
      }
    }
  },
  {
    "title": "Count Almost Equal Pairs I",
    "slug": "count-almost-equal-pairs-i",
    "schema": {
      "Input Structure": [
        "数组 nums[1..n]",
        "每个元素为正整数，1 <= nums[i] <= 1e6",
        "数组长度 2 <= n <= 100"
      ],
      "Core Constraint": [
        "两个数 x 和 y 近似相等，当且仅当至多一次交换某一个数的两个数位后，二者相等",
        "允许前导零（即交换后数值按十进制解析）",
        "只能对 x 或 y 中的一个进行一次数位交换操作"
      ],
      "Objective Function": "计数：满足 i < j 且 nums[i] 与 nums[j] 近似相等的数对 (i, j) 的总数",
      "Algorithmic Invariant": [
        "对于任意整数 x，其通过一次数位交换能生成的所有值集合 S(x) 是固定的、有限的（最多 C(d,2) 种，d 为位数）",
        "x 与 y 近似相等 ⇔ y ∈ {x} ∪ S(x) 或 x ∈ {y} ∪ S(y)",
        "关系具有对称性但不对传递性，需逐对判定",
        "可预处理每个数字的‘可达值集合’以加速比较"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": "小规模（≤ 100），支持 O(n² × d²) 解法",
          "nums[i] 值域": "1 到 1e6，最多 7 位数"
        },
        "输入形式": {
          "是否有序": "无序数组",
          "是否多组数据": "单组输入",
          "是否在线": "离线处理"
        },
        "操作限制": {
          "操作次数": "至多一次交换（可不操作）",
          "操作对象": "只能选其中一个数进行交换",
          "交换类型": "任意两个数位交换（不要求相邻）"
        },
        "输出要求": {
          "目标函数类型": "计数问题",
          "是否需要构造方案": "否，仅统计数对数量"
        },
        "可变形方向": [
          "改为可对两个数都操作一次",
          "限制只能交换相邻数位",
          "扩展为 k 次交换",
          "判断是否存在而非计数",
          "改为字符串数组输入",
          "加入去重约束（如不同下标但相同值只算一次）"
        ]
      }
    }
  },
  {
    "title": "Snake in Matrix",
    "slug": "snake-in-matrix",
    "schema": "{\n  \"Input Structure\": {\n    \"grid_size\": \"n x n matrix\",\n    \"cell_indexing\": \"grid[i][j] = (i * n) + j\",\n    \"start_position\": \"cell 0 (i=0, j=0)\",\n    \"commands\": \"string array of directions: ['UP', 'RIGHT', 'DOWN', 'LEFT']\",\n    \"constraints\": {\n      \"2 <= n <= 10\",\n      \"1 <= commands.length <= 100\",\n      \"snake remains within grid boundaries during movement\"\n    }\n  },\n  \"Core Constraint\": {\n    \"movement_rules\": \"each command moves the snake one unit in the specified direction\",\n    \"boundary_safety\": \"guaranteed that all moves remain inside the grid\",\n    \"position_mapping\": \"current position can be mapped to (i, j) via integer division and modulo: i = pos // n, j = pos % n\"\n  },\n  \"Objective Function\": \"compute the final cell position (integer value) after executing all commands\",\n  \"Algorithmic Invariant\": {\n    \"state_representation\": \"current position encoded as a single integer in [0, n^2 - 1]\",\n    \"coordinate_conversion\": \"at each step, convert scalar position to (i, j) coordinates to apply movement, then convert back\",\n    \"deterministic_transition\": \"each direction maps to a fixed coordinate delta: UP=(-1,0), DOWN=(1,0), LEFT=(0,-1), RIGHT=(0,1)\",\n    \"invariance_under_modulo_arithmetic\": \"position updates preserve correctness under row-major indexing\"\n  },\n  \"Transformable Parameters\": {\n    \"n_value_range\": \"small scale: 2 <= n <= 10 → allows simulation without optimization\",\n    \"command_length\": \"up to 100 steps → suitable for linear traversal\",\n    \"input_form\": \"commands given as offline batch; could transform to online stream\",\n    \"output_form\": \"return final scalar cell index; alternatively could ask for path or intermediate positions\",\n    \"grid_type\": \"could generalize to m x n rectangular grid\",\n    \"movement_constraints\": \"currently no obstacles or restrictions beyond bounds — could add blocked cells or state-dependent movement rules\",\n    \"direction_set\": \"could extend with diagonal moves or rotational commands\",\n    \"indexing_schema\": \"could change from row-major to column-major or zigzag\"\n  }\n}"
  },
  {
    "title": "Time Taken to Mark All Nodes",
    "slug": "time-taken-to-mark-all-nodes",
    "schema": {
      "Input Structure": {
        "type": "Tree",
        "nodes": "n nodes labeled from 0 to n-1",
        "edges": "a 2D integer array edges of length n - 1, where edges[i] = [u_i, v_i] represents an undirected edge between nodes u_i and v_i",
        "node_parity": "each node i has a parity (even or odd), which determines its labeling delay rule",
        "initial_state": "all nodes are unmarked at t = 0"
      },
      "Core Constraint": {
        "labeling_rule_odd": "an odd-indexed node i gets marked at time x if at least one of its neighbors was marked at time x - 1",
        "labeling_rule_even": "an even-indexed node i gets marked at time x if at least one of its neighbors was marked at time x - 2",
        "propagation_dependency": "marking propagates through the tree based on neighbor status and node index parity",
        "independence": "each query starts independently: only one node is initially marked at t = 0"
      },
      "Objective Function": {
        "goal": "compute for each node i, the earliest time when all nodes in the tree become marked, assuming node i is the only one marked at t = 0",
        "output_type": "an integer array times of length n, where times[i] is the completion time starting from node i"
      },
      "Algorithmic Invariant": {
        "BFS_propagation_invariant": "once a node's marking condition is satisfied (based on its parity and neighbor history), it will be marked at the correct future time step",
        "monotonic_time_evolution": "time values increase monotonically during propagation; no node can be marked earlier than dictated by its dependency chain",
        "tree_structure_utilization": "the absence of cycles allows dynamic programming or multi-source BFS without revisiting conflicts, enabling efficient simulation from each root",
        "separate_queues_by_parity": "for simulation efficiency, events can be scheduled using time-delay queues depending on target node parity"
      },
      "Transformable Parameters": {
        "n_value_range": "2 <= n <= 1e5",
        "edge_directionality": "undirected (can be transformed to directed with propagation rules)",
        "initial_mark_count": "single initial mark (can generalize to multiple seeds)",
        "labeling_rules": [
          "parity-dependent delays (odd: +1, even: +2) — can vary to arbitrary delay functions",
          "generalized: delay(i) = f(i mod k)"
        ],
        "input_form": {
          "online_queries": false,
          "offline_batch": true
        },
        "output_requirements": [
          "full times array (can change to single query or min/max over i)"
        ],
        "dynamic_updates": {
          "edge_addition_removal": false,
          "node_property_changes": false
        },
        "simulation_model": "discrete-time event-driven BFS from each source"
      }
    }
  },
  {
    "title": "Minimum Amount of Damage Dealt to Bob",
    "slug": "minimum-amount-of-damage-dealt-to-bob",
    "schema": {
      "Input Structure": [
        "整数 power",
        "两个长度为 n 的一维数组 damage[1..n] 和 health[1..n]",
        "damage[i] ≥ 1, health[i] ≥ 1",
        "所有输入均为正整数"
      ],
      "Core Constraint": [
        "每秒 Bob 只能对一个存活敌人造成 power 点伤害",
        "敌人在 health[i] > 0 时持续每秒造成 damage[i] 点伤害",
        "伤害累计发生在攻击之前，且每秒顺序为：先全体敌人造成总伤害，后 Bob 攻击一次",
        "消灭敌人意味着其 health[i] ≤ 0",
        "敌人的存活时间决定了其造成的总伤害贡献"
      ],
      "Objective Function": "最小化 Bob 在消灭所有敌人过程中所受到的总伤害总和",
      "Algorithmic Invariant": [
        "总伤害是各敌人存活时间与其单位时间伤害的乘积之和：Σ(damage[i] × 存活秒数)",
        "每个敌人的死亡时间由 Bob 对其攻击次数（向上取整(health[i] / power)）和攻击时机决定",
        "最优策略下，应优先击杀单位时间伤害高或性价比高的敌人（贪心顺序可证明）",
        "存在贪心排序不变量：按 damage[i] / ceil(health[i] / power) 或等价形式排序可得最优攻击序列",
        "局部攻击决策不影响已过时间的伤害累积，未来伤害仅依赖剩余敌人集合及其存活时长"
      ],
      "Transformable Parameters": [
        "power 的值域：[1, 1e4]",
        "n 的规模：[1, 1e5]",
        "damage[i], health[i] 的值域：[1, 1e4]",
        "是否允许浮点 power 或 damage（变形题）",
        "是否支持多组敌人分组、技能机制（如连锁攻击）",
        "是否改为在线输入：敌人逐个出现",
        "是否要求构造最优攻击序列而非仅求最小伤害",
        "是否加入冷却、能量限制等额外约束",
        "目标函数变换：从最小化总伤害 → 判定是否存在策略使伤害 ≤ K → 计数满足条件的策略数"
      ]
    }
  },
  {
    "title": "Odd and Even Transactions",
    "slug": "odd-and-even-transactions",
    "schema": {
      "Input Structure": [
        "表 transactions，包含三列：",
        "  - transaction_id: int（唯一标识）",
        "  - amount: int（非负整数或任意整数）",
        "  - transaction_date: date",
        "输入为一组按时间无序的交易记录"
      ],
      "Core Constraint": [
        "每天的交易可被划分为两个互斥集合：奇数金额、偶数金额",
        "奇偶性由 amount % 2 决定",
        "每个交易只能属于一个类别（奇/偶）",
        "需对每个日期独立聚合两类值"
      ],
      "Objective Function": [
        "对每个 transaction_date，计算：",
        "  - 奇数 amount 的总和（odd_sum）",
        "  - 偶数 amount 的总和（even_sum）",
        "若某类不存在，则对应和为 0",
        "最终结果按 transaction_date 升序排序"
      ],
      "Algorithmic Invariant": [
        "分组不变性：相同 transaction_date 的记录必须归入同一日统计",
        "分类不变性：每条记录根据 amount 的奇偶性唯一确定归属",
        "聚合不变性：sum 操作满足结合律与交换律，支持增量计算",
        "空缺补全不变性：即使某天无奇数或偶数交易，仍输出 0 而非缺失"
      ],
      "Transformable Parameters": {
        "数据规模": "n = 交易总数，可变范围：1 ≤ n ≤ 10^5 或更大",
        "值域约束": {
          "amount": "可扩展为负数、大数（需考虑溢出）、浮点数",
          "transaction_date": "日期跨度：单日密集 / 多年稀疏分布"
        },
        "奇偶定义": "可替换为其他模条件（如 amount % 3 == r）",
        "聚合函数": "sum → count / avg / max / min 等",
        "分组粒度": "按日 → 按周 / 按月 / 按用户（若添加 account_id）",
        "输入形式": "静态表 → 流式插入 → 支持删除与修改的动态表",
        "输出要求": "是否必须补零（NULL 补 0），是否排序，是否只返回特定日期区间",
        "多组数据": "是否处理多个账户或多币种的交叉情况",
        "在线性": "是否支持实时查询当日累计奇偶和"
      }
    }
  },
  {
    "title": "Maximum Array Hopping Score II",
    "slug": "maximum-array-hopping-score-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能够接住雨水的量由其左侧最大高度和右侧最大高度中的较小值决定，且仅当该最小值大于 H[i] 时才能积水",
        "properties": [
          "左右边界约束独立但需全局一致",
          "局部积水能力依赖于全局极值信息"
        ]
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算所有位置上能够接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "维护两个指针 L 和 R，分别从数组两端向中间移动",
          "维护 maxLeft = max(H[1..L]) 和 maxRight = max(H[R..n])",
          "若 maxLeft ≤ maxRight，则位置 L 处的积水可被唯一确定（由 maxLeft - H[L] 决定），因为右侧至少存在一个不低于 maxLeft 的右边界",
          "同理，若 maxRight < maxLeft，则 R 处的积水可被确定",
          "每次移动较小一侧的指针，保证已确定区域的贡献不会被后续操作破坏"
        ],
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_range",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "description": "是否允许柱子高度为负数（如地下坑洞模型）"
          },
          {
            "name": "dimension",
            "options": [
              "1D",
              "2D",
              "circular"
            ],
            "description": "输入结构是否扩展到二维矩阵或环形数组"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online_streaming"
            ],
            "description": "是否支持在线数据流式输入"
          },
          {
            "name": "query_type",
            "options": [
              "total_volume",
              "per_position_volume",
              "range_query"
            ],
            "description": "输出目标是总体积、逐点体积还是区间查询"
          },
          {
            "name": "update_support",
            "options": [
              "static",
              "dynamic_with_updates"
            ],
            "description": "是否支持单点修改或插入删除操作"
          },
          {
            "name": "data_order",
            "options": [
              "unsorted",
              "partially_sorted",
              "fully_sorted"
            ],
            "description": "输入数组是否有序"
          },
          {
            "name": "multiple_test_cases",
            "options": [
              true,
              false
            ],
            "description": "是否包含多组测试数据"
          }
        ]
      }
    }
  },
  {
    "title": "Reach End of Array With Max Score",
    "slug": "reach-end-of-array-with-max-score",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "name": "nums",
        "size": "n",
        "element_type": "integer",
        "constraints": [
          "1 <= n <= 10^5",
          "1 <= nums[i] <= 10^5",
          "indexed from 0 to n-1"
        ],
        "initial_position": 0,
        "target_position": "n-1",
        "movement_direction": "forward_only (j > i)"
      },
      "Core Constraint": {
        "movement_rule": "can only jump from index i to index j where j > i",
        "score_definition": "(j - i) * nums[i] for a jump from i to j",
        "path_structure": "sequence of strictly increasing indices starting at 0 and ending at n-1",
        "no_backward_movement": true,
        "single_pass": true
      },
      "Objective Function": {
        "type": "maximization",
        "goal": "maximum total score",
        "description": "sum of scores over all jumps in a valid path from index 0 to index n-1"
      },
      "Algorithmic Invariant": {
        "dp_state_invariant": "dp[i] = maximum total score achievable when reaching index i",
        "transition_rule": "for each i, update dp[j] = max(dp[j], dp[i] + (j - i) * nums[i]) for all j > i",
        "optimal_substructure": true,
        "greedy_choice_not_applicable": true,
        "monotonic_index_evolution": true,
        "irreversibility": "once advanced beyond index i, no return"
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "10^5"
        ],
        "value_domain": [
          "1",
          "10^5"
        ],
        "array_order": "arbitrary (not necessarily sorted or monotonic)",
        "input_dimensionality": "1D only (potential extension: 2D grid movement)",
        "multiple_queries": false,
        "online_input": false,
        "modifications_allowed": false,
        "objective_variants": [
          "minimize total score",
          "count number of optimal paths",
          "determine existence of path with score >= K"
        ],
        "constraint_transforms": [
          "allow backward jumps (with penalty)",
          "limit maximum jump length",
          "add energy cost per jump",
          "introduce negative values in nums"
        ],
        "output_form": "single integer (total maximum score); could extend to path reconstruction"
      }
    }
  },
  {
    "title": "Alternating Groups III",
    "slug": "alternating-groups-iii",
    "schema": {
      "Input Structure": [
        "环形一维数组 colors[0..n-1]，其中 n = len(colors)",
        "colors[i] ∈ {0, 1}，表示第 i 块瓷砖的颜色（0: 红，1: 蓝）",
        "二维查询数组 queries，每个 query 形如 [1, size] 或 [2, index, color]",
        "n 满足 4 <= n <= 5 * 10^4",
        "queries 长度不超过 5 * 10^4"
      ],
      "Core Constraint": [
        "交替组定义：连续子数组中，除首尾外，每个中间元素与其左右邻居颜色不同",
        "由于是环形结构，colors[0] 与 colors[n-1] 相邻，需满足循环相邻约束",
        "交替组的判定依赖局部三元组 (prev, curr, next) 的颜色差异性",
        "修改操作会影响至多两个原有交替组的断裂或合并"
      ],
      "Objective Function": [
        "对于类型 1 查询：统计当前环中长度恰好为 size_i 的交替组的数量",
        "对于类型 2 查询：更新 colors[index_i] 为 color_i，并维护后续查询的正确性",
        "最终输出所有类型 1 查询的结果序列"
      ],
      "Algorithmic Invariant": [
        "交替组可通过滑动窗口在线性时间内识别，但需支持动态修改",
        "每个位置最多属于一个交替组的内部（非端点），端点可共享于多个候选组边界",
        "交替组长度变化仅在颜色修改时局部影响：影响范围限于修改点前后若干连续段",
        "可维护一组区间链表或双指针结构记录当前所有极大交替段，支持 O(1) 或 O(log n) 更新",
        "利用环形结构下极大交替段的不重叠性和闭合性，实现高效计数"
      ],
      "Transformable Parameters": [
        "n 的数量级：从 1e3 到 5e4（支持离线 / 在线处理）",
        "是否为环形结构：可变换为线性版本（去环）",
        "颜色种类：从二值 {0,1} 扩展为 k 种颜色的交替模式",
        "交替定义：从‘严格交替’变为‘无连续相同颜色’或引入容忍度",
        "查询类型比例：单次查询 vs 多次修改混合",
        "是否要求实时返回每次查询结果（强制在线）",
        "目标函数变化：求最长交替组 → 求总数 → 求是否存在长度 ≥ K 的组",
        "是否允许删除/插入瓷砖（动态长度）"
      ]
    }
  },
  {
    "title": "Minimum Number of Flips to Make Binary Grid Palindromic I",
    "slug": "minimum-number-of-flips-to-make-binary-grid-palindromic-i",
    "schema": {
      "Input Structure": "二维二进制矩阵 grid[1..m][1..n]，其中 m >= 1, n >= 1, grid[i][j] ∈ {0, 1}",
      "Core Constraint": "回文性约束：一行（或一列）是回文的当且仅当其第 j 个元素与倒数第 j 个元素相等；行与列的回文状态相互独立，可通过翻转任意格子调整；每个格子最多参与一次对称位置的配对比较",
      "Objective Function": "求最小翻转次数，使得整个矩阵要么所有行都是回文的，要么所有列都是回文的（二选一）",
      "Algorithmic Invariant": "对于每行（或每列），其回文所需翻转次数等于该行（或列）中对称位置不相等的元素对的数量的一半（向下取整）；全局最优解可在‘全行回文’和‘全列回文’两种策略中取最小值；翻转操作具有可交换性和局部独立性，不影响其他非对称位置",
      "Transformable Parameters": {
        "数据规模": "1 <= m * n <= 2 * 10^5, 可扩展至更大规模在线场景",
        "值域类型": "仅限二进制 {0,1}，可推广为多值回文（如三进制、字符串字符）",
        "目标模式": "可变为目标：要求同时所有行和列回文，或恰好 k 行回文，或至少一行/列回文",
        "操作限制": "可增加操作代价差异（如0→1代价≠1→0）、最多允许k次翻转、仅允许某类值翻转",
        "输入形式": "可支持动态更新（在线翻转查询）、流式输入块、稀疏表示",
        "结构变形": "可推广至环形回文、高维张量回文（如立方体切片）、树形序列回文"
      }
    }
  },
  {
    "title": "Maximum Energy Boost From Two Drinks",
    "slug": "maximum-energy-boost-from-two-drinks",
    "schema": {
      "Input Structure": {
        "type": "two_arrays",
        "description": "两个长度均为 n 的一维数组 energyDrinkA[1..n] 和 energyDrinkB[1..n]",
        "element_constraints": "energyDrinkA[i] ≥ 1, energyDrinkB[i] ≥ 1",
        "length_constraint": "3 <= n <= 1e5"
      },
      "Core Constraint": {
        "switch_penalty": "从一种饮料切换到另一种需等待 1 小时（该小时无能量收益）",
        "no_concurrent_consumption": "每小时只能饮用一种饮料或处于切换冷却中",
        "initial_choice_free": "第一小时可自由选择 A 或 B，无切换代价"
      },
      "Objective Function": "最大化总强化能量（即：所选有效饮用小时的能量值之和）",
      "Algorithmic Invariant": {
        "dp_state_definition": "维护两个状态变量：holdA[i] 表示前 i 小时且第 i 小时饮用 A 所能获得的最大能量；holdB[i] 类似",
        "transition_rule": "holdA[i] = max(holdA[i-1], holdB[i-2]) + energyDrinkA[i-1]; 对称适用于 holdB[i]",
        "invariant_property": "状态转移保证任意时刻的最优解不破坏历史最优性，且切换约束被正确建模为延迟访问另一序列的状态",
        "boundary_handling": "初始化时考虑首项直接选取 A 或 B 的情况，无前置切换惩罚"
      },
      "Transformable Parameters": {
        "n_range": "3 <= n <= 1e5 (可调整至更小如 10^3 或更大如 1e6 以改变复杂度需求)",
        "value_domain": "energyDrinkA[i], energyDrinkB[i] ∈ [1, 1e5] (可扩展为负数、零或浮点数以构造变体)",
        "switch_cost": "当前为固定延迟 1 小时，可参数化为 k 小时冷却期",
        "start_constraint": "是否允许自由起始（可改为强制从某类开始）",
        "multiple_test_cases": "是否为多组输入（当前为单例，可拓展为 T 组数据）",
        "online_input": "是否支持在线流式输入（当前为离线批量输入）",
        "output_type": "当前输出最大总能量，可变形为输出方案路径、最小切换次数下的最大收益等"
      }
    }
  },
  {
    "title": "Minimum Number of Flips to Make Binary Grid Palindromic II",
    "slug": "minimum-number-of-flips-to-make-binary-grid-palindromic-ii",
    "schema": {
      "Input Structure": [
        "二维二进制矩阵 grid[1..m][1..n]",
        "m >= 1, n >= 1",
        "grid[i][j] ∈ {0, 1}",
        "总元素数满足 1 <= m * n <= 2 * 10^5"
      ],
      "Core Constraint": [
        "每一行必须是回文：对所有 i，有 grid[i][j] == grid[i][n+1-j] 对所有 j 成立",
        "每一列必须是回文：对所有 j，有 grid[i][j] == grid[m+1-i][j] 对所有 i 成立",
        "翻转操作可改变任意格子的值，每次翻转计数为1",
        "最终矩阵中 1 的总数必须被 4 整除"
      ],
      "Objective Function": "最小化翻转次数，使得所有行和列均为回文，且矩阵中 1 的总数 ≡ 0 (mod 4)",
      "Algorithmic Invariant": [
        "每个对称位置组（由行列回文性约束决定）中的四个角或两个边或单个中心点构成一个等价类，其值应一致以满足回文条件",
        "在最优解中，每个等价类内的所有元素应统一为该类中出现频率更高的值（贪心不变量）",
        "翻转后 1 的总数 mod 4 的状态可通过局部调整（如额外翻转一对对称位）进行微调而不破坏回文结构",
        "回文约束将原矩阵划分为独立的对称变量组，每组决策互不影响"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m * n 范围": "1 ~ 2e5",
          "是否允许更大规模（如支持 1e6）": false,
          "是否稀疏矩阵": false
        },
        "输入形式": {
          "是否离线批量处理": true,
          "是否在线流式输入": false,
          "是否多组测试用例": true
        },
        "约束条件": {
          "是否强制 1 的数量被 k 整除": "k=4（可变参数 k）",
          "是否取消整除约束": false,
          "是否仅要求行回文或列回文": false
        },
        "矩阵形状": {
          "是否正方形": "可变为矩形、细长型",
          "是否环形回文（首尾相连）": false
        },
        "数值类型": {
          "是否扩展到多进制（如三进制）": false,
          "是否允许负值": false
        },
        "操作限制": {
          "是否限制翻转次数上限": false,
          "是否只能翻转特定区域": false,
          "是否支持删除/插入行或列": false
        },
        "目标函数变形": [
          "改为判定是否存在解",
          "改为计数满足条件的方案数",
          "改为构造字典序最小结果"
        ]
      }
    }
  },
  {
    "title": "Find the Power of K-Size Subarrays II",
    "slug": "find-the-power-of-k-size-subarrays-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": "[1, 1e6]",
        "constraints": [
          "nums.length == n",
          "1 <= n <= 1e5",
          "1 <= k <= n"
        ]
      },
      "Core Constraint": {
        "subarray_condition": "子数组必须严格连续且上升",
        "continuous_condition": "对于长度为 k 的子数组 nums[i..i+k-1]，需满足 nums[j] + 1 = nums[j+1] 对所有 j ∈ [i, i+k-2]",
        "monotonicity": "必须严格递增",
        "local_determination": "每个子数组的能量值仅由其内部元素决定，无全局依赖"
      },
      "Objective Function": {
        "type": "per_subarray_evaluation",
        "output_form": "array of length n - k + 1",
        "value_definition": "若子数组连续上升，则为其最大元素（即最后一个元素）；否则为 -1",
        "goal": "对每个起始位置 i，计算子数组 nums[i..i+k-1] 的能量值"
      },
      "Algorithmic Invariant": {
        "sliding_window_validity_check": "通过滑动窗口遍历所有长度为 k 的子数组",
        "incremental_validation": "相邻窗口间可复用部分信息：检查 nums[i-1+k-1] + 1 == nums[i+k-1] 可快速判断新窗口是否延续连续性",
        "boundary_independence": "每个子数组的判定独立，不依赖其他子数组结果",
        "last_element_max": "若子数组连续上升，则最大值恒为末尾元素"
      },
      "Transformable Parameters": {
        "n_value": "1e5 (可调整至更小或更大以适应不同复杂度要求)",
        "k_value": "可变参数，支持 k=1 或 k=n 的边界情况",
        "array_order": "输入数组无序，但子数组需局部有序",
        "continuity_definition": "可变形为非严格连续（如允许重复）、环形连续等",
        "energy_function": "可修改为目标函数如最小值、长度、是否存在等",
        "output_format": [
          "返回完整 results 数组",
          "仅返回最大能量值",
          "返回满足条件的子数组个数"
        ],
        "input_type": "可扩展为多维数组切片、在线流式输入子数组",
        "constraint_modality": "可改为‘至少有 m 个连续元素’或‘最多断开一次’等软约束"
      }
    }
  },
  {
    "title": "Find the Power of K-Size Subarrays I",
    "slug": "find-the-power-of-k-size-subarrays-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "subarray_length": "k",
        "value_range": "[1, 10^5]",
        "order": "arbitrary"
      },
      "Core Constraint": {
        "condition": "子数组能量值的合法性依赖于两个条件：(1) 元素是否连续递增（即 nums[i+1] == nums[i] + 1）；(2) 整个子数组严格上升且相邻元素差为1",
        "dependency": "局部连续性约束：每个位置的值必须恰好比前一个大1，否则整个窗口失效",
        "determinism": "一旦发现任意相邻元素不满足递增连续，则该子数组能量值立即为-1"
      },
      "Objective Function": {
        "type": "construction",
        "output_per_subarray": "max_element_if_consecutively_increasing_else_-1",
        "goal": "对每一个长度为 k 的连续子数组，判断其是否为连续上升序列，若是则输出最大值，否则输出 -1",
        "result_structure": "长度为 n - k + 1 的整数数组 results，其中 results[i] 对应子数组 nums[i..i+k-1] 的能量值"
      },
      "Algorithmic Invariant": {
        "sliding_window_validity": "窗口滑动时，只需检查新进入和离开的元素对连续递增性质的影响",
        "local_check_suffices": "若一个长度为 k 的子数组是连续递增，则必有：对于所有 j ∈ [i+1, i+k-1]，nums[j] == nums[j-1] + 1",
        "monotonic_break": "只要有一个位置不满足 nums[j] == nums[j-1] + 1，则整个窗口无效，无需进一步验证",
        "maximum_computation": "若窗口有效，最大值 = 起始值 + k - 1，也可直接取窗口末尾元素"
      },
      "Transformable Parameters": {
        "n_magnitude": "small (≤ 500), 允许 O(nk) 解法",
        "k_value": "可变参数，支持从 1 到 n",
        "array_order": "原始顺序不可变，但可考虑排序后变形题",
        "continuity_definition": "可调整为非严格连续、模意义下连续（环形）、或允许一次跳跃等",
        "energy_function": "可改为求最小值、长度、计数符合条件的子数组个数等",
        "output_format": [
          "仅返回最大值列表",
          "返回每个子数组是否合法的布尔数组",
          "返回所有合法子数组的最大值之和（计数型目标）"
        ],
        "input_mode": "offline batch processing（一次性输入），可扩展为在线流式输入查询固定k的滑窗能量值",
        "multiple_queries": "是否多组(k_i)查询，推动预处理结构设计",
        "negative_values_allowed": "当前不允许，可作为变形：允许负数并定义跨零连续"
      }
    }
  },
  {
    "title": "Count Triplets with Even XOR Set Bits II",
    "slug": "count-triplets-with-even-xor-set-bits-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the distance between their indices and the minimum of their heights.",
        "key_insight": "For any two lines at positions i and j (i < j), the area they form is (j - i) * min(height[i], height[j]). The bottleneck is the shorter line."
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "the maximum area that can be formed by two lines from the array"
      },
      "Algorithmic Invariant": {
        "invariant": "Two-pointer inward convergence with monotonic elimination",
        "rules": [
          "Initialize left = 0, right = n - 1.",
          "At each step, compute the area formed by height[left] and height[right].",
          "Move the pointer pointing to the shorter line inward, because moving the taller one cannot increase the area (width decreases and height is bounded by the shorter).",
          "This greedy move preserves optimality: the eliminated configurations are provably not better than current or future candidates."
        ],
        "proof_sketch": "If height[left] < height[right], then for all positions k in (left, right), (k - left) * min(height[left], height[k]) ≤ (right - left) * height[left], so no better area can be found with fixed left. Hence, left can be safely advanced."
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 1e5",
          "small n: brute-force feasible"
        ],
        "value_domain": "height[i] >= 0; variant: allow negative values (meaningless physically, but possible in generalization)",
        "ordering": "unsorted; variant: sorted or partially ordered",
        "input_dimension": "1D → 2D (e.g., matrix version where containers are in grid)",
        "circular": false,
        "online_queries": false,
        "data_updates": false,
        "output_type": "single value (maximum area); variant: return indices or all optimal pairs",
        "multiple_test_cases": false,
        "constraints_on_indices": "variant: require |i - j| >= K or other spacing constraints"
      }
    }
  },
  {
    "title": "Year on Year Growth Rate",
    "slug": "year-on-year-growth-rate",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at that position."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the distance between their indices and the minimum of their heights.",
        "key_insight": "For any two lines at positions i and j (i < j), the area they form is (j - i) * min(height[i], height[j]). The optimal solution must balance width and height constraints."
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "the amount of water a container can store",
        "type": "maximum value",
        "excludes": [
          "counting",
          "decision",
          "construction"
        ]
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers moving towards each other maintain the property that no unseen pair can yield a larger area than the current maximum if the shorter line is fixed.",
        "rules": [
          "Initialize left = 0, right = n - 1.",
          "At each step, compute the area formed by height[left] and height[right].",
          "Always move the pointer pointing to the shorter line inward, because moving the taller one cannot increase the area (width decreases and height is bounded by the shorter).",
          "This ensures that all potentially optimal pairs are considered without exhaustive search."
        ],
        "proof_sketch": "By always advancing the shorter end, we eliminate only configurations that cannot outperform the current best under the min-height constraint."
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 1e5",
          "small n: brute-force viable"
        ],
        "value_domain": "height[i] >= 0",
        "ordering": "unsorted input; relative order matters geometrically",
        "dimensionality": "1D → possible extension to 2D grid or circular arrangement",
        "query_mode": "offline single instance",
        "updates": "static array; could be extended to support point updates or insertions",
        "output_type": "single integer (max area); could require indices or multiple queries",
        "variations": [
          "Target function change: count number of valid containers above threshold K",
          "Constraint reversal: maximize area with at most K units of water",
          "Online version: process queries for max area in subarray",
          "Hidden monotonicity: data arrives in stream, detect maximal pair so far"
        ]
      }
    }
  },
  {
    "title": "Find the Number of Winning Players",
    "slug": "find-the-number-of-winning-players",
    "schema": {
      "Input Structure": [
        "整数 n，表示玩家数量，范围 [2, 10]",
        "二维整数数组 pick，其中 pick[i] = [x_i, y_i]",
        "x_i ∈ [0, n-1] 表示玩家编号",
        "y_i ∈ [0, 10] 表示球的颜色"
      ],
      "Core Constraint": [
        "每个玩家获得的球按颜色分组统计",
        "玩家 i 成为胜利玩家的条件是：存在至少一种颜色 c，使得该玩家拥有颜色 c 的球的数量 ≥ i + 1",
        "不同颜色之间独立，不合并计数",
        "胜利判定仅依赖于单个玩家内部的颜色频次分布"
      ],
      "Objective Function": "计数 —— 统计满足胜利条件的玩家总数",
      "Algorithmic Invariant": [
        "对每个玩家独立维护其各颜色球的计数映射（哈希表）",
        "一旦某个玩家的某一颜色计数达到 i + 1，则该玩家可标记为胜利，无需后续更新",
        "玩家之间的判断完全独立，无依赖关系"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可扩展至 1e5（需优化输入规模）",
        "pick 长度": "当前 ≤100，可变为更大规模或流式输入",
        "颜色值域": "当前 [0,10]，可扩大或离散化处理",
        "是否多组数据": "可设为多测输入形式",
        "是否在线": "可改为动态添加 pick 操作，支持查询实时胜利玩家数",
        "胜利条件变形": [
          "由 '严格大于 i' 改为 '等于 i+1'",
          "改为所有颜色球总数 > i",
          "引入多种颜色组合才能胜利（如两种颜色各≥i/2）"
        ],
        "输出形式": [
          "仅返回数目",
          "改为返回所有胜利玩家列表",
          "要求按顺序输出或去重"
        ]
      }
    }
  },
  {
    "title": "Maximum Multiplication Score",
    "slug": "maximum-multiplication-score",
    "schema": {
      "Input Structure": [
        "一维整数数组 a[0..3]",
        "一维整数数组 b[0..m-1]，其中 m >= 4",
        "a[i], b[i] ∈ [-10^5, 10^5]",
        "数组 a 长度固定为 4"
      ],
      "Core Constraint": [
        "必须从数组 b 中选择 4 个严格递增下标的元素：i₀ < i₁ < i₂ < i₃",
        "得分由线性组合 a[0]*b[i₀] + a[1]*b[i₁] + a[2]*b[i₂] + a[3]*b[i₃] 决定",
        "a 数组系数可正可负，影响贪心方向",
        "选择顺序与 a 的索引一一对应，即 a[k] 必须乘以 b 中第 k 个选中的元素"
      ],
      "Objective Function": "最大化线性加权和（最大得分）",
      "Algorithmic Invariant": [
        "动态规划状态：dp[k][i] 表示使用 a 的前 k+1 项，并以 b[i] 作为第 k+1 项时的最大得分",
        "状态转移满足最优子结构：dp[k][i] = max_{j < i}(dp[k-1][j]) + a[k] * b[i]",
        "每层 k 的状态仅依赖于前一层的前缀最大值，可滚动优化",
        "若 a[k] >= 0，则倾向于选择较大的 b[i]；若 a[k] < 0，则倾向于选择较小的 b[i] —— 贪心方向随系数符号变化"
      ],
      "Transformable Parameters": {
        "数组 a 的长度": {
          "当前值": 4,
          "可变范围": "扩展为 k（如 k=3 或 k=5），形成通用模式"
        },
        "数组 b 的长度": {
          "当前值": ">=4, <=1e5",
          "可变形式": "是否允许更小或极大规模（如 1e6，在线处理）"
        },
        "数据值域": {
          "当前范围": [
            -100000,
            100000
          ],
          "变形可能": "非负限制、全正、全负、浮点数"
        },
        "是否有序": {
          "当前": "b 无序",
          "变形": "b 有序 → 可用贪心直接选极值"
        },
        "目标函数类型": {
          "当前": "最大化",
          "可变换": "最小化、计数方案数、判定是否存在大于某值的解"
        },
        "输入形式": {
          "当前": "一次性离线输入",
          "可扩展": "在线流式输入 b，要求实时维护最大得分候选"
        },
        "多组数据": {
          "当前": "单组",
          "可支持": "多组测试用例，共享预处理结构"
        },
        "约束条件变化": {
          "下标限制": "是否允许重复下标（不允许）、是否环形数组",
          "选择数量": "是否改为选择 3 个或 5 个元素"
        }
      }
    }
  },
  {
    "title": "Shortest Distance After Road Addition Queries I",
    "slug": "shortest-distance-after-road-addition-queries-i",
    "schema": {
      "Input Structure": [
        "一维城市线性排列：城市编号为 0 到 n-1",
        "初始单向边：i → i+1（对所有 0 ≤ i < n-1）",
        "二维整数数组 queries，其中 queries[i] = [u_i, v_i] 表示新增一条从 u_i 到 v_i 的单向边",
        "保证 u_i < v_i 且 v_i - u_i > 1",
        "图是有向无环图（DAG）的扩展结构"
      ],
      "Core Constraint": [
        "图结构随查询逐步演化（动态加边）",
        "每次新增边后，需重新计算从起点 0 到终点 n-1 的最短路径",
        "由于所有边都从低编号指向高编号，图始终保持 DAG 结构",
        "最短路径仅依赖拓扑顺序，无需考虑环或负权"
      ],
      "Objective Function": "对于每个前缀查询集合（前 i+1 条边添加后），输出从城市 0 到城市 n-1 的最短路径长度",
      "Algorithmic Invariant": [
        "基于 DAG 的动态规划：dist[i] 表示从 0 到 i 的最短距离，初始 dist[0] = 0，其余为无穷大",
        "每次加入新边 u → v 后，尝试用 dist[u] + 1 更新 dist[v]",
        "更新可沿拓扑序传播：若 dist[v] 被更新，则其所有后继可能被进一步松弛",
        "由于节点编号即拓扑序，可按 0 到 n-1 顺序进行松弛操作",
        "每轮查询后的最短路可通过局部松弛完成增量更新，避免全图 BFS/DP 重算"
      ],
      "Transformable Parameters": {
        "n 的数量级": "3 <= n <= 500（适合 O(n^2) 或 O(q*n) 解法）",
        "queries 长度": "1 <= q <= 500",
        "输入形式": "离线批量查询，但要求在线回答每个前缀状态",
        "是否多组数据": "否（单实例），但可扩展为多测",
        "是否在线": "边是逐步加入的，问题具有‘半在线’特性",
        "图结构变化类型": "仅支持单向边添加，不支持删除或修改",
        "边的方向约束": "当前限制为 u < v，可变形为允许反向边或双向边",
        "权重设置": "当前为单位权重（边权为1），可推广为带权边",
        "目标节点变化": "固定为从 0 到 n-1，可改为任意终点或多终点"
      }
    }
  },
  {
    "title": "Design Neighbor Sum Service",
    "slug": "design-neighbor-sum-service",
    "schema": {
      "Input Structure": [
        "二维数组 grid[1..n][1..n]",
        "n ∈ [3, 10]",
        "grid 包含 [0, n² - 1] 内所有不重复整数",
        "每个值唯一对应一个坐标 (i, j)"
      ],
      "Core Constraint": [
        "元素位置关系由二维网格拓扑决定",
        "相邻定义为四连通方向（上、下、左、右）",
        "对角线相邻定义为四对角方向（左上、右上、左下、右下）",
        "查询操作基于值定位坐标，再考察其邻域"
      ],
      "Objective Function": [
        "adjacentSum(value): 返回与 value 四连通相邻元素之和",
        "diagonalSum(value): 返回与 value 四对角相邻元素之和"
      ],
      "Algorithmic Invariant": [
        "每个值在 grid 中唯一，可预建 value → (i, j) 映射",
        "一旦知道 value 的坐标 (i, j)，其邻居坐标可通过方向偏移确定",
        "边界检查保证不越界访问：0 ≤ i, j < n",
        "邻域结构固定，支持 O(1) 查询求和"
      ],
      "Transformable Parameters": {
        "n 的数量级": "3 <= n <= 10（当前），可扩展至更大规模以要求优化",
        "值域特性": "[0, n²-1] 不重复整数（可变：是否连续、是否允许重复）",
        "是否有序": "grid 无序（可变：行/列有序）",
        "是否循环": "非环形网格（可变：循环边界/环形网格）",
        "是否多组输入": "单个 grid 初始化（可变：支持多实例或动态切换）",
        "是否在线": "是，在初始化后支持在线查询",
        "操作类型": [
          "支持两种查询：adjacentSum、diagonalSum",
          "可变：增加 knight-move 相邻、扩展 k 层邻域等"
        ],
        "输出形式": "返回整数和（可变：返回列表、最大值、模意义下和等）",
        "调用次数限制": "最多 2 * n² 次查询（暗示预处理可行）"
      }
    }
  },
  {
    "title": "Find if Digit Game Can Be Won",
    "slug": "find-if-digit-game-can-be-won",
    "schema": {
      "Input Structure": [
        "一维数组 nums[1..n]",
        "nums[i] ∈ 正整数",
        "1 <= n <= 100",
        "1 <= nums[i] <= 99",
        "数字为个位数（1–9）或两位数（10–99）"
      ],
      "Core Constraint": [
        "Alice 只能选择全部个位数或全部两位数（二选一策略）",
        "选择具有排他性：一旦选定某一类，另一类自动归 Bob",
        "总和分配完全由分类决定，无中间状态或混合选择"
      ],
      "Objective Function": "判定是否存在一种选择（个位数或两位数），使得 Alice 所选数字之和 严格大于 Bob 的数字之和",
      "Algorithmic Invariant": [
        "两类数字可预先分离并求和（前处理不变量）",
        "全局和固定：sum_total = sum_Alice + sum_Bob",
        "Alice 获胜条件等价于：sum_selected > sum_total / 2",
        "只需验证两个候选方案中的最大值是否满足严格大于条件"
      ],
      "Transformable Parameters": {
        "数值范围": "可扩展至三位数及以上，引入更多类别",
        "分类规则": "从‘位数’改为其他特征（如奇偶、模k余数、质数/合数）",
        "选择方式": "从‘全取一类’变为‘最多选k个’或‘成本限制下选择’",
        "目标函数形式": [
          "改为最小化差值",
          "计数有多少种分类策略可获胜",
          "构造使游戏公平的最小修改"
        ],
        "输入结构变化": [
          "是否允许负数或零",
          "是否多组玩家轮流选择（博弈树延伸）"
        ],
        "数据流模式": "是否在线输入（动态判断当前是否可能获胜）",
        "约束强度": "从‘严格大于’变为‘大于等于’或‘至少超过K’"
      }
    }
  },
  {
    "title": "Shortest Distance After Road Addition Queries II",
    "slug": "shortest-distance-after-road-addition-queries-ii",
    "schema": {
      "Input Structure": [
        "整数 n，表示城市数量（编号从 0 到 n-1）",
        "初始时存在单向边：对所有 i ∈ [0, n-2]，有边 i → i+1",
        "二维整数数组 queries，其中 queries[i] = [u_i, v_i] 表示添加一条新的单向边 u_i → v_i",
        "保证：u_i < v_i，且 v_i - u_i > 1",
        "输入规模：n ≤ 1e5, queries.length ≤ 1e5"
      ],
      "Core Constraint": [
        "图是有向无环图（DAG），节点按编号递增排列",
        "新增的边是前向跳跃边（jump edge），可缩短路径",
        "关键约束：不存在两个查询满足交叉关系 queries[i][0] < queries[j][0] < queries[i][1] < queries[j][1]",
        "该约束保证了跳跃区间之间最多为嵌套或不相交，不能交叉 → 支持单调性维护"
      ],
      "Objective Function": [
        "在线处理每次查询后，求从城市 0 到城市 n-1 的最短路径长度",
        "输出为长度数组 answer，answer[i] 对应前 i+1 次添加后的最短距离"
      ],
      "Algorithmic Invariant": [
        "最短路径在 DAG 上可通过 DP 或 BFS 更新：dist[i] = min(dist[j] + 1) for all j → i",
        "利用跳跃边的非交叉性质，可维护一个关于可达区间的单调结构（如单调栈或有序集合）",
        "当加入新边 u → v 时，若它能更新 dist[v]，则可能触发后续传播，但由于边是前向的，可按拓扑序处理",
        "不变量：dist 数组始终满足 dist[i] ≤ dist[j] + (i - j) 当 i > j（位置越靠后，距离不会因更长跳跃而变差）",
        "非交叉条件允许将有效跳跃边组织成可合并的区间结构，避免重复松弛"
      ],
      "Transformable Parameters": [
        "n 的数量级：[3, 1e5]",
        "queries 长度：[1, 1e5]",
        "是否离线处理：当前为在线添加，可变体支持离线批处理",
        "图结构形式：链式基础图 + 动态加边",
        "边方向限制：仅允许前向边（u < v）",
        "是否存在交叉约束：原题禁止交叉，可变形为允许交叉 → 升级为一般 DAG 最短路问题",
        "是否允许多重边或自环：题目禁止",
        "目标点固定为 n-1，可推广为任意终点查询",
        "是否要求构造路径方案：当前只需长度",
        "是否支持删边操作：当前只增不删，可扩展为动态图"
      ]
    }
  },
  {
    "title": "Maximum Array Hopping Score I",
    "slug": "maximum-array-hopping-score-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "description": "Given an integer array height of length n, where each element represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the distance between their indices and the minimum of their heights.",
        "reasoning": "Due to the geometric nature of the problem, the maximal container must balance width (index difference) and bottleneck height (min of two ends)."
      },
      "Objective Function": {
        "goal": "maximize",
        "target": "the amount of water that can contain between two lines"
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers start from both ends; at each step, moving the shorter-end pointer inward never loses the optimal solution.",
        "proof_hint": "Because the area is limited by the shorter height, advancing the taller side cannot yield a better result under reduced width, preserving optimality."
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 10^5",
        "value_domain": "0 <= height[i] <= 10^4",
        "ordering": "unsorted",
        "circular": false,
        "online_query": false,
        "multiple_cases": false,
        "output_detail": "return only the maximum area, not the indices",
        "modifications_allowed": false,
        "extensions": [
          "2D version: matrix with elevation map",
          "with obstacles or variable ground level",
          "dynamic updates: add/remove lines",
          "target change: count number of valid containers above threshold K"
        ]
      }
    }
  },
  {
    "title": "Bitwise User Permissions Analysis",
    "slug": "bitwise-user-permissions-analysis",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "An integer array height of length n, where each element represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the minimum of their heights and the distance between them.",
        "dependency": "Pairwise comparison of elements with positional separation",
        "independence": "No dependency on intermediate elements between the two chosen lines"
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "the container that can hold the most water",
        "output_type": "integer",
        "description": "Find two lines that together with the x-axis form a container such that the container contains the most water."
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariants": [
          "The left pointer starts at the beginning and the right pointer at the end, ensuring maximum initial width.",
          "At each step, moving the shorter-height pointer preserves the possibility of finding a larger area due to potential height increase.",
          "The area formed by the current pair is locally optimal in the sense that all containers involving the shorter line and any inner line cannot exceed the current candidate when outer lines are wider."
        ],
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "n_range": [
          2,
          100000
        ],
        "value_range": [
          0,
          10000
        ],
        "sorted_input": false,
        "circular_array": false,
        "online_queries": false,
        "multiple_test_cases": true,
        "modifiable_array": false,
        "output_detail": "only maximum area value",
        "extensions": [
          "2D version: matrix with elevation data",
          "with obstacles or forbidden positions",
          "dynamic updates: add/remove lines",
          "count number of containers exceeding threshold K",
          "target transformation: minimize area under constraint"
        ]
      }
    }
  },
  {
    "title": "Find the Winning Player in Coin Game",
    "slug": "find-the-winning-player-in-coin-game",
    "schema": {
      "Input Structure": {
        "description": "两个正整数 x 和 y",
        "types": [
          "x: 正整数，表示价值为 75 的硬币数量",
          "y: 正整数，表示价值为 10 的硬币数量"
        ],
        "constraints": [
          "1 <= x <= 100",
          "1 <= y <= 100"
        ],
        "structure": "一维离散资源对 (x, y)"
      },
      "Core Constraint": {
        "description": "每轮操作必须恰好拿走总和为 115 的硬币组合，且每次操作由当前玩家完成；无法操作者输",
        "operation_rule": "每次操作需满足 75 * a + 10 * b = 115，其中 a 是拿走的 75 面值硬币数，b 是拿走的 10 面值硬币数",
        "feasible_moves": [
          "唯一可行解：a = 1, b = 4 （因为 75*1 + 10*4 = 115）"
        ],
        "implication": "每轮操作固定消耗 1 枚 75 硬币和 4 枚 10 硬币",
        "state_evolution": "状态 (x, y) 按照确定性规则转移至 (x-1, y-4)，直到任一资源不足为止"
      },
      "Objective Function": {
        "type": "判定类问题",
        "goal": "判断在双方均采用最优策略的前提下，最终谁会获胜",
        "output": "返回 'Alice' 或 'Bob'"
      },
      "Algorithmic Invariant": {
        "invariant_type": "博弈状态奇偶性不变量",
        "key_insight": "游戏胜负仅取决于最多可执行的操作轮数是否为奇数",
        "reasoning": "Alice 先手，若总可行轮数 k 为奇数，则 Alice 赢；否则 Bob 赢",
        "deterministic_transition": "由于每次操作唯一（1枚75 + 4枚10），无分支选择，最优策略即贪心执行合法操作",
        "monotonicity": "状态 (x, y) 单调递减，不会回溯或分支"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "硬币面值组合",
            "example_values": [
              "(75,10) → (50,15)",
              "(v1,v2)"
            ],
            "effect": "改变可行操作集合，可能引入多解法或动态规划需求"
          },
          {
            "name": "目标总和 S",
            "example_values": [
              "115 → 任意正整数"
            ],
            "effect": "影响是否存在可行解及解的数量"
          },
          {
            "name": "操作模式",
            "example_values": [
              "固定消耗 → 可变组合",
              "单种操作 → 多种合法(a,b)组合"
            ],
            "effect": "从唯一路径变为决策树，需使用博弈DP"
          },
          {
            "name": "数据规模",
            "example_values": [
              "x,y <= 100 → 更大范围或高精度"
            ],
            "effect": "影响是否可用模拟或需要数学公式"
          },
          {
            "name": "是否允许多组测试用例",
            "example_values": [
              false,
              true
            ],
            "effect": "决定预处理或打表可行性"
          },
          {
            "name": "是否在线输入",
            "example_values": [
              false,
              true
            ],
            "effect": "影响算法响应方式设计"
          },
          {
            "name": "胜负条件变形",
            "example_values": [
              "无法操作者输 → 最后拿者赢 / 得分制"
            ],
            "effect": "改变目标函数语义"
          }
        ]
      }
    }
  },
  {
    "title": "Maximize the Total Height of Unique Towers",
    "slug": "maximize-the-total-height-of-unique-towers",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"array\",\n    \"description\": \"一维数组 maximumHeight[1..n]\",\n    \"element\": \"positive integer\",\n    \"constraints\": [\n      \"maximumHeight[i] >= 1\",\n      \"n in [1, 1e5]\",\n      \"values can be repeated\"\n    ]\n  },\n  \"Core Constraint\": {\n    \"description\": \"每个塔的高度必须是正整数且不超过其最大允许高度，所有塔的高度互不相同\",\n    \"key_observations\": [\n      \"高度分配需满足全局唯一性约束\",\n      \"若存在过多塔集中在小值域，则可能无解（如示例3）\",\n      \"最优策略应尽可能将较大的可用高度分配给某座塔，避免浪费高上限\"\n    ]\n  },\n  \"Objective Function\": {\n    \"type\": \"maximization\",\n    \"target\": \"sum of assigned heights\",\n    \"fallback\": -1 if no valid assignment exists\n  },\n  \"Algorithmic Invariant\": {\n    \"principle\": \"贪心可解：按 maximumHeight 排序后，从低限到高限依次分配未使用的最小合法高度\",\n    \"invariants\": [\n      \"已处理的塔不会影响后续更高上限塔的最优性\",\n      \"每一步分配保持剩余可选高度集合的连续性和可行性\",\n      \"若当前塔无法分配合法高度，则整体无解\"\n    ],\n    \"proof_hint\": \"交换论证：任何最优解可通过调整变为按 maximumHeight 排序后的贪心分配形式而不劣化结果\"\n  },\n  \"Transformable Parameters\": {\n    \"n_range\": \"[1, 1e5]\",\n    \"value_domain\": \"[1, 1e9]\",\n    \"ordering\": \"unsorted input; sorting is part of solution strategy\",\n    \"uniqueness_constraint\": \"strictly distinct positive integers\",\n    \"output_form\": \"single integer: maximum total height or -1\",\n    \"multi_query\": false,\n    \"online_input\": false,\n    \"modifications_allowed\": false,\n    \"extensions\": [\n      \"allow zero or negative heights (with redefinition)\",\n      \"add grouping constraints (e.g., adjacent towers cannot have similar heights)\",\n      \"change objective to minimize variance under uniqueness\",\n      \"2D version: grid of towers with local uniqueness in neighborhoods\"\n    ]\n  }\n}"
  },
  {
    "title": "K-th Largest Perfect Subtree Size in Binary Tree",
    "slug": "k-th-largest-perfect-subtree-size-in-binary-tree",
    "schema": {
      "Input Structure": "二叉树 root，其中每个节点具有左子节点和右子节点指针；节点值为整数；树的节点数 n ∈ [1, 2000]；给定整数 k ∈ [1, 1024]",
      "Core Constraint": "完美二叉树要求：每个非叶节点恰好有两个子节点，且所有叶子节点处于同一深度；一个子树是完美二叉树当且仅当其左右子树均为完美二叉树且高度相同；子树大小可通过递归结构自底向上验证",
      "Objective Function": "返回第 k 大的完美二叉子树的大小（按非递增顺序排序后取第 k 个），若完美二叉子树数量少于 k，则返回 -1",
      "Algorithmic Invariant": "采用后序遍历（post-order traversal）进行自底向上验证：\n- 对每个节点，判断其左右子树是否均为完美二叉树且高度相等；\n- 若满足条件，则当前子树为完美二叉树，其高度为子树高度 + 1，大小可计算为 2^h - 1；\n- 所有合法完美子树的大小被收集并排序，维护全局有序列表不变性；\n- 递归过程中，状态传递仅依赖子树返回的高度与是否完美，无回溯破坏",
      "Transformable Parameters": {
        "数据规模": "树节点数范围 [1, N]，N 可调整至 1e5 或更高以测试效率；k 的范围可扩展",
        "树结构变体": "可推广至完全二叉树、满二叉树或其他正则树结构作为判定目标",
        "目标函数变换": "改为求第 k 小、最大数量、计数问题（如大小为 s 的完美子树个数）、是否存在大小 ≥ s 的完美子树",
        "输入形式": "支持多组测试数据；或在线动态插入/删除节点后查询",
        "输出形式": "返回子树根节点列表、所有候选大小的有序序列、或仅布尔判定",
        "约束松弛": "允许近似完美（如容许少量缺失叶子）、或限定子树深度范围"
      }
    }
  },
  {
    "title": "Number of Bit Changes to Make Two Integers Equal",
    "slug": "number-of-bit-changes-to-make-two-integers-equal",
    "schema": {
      "Input Structure": "两个正整数 n 和 k，其中 1 <= n, k <= 10^6；考虑其二进制表示（长度至多为 20 位）",
      "Core Constraint": "只能将 n 的二进制位中值为 1 的位改为 0，不能将 0 改为 1；因此 n 只能通过减少 1 的数量来逼近 k，且最终结果必须满足 n == k",
      "Objective Function": "求最小更改次数（即最少将多少个 1 改为 0），使得 n 变为 k；若无法实现则返回 -1",
      "Algorithmic Invariant": "n 的二进制中所有被置零的位置必须是原为 1 的位置；k 中为 1 的位在 n 中也必须为 1，否则无法构造成功（贪心可行性条件）；操作具有单调性：一旦某位从 1 变为 0，不可逆，且不会影响更高位的合法性",
      "Transformable Parameters": [
        "数据规模：n, k 的范围（如扩展到 10^9 或更大，需使用位运算优化）",
        "是否允许多次操作类型变化（例如也可将 0 改为 1，变为汉明距离问题）",
        "是否支持在线查询：多次 (n, k) 查询，预处理幂次或掩码",
        "输入形式：是否直接给出二进制字符串而非整数",
        "是否要求输出具体修改方案路径",
        "是否限制只能修改连续区间内的 1",
        "是否加入代价权重（不同位修改代价不同）"
      ]
    }
  },
  {
    "title": "Find the Count of Numbers Which Are Not Special",
    "slug": "find-the-count-of-numbers-which-are-not-special",
    "schema": {
      "Input Structure": {
        "type": "interval of integers",
        "domain": "positive integers",
        "variables": [
          {
            "name": "l",
            "description": "left endpoint of the interval",
            "constraint": "1 <= l <= r"
          },
          {
            "name": "r",
            "description": "right endpoint of the interval",
            "constraint": "l <= r <= 1e9"
          }
        ]
      },
      "Core Constraint": {
        "definition": "A number x is 'special' if it has exactly two proper divisors (positive divisors excluding x itself).",
        "mathematical_form": "count({d | d divides x, 1 <= d < x}) == 2",
        "implication": "The condition implies that x must have exactly three positive divisors in total (including x), which occurs if and only if x is the square of a prime number."
      },
      "Objective Function": {
        "goal": "count",
        "target": "numbers in [l, r] that are NOT special numbers",
        "complement": "total numbers in range minus count of special numbers"
      },
      "Algorithmic Invariant": {
        "number_theory_invariant": "A number has exactly three positive divisors if and only if it is p^2 where p is a prime.",
        "prime_square_condition": "Only perfect squares of primes can be special numbers.",
        "efficiency_implication": "Instead of factoring every number in [l, r], we can generate all prime squares within the range by iterating over primes up to sqrt(r)."
      },
      "Transformable Parameters": {
        "data_range": {
          "n": "up to 1e9",
          "range_length": "can be large, so direct iteration not feasible"
        },
        "input_form": "single query interval [l, r]",
        "online_offline": "can be extended to multiple queries (offline) with Mo's algorithm or precomputed sieve",
        "value_domain": "positive integers, no negatives or zero",
        "structural_variation": [
          "change definition of 'special': e.g., exactly k proper divisors",
          "change objective: count special numbers instead",
          "extend to higher dimensions: pairs (a,b) such that gcd(a,b) is special",
          "add constraints: require special numbers to be even / odd / palindromic"
        ],
        "computation_mode": "offline counting; could become online with pre-sieve of prime squares up to 1e9"
      }
    }
  },
  {
    "title": "Count Triplets with Even XOR Set Bits I",
    "slug": "count-triplets-with-even-xor-set-bits-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "notation": "H[1..n]",
        "description": "一维非负整数数组，表示柱子的高度"
      },
      "Core Constraint": {
        "constraint": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右边界约束可分离但需全局信息一致",
        "key_insight": "局部积水容量依赖于两侧极值的最小值与当前高度之差"
      },
      "Objective Function": {
        "goal": "sum",
        "objective": "计算整个数组所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "two-pointers",
        "invariants": [
          "维护左指针L及其左边的最大高度maxLeft",
          "维护右指针R及其右边的最大高度maxRight",
          "若maxLeft ≤ maxRight，则当前位置L的积水可确定，移动L",
          "若maxRight < maxLeft，则当前位置R的积水可确定，移动R",
          "指针移动过程中已确定区域的解不变且最优"
        ]
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 10^5",
        "value_range": "0 <= H[i] <= 10^4",
        "negatives_allowed": false,
        "dimension_extension": "2D variant: matrix rainfall trapping",
        "circular_array": false,
        "online_input": false,
        "output_granularity": "total sum only",
        "support_updates": false,
        "multiple_queries": false,
        "input_order": "arbitrary (not necessarily sorted)",
        "data_streaming": false
      }
    }
  },
  {
    "title": "Find Cities in Each State",
    "slug": "find-cities-in-each-state",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "An array height[0..n-1] where each element represents the height of a vertical line at that index."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is limited by the shorter line and the distance between them.",
        "key_insight": "For any two indices i and j (i < j), the container's capacity is determined by min(height[i], height[j]) * (j - i).",
        "structure_dependency": "Pairwise comparison with geometric spacing; no overlapping containers allowed in optimal solution."
      },
      "Objective Function": {
        "goal": "maximize",
        "output_type": "single_value",
        "objective": "Find the maximum area of water that can be contained between any two lines."
      },
      "Algorithmic Invariant": {
        "invariant": "Two-pointer monotonic convergence",
        "rules": [
          "Initialize left = 0, right = n-1.",
          "At each step, the smaller height side has its pointer moved inward because moving the taller side cannot increase area due to width decrease.",
          "The move preserves optimality: all configurations skipped are provably not better than current or future candidates."
        ],
        "proof_basis": "Greedy elimination — for a fixed shorter boundary, reducing width can never yield a larger area."
      },
      "Transformable Parameters": {
        "n_range": [
          2,
          100000
        ],
        "value_range": [
          0,
          10000
        ],
        "input_variants": [
          "2D version: matrix of heights",
          "Circular arrangement: connect last to first",
          "Online queries: dynamic insertion of new lines",
          "Multiple containers: disjoint segments under sum constraint",
          "Output type change: return indices instead of value",
          "Constraint reversal: minimize area ≥ K",
          "Hidden monotonicity: unsorted vs sorted preprocessing required"
        ],
        "data_mode": "offline",
        "multiple_cases": false,
        "modifications_allowed": false
      }
    }
  },
  {
    "title": "Minimum Moves to Get a Peaceful Board",
    "slug": "minimum-moves-to-get-a-peaceful-board",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "sorted": false,
        "duplicates": true,
        "description": "给定一个长度为 n 的非负整数数组 height，height[i] 表示第 i 根柱子的高度。"
      },
      "Core Constraint": {
        "constraint": "每个位置的盛水量由其左右两侧最高柱子中的较小者决定，且水只能在凹陷处积累。",
        "independence": "左侧最大值和右侧最大值可独立维护，但共同决定当前点的瓶颈高度。",
        "global_dependency": "整体容量依赖于全局极值分布，局部最优不等于全局最优。"
      },
      "Objective Function": {
        "goal": "sum",
        "target": "total trapped water",
        "description": "计算按此数组排列的柱子，下雨后能接住的雨水总量。"
      },
      "Algorithmic Invariant": {
        "technique": "two-pointers",
        "invariants": [
          "维护左指针 L 和右指针 R，分别从两端向中间移动。",
          "维护 maxLeft 表示 [0, L) 区间的最大高度，maxRight 表示 (R, n-1] 区间的最大高度。",
          "若 maxLeft <= maxRight，则 L 处的积水仅由 maxLeft 决定，可安全累加并右移 L。",
          "否则，R 处的积水由 maxRight 决定，可累加并左移 R。",
          "指针移动过程中，已确定区域的贡献值不变且正确。"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_range",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "default": "non-negative",
            "description": "是否允许柱子高度为负（如表示地下坑洞）"
          },
          {
            "name": "dimension",
            "options": [
              "1D",
              "2D"
            ],
            "default": "1D",
            "description": "扩展到二维矩阵上的接雨水问题"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online"
            ],
            "default": "offline",
            "description": "是否支持在线查询或动态更新"
          },
          {
            "name": "output_type",
            "options": [
              "total_sum",
              "per_position_contribution"
            ],
            "default": "total_sum",
            "description": "返回总和还是每个位置的具体储水量"
          },
          {
            "name": "operation_support",
            "options": [
              "static",
              "update_supported"
            ],
            "default": "static",
            "description": "是否支持单点修改、插入或删除操作"
          },
          {
            "name": "data_form",
            "options": [
              "linear",
              "circular"
            ],
            "default": "linear",
            "description": "数组是否首尾相连形成环形结构"
          },
          {
            "name": "multiple_queries",
            "options": [
              "single",
              "multiple"
            ],
            "default": "single",
            "description": "是否处理多组测试用例或区间查询"
          }
        ]
      }
    }
  },
  {
    "title": "Find Top Scoring Students II",
    "slug": "find-top-scoring-students-ii",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置 i 能存储的水量由其左侧最大高度 maxLeft[i] 和右侧最大高度 maxRight[i] 的最小值决定，即 min(maxLeft[i], maxRight[i]) - H[i]（若为正）",
      "Objective Function": "计算整个数组能接住的雨水总量（求和型计数问题）",
      "Algorithmic Invariant": "使用双指针 L 和 R 分别从左右两端向内收缩；维护当前遍历过的 left_max 和 right_max；若 left_max ≤ right_max，则 L 处的瓶颈由 left_max 决定，可直接累加贡献并右移 L；否则对 R 做对称操作；移动过程中始终保持已访问区域的最优性不变",
      "Transformable Parameters": [
        "n 的数量级：1e3 / 1e5 / 1e7（影响解法选择）",
        "H[i] 是否允许负值（如坑洞建模）",
        "是否扩展到二维矩阵（2D 接雨水问题）",
        "是否环形排列（首尾相连的地形）",
        "是否支持在线更新（动态增删改高度）",
        "输出形式：总容量 / 每个位置的容量 / 最大单段蓄水区间",
        "是否多组测试数据输入"
      ]
    }
  },
  {
    "title": "Count Substrings With K-Frequency Characters I",
    "slug": "count-substrings-with-k-frequency-characters-i",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n (1 <= n <= 3000)",
        "substructure": "contiguous non-empty substring"
      },
      "Core Constraint": {
        "condition": "a valid substring must contain at least one character that appears at least k times",
        "implication": "global frequency count within substring determines validity",
        "dependency": "validity depends on character frequency distribution in the substring"
      },
      "Objective Function": {
        "goal": "count",
        "target": "total number of substrings where at least one character occurs at least k times"
      },
      "Algorithmic Invariant": {
        "invariant_type": "frequency-driven pruning",
        "key_properties": [
          "if all characters in a substring have frequency < k, then any extension of this substring cannot fix internal deficiencies without changing composition",
          "for fixed set of characters, divide-and-conquer based on infrequent characters (appear < k times) breaks problem into independent subproblems",
          "sliding window is not directly applicable due to non-monotonicity of 'at least one char >= k' condition"
        ],
        "primary_method": "divide and conquer using rare characters as splitters",
        "alternative_approach": "enumeration over starting points with early termination using frequency tracking"
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          3000
        ],
        "k_range": "1 <= k <= n",
        "alphabet_type": "fixed: lowercase English letters (26 letters)",
        "character_distribution": "arbitrary, possibly repeated",
        "input_form": "single string with integer k",
        "multiple_queries": false,
        "online_input": false,
        "output_form": "integer count",
        "variation_potential": [
          "change objective: find longest/shortest such substring",
          "add constraint: all characters must appear at least k times",
          "transform to decision problem: does there exist a substring satisfying condition?",
          "extend to circular string",
          "allow wildcards or case sensitivity",
          "require reporting all valid substrings instead of counting"
        ]
      }
    }
  },
  {
    "title": "Delete Nodes From Linked List Present in Array",
    "slug": "delete-nodes-from-linked-list-present-in-array",
    "schema": {
      "Input Structure": [
        "整数数组 nums，长度为 m，元素唯一，1 <= m <= 10^5，1 <= nums[i] <= 10^5",
        "单向链表 head，节点数 n 满足 1 <= n <= 10^5，每个节点的值 Node.val 满足 1 <= Node.val <= 10^5"
      ],
      "Core Constraint": [
        "链表中某节点是否被保留，仅取决于其值是否出现在集合 nums 中",
        "移除操作是独立的、局部的：每个节点的删除决策不依赖于其他节点的位置或顺序",
        "输入保证至少有一个节点不会被移除，因此返回头节点非空"
      ],
      "Objective Function": "移除链表中所有值存在于数组 nums 中的节点，返回修改后链表的头节点",
      "Algorithmic Invariant": [
        "使用集合（HashSet）预处理 nums，实现 O(1) 值存在性查询",
        "遍历链表时，当前指针所指节点的删除决策不影响已处理部分的正确性",
        "通过虚拟头节点（dummy node）统一处理头节点可能被删除的情况",
        "双指针技术中：prev 指针始终指向已处理部分的最后一个有效节点，curr 指针用于遍历探测"
      ],
      "Transformable Parameters": {
        "nums 性质": {
          "是否允许重复元素": false,
          "是否有序": "可变（影响是否可用二分等优化）",
          "值域范围": "[1, 10^5]",
          "数据规模": "小规模（<= 10^5），适合哈希化"
        },
        "链表性质": {
          "是否循环链表": false,
          "是否双向链表": false,
          "节点数量级": "10^5，要求 O(n) 解法",
          "是否有重复值": true
        },
        "操作模式": {
          "是否原地修改": true,
          "是否允许额外空间": "O(m) 空间用于哈希集合",
          "是否在线处理": "可扩展为流式链表节点输入"
        },
        "目标函数变化空间": [
          "计数被删除节点个数",
          "返回被删除节点组成的链表",
          "仅当连续出现于 nums 中时才删除（引入上下文依赖）"
        ],
        "约束变换": [
          "nums 改为区间 [a,b]，删除值在区间内的节点（从离散到连续约束）",
          "改为保留仅出现在 nums 中的节点（逻辑反转）",
          "多组查询：多个 nums 数组，批量过滤链表（离线批处理）"
        ]
      }
    }
  },
  {
    "title": "Minimum Cost for Cutting Cake II",
    "slug": "minimum-cost-for-cutting-cake-ii",
    "schema": {
      "Input Structure": [
        "二维矩形蛋糕，尺寸为 m × n",
        "整数 m, n 表示行数和列数",
        "数组 horizontalCut[1..m-1]：每个元素表示在水平线 i 处切割的开销",
        "数组 verticalCut[1..n-1]：每个元素表示在垂直线 j 处切割的开销",
        "所有切割开销为正整数"
      ],
      "Core Constraint": [
        "每次切割只能作用于一个非 1×1 的矩形块",
        "每条切割线的开销固定且仅取决于原始定义（不随子块位置变化）",
        "横向切割次数为 m - 1，但需重复应用于多个横向分割后的子块（共 n 次等效使用）",
        "纵向切割次数为 n - 1，同样需在 m 个纵向子块中各执行一次",
        "总开销 = Σ(切割开销 × 被切割的块数)，而块数由另一方向已进行的切割数决定",
        "越早进行高成本切割，其被重复的次数越少 → 应优先选择单位代价高的切割"
      ],
      "Objective Function": "最小化将整个 m × n 蛋糕切分为 m × n 个 1×1 块的总开销",
      "Algorithmic Invariant": [
        "贪心选择不变性：始终优先执行当前未使用的、单位影响最大（即开销最大）的切割操作",
        "切割顺序不影响最终结果，只要满足‘高成本切割尽早执行’以减少重复计数",
        "横向切割的实际总贡献 = horizontalCut[i] × (当前 vertical 切割数 + 1)",
        "纵向切割的实际总贡献 = verticalCut[j] × (当前 horizontal 切割数 + 1)",
        "通过归并两个排序后的切割序列，模拟最优切割顺序，保持局部最优可扩展至全局"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": "1 <= m, n <= 10^5",
          "切割数组值域": "1 <= cut[i] <= 10^3"
        },
        "输入形式": [
          "是否提供已排序的 horizontalCut / verticalCut",
          "是否允许负开销（变形题）",
          "是否支持动态增删切割线"
        ],
        "输出形式": [
          "仅求最小总开销（标准）",
          "要求输出切割顺序方案",
          "构造字典序最小的操作序列"
        ],
        "多组数据": "是否处理 T 组独立测试用例",
        "在线/离线": "是否支持在线添加切割请求并实时更新最小开销",
        "结构变形": [
          "从矩形到环形切割（如圆柱面蛋糕）",
          "三维推广：m × n × k 立方体切割问题",
          "非均匀网格：允许不规则切割线分布"
        ]
      }
    }
  },
  {
    "title": "Count Substrings With K-Frequency Characters II",
    "slug": "count-substrings-with-k-frequency-characters-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "Given an integer array height of size n, where each element height[i] represents the height of a vertical line at position i."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is determined by the minimum of their heights and the distance between their indices.",
        "key_insight": "For any two lines at positions i and j (i < j), the area they form is (j - i) * min(height[i], height[j]). The optimal solution must balance height and width trade-off.",
        "dependency": "Local choices affect global optimality; however, moving the pointer with smaller height preserves the chance to find larger area."
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "the container with the most water",
        "output_type": "integer representing maximum area"
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers start at both ends, and at each step, the pointer with the smaller height is moved inward.",
        "proof_condition": "Since the area is limited by the shorter line, moving the taller one cannot increase the area without risking loss of potential wider+higher combinations. Moving the shorter one maintains monotonic progress toward optimal.",
        "state_preservation": "After each move, all configurations excluded by the current step are provably not better than the best seen so far."
      },
      "Transformable Parameters": {
        "n_range": [
          "1 ≤ n ≤ 10^5",
          "small n: brute-force viable"
        ],
        "value_domain": "height[i] ≥ 0",
        "ordering": "unsorted array",
        "dimensionality": "1D → can be extended to 2D grid or circular arrangement",
        "query_mode": "offline single query",
        "data_updates": "static input → can be adapted to support point updates or online insertion",
        "output_detail": "return only max value → can require positions or all maximal pairs",
        "additional_constraints": [
          "lines cannot be slanted",
          "can be relaxed to allow diagonal containers in grid variants"
        ]
      }
    }
  },
  {
    "title": "Minimum Array Changes to Make Differences Equal",
    "slug": "minimum-array-changes-to-make-differences-equal",
    "schema": {
      "Input Structure": [
        "长度为 n 的整数数组 nums，n 为偶数",
        "每个元素满足 0 <= nums[i] <= k",
        "k 为给定整数，值域范围 [0, 1e5]",
        "数组按顺序给出，无额外结构（如排序、树形等）"
      ],
      "Core Constraint": [
        "数组需满足对称位置差的绝对值相等：存在整数 X，使得对所有 i ∈ [0, n-1]，有 |nums[i] - nums[n-i-1]| = X",
        "每对对称位置 (i, n-i-1) 的差值绝对值必须相同",
        "X 不是输入，而是由最终数组决定的存在性变量",
        "操作允许将任意元素替换为 [0, k] 范围内的任意整数"
      ],
      "Objective Function": "最小化修改次数（即最少操作数），使得数组满足上述对称差条件",
      "Algorithmic Invariant": [
        "对于每一对对称位置 (i, n-i-1)，其原始值对 (a, b) 可通过零次、一次或两次修改变为新对 (a', b')，使得 |a' - b'| = X",
        "固定 X 后，每对的最小修改代价可独立计算：若原差已为 X 则代价为 0；若可通过单边修改达成则为 1；否则为 2",
        "由于 X 的取值范围有限（0 <= X <= k），可枚举所有可能的 X 并计算总代价",
        "最优解中 X 必然出现在某对经过最少修改后可达的合法差集中，因此无需穷举全部 [0,k]，只需考虑候选集"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e5（支持线性或 O(n log k) 解法）",
        "值域": "nums[i] 和 k 在 [0, 1e5] 内，影响枚举策略可行性",
        "是否有序": "数组无序，但处理方式基于对称对，不依赖全局顺序",
        "是否循环": "否，为普通线性数组",
        "是否多组输入": "可扩展为多测案例（T 组数据）",
        "是否在线": "当前为离线输入，可改造为流式输入对并动态更新答案",
        "X 是否给定": "当前 X 未知，为目标存在量词；可变形为 X 给定，判断可行性或求最小修改",
        "目标函数变换": "可改为计数满足条件的 X 数量，或判定是否存在 0 次修改方案",
        "操作限制": "可增加限制：只能修改前半部分 / 每个位置最多改一次 / 修改成本非均匀",
        "差的形式": "可改为 a[i] + a[n-i-1] = X（和恒定）或其他函数形式"
      }
    }
  },
  {
    "title": "Find the Last Marked Nodes in Tree",
    "slug": "find-the-last-marked-nodes-in-tree",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度，H[i] ≥ 0"
      },
      "Core Constraint": {
        "constraint": "每个位置能积累的水量由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右边界约束可分离，但最终需联合取 min",
        "global_dependency": "单个位置的贡献依赖于全局信息（左右两侧的最大值）"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算所有位置上能够接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "two_pointers",
        "invariants": [
          "维护两个指针 L=0, R=n-1，以及从左向右扫描的最大值 maxLeft 和从右向左的最大值 maxRight",
          "若 maxLeft ≤ maxRight，则当前 L 位置的可接雨水量仅由 maxLeft 决定，且可以安全累加并右移 L",
          "反之，若 maxRight < maxLeft，则当前 R 位置的贡献由 maxRight 决定，可累加并左移 R",
          "指针移动过程中，已确定区域的解始终保持最优性与完整性"
        ]
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 3 * 10^4",
          "可调整至 1e5 或更高以限制暴力"
        ],
        "value_range": [
          "0 <= H[i] <= 3 * 10^4",
          "可扩展至负数（变形语义）"
        ],
        "ordering": "无序输入，但隐含单调结构可用于优化",
        "circular": false,
        "online": false,
        "mutable": false,
        "output_detail": {
          "total_only": true,
          "per_position_required": false
        },
        "dimensions": 1,
        "data_updates": false,
        "multiple_queries": false,
        "variations": [
          "目标函数变为：最大宽度容器（maximize (j-i)*min(H[i],H[j])）",
          "升维：2D 接雨水（矩阵形式）",
          "动态：支持单点修改或插入删除",
          "流式：在线输入，要求实时估算容量下界"
        ]
      }
    }
  },
  {
    "title": "Minimum Number of Seconds to Make Mountain Height Zero",
    "slug": "minimum-number-of-seconds-to-make-mountain-height-zero",
    "schema": {
      "Input Structure": [
        "整数 mountainHeight，表示山的初始高度（1 <= mountainHeight <= 1e5）",
        "整数数组 workerTimes[1..m]，长度 m >= 1，每个 workerTimes[i] 表示第 i 个工人的单位时间系数（1 <= workerTimes[i] <= 1e6）"
      ],
      "Core Constraint": [
        "多个工人并行工作，总耗时为各工人完成其分配任务所需时间的最大值",
        "工人 i 完成降低 x 高度的任务所需时间为：workerTimes[i] * (1 + 2 + ... + x) = workerTimes[i] * x * (x + 1) / 2",
        "所有工人降低的高度之和必须恰好等于 mountainHeight",
        "每个工人的工作量是非负整数，且一旦开始连续作业，不能中断或跳步"
      ],
      "Objective Function": "最小化最大完成时间：minimize max_i( workerTimes[i] * x_i * (x_i + 1) / 2 )，其中 sum(x_i) = mountainHeight，x_i ∈ ℕ",
      "Algorithmic Invariant": [
        "使用二分搜索在答案空间上枚举可能的最少时间 T",
        "对于给定的 T，每个工人 i 最多能承担的工作量 x_i 是确定的（通过解不等式 workerTimes[i] * x_i*(x_i+1)/2 <= T 可得）",
        "总可承担工作量 sum(x_i) >= mountainHeight 时，T 可行",
        "时间 T 的可行性具有单调性：若 T 可行，则所有 T' >= T 均可行 → 支持二分",
        "贪心分配不变性：在判断可行性时，每个工人应尽可能多地工作（在 T 约束下取最大整数 x_i），以最大化总贡献"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "mountainHeight 数量级": "1e5",
          "workerTimes 长度": "1e4",
          "workerTimes[i] 值域": "1e6"
        },
        "目标函数形式": [
          "最小化最大时间（当前）",
          "改为最小化总时间（变形）",
          "改为计数满足条件的分配方案数"
        ],
        "输入形式": [
          "单组输入（当前）",
          "多组测试数据",
          "在线流式添加工人或动态 mountainHeight"
        ],
        "约束条件变化": [
          "工人有启动延迟或休息周期（修改时间计算公式）",
          "要求输出具体分配方案（构造型）",
          "加入工人之间的协作效率因子"
        ],
        "并行模型扩展": [
          "二维资源分配：工人有技能维度",
          "任务不可分割 → 整数规划变体"
        ],
        "是否允许非整数工作量": "否（必须整数 x_i）"
      }
    }
  },
  {
    "title": "K-th Nearest Obstacle Queries",
    "slug": "k-th-nearest-obstacle-queries",
    "schema": {
      "Input Structure": [
        "无限大二维平面",
        "正整数 k（第 k 近）",
        "二维数组 queries，其中 queries[i] = [x, y] 表示在坐标 (x, y) 处动态添加一个障碍物",
        "曼哈顿距离定义：|x| + |y|",
        "所有 queries[i] 坐标互不相同",
        "初始无障碍物"
      ],
      "Core Constraint": [
        "每次查询后动态新增一个障碍物，不可删除",
        "需维护当前所有障碍物到原点的曼哈顿距离",
        "只关心第 k 小的距离（k-th smallest distance）",
        "局部信息不足以确定全局顺序，需维护有序集合中的前 k 个最小值",
        "数据规模大（queries.length ≤ 2×10⁵），要求高效更新和查询"
      ],
      "Objective Function": [
        "对于每个 i，返回前 i+1 次插入后的第 k 小曼哈顿距离",
        "若障碍物数量 < k，则结果为 -1",
        "目标函数类型：在线查询 + 第 k 小元素判定"
      ],
      "Algorithmic Invariant": [
        "使用大小为 k 的最大堆（或支持删除的有序集合）维护当前最小的 k 个距离",
        "堆顶为当前第 k 小距离的候选值",
        "新距离 d 若小于堆顶或堆未满，则入堆；若堆已满且 d < 堆顶，则弹出堆顶并压入 d",
        "每次插入后，若堆大小 == k，则堆顶即为答案；否则为 -1",
        "堆中始终保留迄今为止最小的 min(count, k) 个距离，且最大值被保留以支持后续替换"
      ],
      "Transformable Parameters": {
        "k 的数量级": "1 <= k <= 10^5",
        "queries 长度": "1 <= queries.length <= 2 * 10^5",
        "坐标值域": "-10^9 <= x, y <= 10^9",
        "距离类型": [
          "可变换为欧几里得距离平方（变形题）",
          "可变换为切比雪夫距离"
        ],
        "输入形式": [
          "是否离线（全部给出）→ 在线流式插入",
          "是否允许重复坐标（本题不允许）"
        ],
        "输出形式": [
          "返回每次查询后的第 k 小距离",
          "可改为返回第 k 大、或前 k 个距离之和等"
        ],
        "数据操作扩展": [
          "加入删除操作 → 支持撤销（需平衡树或对顶堆+懒删除）",
          "加入修改操作 → 动态点更新"
        ],
        "多组数据": "否（单组序列插入）",
        "是否在线": "是（必须逐个处理查询并立即返回结果）"
      }
    }
  },
  {
    "title": "Minimum Cost for Cutting Cake I",
    "slug": "minimum-cost-for-cutting-cake-i",
    "schema": {
      "Input Structure": "二维矩形蛋糕，由整数 m 和 n 定义其大小（m x n）；两个一维数组 horizontalCut[0..m-2] 和 verticalCut[0..n-2]，分别表示在每条水平线和垂直线切割的开销；所有值为正整数。",
      "Core Constraint": "每次切割操作作用于一个大于 1x1 的矩形块，将其沿某条预定义的水平或垂直线切开，产生两个独立子矩形；每条切割线的开销固定且只能被计入总开销的次数等于该切割线所跨越的当前连通块数量（即：越早切开，后续重复使用代价越高）。",
      "Objective Function": "最小化将整个 m x n 蛋糕完全分割成 1x1 小块的总切割开销",
      "Algorithmic Invariant": "贪心选择不变量：优先执行单位贡献收益最高的切割（即：当前最大单位开销的切割应尽早执行，以减少其在后续多个子块中重复计费的次数）；等价地，每增加一次横向切割，会使得后续所有纵向切割的成本多承担一次该开销（反之亦然），因此高成本切割应尽可能‘共享’到更多子块中 —— 即应优先进行高开销切割。",
      "Transformable Parameters": {
        "m_n_size": "原题中 m, n <= 20，可变更为更大规模（如 1e5），要求使用高效数据结构",
        "cut_cost_range": "当前 cut 值域为 [1, 1000]，可扩展至负数（引入奖励机制）或零开销切割",
        "input_dimensionality": "可推广至三维（立方体切分为 1x1x1）或多维超矩形",
        "cut_direction_availability": "是否允许斜切 / 多段切 / 非直线切割（变形题）",
        "operation_model": "是否支持批量切割操作 / 是否允许合并操作",
        "query_mode": "是否为在线查询模式（动态添加切割线）",
        "output_requirement": "是否要求输出最优切割顺序方案路径",
        "constraint_type": "是否加入顺序约束（某些切割必须先于其他切割执行）",
        "multiple_test_cases": true,
        "is_sorted_input": "horizontalCut 与 verticalCut 是否已排序（影响实现方式）"
      }
    }
  },
  {
    "title": "Maximum Number of Operations to Move Ones to the End",
    "slug": "maximum-number-of-operations-to-move-ones-to-the-end",
    "schema": {
      "Input Structure": [
        "长度为 n 的二进制字符串 s",
        "n ∈ [1, 1e5]",
        "s[i] ∈ {'0', '1'}"
      ],
      "Core Constraint": [
        "操作仅在满足 s[i] == '1' 且 s[i+1] == '0' 时可执行",
        "每次操作将某个 '1' 向右移动，直到遇到末尾或另一个 '1'",
        "所有 '1' 的相对顺序保持不变（因为只能右移，不能跨越其他 '1'）",
        "每轮操作实质上是将一个孤立的 '1' 穿过一段连续的 '0' 移动到右侧的 '1' 块前"
      ],
      "Objective Function": "最大化可执行的操作次数（即总移动步数之和）",
      "Algorithmic Invariant": [
        "每个 '1' 最多可以向右穿过其右侧连续的 '0' 块，直到被已存在的 '1' 阻挡",
        "左侧的 '1' 可以利用右侧 '0' 的空隙进行移动，但不会影响更右端 '1' 的可用空间",
        "总的可移动距离等于：对每个 '1'，统计它右边在其之后出现的 '0' 的数量（即未被更左的 '1' 占用的）",
        "贪心结构成立：优先移动左边的 '1' 不会减少总操作数（因为右边的 '0' 资源可共享，且移动不破坏后续可行性）"
      ],
      "Transformable Parameters": {
        "数据规模": "n ∈ [1, 1e5], 可扩展至 1e6（要求线性解法）",
        "字符集": "是否推广到三进制或更多符号（如 '2' 是否可移动）",
        "操作方向": "是否允许左移或双向移动",
        "移动规则": "是否改为块移动（如连续多个 '1' 同时右移）",
        "目标函数变换": [
          "求最小操作次数（构造类问题）",
          "判断是否能到达某一目标状态",
          "计数可达状态总数"
        ],
        "输入形式": [
          "是否多组字符串",
          "是否在线输入字符流",
          "是否支持修改操作（动态字符串）"
        ],
        "约束变化": [
          "限制每个下标只能使用一次",
          "引入能量代价：移动 k 步消耗 k^2 能量"
        ]
      }
    }
  },
  {
    "title": "Count Submatrices With Equal Frequency of X and Y",
    "slug": "count-submatrices-with-equal-frequency-of-x-and-y",
    "schema": {
      "Input Structure": {
        "type": "2D character matrix",
        "dimensions": "m x n",
        "elements": [
          "'X'",
          "'Y'",
          "'.'"
        ],
        "constraints": {
          "m": "1 <= m <= 1000",
          "n": "1 <= n <= 1000",
          "values": "each grid[i][j] ∈ {'X', 'Y', '.'}"
        }
      },
      "Core Constraint": {
        "description": "子矩阵必须包含左上角 grid[0][0]，且其中 'X' 和 'Y' 的出现次数相等；同时至少包含一个 'X'",
        "key_conditions": [
          "submatrix must include (0,0)",
          "count('X') == count('Y') within submatrix",
          "count('X') >= 1"
        ],
        "structural_implication": "所有合法子矩阵均为从 (0,0) 出发的矩形区域（即 top-left fixed at origin）"
      },
      "Objective Function": {
        "type": "计数",
        "target": "满足条件的子矩阵数量",
        "specifics": [
          "枚举所有以 (0,0) 为左上角的子矩阵",
          "统计其中字符 'X' 与 'Y' 频数相等且至少有一个 'X' 的个数"
        ]
      },
      "Algorithmic Invariant": {
        "invariant_type": "前缀差分 + 哈希映射累加",
        "key_ideas": [
          "将二维子矩阵问题转化为右下角扩展路径上的频数差追踪",
          "定义每个位置 (i,j) 上从 (0,0) 到 (i,j) 构成的矩形中：diff = count('X') - count('Y')",
          "若两个不同右下角对应的 diff 值相同，则其间区域（虚拟）具有零净变化，可用于构造平衡子矩阵",
          "使用哈希表记录各 diff 值的历史出现次数，实现 O(1) 状态转移累加",
          "初始化：在未开始时 diff=0 视为已出现一次（对应空矩阵前状态）"
        ],
        "monotonicity_or_stability": "随着遍历进行，累积 diff 可重复，相同值意味着可形成有效区间"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "grid dimensions",
            "range": [
              "1..1000",
              "1..1000"
            ],
            "transformations": [
              "smaller scale",
              "larger scale → require optimization",
              "1D reduction"
            ]
          },
          {
            "name": "character set",
            "possible_values": [
              "{'X','Y','.'}",
              "generalized to k types with balance constraint",
              "only two relevant types"
            ]
          },
          {
            "name": "balance condition",
            "transformation": [
              "count('X') == count('Y')",
              "count('X') - count('Y') == k",
              "ratio-based instead of equality"
            ]
          },
          {
            "name": "anchor constraint",
            "transformation": [
              "must include (0,0)",
              "arbitrary anchor",
              "no anchor → all submatrices"
            ]
          },
          {
            "name": "minimum requirement",
            "transformation": [
              "at least one 'X'",
              "at least k symbols",
              "exclude '.'-only regions"
            ]
          },
          {
            "name": "input mode",
            "transformation": [
              "offline batch",
              "online queries on dynamic grid",
              "streaming rows"
            ]
          },
          {
            "name": "output type",
            "transformation": [
              "count only",
              "list all valid submatrices",
              "find maximum/minimum area among valid ones"
            ]
          },
          {
            "name": "dimensionality",
            "transformation": [
              "2D matrix",
              "1D array version",
              "3D cuboid extension"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Find the Maximum Length of Valid Subsequence II",
    "slug": "find-the-maximum-length-of-valid-subsequence-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "constraints": [
          "nums: integer array of length n, where 2 <= n <= 10^3",
          "each element satisfies 1 <= nums[i] <= 10^7",
          "k: positive integer with 1 <= k <= 10^3"
        ],
        "properties": [
          "unordered",
          "may contain duplicates",
          "values are positive integers"
        ]
      },
      "Core Constraint": {
        "description": "For a subsequence sub of length x, the modular sum condition must be consistent across consecutive pairs: (sub[i] + sub[i+1]) % k is constant for all valid i.",
        "mathematical_form": "∃ c ∈ [0, k) such that ∀ i ∈ [0, x-2], (sub[i] + sub[i+1]) % k = c",
        "implication": "The transition between adjacent elements in the subsequence is governed by a fixed residue class modulo k."
      },
      "Objective Function": {
        "type": "optimization",
        "goal": "maximization",
        "target": "length of the longest valid subsequence satisfying the modular consistency constraint"
      },
      "Algorithmic Invariant": {
        "invariant_description": "For a fixed residue r, we can model transitions between values using directed edges: from a to b if (a + b) % k == r. Then the longest valid subsequence under this r corresponds to the longest path in the functional graph induced by this transition rule.",
        "key_observations": [
          "The problem decomposes by residue class r ∈ [0, k)",
          "Within each r, state can be represented as last element value",
          "We can use dynamic programming: dp[r][v] = maximum length of valid subsequence ending with value v under residue r",
          "Transitions: for each new num u, and for each possible previous value v such that (v + u) % k == r, update dp[r][u] = max(dp[r][u], dp[r][v] + 1)"
        ],
        "monotonicity": "DP state only extends forward; no backtracking needed due to sequential processing",
        "optimal_substructure": true
      },
      "Transformable Parameters": {
        "n_range": [
          "10^3 (current)",
          "up to 10^5 → requires optimization via hashing or state compression",
          "up to 10^6 → may require offline preprocessing"
        ],
        "value_domain": [
          "current: 1 <= nums[i] <= 1e7",
          "can be negative → affects modulo behavior"
        ],
        "k_range": [
          "small (<= 1e3): allows iterating over residues",
          "large (e.g., 1e9): forces structural analysis instead of iteration"
        ],
        "modular_condition": [
          "current: (a+b)%k == const",
          "variation: (a-b)%k == const → arithmetic progression mod k",
          "variation: (a*b)%k == const"
        ],
        "subsequence_type": [
          "contiguous → becomes substring problem",
          "non-contiguous (current)"
        ],
        "output_type": [
          "length only (current)",
          "count number of longest valid subsequences",
          "reconstruct one such subsequence"
        ],
        "input_mode": [
          "offline batch (current)",
          "online streaming → requires incremental DP"
        ],
        "additional_constraints": [
          "distinct elements only",
          "bounded frequency per value"
        ]
      }
    }
  },
  {
    "title": "Find the Maximum Length of Valid Subsequence I",
    "slug": "find-the-maximum-length-of-valid-subsequence-i",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n ≥ 2，nums[i] ∈ [1, 10^7]",
      "Core Constraint": "有效子序列中所有相邻元素对的和模 2 相等，即 (sub[i] + sub[i+1]) % 2 对所有 i 为常量（全为偶或全为奇）",
      "Objective Function": "求最长有效子序列的长度（最大化）",
      "Algorithmic Invariant": "序列中相邻元素和的奇偶性保持一致；该性质等价于子序列中元素的奇偶性呈周期性：要么全相同（偶+偶=偶，奇+奇=偶），要么交替出现（偶+奇=奇，奇+偶=奇）；因此最优解必属于以下两类之一：(1) 全部元素奇偶性相同；(2) 奇偶交替排列。可通过一次遍历维护当前模式下的最大长度。",
      "Transformable Parameters": {
        "数据规模": "n ∈ [2, 2×10^5]",
        "值域范围": "nums[i] ∈ [1, 10^7]",
        "是否有序": "输入无序，但不影响子序列顺序继承原数组",
        "目标函数可变形式": [
          "改为计数最长有效子序列的个数",
          "判断是否存在长度 ≥ K 的有效子序列",
          "输出具体方案而非仅长度"
        ],
        "约束条件变形": [
          "(a + b) % 2 == c 改为 (a + b) % k == c（模数推广）",
          "要求连续子数组而非子序列",
          "增加最多删除 d 个元素的限制"
        ],
        "输入维度扩展": [
          "二维数组上的路径子序列满足模条件",
          "树上路径中的有效序列"
        ],
        "是否多组数据": "可设计为多组测试用例输入",
        "是否在线": "可改为流式添加元素，在线维护最长有效子序列长度"
      }
    }
  },
  {
    "title": "The Number of Ways to Make the Sum",
    "slug": "the-number-of-ways-to-make-the-sum",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接雨水的高度由其左侧最大值和右侧最大值中的较小者决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针维护左右两侧的最大高度，移动较矮一侧的指针并累加其当前位置的蓄水量，因为较矮侧的瓶颈已被确定，无需等待另一侧更多信息",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许为负数（如表示凹陷地形）",
        "维度扩展": "从 1D 扩展到 2D 网格（二维接雨水问题）",
        "输入形式": "是否在线输入或支持动态修改（如加入、删除柱子）",
        "输出要求": "是否需要输出每个位置的具体蓄水量而非总和",
        "数据规模": "n 的数量级（例如：n ≤ 10^3 / 10^5 / 10^6），影响解法选择（预处理 vs 双指针）",
        "多组数据": "是否处理多组测试用例",
        "数组性质": "数组是否有序、部分有序或具有周期性"
      }
    }
  },
  {
    "title": "Find Top Scoring Students",
    "slug": "find-top-scoring-students",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element": "non-negative integer",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 height，height[i] 表示第 i 根柱子的高度"
      },
      "Core Constraint": {
        "constraint": "每个位置的盛水能力由其左右两侧最高柱子中的较小值决定",
        "property": "左右边界约束可分离，且局部决策依赖全局极值",
        "key_insight": "若某一侧当前边界是全局较矮的一侧，则该侧当前位置的积水高度可立即确定"
      },
      "Objective Function": {
        "goal": "sum",
        "objective": "计算整个数组能接住的雨水总量",
        "type": "numeric accumulation"
      },
      "Algorithmic Invariant": {
        "invariant": "双指针维护已处理区域外的左右最大值",
        "rules": [
          "初始化左指针 L=0，右指针 R=n-1，maxLeft=0，maxRight=0",
          "若 height[L] <= height[R]，则 L 处的积水由 maxLeft 决定（因右侧存在更高屏障）",
          "移动较矮一侧的指针，并更新对应侧的最大值",
          "每次移动保证不破坏已计算区域的正确性"
        ],
        "monotonicity": "maxLeft 和 maxRight 单调不减",
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "2 * 10^4"
        ],
        "value_range": [
          "0",
          "10^5"
        ],
        "is_sorted": false,
        "is_circular": false,
        "multiple_test_cases": false,
        "online_query": false,
        "mutable_input": false,
        "output_detail_level": "total sum only",
        "allow_negative_heights": false,
        "dimension_extension": "1D → 2D (e.g., 二维接雨水)",
        "operation_support": [
          "point update",
          "range query"
        ]
      }
    }
  },
  {
    "title": "Find Maximum Removals From Source String",
    "slug": "find-maximum-removals-from-source-string",
    "schema": {
      "Input Structure": {
        "source": "string of length n (1 <= n <= 3 * 10^3), consisting of lowercase English letters",
        "pattern": "non-empty string, a subsequence of source",
        "targetIndices": "sorted array of distinct integers, each in [0, n-1], indicating allowed deletion positions"
      },
      "Core Constraint": {
        "deletion_constraint": "Only characters at indices in targetIndices can be deleted",
        "subsequence_preservation": "After each deletion, pattern must remain a subsequence of the modified source",
        "index_invariance": "Deletion does not shift the indices of remaining characters"
      },
      "Objective Function": "Maximize the number of deletion operations that can be performed while preserving pattern as a subsequence",
      "Algorithmic Invariant": {
        "greedy_feasibility": "A deletion at index i is safe if there exists a valid matching of pattern to source where no character in pattern is matched to source[i]",
        "match_separation": "We can precompute leftmost and rightmost possible matchings of pattern in source; any index not covered by all possible matchings can be safely deleted",
        "monotonic_coverage": "If an index is not used in some valid embedding of pattern, it may be deletable — but only if such embeddings can coexist across multiple deletions"
      },
      "Transformable Parameters": {
        "n_scale": "n ∈ [1, 3000] → could be scaled down to 100 or up to 1e5 with efficient algorithms",
        "pattern_length": "Can vary from 1 to n; affects density of constraints",
        "targetIndices_ordering": "Currently sorted; could generalize to unsorted or require sorting",
        "online_deletion": "Currently offline batch; could transform into online query: 'can this index be deleted given prior deletions?'",
        "output_type": "Currently returns maximum count; could ask for actual sequence of deletions or which indices are deletable",
        "multiple_patterns": "Extension: support multiple patterns that must all remain subsequences",
        "character_shift_on_delete": "Alternative model: enable index shifting after deletion (standard behavior), making problem more dynamic"
      }
    }
  },
  {
    "title": "Count the Number of Good Nodes",
    "slug": "count-the-number-of-good-nodes",
    "schema": {
      "Input Structure": {
        "type": "tree",
        "representation": "undirected edge list",
        "nodes": "n nodes labeled from 0 to n-1",
        "edges": "length n-1, edges[i] = [a_i, b_i]",
        "root": "node 0 is the root",
        "constraints": {
          "n_range": "2 <= n <= 1e5",
          "valid_tree": true
        }
      },
      "Core Constraint": {
        "definition": "A node is 'good' if all of its children's subtrees have the same number of nodes.",
        "subtree_definition": "A subtree includes a node and all its descendants.",
        "dependency": "The property of being 'good' depends on uniformity of subtree sizes among direct children."
      },
      "Objective Function": {
        "goal": "count",
        "target": "total number of good nodes in the tree"
      },
      "Algorithmic Invariant": {
        "postorder_traversal": "Subtree sizes can be computed via DFS postorder traversal: size(u) = 1 + sum(size(v) for all children v).",
        "uniformity_check": "For a non-leaf node u, after computing all child subtree sizes, check if they are all equal.",
        "independence": "Each node's 'good' status is determined independently once its children's subtree sizes are known.",
        "correctness_preservation": "DFS ensures that all dependencies (children) are resolved before processing parent."
      },
      "Transformable Parameters": {
        "n_magnitude": "1e5 → 1e3 or online streaming of edges",
        "tree_shape": [
          "chain (linear)",
          "complete binary",
          "star-shaped"
        ],
        "output_form": [
          "count only",
          "list all good nodes",
          "deepest good node",
          "longest path of consecutive good nodes"
        ],
        "constraint_modification": [
          "allow multiple roots (forest)",
          "require at least k children to have equal size",
          "define 'good' as having Fibonacci-sized subtrees",
          "relax condition: ratio within threshold instead of exact equality"
        ],
        "input_dynamics": [
          "dynamic tree with edge additions/deletions",
          "queries on subtrees after updates"
        ],
        "evaluation_condition": [
          "only internal nodes considered",
          "leaves defined as not good by default",
          "consider node 0 excluded"
        ]
      }
    }
  },
  {
    "title": "Maximize Score of Numbers in Ranges",
    "slug": "maximize-score-of-numbers-in-ranges",
    "schema": {
      "Input Structure": [
        "一维整数数组 start[1..n]",
        "一个非负整数 d",
        "表示 n 个区间 [start[i], start[i] + d]，每个区间长度为 d + 1",
        "n ∈ [2, 1e5], start[i] ∈ [0, 1e9], d ∈ [0, 1e9]"
      ],
      "Core Constraint": [
        "第 i 个选定的整数 x_i 必须满足 x_i ∈ [start[i], start[i] + d]",
        "所有选定整数构成集合 {x_1, x_2, ..., x_n}",
        "目标是最大化两两间最小绝对差，即 max(min_{i < j} |x_i - x_j|)",
        "最优解中，所选数值应尽可能均匀分布以拉大最小间距"
      ],
      "Objective Function": "最大化所选 n 个整数之间两两绝对差的最小值（即最大可能的‘得分’）",
      "Algorithmic Invariant": [
        "排序后贪心构造：将区间按左端点排序后，可以依次决定每个 x_i 的取值",
        "存在单调性：若存在一种方案使得最小绝对差 ≥ k，则对于任意 k' < k 也存在可行方案 → 可二分答案",
        "在固定候选得分 k 下，可用贪心策略验证是否可选出一组数使得任意两数之差 ≥ k",
        "贪心验证过程保持‘最右放置’不变性：从前向后遍历排序后的区间，每次选择当前允许的最小可行值，以保留后续空间"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可变范围 [2, 1e5] → 可扩展至支持更大规模或更小样例",
        "d 是否为变量": "当前全局常量 d → 可改为每个区间独立的 d_i",
        "区间是否重叠": "当前允许重叠 → 可添加约束限制不重叠",
        "输入形式": "start 数组与统一 d → 可变为区间列表 [l_i, r_i]",
        "是否有序": "当前未排序 → 可指定 start 已排序或需自行排序",
        "目标函数变换": "从‘最大化最小绝对差’→ 变为‘最小化最大差’或‘计数满足条件的方案数’",
        "数据流化": "一次性输入 → 可设计为在线查询新增区间动态更新最大得分",
        "多组数据": "单次实例 → 可扩展为 T 组测试用例",
        "输出要求": "仅返回最大得分 → 可要求输出具体选数方案"
      }
    }
  },
  {
    "title": "Lexicographically Smallest String After a Swap",
    "slug": "lexicographically-smallest-string-after-a-swap",
    "schema": {
      "Input Structure": [
        "字符串 s，长度为 n，其中每个字符是 '0' 到 '9' 的数字",
        "n ∈ [2, 100]",
        "输入为一维有序序列，元素具有奇偶性属性"
      ],
      "Core Constraint": [
        "只能进行至多一次相邻交换",
        "交换的两个字符必须具有相同的奇偶性（同为奇数或同为偶数）",
        "目标是字典序最小化，因此贪心地尽早降低高位数值"
      ],
      "Objective Function": "在最多一次合法相邻交换后，返回字典序最小的字符串",
      "Algorithmic Invariant": [
        "从左到右扫描时，一旦找到一个位置 i 满足 s[i] > s[i+1] 且 s[i] 与 s[i+1] 奇偶性相同，则立即交换可得最优解",
        "由于只允许一次交换，且字典序最小要求优先减小高位，因此第一个满足贪心条件的位置即全局最优交换点",
        "若不存在这样的位置，则原串已为最优"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的范围可扩展至 1e5（需考虑算法复杂度变化）",
        "交换次数": "可改为最多 k 次交换，或不限次数但每次仅限同奇偶相邻交换",
        "交换规则": "可变为任意位置同奇偶数字交换，或允许不同奇偶性但引入代价函数",
        "输入形式": "可改为数组形式输入，或支持大数字符串",
        "是否在线": "可设计为动态字符串支持单点修改与查询最小字典序",
        "输出目标": "可改为求字典序最大的结果，或计数所有可能结果中最小者",
        "奇偶定义扩展": "可推广为模 m 同余类之间的交换限制"
      }
    }
  },
  {
    "title": "Alternating Groups II",
    "slug": "alternating-groups-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "integer",
        "value_domain": [
          0,
          1
        ],
        "length": "n",
        "constraints": [
          "3 <= n <= 1e5",
          "colors[i] == 0 表示红色，colors[i] == 1 表示蓝色",
          "数组表示一个环形结构（首尾相邻）"
        ]
      },
      "Core Constraint": {
        "description": "交替组定义为长度为 k 的连续子数组，其中每个中间元素与其左右邻居颜色不同；由于是环形结构，需处理首尾连接处的连续性。",
        "properties": [
          "颜色序列在局部满足交替性：对于位置 i (非首尾)，有 colors[i] != colors[i-1] 且 colors[i] != colors[i+1]",
          "整个子段长度恰好为 k",
          "环形结构导致索引需取模运算"
        ]
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计所有长度为 k 的连续子数组中，满足交替条件的子数组个数"
      },
      "Algorithmic Invariant": {
        "invariants": [
          "使用滑动窗口遍历环形数组时，窗口大小恒定为 k",
          "窗口内交替性的判断可通过检查相邻元素是否互异来维护",
          "利用模运算 (i % n) 实现环形索引的无缝衔接",
          "若当前窗口 [i, i+k-1] 满足交替性，则其成立当且仅当对所有 j ∈ [i+1, i+k-2]，有 colors[j] != colors[j-1] 且 colors[j] != colors[j+1]，同时边界条件 colors[i] != colors[i+1] 和 colors[i+k-1] != colors[i+k-2] 成立，并考虑环状首尾相连处的一致性"
        ],
        "optimization_insight": "可在 O(n) 时间内通过一次遍历结合预处理差异标记完成计数"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "k",
            "role": "window_size",
            "range": "3 <= k <= n",
            "transformations": [
              "increase",
              "decrease",
              "set_to_variable"
            ]
          },
          {
            "name": "colors",
            "role": "input_structure",
            "variations": [
              "linear_array (non-circular)",
              "higher_dimensional_grid",
              "more_colors (e.g., ternary or general c-colors)"
            ]
          },
          {
            "name": "alternating_definition",
            "options": [
              "strict_alternating (current definition)",
              "allow_one_mismatch",
              "global_periodicity_constraint"
            ]
          },
          {
            "name": "output_type",
            "options": [
              "count_only",
              "list_all_starting_indices",
              "longest_alternating_subarray"
            ]
          },
          {
            "name": "data_mode",
            "options": [
              "offline_single_query",
              "online_queries_with_updates",
              "multiple_test_cases"
            ]
          },
          {
            "name": "color_representation",
            "options": [
              "binary {0,1}",
              "string {'R','B'}",
              "arbitrary_integers_with_equality_check"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Construct String with Minimum Cost",
    "slug": "construct-string-with-minimum-cost",
    "schema": {
      "Input Structure": [
        "字符串 target，长度为 n，其中 1 <= n <= 5 * 10^4",
        "字符串数组 words，长度为 m，每个 words[i] 是小写英文字母组成的字符串，且 1 <= len(words[i]) <= n",
        "整数数组 costs，长度为 m，对应每个 words[i] 的追加成本，1 <= costs[i] <= 10^4",
        "所有 words[i] 的总字符数 <= 5 * 10^4"
      ],
      "Core Constraint": [
        "目标字符串 target 必须由 words 中的子串通过拼接构造而成",
        "只能完整使用 words[i] 进行追加操作，不可截断或反转",
        "同一个 words[i] 可重复使用任意次",
        "拼接顺序必须形成连续前缀匹配：即每一步拼接后，s 始终是 target 的前缀"
      ],
      "Objective Function": "求使 s 等于 target 的最小总成本；若无法构造，返回 -1",
      "Algorithmic Invariant": [
        "动态规划状态 dp[i] 表示构造 target 前 i 个字符的最小成本",
        "状态转移：对于每个能匹配 target[i:i+L] 的 words[j]（长度 L），有 dp[i+L] = min(dp[i+L], dp[i] + costs[j])",
        "初始状态 dp[0] = 0（空串成本为 0），其余初始化为无穷大",
        "贪心选择无效，但状态转移具有最优子结构和重叠子问题性质",
        "字符串匹配可通过预处理建立 '从每个位置出发可匹配哪些 words' 的映射以加速"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1e4 ~ 5e4，适合 O(n * |Σ words|) 或 O(n * m) 优化算法",
        "值域": "costs[i] 为正整数，允许使用 Dijkstra 或 DP；若含负权则需考虑环检测",
        "是否有序": "target 和 words 均为静态输入，离线处理",
        "是否循环": "否，线性字符串构造",
        "是否多组输入": "单组输入，但可扩展为多测",
        "是否在线": "当前为一次性输入，可变体支持在线添加 words/costs",
        "words 是否可重用": "默认可重复使用，可改为‘仅使用一次’变为背包类限制",
        "目标函数变化": [
          "最小成本",
          "最少操作次数",
          "是否存在方案"
        ],
        "约束变形": [
          "限制每个 words[i] 最多使用 k 次 → 完全背包 → 多重背包",
          "要求恰好用完某些词 → 约束满足问题",
          "target 变为子序列匹配而非子串拼接"
        ],
        "数据流化": "可设计为动态增加 word-cost 对，在线查询构造某个新 target 的最小成本"
      }
    }
  },
  {
    "title": "Second Day Verification",
    "slug": "second-day-verification",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "description": "给定一个长度为 n 的一维数组 H[1..n]，其中 H[i] 表示第 i 个位置的柱子高度",
        "constraints": [
          "n ≥ 1",
          "H[i] ≥ 0, ∀i ∈ [1, n]"
        ]
      },
      "Core Constraint": {
        "description": "每个位置 i 能够储存的水量由其左侧最大值和右侧最大值中的较小者决定，且只有当该较小值大于当前高度时才能储水",
        "properties": [
          "局部储水能力依赖于全局极值信息（左/右最大值）",
          "左右边界约束独立但需协同确定有效瓶颈"
        ]
      },
      "Objective Function": {
        "type": "sum",
        "goal": "total accumulated water capacity",
        "description": "计算所有位置可累计的雨水总量"
      },
      "Algorithmic Invariant": {
        "name": "dual-pointer with monotonic state propagation",
        "rules": [
          "维护两个指针 L=0 和 R=n-1，以及从两侧遍历得到的 maxLeft 和 maxRight",
          "若 maxLeft ≤ maxRight，则位置 L 处的储水量仅受限于 maxLeft，可立即计算并移动 L 指针",
          "反之则位置 R 可确定，移动 R 指针",
          "每次移动指针后更新对应侧的最大值",
          "已处理区域的状态不会被后续操作影响，保证贪心正确性"
        ],
        "invariant_preservation": "指针移动过程中，始终维持‘未访问区间外侧最大值’对内侧潜在贡献的控制力"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "description": "是否允许柱高为负数（如坑洼地形建模）"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D",
              "circular_1D"
            ],
            "description": "输入结构是否扩展至二维矩阵或环形数组"
          },
          {
            "name": "data_mode",
            "options": [
              "offline",
              "online_streaming"
            ],
            "description": "输入是批量给出还是在线逐个到达"
          },
          {
            "name": "query_type",
            "options": [
              "total_sum",
              "per_position_output",
              "range_query"
            ],
            "description": "输出要求：总和 / 各点储水量 / 区间查询"
          },
          {
            "name": "update_support",
            "options": [
              "static",
              "dynamic_with_updates"
            ],
            "description": "是否支持单点修改、插入删除等动态操作"
          },
          {
            "name": "multi_instance",
            "options": [
              "single_case",
              "multiple_test_cases"
            ],
            "description": "是否包含多组测试数据"
          }
        ]
      }
    }
  },
  {
    "title": "Construct String with Minimum Cost (Easy)",
    "slug": "construct-string-with-minimum-cost-easy",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "duplicates_allowed": true,
        "description": "An array H[1..n] where each element H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The water trapped at any position depends on the maximum heights to its left and right; specifically, the effective boundary is determined by the minimum of the two global maxima on either side.",
        "key_insight": "Left and right maxima evolve independently but jointly constrain the trapping capacity at each point.",
        "independence": "Left-side maximum can be computed incrementally from left; right-side similarly from right."
      },
      "Objective Function": {
        "goal": "sum",
        "objective": "Compute the total amount of rainwater that can be trapped between the bars after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two-pointer technique maintains that for current pointers L and R, if maxLeft <= maxRight, then the trapped water at L is fully determined by maxLeft (and vice versa for R).",
        "movement_rule": "Move the pointer corresponding to the smaller edge maximum, updating local maxima accordingly.",
        "correctness_preservation": "At each step, the decision to compute H[L] or H[R] contribution does not require future knowledge beyond the current extremal values."
      },
      "Transformable Parameters": {
        "n_range": [
          1,
          20000
        ],
        "value_range": [
          0,
          10000
        ],
        "negative_values_allowed": false,
        "dimension_extension": "Can be extended to 2D grid (e.g., elevation map)",
        "input_form": "offline_batch",
        "online_updates": false,
        "mutable_array": false,
        "output_detail_level": "total_sum_only",
        "multiple_test_cases": false,
        "circular_array": false,
        "additional_operations": []
      }
    }
  },
  {
    "title": "Count the Number of Substrings With Dominant Ones",
    "slug": "count-the-number-of-substrings-with-dominant-ones",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "binary",
        "length": "n",
        "constraints": [
          "s.length ∈ [1, 4 * 10^4]",
          "s[i] ∈ {'0', '1'}"
        ]
      },
      "Core Constraint": {
        "definition": "子字符串是 '1 显著' 当且仅当其中 '1' 的数量 ≥ ('0' 的数量)²",
        "implication": "判定条件是非线性的（平方关系），导致无法通过简单前缀和或线性扫描直接求解",
        "structure_dependency": "子字符串的统计依赖于区间内 0 和 1 的计数差，但目标函数非线性，破坏了单调性和可叠加性"
      },
      "Objective Function": {
        "type": "counting",
        "goal": "统计所有满足 '1 的数量 ≥ (0 的数量)²' 的连续子字符串的数量"
      },
      "Algorithmic Invariant": {
        "invariant_type": "枚举优化下的剪枝条件",
        "description": [
          "对于固定左端点 i，随着右端点 j 增加，1 的数量单调不减，0 的数量也单调不减",
          "但由于约束为 count_1 ≥ count_0²，右侧增长初期可能满足，后期因 count_0² 增长过快而不再满足",
          "然而，由于平方项的存在，一旦某个 j 开始不满足，后续仍可能再次满足（非单调），故不能轻易剪枝",
          "但可利用：若当前 count_0 > sqrt(count_1_max_possible)，则后续不可能再满足，用于提前终止"
        ],
        "feasible_optimization": "外层枚举左端点，内层扩展右端点并维护 count_0 和 count_1；利用数值范围限制进行常数级优化"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "threshold_function",
            "description": "将 '≥ k²' 改为 '≥ f(k)'，如线性、对数、立方等",
            "example": "改为 count_1 ≥ 2 * count_0 或 count_1 ≥ log(count_0 + 1)"
          },
          {
            "name": "input_dimension",
            "description": "从一维字符串扩展到二维二进制矩阵的子矩阵计数",
            "example": "求子矩阵中 1 的数量 ≥ (0 的数量)²"
          },
          {
            "name": "data_streaming",
            "description": "是否支持在线查询或滑动窗口模式",
            "example": "动态添加字符，实时返回当前串中显著子串数量"
          },
          {
            "name": "alphabet_size",
            "description": "从二元字符集扩展到多元字符集（如包含 '?' 等通配符）",
            "example": "允许 '?' 可视为 0 或 1，求是否存在赋值使子串显著"
          },
          {
            "name": "objective_variation",
            "description": "由计数变为判定 / 最大长度 / 构造方案",
            "example": "求最长的 1 显著子字符串"
          },
          {
            "name": "multiple_queries",
            "description": "是否多组输入或区间查询",
            "example": "给定多个字符串，或在单个字符串上做多次区间询问"
          },
          {
            "name": "numerical_scale",
            "description": "改变数据规模以适配不同算法复杂度",
            "example": "n ≤ 100 → 可 O(n²)；n ≤ 1e6 → 需 O(n log n) 或数学优化"
          }
        ]
      }
    }
  },
  {
    "title": "Check if the Rectangle Corner Is Reachable",
    "slug": "check-if-the-rectangle-corner-is-reachable",
    "schema": {
      "Input Structure": [
        "正整数 xCorner, yCorner 表示矩形右上角坐标 (xCorner, yCorner)，左下角固定为 (0, 0)",
        "二维整数数组 circles，其中 circles[i] = [x_i, y_i, r_i]，表示第 i 个圆的圆心在 (x_i, y_i)，半径为 r_i",
        "所有输入均为整数，且满足：3 <= xCorner, yCorner <= 1e9, 1 <= len(circles) <= 1000, 1 <= x_i, y_i, r_i <= 1e9"
      ],
      "Core Constraint": [
        "路径必须完全位于矩形内部（不包括边界，除了起点和终点）",
        "路径不能接触或进入任何圆的内部或边界",
        "路径只能在起点 (0,0) 和终点 (xCorner, yCorner) 处与矩形边界相交",
        "障碍物（圆）之间可能重叠，形成连通阻挡区域",
        "问题本质是判断是否存在从矩形左下到右上的“自由通道”，即路径被圆形障碍阻断的拓扑连通性问题"
      ],
      "Objective Function": "判定是否存在一条从 (0, 0) 到 (xCorner, yCorner) 的连续路径，满足上述约束条件；返回布尔值（true / false）",
      "Algorithmic Invariant": [
        "若两个圆之间的距离小于等于半径之和，则它们构成连通障碍块（可构建图进行连通性分析）",
        "若某个障碍块同时与矩形的左/下边界相连，并且也与上/右边界相连，则形成‘隔离带’，阻断路径",
        "路径存在的充要条件是：不存在一个圆组成的连通区域，将其‘左下被封锁区’与‘右上被封锁区’连接起来，从而分割平面",
        "可通过构建‘阻挡图’：将与左/下边界相交的圆视为一类节点，与上/右边界相交的圆视为另一类，若两者在同一个连通分量中，则路径不存在",
        "平面几何中，路径存在当且仅当没有‘横跨’方向的障碍连通链（如从左侧到顶部、左侧到右侧、底部到右侧等）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "xCorner, yCorner 的数量级": "可变范围：[3, 1e9]，可缩小至网格化场景或放大至浮点高精度场景",
          "circles 长度": "1 <= n <= 1000，可扩展为动态插入/删除圆的在线版本"
        },
        "几何形式": [
          "圆 → 椭圆 / 多边形 / 线段障碍",
          "矩形 → 任意凸多边形区域",
          "二维平面 → 三维空间球体阻挡"
        ],
        "路径约束变化": [
          "允许接触矩形边界 → 不允许中途触边",
          "起点终点位置可变 → 固定为对角",
          "路径可接触圆边界 → 完全避开"
        ],
        "目标函数变换": [
          "判定存在性 → 计算最长可达路径长度",
          "判定存在性 → 输出一条合法路径（构造题）",
          "最小化与障碍的最近距离（优化版）"
        ],
        "输入形式": [
          "离线一次性输入 → 在线流式添加圆",
          "静态圆 → 动态移动的圆（时间维度引入）"
        ],
        "精度要求": [
          "整数坐标 → 浮点坐标，需考虑精度误差处理",
          "是否需要高精度几何计算（如 sqrt 判断距离）"
        ],
        "是否多组数据": "可设定为多测例批量处理，影响预处理策略设计"
      }
    }
  },
  {
    "title": "Minimum Operations to Make Binary Array Elements Equal to One II",
    "slug": "minimum-operations-to-make-binary-array-elements-equal-to-one-ii",
    "schema": {
      "Input Structure": "一维二进制数组 nums[1..n]，其中 nums[i] ∈ {0, 1}，长度 n 满足 1 <= n <= 1e5",
      "Core Constraint": "每次操作可选择任意下标 i，反转从 i 到末尾的所有元素；操作具有后缀叠加性，即后续操作会影响前面已处理的部分；最优策略需从前向后逐步确定翻转状态",
      "Objective Function": "求将数组所有元素变为 1 的最少操作次数（最小化）",
      "Algorithmic Invariant": "维护一个当前累积的翻转次数 parity（模 2），表示当前位置被翻转的总次数；从左到右遍历，若当前位置的实际值（原值异或 parity）为 0，则必须在此开始一次新操作以触发翻转；一旦决策在位置 i 操作，则影响所有 j >= i 的后续状态，但可通过 parity 传递状态不变性",
      "Transformable Parameters": {
        "数据规模": "n 的范围：1 <= n <= 1e5（可调整至更小或支持在线流式输入）",
        "值域扩展": "是否推广到三进制或整数数组（如反转定义为 +1 mod k）",
        "操作类型变换": "反转区间从 'i 到末尾' 改为 'i 到 j' 或 '前缀反转'",
        "目标状态变化": "目标不一定是全 1，可改为全 0、交替模式或其他指定模式",
        "是否允许多组数据": "单组输入 / 多组测试用例",
        "输入形式": "离线一次性给出 / 在线逐位输入需实时响应",
        "操作代价变化": "不同位置 i 的操作代价不同（加权最小化）"
      }
    }
  },
  {
    "title": "Find Minimum Operations to Make All Elements Divisible by Three",
    "slug": "find-minimum-operations-to-make-all-elements-divisible-by-three",
    "schema": {
      "Input Structure": "一维数组 nums[1..n]，其中每个元素为正整数，1 <= n <= 50，1 <= nums[i] <= 50",
      "Core Constraint": "每个元素的操作代价等于其值对 3 取模的最小调整距离（即 min(r, 3 - r)，其中 r = nums[i] % 3）；各元素之间操作独立，无相互影响",
      "Objective Function": "求使数组中所有元素均可被 3 整除所需的最少操作次数（最小化总操作步数）",
      "Algorithmic Invariant": "每个元素的最优调整策略仅取决于其自身模 3 的余数，且局部最优选择可直接构成全局最优解（贪心不变量成立）",
      "Transformable Parameters": {
        "modulus": "可变为目标整除的模数（如改为被 k 整除）",
        "operation_cost": "可变为非单位代价（如增加/减少代价不同）",
        "data_range": "nums 长度和值域可扩展（如 n 到 1e5）",
        "array_dimension": "可推广至二维数组或矩阵",
        "online_queries": "是否支持动态修改 + 查询最小操作数",
        "output_type": "是否要求构造具体方案而非仅输出次数",
        "group_constraints": "是否存在分组约束（如某些元素必须同步调整）"
      }
    }
  },
  {
    "title": "Minimum Operations to Make Binary Array Elements Equal to One I",
    "slug": "minimum-operations-to-make-binary-array-elements-equal-to-one-i",
    "schema": {
      "Input Structure": "一维二进制数组 nums[1..n]，其中 n ∈ [3, 1e5]，nums[i] ∈ {0, 1}",
      "Core Constraint": "每次操作必须选择连续三个元素并将其全部反转；反转操作是可逆且对称的；每个位置被覆盖的操作次数奇偶性决定其最终状态",
      "Objective Function": "求将整个数组变为全 1 的最少操作次数；若不可能，则返回 -1（判定 + 最小化）",
      "Algorithmic Invariant": "从左到右贪心处理：一旦遇到 0，则必须在当前位置起始进行一次操作（因为后续操作无法影响该位）；操作的影响具有前向传播但不可回溯的特性；状态演化具有单调推进性，即前缀一旦变为 1 就不再改变",
      "Transformable Parameters": {
        "操作长度": "3 → 可改为 k（如 2 或 4），影响可行性与解法结构",
        "数组维度": "1D → 2D 网格上定义连续块反转",
        "是否循环数组": "否 → 是（首尾相连的环形结构）",
        "目标状态": "全 1 → 指定模式串 或 全 0",
        "操作方式": "反转连续三元组 → 异或某个掩码 / 加法模 2",
        "数据规模": "n <= 1e5 → 更大需支持在线或分块处理",
        "是否允许多次查询": "单次输入 → 支持修改后的重新查询（动态版本）",
        "输出要求": "仅最小次数 → 输出具体操作序列"
      }
    }
  },
  {
    "title": "Better Compression of String",
    "slug": "better-compression-of-string",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "sorted": false,
        "description": "Given an integer array height of size n, where each element represents the height of a vertical line at that position."
      },
      "Core Constraint": {
        "constraint": "The area between two lines is bounded by the minimum of their heights and the distance between their indices.",
        "key_insight": "For any two lines at positions i and j (i < j), the container's area is (j - i) * min(height[i], height[j]). The optimal solution must balance width and height constraints.",
        "dependency": "Pairwise comparison with geometric bottleneck"
      },
      "Objective Function": {
        "goal": "maximize",
        "objective": "the area formed between two vertical lines and the x-axis",
        "type": "single numerical value"
      },
      "Algorithmic Invariant": {
        "technique": "two pointers",
        "invariant": [
          "At each step, the pointer with smaller height is moved inward because moving the taller one cannot increase the area (height is bottlenecked by the shorter side).",
          "The maximum area seen so far is globally optimal among all pairs already considered or skipped due to monotonicity.",
          "The search space is reduced without missing the global optimum."
        ],
        "proof_condition": "Greedy choice property: advancing the shorter end preserves optimality; no better solution exists in the discarded region."
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 10^5",
          "small n for brute-force variants"
        ],
        "value_domain": "height[i] >= 0",
        "input_form": "offline, single array",
        "output_form": "maximum area as integer",
        "multi_query": false,
        "online_updates": false,
        "structural_variants": [
          "2D version: matrix of heights",
          "Circular arrangement: array treated as circular",
          "Three-line container: volume defined by three indices",
          "Weighted distances or non-uniform spacing",
          "Add constraint: indices must be coprime / prime distance",
          "Count number of containers exceeding threshold K"
        ],
        "objective_transforms": [
          "minimize area under constraint",
          "count all valid pairs with area ≥ K",
          "find k-th largest container area"
        ]
      }
    }
  },
  {
    "title": "Calculate Parking Fees and Duration",
    "slug": "calculate-parking-fees-and-duration",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度的较小值决定；若当前高度低于该值，则可蓄水，否则不能",
      "Objective Function": "计算整个数组中所有位置能够接到的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针从左右两端向内收缩，维护 left_max 和 right_max：当 left_max ≤ right_max 时，左指针所在位置的蓄水量仅受限于 left_max，可安全计算并右移左指针；反之则右移右指针。指针移动过程中不破坏已确定区域的最优性",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许为负数（如表示凹陷地形）",
        "维度扩展": "从 1D 扩展到 2D 网格上的接雨水问题",
        "输入模式": "是否支持在线输入或动态更新（如单点修改后重新查询）",
        "输出要求": "是否需要输出每个位置的具体蓄水量而非总和",
        "结构变形": "数组是否为环形结构（即首尾相连）",
        "数据规模": "n 的数量级（例如 1e3 / 1e5 / 1e7），影响解法选择（预处理 or 双指针）",
        "多组数据": "是否包含多组测试用例或批量处理请求"
      }
    }
  },
  {
    "title": "Bitwise OR of Adjacent Elements",
    "slug": "bitwise-or-of-adjacent-elements",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "size": "n",
        "description": "Given an array H[1..n] where each element H[i] represents the height of a vertical bar at position i."
      },
      "Core Constraint": {
        "constraint": "The water trapped at any position depends on the maximum height to its left and right; specifically, the effective boundary is determined by the minimum of the two maxima.",
        "properties": [
          "Left and right maxima are independent but must be globally consistent",
          "Local information (current height) is insufficient without global context (max left/right)"
        ]
      },
      "Objective Function": {
        "type": "sum aggregation",
        "goal": "Compute the total amount of rainwater that can be trapped between the bars after raining."
      },
      "Algorithmic Invariant": {
        "invariant": "Two pointers (L, R) traverse from both ends toward the center, maintaining the following:",
        "rules": [
          "maxLeft maintains the highest bar encountered so far from the left",
          "maxRight maintains the highest bar encountered so far from the right",
          "If maxLeft <= maxRight, then the water at L is solely constrained by maxLeft, so it can be safely calculated",
          "Similarly, if maxRight < maxLeft, the water at R is constrained by maxRight",
          "Moving the pointer with smaller max does not risk underestimating the trapping capacity"
        ],
        "correctness_basis": "The lower of the two side maxima determines the current safe fill level, and advancing the corresponding index preserves optimality."
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value domain",
            "options": [
              "non-negative integers",
              "integers (allowing negative heights)",
              "real numbers"
            ]
          },
          {
            "name": "input dimension",
            "options": [
              "1D",
              "2D (grid version: 'Trapping Rain Water II')",
              "circular array"
            ]
          },
          {
            "name": "data mode",
            "options": [
              "offline batch input",
              "online streaming queries",
              "dynamic updates (support point update or range modification)"
            ]
          },
          {
            "name": "output requirement",
            "options": [
              "total sum only",
              "per-position contribution",
              "maximum single container capacity",
              "number of filled positions"
            ]
          },
          {
            "name": "objective variation",
            "options": [
              "minimize overflow",
              "count number of trapped units",
              "maximize container area (e.g., 'Container With Most Water')"
            ]
          },
          {
            "name": "constraint visibility",
            "options": [
              "explicit monotonicity",
              "implicit structure (e.g., unimodal, random)"
            ]
          },
          {
            "name": "input order",
            "options": [
              "arbitrary order",
              "sorted (by height or index)",
              "partially ordered"
            ]
          },
          {
            "name": "multiplicity",
            "options": [
              "single instance",
              "multiple test cases",
              "interactive problem"
            ]
          }
        ]
      }
    }
  },
  {
    "title": "Minimum Average of Smallest and Largest Elements",
    "slug": "minimum-average-of-smallest-and-largest-elements",
    "schema": {
      "Input Structure": [
        "长度为 n 的整数数组 nums，其中 n 为偶数",
        "nums[i] ∈ [1, 50]",
        "初始为空的浮点数数组 averages"
      ],
      "Core Constraint": [
        "每次操作必须移除当前 nums 中的最小元素和最大元素",
        "每轮生成的平均值 (minElement + maxElement) / 2 依赖全局极值的位置",
        "操作不可逆，且每轮改变数组规模（-2）",
        "最终 averages 数组长度为 n / 2"
      ],
      "Objective Function": "返回 averages 数组中的最小元素",
      "Algorithmic Invariant": [
        "贪心选择不变性：每次取全局最小与最大元素可保证配对策略最优",
        "排序后双端推进不变性：将 nums 排序后，最优配对始终发生在首尾指针之间",
        "averages 中的最小值必然出现在某一对 (sorted[i], sorted[n-1-i]) 的均值中，i ∈ [0, n/2)"
      ],
      "Transformable Parameters": {
        "n 的数量级": "原题较小（n ≤ 50），可扩展至 1e5 要求在线算法",
        "值域范围": "nums[i] 是否允许负数或浮点数",
        "是否有序输入": "输入是否已排序（影响实现方式）",
        "配对规则变化": "从 '最小+最大' 改为 '最小+次小' 或相邻配对等",
        "目标函数变化": "求 averages 的最大值、中位数、总和或方差",
        "输出形式变化": "返回整个 averages 数组，或构造字典频次统计",
        "多组数据": "处理 T 组测试用例，T ≥ 1",
        "在线版本": "元素动态加入 nums，支持查询当前可能的最小平均配对值",
        "约束反转": "要求最大化最终 averages 的最小值（类似二分判定）"
      }
    }
  },
  {
    "title": "Maximum Score From Grid Operations",
    "slug": "maximum-score-from-grid-operations",
    "schema": {
      "Input Structure": {
        "type": "2D matrix",
        "dimensions": "n x n",
        "values": "non-negative integers",
        "initial_state": "all cells are white (conceptual)",
        "operation_definition": "select cell (i, j), color column j from row 0 to row i (inclusive) black"
      },
      "Core Constraint": {
        "coloring_rule": "only downward coloring in a column is allowed, starting from the top",
        "scoring_condition": "a white cell (i, j) contributes to score only if at least one of its left or right neighbors (in the same row) is black",
        "independence": "column operations are independent; effect on scoring depends on horizontal adjacency"
      },
      "Objective Function": "maximize total score by choosing optimal sequence of column coloring operations",
      "Algorithmic Invariant": {
        "greedy_column_decision": "each column's coloring height can be decided independently to maximize contribution under neighbor constraints",
        "monotonicity_in_effect": "increasing the depth of coloring in a column never removes previously enabled contributions, but may enable new ones via side adjacency",
        "state_separation": "once a row segment is colored black, it permanently enables potential scoring for adjacent columns' white cells in that row"
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 100",
        "value_range": "0 <= grid[i][j] <= 1e9",
        "matrix_shape": "square (n x n), but extensible to rectangular m x n",
        "coloring_direction": "current: top-down per column; modifiable to bottom-up, or bidirectional with cost",
        "adjacency_definition": "currently left/right; could extend to include up/down or diagonal",
        "scoring_trigger": "currently requires at least one horizontal black neighbor; could change to both, or weighted neighborhood sum",
        "input_type": "offline batch input; could become online stream of updates or queries",
        "operation_constraints": "unlimited operations now; could add limits on number of operations or per-column usage",
        "output_requirement": "currently maximum total score; could ask for construction of operation sequence or lexicographically smallest solution"
      }
    }
  },
  {
    "title": "Maximum Height of a Triangle",
    "slug": "maximum-height-of-a-triangle",
    "schema": {
      "Input Structure": [
        "两个整数 red 和 blue",
        "表示红色球和蓝色球的数量",
        "1 <= red, blue <= 100"
      ],
      "Core Constraint": [
        "三角形第 i 行恰好有 i 个球",
        "每一行的球颜色必须相同",
        "相邻行颜色必须不同",
        "总使用球数不能超过 red + blue",
        "颜色分配受红蓝数量限制，且交替约束导致路径唯一（以起始颜色决定）"
      ],
      "Objective Function": "最大化三角形的高度（即完整行数）",
      "Algorithmic Invariant": [
        "高度 h 的构造仅依赖于两种策略：从红色开始或从蓝色开始",
        "对于固定 h，所需红蓝球总数可预先计算：若从红开始，则奇数行用红（1+3+5+...），偶数行用蓝（2+4+6+...）",
        "最优性不依赖中间状态，只取决于累计和是否满足资源约束",
        "贪心可行性：一旦某高度不可构造，更高高度必然不可构造（单调性）"
      ],
      "Transformable Parameters": {
        "n 的数量级": "red, blue <= 100 → 可扩展至 1e9（允许公式推导）",
        "值域": "非负整数，可支持零值或负数（无效输入处理）",
        "是否有序": "无关（输入为标量）",
        "是否循环": "否（可变形为环形染色？但结构不兼容）",
        "是否多组输入": "可支持多组测试用例",
        "是否在线": "离线为主；可设计为动态增加球数并查询当前最大高度",
        "颜色数量": "可推广至 k 种颜色交替限制",
        "交替规则": "相邻不同 → 更长周期如 RGB 循环",
        "目标形式": "最大高度 → 判定是否存在高度 h 的方案 / 方案计数"
      }
    }
  },
  {
    "title": "Find the Encrypted String",
    "slug": "find-the-encrypted-string",
    "schema": {
      "Input Structure": [
        "字符串 s[1..n]，其中 n = |s|",
        "字符集：小写英文字母（a-z）",
        "整数 k，表示循环偏移量",
        "约束：1 <= n <= 100, 1 <= k <= 10000"
      ],
      "Core Constraint": [
        "每个字符的加密结果由其在字符串中后方第 k 个位置的字符决定（循环索引）",
        "索引计算具有模运算周期性：(i + k) % n",
        "加密过程不依赖字符语义，仅依赖位置和循环结构"
      ],
      "Objective Function": "构造并返回加密后的字符串，其中每个位置 i 的字符被替换为 s[(i + k) % n]",
      "Algorithmic Invariant": [
        "加密映射是确定性的：每个输入位置 i 唯一对应输出位置 (i + k) % n",
        "整个变换是双射（bijection），可逆（若已知 k 和 n）",
        "无需额外状态维护：每个字符的替换独立于其他字符的值"
      ],
      "Transformable Parameters": {
        "k 的取值范围": "正整数 → 可扩展为负数（左移）或动态变化",
        "字符串是否循环": "是（当前设定）→ 可改为非循环（越界则填充默认字符）",
        "字符集类型": "小写字母 → 可推广至大写、数字、ASCII 或 Unicode",
        "加密层级": "单层偏移 → 可叠加多轮加密或条件跳变 k",
        "输入形式": "单组字符串 → 多组查询 / 在线流式字符输入",
        "操作类型": "只读加密 → 支持修改某个字符后重新加密（支持更新操作）",
        "数据规模": "n <= 100 → 可放大至 1e5+，要求 O(n) 或更优解法",
        "输出要求": "返回完整字符串 → 可改为输出某一位或支持随机访问查询"
      }
    }
  },
  {
    "title": "Find the Level of Tree with Minimum Sum",
    "slug": "find-the-level-of-tree-with-minimum-sum",
    "schema": {
      "Input Structure": "一维数组 H[1..n]，其中 H[i] ≥ 0，表示每个位置的柱状图高度",
      "Core Constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度中的较小值决定；若当前高度低于该值，则可蓄水",
      "Objective Function": "计算整个数组中能接住的雨水总量（求和）",
      "Algorithmic Invariant": "使用双指针维护左右两侧的最大高度；当左指针处的左侧最大值小于等于右指针处的右侧最大值时，左指针当前位置的蓄水量可确定，并向右移动左指针；反之则右指针左移；已遍历区域的贡献值不变",
      "Transformable Parameters": {
        "值域变化": "H[i] 是否允许负数（如地下结构变形题）",
        "维度扩展": "从 1D 扩展到 2D 网格（二维接雨水问题）",
        "输入模式": "是否在线输入（动态添加柱子）",
        "操作类型": "是否支持修改、删除或插入操作（带更新的数据结构题）",
        "输出要求": "是否需要输出每个位置的具体蓄水量而非总和",
        "多组数据": "是否存在多组测试用例连续输入",
        "数组性质": "数组是否有序、是否循环（环形地形蓄水问题）"
      }
    }
  },
  {
    "title": "Number of Subarrays With AND Value of K",
    "slug": "number-of-subarrays-with-and-value-of-k",
    "schema": {
      "Input Structure": [
        "一维整数数组 nums[1..n]",
        "每个元素 nums[i] ∈ [0, 10^9]",
        "整数 k ∈ [0, 10^9]",
        "n ∈ [1, 10^5]"
      ],
      "Core Constraint": [
        "子数组的按位 AND 结果具有单调不增性：随着子数组扩展，AND 值只能保持不变或变小",
        "一旦某个位置开始向右延伸的 AND 值小于 k，则继续延伸不可能再等于 k（除非 k=0）",
        "对于固定左端点，右端点范围内满足 AND = k 的区间至多为连续的一段"
      ],
      "Objective Function": "计数：统计有多少个连续子数组，其所有元素的按位 AND 运算结果恰好等于 k",
      "Algorithmic Invariant": [
        "双指针或滑动窗口结合值域分组：利用 AND 单调性剪枝搜索空间",
        "每个起始位置 i 的 AND 路径上，不同取值最多 O(log(max(nums))) 个（因为每次变化至少一位被清零）",
        "使用哈希表维护以当前位置结尾的所有可能 AND 值及其来源数量，实现线性递推（动态状态压缩）"
      ],
      "Transformable Parameters": {
        "数据规模": "n 的范围可调整（如 1e3 → 1e5），影响是否允许 O(n^2) 或必须 O(n log max) 解法",
        "值域": "nums[i] 和 k 的范围可缩放（如限制在 [0, 2^m-1]），控制位运算复杂度",
        "目标函数变换": [
          "改为求最大/最小子数组 AND 值",
          "求是否存在一个子数组 AND 等于 k（判定问题）",
          "求 AND ≥ k 的子数组个数"
        ],
        "输入形式": [
          "是否多组测试数据",
          "是否在线查询（逐步添加元素并回答当前答案）"
        ],
        "约束条件": [
          "是否要求子数组长度至少为 L",
          "是否要求子数组长度为偶数等附加限制"
        ],
        "结构变形": [
          "从一维数组变为环形数组",
          "扩展到二维矩阵中子矩形 AND 为 k 的计数"
        ]
      }
    }
  },
  {
    "title": "Employee Task Duration and Concurrent Tasks",
    "slug": "employee-task-duration-and-concurrent-tasks",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "non-negative integer",
        "size": "n",
        "description": "一维数组 H[1..n]，H[i] ≥ 0，表示柱状图中每个位置的高度"
      },
      "Core Constraint": {
        "constraint": "每个位置能接的雨水量由其左侧最大高度和右侧最大高度中的较小值决定",
        "independence": "左右两侧的最大值可以独立维护",
        "global_consistency": "必须在整个数组范围内确定左右边界极值才能计算局部容量"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "two_pointers",
        "invariants": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示左指针遍历过的最大高度，maxRight 表示右指针遍历过的最大高度",
          "若 maxLeft ≤ maxRight，则左指针当前位置的可接水量仅由 maxLeft 决定，可安全累加并右移 L",
          "反之则右指针当前位置的可接水量由 maxRight 决定，可安全累加并左移 R",
          "指针移动过程中已确定区域的解始终保持最优性"
        ]
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "description": "高度是否允许为负数"
          },
          {
            "name": "dimensionality",
            "options": [
              "1D",
              "2D",
              "circular"
            ],
            "description": "从一维扩展到二维或环形结构"
          },
          {
            "name": "input_mode",
            "options": [
              "offline",
              "online",
              "streaming"
            ],
            "description": "输入是一次性给出还是在线流式输入"
          },
          {
            "name": "output_granularity",
            "options": [
              "total_sum",
              "per_position"
            ],
            "description": "输出是总和还是每个位置的具体接水量"
          },
          {
            "name": "dynamic_operations",
            "options": [
              "static",
              "support_update_delete"
            ],
            "description": "是否支持对数组进行修改、删除等动态操作"
          },
          {
            "name": "data_order",
            "options": [
              "unordered",
              "sorted"
            ],
            "description": "输入数组是否有序"
          },
          {
            "name": "multiple_test_cases",
            "type": "boolean",
            "description": "是否包含多组测试数据"
          }
        ]
      }
    }
  },
  {
    "title": "Maximize Total Cost of Alternating Subarrays",
    "slug": "maximize-total-cost-of-alternating-subarrays",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "constraints": [
          "n >= 1",
          "n <= 1e5",
          "nums[i] ∈ [-1e9, 1e9]",
          "array is given as nums[0..n-1]"
        ]
      },
      "Core Constraint": {
        "description": "子数组成本按交替符号计算：起始项为正，后续项符号交替；可通过分割改变总和——分割可消除负贡献项的影响。",
        "key_idea": "每个子数组的成本由其起始位置的符号规则决定（首项为正），因此通过合理分割可以强制某些元素以正值参与求和。",
        "implication": "任意位置 i 的 nums[i] 可被包含在一个以其为起点或偶数偏移处开始的子数组中，从而使其贡献为 +nums[i]。目标是最大化正贡献、最小化负贡献。"
      },
      "Objective Function": {
        "goal": "maximization",
        "target": "sum of cost(l, r) over all contiguous subarrays in a partition",
        "requirement": "every element belongs to exactly one subarray"
      },
      "Algorithmic Invariant": {
        "primary_method": "dynamic programming",
        "state_definition": "dp[i] = maximum total cost achievable for prefix nums[0..i]",
        "transition_rule": "dp[i] = max_{0 <= j <= i} { dp[j-1] + alternating_sum(nums[j..i]) }",
        "optimization_invariant": "在最优分割下，每个位置 i 要么作为新子数组起点（贡献为 +nums[i]），要么继承前一项的交替模式；可通过状态机压缩转移：维护两个状态：last_positive_end 和 last_negative_end，表示以上一个元素结尾时其符号是正还是负。",
        "monotonicity_or_greedy_condition": "无直接贪心选择性质，但存在最优子结构和重叠子问题，支持线性DP优化"
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "n",
            "range": [
              1,
              100000
            ],
            "can_be_modified": true
          },
          {
            "name": "value_range",
            "range": [
              -1000000000,
              1000000000
            ],
            "can_be_modified": true
          },
          {
            "name": "initial_sign_rule",
            "options": [
              "positive_first",
              "negative_first",
              "alternating_from_index_parity"
            ],
            "default": "positive_first",
            "description": "是否改变子数组内符号起始方式"
          },
          {
            "name": "partition_constraint",
            "options": [
              "unrestricted_partition",
              "at_least_k_subarrays",
              "at_most_k_subarrays",
              "exact_k_subarrays"
            ],
            "default": "unrestricted_partition"
          },
          {
            "name": "input_structure",
            "options": [
              "1D_array",
              "2D_grid",
              "circular_array"
            ],
            "default": "1D_array"
          },
          {
            "name": "data_mode",
            "options": [
              "offline_single",
              "multiple_test_cases",
              "online_queries"
            ],
            "default": "offline_single"
          },
          {
            "name": "output_requirement",
            "options": [
              "max_sum_only",
              "construct_optimal_partition",
              "count_number_of_optimal_partitions"
            ],
            "default": "max_sum_only"
          }
        ]
      }
    }
  },
  {
    "title": "Alternating Groups I",
    "slug": "alternating-groups-i",
    "schema": {
      "Input Structure": [
        "环形一维数组 colors[1..n]",
        "colors[i] ∈ {0, 1}",
        "n ≥ 3",
        "表示瓷砖颜色的二值数组"
      ],
      "Core Constraint": [
        "交替组定义为连续三块瓷砖 (i-1, i, i+1)，满足：",
        "colors[i] ≠ colors[i-1] 且 colors[i] ≠ colors[i+1]",
        "由于是环形结构，下标对 n 取模，即 colors[n] 与 colors[1] 相邻",
        "局部判定依赖三个连续元素，且左右对称"
      ],
      "Objective Function": [
        "计数：统计整个环中满足条件的交替组数量"
      ],
      "Algorithmic Invariant": [
        "遍历每个位置 i 作为中间点时，其是否构成交替组仅取决于其左右邻居",
        "环形结构下，(i-1, i, i+1) 的合法性可通过模运算统一处理",
        "无需状态记忆或全局信息，每个位置可独立判断",
        "总答案为所有合法中间点的累加，具有可加性"
      ],
      "Transformable Parameters": {
        "n 的数量级": "3 <= n <= 100（当前），可扩展至 1e5（需线性解）",
        "颜色种类": "当前为二色（0/1），可推广为 k 色序列",
        "交替长度": "当前固定为3块，可改为长度为 k 的交替模式",
        "结构形式": "当前为环形，可变换为线性（非环）结构",
        "是否多组数据": "当前单组输入，可设计为多测情形",
        "是否在线": "当前离线输入，可改造为动态添加瓷砖并查询交替组数",
        "输出形式": "当前为总数，可改为输出所有交替组的位置索引"
      }
    }
  },
  {
    "title": "Vowels Game in a String",
    "slug": "vowels-game-in-a-string",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n",
        "constraints": [
          "1 <= n <= 10^5",
          "s consists of lowercase English letters only"
        ],
        "feature": "vowel count parity in substrings",
        "vowels": [
          "a",
          "e",
          "i",
          "o",
          "u"
        ]
      },
      "Core Constraint": {
        "turn_based_removal": true,
        "player_rules": {
          "Xiaohong": "must remove a non-empty substring with odd number of vowels",
          "Xiaoming": "must remove a non-empty substring with even number of vowels"
        },
        "game_progression": "after each move, the string becomes the concatenation of remaining parts",
        "optimal_play": "both players play optimally",
        "loss_condition": "the player who cannot make a move on their turn loses"
      },
      "Objective Function": {
        "type": "decision problem",
        "goal": "determine whether Xiaohong (first player) can win the game",
        "output": "boolean: true if Xiaohong wins under optimal play, else false"
      },
      "Algorithmic Invariant": {
        "grundy_theory_applicable": true,
        "state_representation": "game state defined by current string or its vowel-count parity profile",
        "substructure_independence": "removal splits string into independent segments if non-adjacent",
        "parity_preservation": "total vowel count modulo 2 is preserved across moves up to removal choice",
        "winning_state_characterization": "a position is winning if there exists at least one valid move leading to a losing state for opponent"
      },
      "Transformable Parameters": {
        "n_range": [
          "1",
          "10^3",
          "10^5"
        ],
        "alphabet_type": [
          "binary (vowel/consonant)",
          "general lowercase letters"
        ],
        "vowel_definition": [
          "standard: a,e,i,o,u",
          "custom set",
          "language-specific"
        ],
        "move_constraints": [
          "odd/even vowel count",
          "exact count",
          "divisibility condition",
          "minimum length + parity"
        ],
        "turn_sequence": [
          "alternating: odd -> even -> odd...",
          "fixed player roles",
          "multiple players"
        ],
        "input_form": [
          "single string",
          "multiple test cases",
          "online stream of characters"
        ],
        "operation_type": [
          "substring removal only",
          "substring replacement",
          "insertion allowed after removal"
        ],
        "output_form": [
          "boolean decision",
          "number of moves until end",
          "construct winning strategy"
        ],
        "additional_constraints": [
          "removed substring must be contiguous and non-empty",
          "can remove any qualifying substring (not necessarily minimal/maximal)",
          "no restriction on position"
        ]
      }
    }
  },
  {
    "title": "Find the Minimum Area to Cover All Ones I",
    "slug": "find-the-minimum-area-to-cover-all-ones-i",
    "schema": {
      "Input Structure": [
        "二维二进制数组 grid[1..m][1..n]",
        "grid[i][j] ∈ {0, 1}",
        "1 <= m, n <= 1000",
        "至少包含一个 1"
      ],
      "Core Constraint": [
        "所有值为 1 的元素必须被包含在矩形内部",
        "矩形的边必须与坐标轴平行（即仅水平和竖直方向）",
        "最小矩形由最左、最右、最上、最下 1 的位置唯一确定"
      ],
      "Objective Function": "求覆盖所有 1 的最小矩形面积（即 (max_row - min_row + 1) * (max_col - min_col + 1)）",
      "Algorithmic Invariant": [
        "一旦确定所有 1 的行坐标的最小值与最大值，列坐标的最小值与最大值，最优矩形即唯一确定",
        "遍历过程中维护当前观测到的 min_row, max_row, min_col, max_col，更新不影响最终解的正确性",
        "局部极值的合并具有全局最优性（即边界可分离计算）"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "m, n 的数量级": [
            "<= 1000",
            "可扩展至 <= 1e5（需压缩坐标）"
          ]
        },
        "输入形式": [
          "静态离线输入",
          "可改为在线流式输入（逐行/逐点给出 1 的位置）"
        ],
        "值域约束": [
          "二进制 → 多类别标记（如要求包围特定类别的点）",
          "允许负坐标（通过坐标偏移）"
        ],
        "几何约束": [
          "轴对齐矩形 → 允许旋转的最小包围矩形（不同算法）",
          "二维 → 三维（最小立方体包围所有 1）"
        ],
        "目标函数变化": [
          "最小面积 → 最小周长",
          "最小面积 → 在面积最小前提下，求字典序最小的矩形"
        ],
        "多组数据": "是否处理多个独立 grid 的查询",
        "隐藏条件": "1 的分布是否具有单调性或聚集性（可用于剪枝）"
      }
    }
  },
  {
    "title": "Count the Number of Inversions",
    "slug": "count-the-number-of-inversions",
    "schema": {
      "Input Structure": [
        "整数 n，表示排列长度，范围 [2, 300]",
        "二维数组 requirements，其中每个元素为 [end_i, cnt_i]",
        "end_i ∈ [0, n-1]，表示前缀 perm[0..end_i] 的末尾下标",
        "cnt_i ∈ [0, 400]，表示该前缀中要求的逆序对数目",
        "输入保证所有 end_i 互不相同，且至少有一个 end_i == n-1",
        "目标是构造排列 perm ∈ {0, 1, ..., n-1} 的一个排列"
      ],
      "Core Constraint": [
        "逆序对定义：i < j 且 perm[i] > perm[j]",
        "每个 requirement 约束了一个前缀 perm[0..end_i] 中的逆序对总数必须恰好等于 cnt_i",
        "多个前缀约束之间可能重叠（如 end_i=1 和 end_i=2），因此具有前后依赖性",
        "排列的构造是顺序决定的，后续元素插入会影响新增逆序对数量",
        "逆序对总数在前缀扩展过程中单调不减"
      ],
      "Objective Function": "计数：求满足所有 requirements 的排列 perm 的总数，结果对 1e9+7 取模",
      "Algorithmic Invariant": [
        "动态规划状态设计：dp[i][k] 表示考虑前 i+1 个位置（即前缀 [0..i]）时，产生恰好 k 个逆序对的合法方式数",
        "状态转移：当确定第 i 个位置插入的数值时，其贡献的新增逆序对数取决于之前已选数字中有多少大于它的值",
        "由于是排列，可利用组合性质：在位置 i 插入一个数时，最多可贡献 i 个新逆序对（若插入最大值则为 0，最小值则为 i）",
        "requirement 提供了关键点上的强制状态约束：若存在 requirement [i, c]，则 dp[i][c] 是唯一有效状态，其余为 0",
        "状态可从前向后递推，且只在满足 constraint 的位置进行剪枝或强制赋值"
      ],
      "Transformable Parameters": [
        "n 的数量级：当前为 ≤300，可变体可设为 ≤1000 或更高以测试优化 DP",
        "cnt_i 上界：当前 ≤400，可扩展至 O(n²) 水平以考察完全逆序情况",
        "是否所有 end_i 都给出：当前 requirements.length ≤ n，可改为稀疏约束或仅部分前缀约束",
        "是否允许多组数据：可设计为多测 case 输入",
        "是否在线添加 requirement：从离线变为在线查询，要求动态更新答案",
        "目标函数变化：从计数 → 判定是否存在 / 构造字典序最小解",
        "输入结构变化：从排列 → 允许重复元素的数组，改变逆序对统计方式",
        "约束类型变化：从‘恰好 cnt_i’ → ‘至少’或‘至多’，改变 DP 转移方向"
      ]
    }
  },
  {
    "title": "Find the Minimum Area to Cover All Ones II",
    "slug": "find-the-minimum-area-to-cover-all-ones-ii",
    "schema": {
      "Input Structure": "二维二进制数组 grid[1..m][1..n]，其中 m, n ≥ 1，grid[i][j] ∈ {0, 1}，表示网格中每个位置是否包含点（1 表示存在）",
      "Core Constraint": "三个矩形必须覆盖所有值为 1 的格子，且互不重叠（可相接），每个矩形必须是边与坐标轴对齐的连续子矩阵，面积非零",
      "Objective Function": "最小化三个矩形的面积之和",
      "Algorithmic Invariant": "最优解中，至少存在一种方式将所有 1 划分为三组连通块，每组可被一个极小外接矩形完全覆盖；通过枚举分割线（水平或垂直）或状态划分，可将问题分解为子结构并保持局部最优性合并的可行性",
      "Transformable Parameters": {
        "grid 尺寸范围": "m, n ∈ [1, 30] → 可扩展至更大规模或固定维度",
        "矩形数量限制": "3 个 → 可推广为 k 个不重叠矩形（k ≥ 1）",
        "重叠约束": "严格不重叠 → 允许边界共享 / 完全分离 / 允许重叠",
        "目标函数形式": "最小面积和 → 最大覆盖效率 / 最小最大面积 / 是否存在可行解",
        "输入类型变化": "二进制网格 → 多值标签网格（不同类别需分别覆盖）",
        "在线性": "一次性输入 → 动态添加/删除 1 点后重新计算",
        "输出要求": "仅返回最小面积和 → 输出三个矩形的具体坐标"
      }
    }
  },
  {
    "title": "Maximum Number of Upgradable Servers",
    "slug": "maximum-number-of-upgradable-servers",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 H[1..n]，表示每个位置的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度中的较小值决定",
        "independence": "左右侧最大值可独立维护",
        "global_dependency": "局部储水量依赖于全局极值信息"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "technique": "双指针",
        "invariants": [
          "维护左指针 L 和右指针 R，以及从左到 L 的最大值 maxLeft，从右到 R 的最大值 maxRight",
          "若 maxLeft ≤ maxRight，则位置 L 处的储水量仅由 maxLeft 决定，且可安全累加并右移 L",
          "反之则位置 R 处的储水量由 maxRight 决定，可累加并左移 R",
          "指针移动过程中已确定区域的解保持不变且最优"
        ]
      },
      "Transformable Parameters": {
        "n_range": "1 <= n <= 10^5",
        "value_range": "0 <= H[i] <= 10^4",
        "negatives_allowed": false,
        "dimension_extension": "可扩展至二维矩阵（2D接雨水）",
        "online_input": false,
        "update_operations": false,
        "output_granularity": "总和（可改为输出每个位置的储水量）",
        "input_order": "静态离线输入（可变为动态或流式输入）",
        "multiplicity": "单组数据（可扩展为多组测试用例）",
        "circular": false
      }
    }
  },
  {
    "title": "Invalid Tweets II",
    "slug": "invalid-tweets-ii",
    "schema": "{\n  \"Input Structure\": {\n    \"type\": \"array\",\n    \"dimension\": 1,\n    \"elements\": \"non-negative integers\",\n    \"size\": \"n\",\n    \"sorted\": false,\n    \"duplicates\": true,\n    \"description\": \"一维数组 H[1..n]，其中 H[i] 表示柱子的高度，H[i] ≥ 0\"\n  },\n  \"Core Constraint\": {\n    \"constraint\": \"每个位置的积水高度由其左侧和右侧最大高度的较小值决定\",\n    \"independence\": \"左右侧最大值可独立维护\",\n    \"global_dependency\": \"局部积水依赖于全局极值分布\",\n    \"monotonicity\": false,\n    \"description\": \"若某位置两侧存在更高的柱子，则该位置可积水；积水容量取决于‘短板’（min(left_max, right_max)）\"\n  },\n  \"Objective Function\": {\n    \"type\": \"sum\",\n    \"goal\": \"compute total trapped water\",\n    \"output\": \"single integer representing the total amount of water that can be trapped\",\n    \"description\": \"求所有索引位置上能接住的雨水总量\"\n  },\n  \"Algorithmic Invariant\": {\n    \"technique\": \"two pointers\",\n    \"invariants\": [\n      \"左指针左侧的最大值 maxLeft 已知\",\n      \"右指针右侧的最大值 maxRight 已知\",\n      \"若 maxLeft ≤ maxRight，则左指针当前位置的积水可确定（无需知道右边全部信息）\",\n      \"移动较小一侧指针，能保证不丢失最优性\",\n      \"已遍历区域的贡献已被正确计算且不再修改\"\n    ],\n    \"description\": \"通过双指针从两端向内收缩，利用当前边界极值关系安全地确定某一端点的局部解\"\n  },\n  \"Transformable Parameters\": {\n    \"n_range\": [1, 2 * 10**4],\n    \"value_range\": [0, 10**5],\n    \"negative_values_allowed\": false,\n    \"input_dimension\": \"1D\",\n    \"extension_to_2D\": true,\n    \"online_queries\": false,\n    \"supports_updates\": false,\n    \"multiple_test_cases\": false,\n    \"circular_array\": false,\n    \"output_detailed\": false,\n    \"constraints_variants\": [\n      \"改为输出每个位置的积水\",\n      \"目标函数变为：是否存在至少 K 单位的水\",\n      \"约束反转：仅允许使用连续区间中的柱子\",\n      \"输入流式化：数据逐个到达，需在线估计上限\",\n      \"隐式单调性：数组不可见，只能通过查询接口获取 H[i]\"\n    ],\n    \"description\": \"可用于生成变体题目的参数空间，支持维度扩展、目标变换、约束调整等规则化变换\"\n  }\n}"
  },
  {
    "title": "Find the Maximum Length of a Good Subsequence I",
    "slug": "find-the-maximum-length-of-a-good-subsequence-i",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size_range": "1 <= n <= 500",
        "value_range": "1 <= nums[i] <= 10^9",
        "additional_properties": [
          "非负整数数组",
          "允许重复元素",
          "无序"
        ]
      },
      "Core Constraint": {
        "description": "好子序列中，在 [0, seq.length - 2] 范围内，最多有 k 个相邻元素不相等的位置（即值变化次数 ≤ k）",
        "key_insight": "子序列的‘变化次数’由相邻不同值的对数决定，而非连续段长度；选择元素时可跳过任意位置，但一旦选定，顺序保持原数组顺序",
        "constraint_formal": "令 changes(seq) = count of i ∈ [0, len(seq)-2] such that seq[i] ≠ seq[i+1]，要求 changes(seq) ≤ k"
      },
      "Objective Function": {
        "type": "maximization",
        "target": "最长好子序列的长度",
        "output_type": "integer"
      },
      "Algorithmic Invariant": {
        "invariant_description": "动态规划状态 dp[i][last_val][changes] 或 dp[pos][last_idx][changes] 可保证：处理到前 i 个元素时，以某值结尾且已发生 c 次变化的所有可能子序列中，长度最大值已被记录",
        "optimality_preservation": [
          "新增元素若与前一元素相同，则不增加变化次数，可安全扩展",
          "若不同，则变化次数 +1，需检查是否超过 k",
          "由于仅关心变化次数和长度，相同结尾值的状态可以合并（贪心压缩）"
        ],
        "main_paradigm": "dynamic programming",
        "secondary_techniques": [
          "coordinate compression (due to large value range but small distinct values)",
          "state optimization via last value and change count"
        ]
      },
      "Transformable Parameters": {
        "n_magnitude": "small scale: n ≤ 500 → allows O(n²k) or O(nkC) DP",
        "k_range": "0 <= k <= min(n, 25): bounded small → enables DP over change count",
        "value_domain_size": "虽然值域大（10^9），但实际不同值数量少（暗示坐标压缩可行性）",
        "ordering": "input is unordered; subsequence preserves original order",
        "data_mode": "single batch input",
        "online_query": false,
        "circular_array": false,
        "multi_dimensional_extension": false,
        "objective_variants": [
          "计数类：有多少个最长好子序列",
          "判定类：是否存在长度 ≥ L 的好子序列",
          "构造类：输出一个最长好子序列"
        ],
        "constraint_transformations": [
          "将 '≤ k 次变化' 改为 '≥ k 次变化'",
          "改为恰好 k 次变化",
          "加入连续段长度限制（如每段至少长 m）"
        ],
        "input_structure_variations": [
          "二维网格路径上的好序列问题",
          "树上路径中的好子序列"
        ],
        "algorithmic_impact_of_changes": "当 k 增大至 O(n)，则退化为普通 LIS 类问题；当 k=0，则变为最长常值子序列问题"
      }
    }
  },
  {
    "title": "Minimum Length of String After Operations",
    "slug": "minimum-length-of-string-after-operations",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "lowercase English letters",
        "length": "n",
        "constraints": [
          "1 <= n <= 2 * 10^5",
          "string s consists of only lowercase letters"
        ]
      },
      "Core Constraint": {
        "operation_rule": "an index i can be selected only if there exists at least one same character to its left and one to its right",
        "deletion_rule": "delete the closest same character to the left and the closest same character to the right of s[i]",
        "independence": "operations can be performed in any order, but each deletion affects future availability of characters",
        "structural_dependency": "feasibility of operation at position i depends on global distribution of character occurrences"
      },
      "Objective Function": "minimize the final length of the string after performing any number of valid operations",
      "Algorithmic Invariant": {
        "greedy_invariance": "if a character occurrence can be used as the 'middle' in an operation, removing its nearest left and right duplicates does not prevent achieving optimal reduction",
        "parity_preservation": "for each character, the possibility of eliminating pairs around a center is constrained by the parity of available symmetric configurations",
        "monotonicity": "each operation reduces the string length by exactly 2, so total reduction is even; thus, minimality depends on maximum number of such reductions"
      },
      "Transformable Parameters": {
        "alphabet_size": "variable (e.g., binary string vs full lowercase)",
        "initial_ordering": "ordered / shuffled",
        "operation_constraints": [
          "require consecutive patterns",
          "limit number of operations",
          "restrict i to certain indices (e.g., only vowels)"
        ],
        "input_form": [
          "offline (entire string given)",
          "online (streaming characters, decision must be made incrementally)"
        ],
        "output_form": [
          "return minimum length",
          "return lexicographically smallest result",
          "return sequence of operations"
        ],
        "data_modification": [
          "allow insertion between operations",
          "support undo operations"
        ],
        "dimension_extension": "extend to 2D grid of characters with neighborhood-based rules"
      }
    }
  },
  {
    "title": "Minimum Operations to Make Array Equal to Target",
    "slug": "minimum-operations-to-make-array-equal-to-target",
    "schema": {
      "Input Structure": [
        "两个长度相同的正整数数组 nums[1..n] 和 target[1..n]",
        "n ∈ [1, 1e5]",
        "nums[i], target[i] ∈ [1, 1e8]"
      ],
      "Core Constraint": [
        "每次操作可对任意子数组内的所有元素整体 ±1",
        "操作成本按操作次数计，与子数组长度无关",
        "问题本质转化为差值数组 d[i] = target[i] - nums[i] 的分解问题",
        "一个操作对应在差值数组上选择一个区间 [l, r] 并整体 ±1"
      ],
      "Objective Function": "最小化将差值数组 d 全部变为 0 所需的操作次数（即最少的区间增减次数）",
      "Algorithmic Invariant": [
        "贪心结构：最优策略中，操作顺序可视为从左到右处理差值变化点",
        "相邻差值的变化量决定是否需要新增操作：操作次数等于差值数组的前缀变化总量",
        "令 d[0] = 0，则总操作次数为 Σ|d[i] - d[i-1]|（i 从 1 到 n），即一阶差分的 L1 范数",
        "该公式成立的关键是：每次操作是一个区间的整体增减，等价于在差分序列上修改两个端点"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n": [
            "1e5",
            "1e3",
            "10"
          ],
          "值域": [
            "[1, 1e8]",
            "[1, 100]",
            "负数允许"
          ]
        },
        "输入形式": [
          "单组数据",
          "多组测试用例",
          "在线流式输入（逐元素给出）"
        ],
        "数组性质": [
          "是否有序",
          "是否允许负数",
          "是否循环数组（环形子数组）"
        ],
        "操作类型扩展": [
          "只能增加 / 只能减少",
          "每次操作必须是 +1 或 -1 整体（不可选）",
          "子数组操作有长度限制（如 ≤K）"
        ],
        "目标函数变形": [
          "求最小操作次数（原题）",
          "求最小操作总元素变动量（即 Σ|变化|×长度）",
          "判定是否能在 K 次内完成",
          "计数满足条件的操作方案数"
        ],
        "结构维度扩展": [
          "二维矩阵版本（子矩阵操作）",
          "树上数组（路径操作）",
          "动态修改 nums 或 target 后重新查询（支持更新）"
        ]
      }
    }
  },
  {
    "title": "Generate Binary Strings Without Adjacent Zeros",
    "slug": "generate-binary-strings-without-adjacent-zeros",
    "schema": {
      "Input Structure": [
        "正整数 n，表示二进制字符串的长度",
        "n ∈ [1, 18]",
        "输出为所有长度为 n 的二进制字符串中满足特定子串约束的字符串集合"
      ],
      "Core Constraint": [
        "每个长度为 2 的连续子字符串（即相邻两位）必须至少包含一个 '1'",
        "等价于：不允许出现 \"00\" 作为任何长度为 2 的子串",
        "该约束具有局部性，仅依赖相邻字符"
      ],
      "Objective Function": [
        "构造并返回所有满足条件的长度为 n 的二进制字符串",
        "目标函数类型：构造方案（枚举所有合法解）"
      ],
      "Algorithmic Invariant": [
        "在递归/DFS 构造过程中，每一步添加新字符时只需检查最后两个字符是否构成 \"00\"",
        "状态可增量维护：当前字符串末尾字符决定下一位的可选范围",
        "若当前末尾字符为 '0'，则下一位只能是 '1'",
        "若当前末尾字符为 '1'，则下一位可以是 '0' 或 '1'",
        "此状态转移规则保持合法性不变"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 18（适合 DFS / 递推构造）",
        "值域": "字符集为 {0, 1}，固定二进制",
        "是否有序": "输出顺序任意",
        "是否循环": "原题非循环；可变形为循环字符串（首位相连也需满足约束）",
        "是否多组输入": "单组输入；可扩展为多组测试用例",
        "是否在线": "离线一次性生成；可设计为在线查询第 k 个有效字符串",
        "约束强度": "可调整为：每个长度为 2 的子串中至少包含两个 '1'（即只允许 \"11\"），或放宽为允许有限次 \"00\" 出现",
        "目标函数变化": "改为计数（求有效字符串个数）或判定（是否存在某种模式）"
      }
    }
  },
  {
    "title": "Find the Maximum Length of a Good Subsequence II",
    "slug": "find-the-maximum-length-of-a-good-subsequence-ii",
    "schema": {
      "Input Structure": "一维整数数组 nums[1..n]，其中 n ∈ [1, 5000]，nums[i] ∈ [1, 1e9]；非负整数 k ∈ [0, min(50, n)]",
      "Core Constraint": "好子序列中，在下标范围 [0, len-2] 内，满足 seq[i] != seq[i+1] 的位置个数不超过 k；即：相邻不同元素的转换次数 ≤ k",
      "Objective Function": "求最长的好子序列长度（最大化）",
      "Algorithmic Invariant": "动态规划状态 dp[i][j][v] 表示考虑前 i 个元素、已发生 j 次值变化、结尾值为 v 时的最大长度；或使用滚动优化后的形式 dp[j][v] 可维护：在固定变化次数和结尾值下，最长可延伸子序列长度不变；转移时根据当前值是否与前一选择相同决定是否消耗一次变化额度",
      "Transformable Parameters": {
        "数据规模": {
          "n 的数量级": [
            "n ≤ 5000",
            "k ≤ 50"
          ],
          "k 的范围": [
            "k = 0",
            "k ≥ n",
            "k 可变"
          ]
        },
        "值域特性": [
          "数值范围大（需离散化）",
          "数值范围小（可用数组直接索引）"
        ],
        "输入形式": [
          "单组输入",
          "多组测试数据"
        ],
        "目标函数变形": [
          "求最长好子序列长度（当前题型）",
          "求好子序列的个数（计数类）",
          "判断是否存在长度 ≥ L 的好子序列（判定类）"
        ],
        "约束条件变形": [
          "最多 k 次变化 → 至少 k 次变化",
          "相邻不同 → 相邻差值 > d",
          "允许删除操作 → 在线查询"
        ],
        "结构扩展": [
          "一维数组 → 树上路径上的好序列",
          "线性序列 → 环形序列"
        ],
        "在线性": [
          "静态一次性输入",
          "支持添加/删除元素的动态版本"
        ]
      }
    }
  },
  {
    "title": "String Compression III",
    "slug": "string-compression-iii",
    "schema": {
      "Input Structure": [
        "字符串 word",
        "长度为 n，满足 1 <= n <= 2 * 10^5",
        "字符集为小写英文字母（a-z）",
        "输入是单个一次性离线字符串"
      ],
      "Core Constraint": [
        "每次操作必须移除最长的单字符连续前缀，且其长度上限为 9",
        "压缩过程具有顺序依赖性：只能从前缀开始逐段处理",
        "每段压缩单位由同一字符构成，最大长度为 9",
        "不可跳过或重组字符顺序"
      ],
      "Objective Function": [
        "构造并返回压缩后的字符串 comp",
        "目标函数为构造型：按规则生成输出字符串",
        "不涉及最优化、计数或判定，而是确定性变换"
      ],
      "Algorithmic Invariant": [
        "使用单指针或双指针遍历字符串，维护当前位置和当前字符的连续段长度",
        "每轮处理一个极大连续相同字符段（最多取9个）",
        "已处理部分不会被回溯修改，保证贪心正确性",
        "状态不变量：处理完的位置已永久编码，剩余字符串仍满足原结构"
      ],
      "Transformable Parameters": {
        "最大段长度限制": {
          "原值": 9,
          "可变形式": "k（如改为最多 k 个相同字符）",
          "影响": "改变编码基数，可用于设计不同压缩率题目"
        },
        "字符集类型": {
          "原值": "小写字母 a-z",
          "可变形式": "数字、大写字母、Unicode 字符等",
          "影响": "是否需要哈希映射或额外编码"
        },
        "输入形式": {
          "原值": "单次完整字符串输入",
          "可变形式": [
            "在线字符流输入",
            "多组字符串批量压缩"
          ]
        },
        "数据规模": {
          "原值": "n <= 2 * 10^5",
          "可变范围": [
            "小规模（n <= 100）用于模拟题",
            "超大规模需考虑 I/O 效率"
          ]
        },
        "输出要求": {
          "原值": "返回最终 comp 字符串",
          "可变形式": [
            "输出每一步的操作结果",
            "返回压缩比",
            "验证 comp 是否可逆"
          ]
        },
        "压缩规则扩展": {
          "可选变形": [
            "允许合并非相邻同字符段（破坏局部性）",
            "引入字典预编码（进入 LZ77 类范畴）",
            "加入长度编码方式（如变长整数编码）"
          ]
        },
        "是否可逆": {
          "当前状态": "是（本题压缩可唯一还原）",
          "可变参数位": "设计为有损压缩或歧义编码以考察解码边界"
        }
      }
    }
  },
  {
    "title": "Find the Child Who Has the Ball After K Seconds",
    "slug": "find-the-child-who-has-the-ball-after-k-seconds",
    "schema": {
      "Input Structure": {
        "type": "一维线性序列",
        "elements": "n个编号为0到n-1的节点（孩子）按顺序排列",
        "parameters": [
          "正整数 n: 序列长度, 2 <= n <= 50",
          "正整数 k: 时间步长, 1 <= k <= 50",
          "初始状态: 编号0的孩子持球，方向向右"
        ],
        "dynamics": "球在序列上按时间步移动，方向在端点处反转"
      },
      "Core Constraint": {
        "movement_rule": "每秒球向当前方向的相邻孩子传递",
        "boundary_reflection": "当球到达任一端点（位置0或n-1）时，传球方向立即反转",
        "determinism": "移动路径完全由初始条件和边界反射规则决定，无分支或随机性",
        "periodicity_hint": "系统状态具有周期性，总运动可分解为往返周期 + 剩余偏移"
      },
      "Objective Function": {
        "goal": "计算k秒后持球孩子的编号",
        "type": "构造性查询（定位）",
        "output": "单个整数：最终持球者的索引"
      },
      "Algorithmic Invariant": {
        "state_monotonicity": "时间推进是单调的，且每一步状态唯一确定下一步",
        "path_symmetry": "从0到n-1再返回0构成一个完整周期，路径对称",
        "effective_position_invariance": "有效位移可通过模运算压缩：令周期T = 2 * (n - 1)，则等效时间为k mod T",
        "position_formula_stability": "给定等效时间t' = k mod T，若t' <= n-1，则位置为t'；否则为2*(n-1) - t'"
      },
      "Transformable Parameters": {
        "n_magnitude": "n的数量级：当前小规模（≤50），可扩展至1e9（需O(1)解）",
        "k_magnitude": "k的数量级：同上，支持大数模周期优化",
        "initial_direction": "是否可变：当前固定向右，可设为输入参数",
        "initial_position": "是否必须从0开始：可推广至任意起点s",
        "boundary_behavior": [
          "当前：触端即反向",
          "变体：延迟反转 / 多次停留 / 弹射出队"
        ],
        "dimensionality": "可扩展至2D网格中的弹跳运动（如矩阵蛇形游走）",
        "data_mode": "是否多组测试数据：当前单例，可改为批量输入",
        "online_query": "是否在线：支持动态修改n/k并快速回答",
        "output_type": "是否仅返回位置：可改为输出整个轨迹或方向序列"
      }
    }
  },
  {
    "title": "Maximum Hamming Distances",
    "slug": "maximum-hamming-distances",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "notation": "H[1..n]",
        "description": "一维非负整数数组，表示每个位置的柱子高度"
      },
      "Core Constraint": {
        "left_right_dependency": "每个位置的积水高度由其左侧最大值和右侧最大值中的较小者决定",
        "independence": "左右边界约束可分离处理，但需保证全局一致性",
        "local_global_link": "局部积水依赖于全局极值信息"
      },
      "Objective Function": {
        "type": "sum",
        "goal": "compute total trapped water",
        "description": "计算所有位置能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "two_pointers": "维护左右指针 L 和 R，分别从两端向中间推进",
        "max_tracking": "维护 maxLeft 和 maxRight 分别表示当前左部和右部的最大高度",
        "safe_movement": "若 maxLeft ≤ maxRight，则 H[L] 处的积水可确定，L 可安全右移；反之 R 左移",
        "invariance_property": "已遍历区域的贡献值一旦确定，不再受后续操作影响"
      },
      "Transformable Parameters": {
        "value_domain": {
          "allow_negative": false,
          "description": "是否允许高度为负（可用于变形题）"
        },
        "spatial_extension": {
          "2d_variant": false,
          "circular_array": false,
          "description": "可扩展至二维接雨水或环形数组变体"
        },
        "data_mode": {
          "online_input": false,
          "mutable_operations": false,
          "description": "是否支持在线输入、动态修改/删除柱子"
        },
        "output_form": {
          "per_position_output": false,
          "construct_solution": false,
          "description": "是否要求输出每个位置的积水高度或构造方案"
        },
        "input_properties": {
          "sorted": false,
          "duplicate_allowed": true,
          "multi_test_cases": false,
          "description": "数组是否有序、是否允许多组数据输入"
        },
        "scale": {
          "n_range": "[1, 2 * 10^4]",
          "value_range": "[0, 10^5]",
          "description": "数据规模与值域范围"
        }
      }
    }
  },
  {
    "title": "Consecutive Available Seats II",
    "slug": "consecutive-available-seats-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "notation": "H[1..n]",
        "properties": [
          "one-dimensional",
          "ordered",
          "allows duplicates",
          "non-negative values"
        ]
      },
      "Core Constraint": {
        "description": "The water trapped at each position is determined by the minimum of the maximum height to the left and the maximum height to the right, minus the current height.",
        "key_insight": "Left and right maxima are independent but must be globally consistent; local decisions depend on global extrema.",
        "constraint_type": "dual-sided boundary dependency"
      },
      "Objective Function": {
        "goal": "sum",
        "objective": "total amount of trapped rainwater",
        "type": "aggregation",
        "output_semantics": "compute the cumulative capacity over all positions where water can be trapped"
      },
      "Algorithmic Invariant": {
        "invariant_description": "Maintain two pointers L and R from both ends, with tracked maxLeft and maxRight. If maxLeft <= maxRight, then the trapped water at L is fully determined by maxLeft (since a sufficient right bound exists). Similarly for R when maxRight <= maxLeft.",
        "pointer_behavior": "Only move the pointer on the side with smaller max boundary",
        "correctness_guarantee": "Movement preserves optimality: the lower boundary ensures that the current side's contribution can be safely computed without seeing the rest of the array",
        "state_preservation": "The invariant ensures no re-visiting or backtracking is needed"
      },
      "Transformable Parameters": {
        "n_range": [
          "1 <= n <= 10^4",
          "n up to 10^5",
          "n → ∞ (streaming)"
        ],
        "value_domain": [
          "H[i] >= 0",
          "H[i] can be negative (interpretation change)",
          "bounded vs unbounded"
        ],
        "input_form": [
          "static array",
          "online/streaming input",
          "mutable array with updates"
        ],
        "dimensionality": [
          "1D",
          "2D extension (trapping in grid)",
          "circular array"
        ],
        "output_requirements": [
          "return total sum",
          "return per-position values",
          "return indices with positive trap"
        ],
        "data_mode": [
          "single instance",
          "multiple test cases",
          "interactive version"
        ],
        "constraints_modification": [
          "add capacity limit per column",
          "allow dynamic insertion/deletion",
          "query subranges"
        ]
      }
    }
  },
  {
    "title": "Clear Digits",
    "slug": "clear-digits",
    "schema": {
      "Input Structure": {
        "type": "string",
        "domain": "s[1..n]",
        "element_type": "char",
        "allowed_characters": [
          "lowercase_letters",
          "digits"
        ],
        "length_constraint": "1 <= n <= 100"
      },
      "Core Constraint": {
        "operation_rule": "每次删除第一个数字字符及其左侧最近的非数字字符",
        "dependency_structure": "操作顺序影响后续字符位置，具有前向依赖性",
        "validity_condition": "不能对左侧无非数字字符的数字执行操作",
        "guarantee": "输入保证所有数字均可被删除"
      },
      "Objective Function": {
        "goal": "构造删除所有数字字符后剩下的字符串",
        "type": "construction",
        "output_form": "remaining_string_after_all_operations"
      },
      "Algorithmic Invariant": {
        "monotonicity": "从左到右扫描过程中，已处理区域中不再包含可触发操作的数字",
        "stack_property": "使用栈维护当前待定字符序列，遇到数字时弹出栈顶（非数字）字符",
        "invariant_maintenance": "每一步操作等价于：若当前字符是数字且栈非空，则弹出栈顶；否则压入当前字符",
        "correctness_guarantee": "栈中始终保存的是尚未被删除的、合法的前缀子序列"
      },
      "Transformable Parameters": {
        "constraints": [
          "允许的字符集合：是否扩展至大写字母、特殊符号",
          "数字定义：是否包括 '0'-'9' 以外的数字符号（如中文数字）",
          "删除规则变化：删除右边最近非数字 / 删除多个字符"
        ],
        "data_form": [
          "输入是否为多组字符串",
          "是否在线流式输入字符（逐个输入）",
          "是否支持撤销或修改操作"
        ],
        "structural_variation": [
          "字符串是否环形（循环字符串）",
          "是否二维字符网格上的类似传播操作"
        ],
        "objective_variation": [
          "改为计数剩余字符数",
          "判断最终是否为空串",
          "求最少/最多可能剩余长度（在规则可选时）"
        ],
        "complexity_parameters": [
          "字符串长度规模：n <= 100 → n <= 1e5",
          "是否要求输出每步中间结果"
        ]
      }
    }
  },
  {
    "title": "Find the Number of Good Pairs I",
    "slug": "find-the-number-of-good-pairs-i",
    "schema": {
      "Input Structure": [
        "一维数组 nums1[0..n-1]，元素为正整数",
        "一维数组 nums2[0..m-1]，元素为正整数",
        "正整数 k"
      ],
      "Core Constraint": [
        "优质数对 (i, j) 满足条件：nums1[i] % (nums2[j] * k) == 0",
        "即 nums1[i] 可被 nums2[j] * k 整除",
        "判定依赖于两数组元素之间的整除关系和常数 k 的缩放作用"
      ],
      "Objective Function": "计数：统计所有满足条件的优质数对 (i, j) 的总数",
      "Algorithmic Invariant": [
        "整除关系具有可枚举性：对于固定的 nums2[j] 和 k，其倍数在有限值域内可预计算",
        "nums1 中每个元素是否为某个 (nums2[j] * k) 的倍数是独立可判的",
        "无状态依赖，问题可分解为独立的成员匹配计数"
      ],
      "Transformable Parameters": {
        "n 的数量级": "可扩展至 1e5（需优化解法）",
        "m 的数量级": "可扩展至 1e5",
        "值域范围": "当前 ≤50，可增大以引入因子枚举或哈希优化",
        "k 的取值": [
          "可变为变量序列",
          "可支持负整数（若允许负数输入）",
          "可设为数组形式（每对使用不同 k）"
        ],
        "是否有序": "当前无序，可考虑排序后利用单调性剪枝",
        "是否多组数据": "可设计为多组测试用例批量处理",
        "是否在线": "可改为动态添加 nums1 或 nums2 元素，在线查询优质数对增量",
        "输入形式变化": [
          "将 nums2[j] * k 预先隐藏，要求从因数关系中推导",
          "改为输出所有优质数对的位置列表（构造方案）",
          "改为求最大/最小下标和的优质数对（目标函数变换）"
        ]
      }
    }
  },
  {
    "title": "Lexicographically Minimum String After Removing Stars",
    "slug": "lexicographically-minimum-string-after-removing-stars",
    "schema": {
      "Input Structure": [
        "字符串 s[1..n]",
        "字符集：小写英文字母和 '*'",
        "1 <= n <= 10^5",
        "s 中至少存在一个 '*' 时可进行操作"
      ],
      "Core Constraint": [
        "每次必须删除最左边的 '*' 字符",
        "同时必须删除该 '*' 左边的一个字典序最小的字符（非 '*'）",
        "只能从已出现的左侧非 '*' 字符中选择删除对象",
        "删除操作不可逆，顺序影响最终结果"
      ],
      "Objective Function": "构造删除所有 '*' 后剩余字符连接而成的字典序最小的字符串",
      "Algorithmic Invariant": [
        "贪心策略：在每一步删除最左边 '*' 及其左侧当前全局字典序最小字符，能保证最终结果最优",
        "局部最优可合并为全局最优：每次删除最小字符不会阻塞后续更优构造",
        "状态单调性：随着 '*' 从左到右处理，已处理区域不再修改",
        "可用栈或优先队列维护左侧可删字符的有序性，支持高效提取最小值"
      ],
      "Transformable Parameters": {
        "n 的数量级": "1 <= n <= 10^5（可调整至 10^6 或更低）",
        "字符集": "可扩展为大写字母、数字或其他符号",
        "星号分布": [
          "连续多个 '*'",
          "仅单个 '*'",
          "'*' 出现在开头（无法删除左侧字符）——需额外约束"
        ],
        "删除规则变化": [
          "改为删除字典序最大字符 → 目标变为字典序最大结果",
          "改为删除最右边 '*' → 输入顺序变化",
          "改为可自由选择任意 '*' 删除 → 需重新设计不变量"
        ],
        "是否在线": "可改为流式输入，要求实时响应每个 '*' 处理",
        "多组数据": "支持 T 组测试用例",
        "输出形式": [
          "仅返回最终字符串",
          "返回删除序列轨迹",
          "返回每步决策依据"
        ],
        "约束放松": "允许无法完全删除 '*' 的情况，目标变为判定是否可行"
      }
    }
  },
  {
    "title": "Find the Number of Good Pairs II",
    "slug": "find-the-number-of-good-pairs-ii",
    "schema": {
      "Input Structure": [
        "一维数组 nums1[0..n-1], 元素为正整数",
        "一维数组 nums2[0..m-1], 元素为正整数",
        "正整数 k",
        "n, m ∈ [1, 1e5]",
        "nums1[i], nums2[j] ∈ [1, 1e6]",
        "k ∈ [1, 1e3]"
      ],
      "Core Constraint": [
        "优质数对 (i, j) 满足：nums1[i] % (nums2[j] * k) == 0",
        "即 nums2[j] * k 是 nums1[i] 的因子",
        "判定关系具有可分解性：若 d = nums2[j] * k，则需 d | nums1[i]",
        "因子关系具有离散性和倍数结构性"
      ],
      "Objective Function": "计数：统计所有满足条件的优质数对 (i, j) 的总数",
      "Algorithmic Invariant": [
        "对于每个 nums1[i]，其能被哪些 nums2[j]*k 整除，仅取决于 nums2[j]*k 是否为其因子",
        "可以预处理 nums2 中所有可能的倍数值 d = nums2[j] * k，并统计频次",
        "利用因子枚举或倍数标记法加速匹配：对每个 d，将其所有倍数位置打标记或累加贡献",
        "使用哈希表或桶结构维护候选除数的出现次数，实现 O(max_value log max_value) 的倍数枚举不变性"
      ],
      "Transformable Parameters": {
        "数据规模": {
          "n, m 数量级": [
            "1e5",
            "可扩展至 1e6"
          ],
          "值域范围": [
            "[1, 1e6]",
            "可压缩至 [1, 1e4] 或放大至 [1, 1e7]"
          ]
        },
        "输入形式": [
          "是否有序（nums1/nums2 是否已排序）",
          "是否允许重复元素",
          "是否多组测试数据"
        ],
        "约束条件": [
          "k 是否固定或也作为变量集合",
          "是否改为 'nums1[i] * k 被 nums2[j] 整除'（目标反转）",
          "是否要求输出具体数对而非总数（构造方案 vs 计数）"
        ],
        "在线性": [
          "是否支持动态添加 nums1 或 nums2 元素（在线查询）",
          "是否支持修改 k 值后的重新计算"
        ],
        "变形方向": [
          "改为最大公约数 / 最小公倍数约束",
          "加入权重：每个数对有权重 w(i,j)，求总权重",
          "限定 j 的取值范围（如 j <= i）形成依赖结构"
        ]
      }
    }
  },
  {
    "title": "Maximum Total Reward Using Operations II",
    "slug": "maximum-total-reward-using-operations-ii",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "element_type": "integer",
        "size": "n",
        "value_range": [
          1,
          50000
        ],
        "properties": [
          "unsorted",
          "may contain duplicates",
          "positive integers only"
        ]
      },
      "Core Constraint": {
        "selection_condition": "rewardValues[i] > current_total_reward_x",
        "irreversible_marking": true,
        "sequential_dependency": "future choices depend on current total reward",
        "monotonic_accumulation": "x increases strictly when a valid element is selected"
      },
      "Objective Function": {
        "goal": "maximize",
        "output_type": "integer",
        "target": "maximum possible total reward achievable through optimal selection sequence"
      },
      "Algorithmic Invariant": {
        "invariant_description": "At each step, selecting a value just above the current total reward enables access to higher values later; greedy choice preserves optimality.",
        "greedy_condition": "If we sort values and process in increasing order, taking a value iff it is greater than current sum maintains possibility of future selections and leads to global optimum.",
        "state_monotonicity": "The accumulated reward x is non-decreasing and strictly increases upon each valid selection.",
        "optimal_substructure": "The problem exhibits optimal substructure: the best solution up to sum s can be extended by adding the next feasible reward."
      },
      "Transformable Parameters": {
        "n_magnitude": [
          "1e4",
          "5e4"
        ],
        "value_domain": {
          "min": 1,
          "max": 50000
        },
        "ordering": {
          "original_order_sensitive": false,
          "can_be_sorted": true
        },
        "input_form": "single static array",
        "multiple_test_cases": false,
        "online_queries": false,
        "modifications_allowed": false,
        "constraints_variation": [
          "change selection condition to ≥ instead of >",
          "allow reuse of indices with penalty",
          "limit number of operations",
          "introduce dependencies between indices (e.g., graph-constrained selection)"
        ],
        "output_form": [
          "return maximum total reward",
          "return lexicographically smallest selection sequence achieving maximum",
          "count number of optimal sequences"
        ]
      }
    }
  },
  {
    "title": "Maximum Total Reward Using Operations I",
    "slug": "maximum-total-reward-using-operations-i",
    "schema": {
      "Input Structure": "一维数组 rewardValues[1..n]，其中 n ≤ 2000，rewardValues[i] ∈ [1, 2000]，整数",
      "Core Constraint": "只有当 rewardValues[i] > 当前总奖励 x 时，才能选择该下标 i；选择后 x 更新为 x + rewardValues[i]，且每个下标至多被选一次",
      "Objective Function": "最大化最终的总奖励值 x",
      "Algorithmic Invariant": "状态单调递增：x 随操作严格递增；贪心可证明：若存在最优解中某步选择了非当前可选最小有效值，则可通过交换调整不劣于原解；因此按值排序后进行动态规划或贪心扩展是安全的",
      "Transformable Parameters": {
        "n 的数量级": "n ≤ 2000（可改为更大规模以要求 O(n log n) 或优化 DP）",
        "值域范围": "rewardValues[i] ∈ [1, 2000]（可扩展为负数或更广范围）",
        "是否有序": "原始无序，但最优策略依赖排序（可变为有序输入或强制在线处理）",
        "是否多组输入": "单组数据（可改为多组测试用例）",
        "是否在线": "离线输入全部已知（可设计为流式输入需实时决策）",
        "操作约束变化": "可修改条件为 ≥ 而非 >，或允许重复选择（改变状态演化规则）",
        "目标函数变形": "从最大总奖励 → 最少操作次数达到某阈值，或计数方案数"
      }
    }
  },
  {
    "title": "Equalize Strings by Adding or Removing Characters at Ends",
    "slug": "equalize-strings-by-adding-or-removing-characters-at-ends",
    "schema": {
      "Input Structure": {
        "type": "array",
        "dimension": 1,
        "elements": "non-negative integers",
        "size": "n",
        "description": "给定一个长度为 n 的非负整数数组 H[1..n]，表示每个位置上的柱子高度"
      },
      "Core Constraint": {
        "constraint": "每个位置 i 能储存的水量由其左侧最大高度和右侧最大高度中的较小者决定，且仅当该值大于 H[i] 时才能储水",
        "key_property": "左右边界约束可分离，局部储水能力依赖于全局极值信息"
      },
      "Objective Function": {
        "goal": "sum",
        "description": "计算整个数组能接住的雨水总量"
      },
      "Algorithmic Invariant": {
        "invariant": [
          "维护两个指针 L 和 R，分别从左右两端向中间移动",
          "维护 maxLeft 表示左指针左侧的最大高度，maxRight 表示右指针右侧的最大高度",
          "若 maxLeft ≤ maxRight，则位置 L 处的储水量仅由 maxLeft 决定，可直接计算并移动 L；否则移动 R",
          "指针移动过程中，已确定区域的储水量不会被后续操作影响"
        ],
        "optimality_preservation": true
      },
      "Transformable Parameters": {
        "parameters": [
          {
            "name": "value_domain",
            "options": [
              "non-negative",
              "allow_negative"
            ],
            "default": "non-negative",
            "impact": "若允许负值，需重新定义储水逻辑或视为无效输入"
          },
          {
            "name": "input_dimension",
            "options": [
              "1D",
              "2D",
              "circular_array"
            ],
            "default": "1D",
            "impact": "2D 可扩展为二维接雨水问题；环形数组需处理首尾相连的边界条件"
          },
          {
            "name": "query_mode",
            "options": [
              "offline_batch",
              "online_queries",
              "dynamic_updates"
            ],
            "default": "offline_batch",
            "impact": "在线查询或支持单点修改时需引入线段树或分块结构"
          },
          {
            "name": "output_granularity",
            "options": [
              "total_sum",
              "per_position_contribution"
            ],
            "default": "total_sum",
            "impact": "若要求输出每个位置的储水量，则需保留中间状态"
          },
          {
            "name": "data_order",
            "options": [
              "unordered",
              "sorted"
            ],
            "default": "unordered",
            "impact": "若有序，可能启用二分或其他优化策略"
          },
          {
            "name": "multiple_test_cases",
            "type": "boolean",
            "default": false,
            "impact": "多组数据需重置状态变量，影响代码组织形式"
          }
        ]
      }
    }
  }
]