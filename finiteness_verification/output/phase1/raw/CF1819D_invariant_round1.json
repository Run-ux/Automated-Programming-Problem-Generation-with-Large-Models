{
  "problem_id": "CF1819D",
  "source": "codeforces",
  "dimension": "invariant",
  "round": 1,
  "result": {
    "invariants": [
      {
        "name": "optimal_substructure",
        "description": "最优子结构：背包中苹果的最大数量可以通过子问题的最优解组合得到，即每个摊位的购买决策基于之前摊位的最佳状态。",
        "properties": {}
      },
      {
        "name": "state_transition",
        "description": "状态转移不变量：在访问每个摊位时，背包中的苹果种类和数量的状态会根据当前摊位的苹果种类进行更新。如果当前摊位有重复的苹果种类，则背包中的所有苹果消失。",
        "properties": {}
      },
      {
        "name": "interval_mergeable",
        "description": "区间可合并性：对于已知摊位的苹果种类，可以将这些信息合并以计算背包中苹果的最大数量。未知摊位的信息可以在最后通过贪心策略来优化。",
        "properties": {}
      }
    ]
  },
  "status": "success"
}