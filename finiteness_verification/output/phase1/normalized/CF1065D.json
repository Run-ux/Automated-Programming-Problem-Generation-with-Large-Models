{
  "problem_id": "CF1065D",
  "source": "codeforces",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "two_dimensional_array",
        "length": {
          "min": 3,
          "max": 10
        },
        "value_range": {
          "min": 1,
          "max": 100
        },
        "properties": {}
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "path_constraint",
            "description": "从起点到终点的路径必须经过所有编号的节点，且按编号顺序访问"
          },
          {
            "name": "distance_bound",
            "description": "每一步移动必须符合骑士、象或车的移动规则"
          },
          {
            "name": "operation_limit",
            "description": "在路径中可以更换棋子，但需要最小化更换次数"
          },
          {
            "name": "optimization_objective",
            "description": "需要最小化总步数，在相同步数的情况下选择最少的更换次数"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "minimize_value",
        "description": "最小化从起点到终点的路径长度，并在路径长度相同的情况下，最小化路径中的替换操作次数"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：问题的最优解可以通过子问题的最优解组合得到。在本题中，从一个位置到下一个位置的最优路径可以通过之前计算出的最优路径来构建。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：当前状态可以由前一个状态通过有限的操作（移动或更换棋子）转换而来。每个状态表示棋盘上的一个位置和当前使用的棋子类型。",
            "properties": {}
          },
          {
            "name": "subproblem_independence",
            "description": "子问题独立性：每个子问题的求解不依赖于其他子问题的具体解法，只依赖于其结果。在本题中，从一个位置到下一个位置的最优路径计算是独立的。",
            "properties": {}
          }
        ]
      }
    }
  ]
}