{
  "problem_id": "P4539",
  "source": "luogu",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "array",
        "length": {
          "min": 1,
          "max": 29
        },
        "value_range": {
          "min": 1,
          "max": 199
        },
        "properties": {
          "ordered": false
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "fixed_start_node",
            "description": "二叉树的中序遍历必须为 (1, 2, 3, ..., n)"
          },
          {
            "name": "minimize_max_min_difference",
            "description": "访问二叉树的平均代价 h_1 * f_1 + h_2 * f_2 + ... + h_n * f_n 必须最小化"
          },
          {
            "name": "leaf_weight_constraint",
            "description": "每个节点的访问代价 h_j 与节点深度 r 成正比，具体为 h_j = k * (r + 1) + c，其中 k 和 c 为已知常数"
          },
          {
            "name": "probability_distribution",
            "description": "每个节点的概率 f_j 定义为 d_j / S，其中 d_j 是第 j 个单词出现的次数，S 是所有单词出现的总次数"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "minimize_value",
        "description": "最小化加权路径长度"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：问题的最优解可以通过子问题的最优解组合得到，即构建 zh_tree 的最小平均代价可以通过其左右子树的最小平均代价来计算",
            "properties": {}
          },
          {
            "name": "divide_conquer",
            "description": "分治不变量：大问题的解由子问题解合成，通过递归地将问题分解为更小的子问题，并在合并子问题的解时保持整体最优性",
            "properties": {}
          }
        ]
      }
    }
  ]
}