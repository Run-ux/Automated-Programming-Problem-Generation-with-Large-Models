{
  "problem_id": "CF1627E",
  "source": "codeforces",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "weighted_undirected_graph",
        "length": {
          "min": 2,
          "max": 100000
        },
        "value_range": {
          "min": -1000000,
          "max": 1000000
        },
        "properties": {
          "weighted": true,
          "directed": true
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "path_constraint",
            "description": "路径必须从起点 (1, 1) 到达终点 (n, m)，且路径上可以使用单向边（梯子）",
            "formal": "存在一条从 (1, 1) 到 (n, m) 的路径，路径上的边可以是水平移动或使用梯子"
          },
          {
            "name": "adjacency_relation",
            "description": "在同一层内，相邻房间之间的移动代价为 |j - k| * x_i",
            "formal": "cost((i, j), (i, k)) = |j - k| * x_i"
          },
          {
            "name": "directed_graph",
            "description": "梯子只能从低楼层到高楼层单向使用",
            "formal": "对于每个梯子 (a_i, b_i) -> (c_i, d_i)，有 a_i < c_i"
          },
          {
            "name": "value_increment",
            "description": "使用梯子时可以获得一定的健康点数 h_i",
            "formal": "使用梯子 (a_i, b_i) -> (c_i, d_i) 时，获得 h_i 健康点数"
          },
          {
            "name": "reachability_constraint",
            "description": "如果不存在从 (1, 1) 到 (n, m) 的路径，则输出 'NO ESCAPE'",
            "formal": "如果不存在从 (1, 1) 到 (n, m) 的路径，则输出 'NO ESCAPE'"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "minimize_value",
        "description": "求从起点到终点的最小代价路径"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：问题的最优解可以通过子问题的最优解组合得到，即从起点到终点的最短路径可以分解为从起点到中间点和从中间点到终点的最短路径之和。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：当前状态的最优解可以通过前一个状态的最优解加上转移代价来计算。具体来说，从当前房间转移到相邻房间或通过梯子到达另一个房间时，新的健康值可以通过之前的状态加上转移代价（损失或增加的健康值）来确定。",
            "properties": {}
          },
          {
            "name": "topological_order",
            "description": "拓扑序不变量：在有向无环图（DAG）中，存在一种顺序使得每个节点都在其所有后继节点之前处理。在这个问题中，楼层和房间可以看作是一个DAG，其中楼层之间的转移和梯子的使用构成了边，且不存在环路。",
            "properties": {}
          }
        ]
      }
    }
  ]
}