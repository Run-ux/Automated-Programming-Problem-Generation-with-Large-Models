{
  "problem_id": "GYM102862J",
  "source": "icpc_gym",
  "input_structure": [
    {
      "round": 1,
      "status": "failed",
      "result": {}
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "distinctness",
            "description": "矩阵 C 中的每个整数在 [0, n * m - 1] 范围内且唯一出现一次（去重约束）",
            "formal": "∀ i, j, C[i][j] ∈ [0, n * m - 1] 且 ∀ i1, j1, i2, j2, (i1, j1) ≠ (i2, j2) → C[i1][j1] ≠ C[i2][j2]"
          },
          {
            "name": "k_mex_constraint",
            "description": "对于每一行 i，mex(C[i]) = a[i]；对于每一列 j，mex(C[:,j]) = b[j]（最小排除值约束）",
            "formal": "∀ i, mex(C[i]) = a[i] 且 ∀ j, mex(C[:,j]) = b[j]"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "feasibility",
        "description": "判断是否存在满足条件的矩阵"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：矩阵 C 的构造可以通过子问题的最优解来合成，每个子问题的解是独立且最优的。",
            "properties": {}
          },
          {
            "name": "subproblem_independence",
            "description": "子问题独立性：在构造矩阵 C 时，每个位置 (i, j) 的值可以独立地确定，不受其他位置的影响。",
            "properties": {}
          },
          {
            "name": "interval_additivity",
            "description": "区间可加性：通过前缀和或其他区间操作，可以有效地计算和验证矩阵 C 中的元素是否满足 mex 条件。",
            "properties": {}
          }
        ]
      }
    }
  ]
}