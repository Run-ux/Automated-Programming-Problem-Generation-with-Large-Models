{
  "problem_id": "CF1671E",
  "source": "codeforces",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "tree",
        "length": {
          "min": 3,
          "max": 262143
        },
        "value_range": {
          "min": "A",
          "max": "B"
        },
        "properties": {
          "connected": true,
          "ordered": true
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "acyclicity",
            "description": "树为完美二叉树，每个非叶节点有两个子节点，且所有叶子节点到根节点的距离相同"
          },
          {
            "name": "operation_order",
            "description": "计算树的前序遍历字符串"
          },
          {
            "name": "alphabet_constraint",
            "description": "每个节点上的字符只能是 A 或 B"
          },
          {
            "name": "operation_limit",
            "description": "可以对树进行任意次数的操作以改变前序遍历字符串"
          },
          {
            "name": "distinctness",
            "description": "计算不同前序遍历字符串的数量"
          },
          {
            "name": "modular_arithmetic",
            "description": "结果需要对 998244353 取模"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "enumeration",
        "description": "求不同预序字符串的数量"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：树的前序字符串可以通过其子树的前序字符串组合得到，且每个子问题的解是独立的。",
            "properties": {}
          },
          {
            "name": "symmetry",
            "description": "对称性：对于任意一个节点，交换其左右子树不会改变该节点的前序字符串。",
            "properties": {}
          }
        ]
      }
    }
  ]
}