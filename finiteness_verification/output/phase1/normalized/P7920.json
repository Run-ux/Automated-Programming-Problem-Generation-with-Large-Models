{
  "problem_id": "P7920",
  "source": "luogu",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "tree",
        "length": {
          "min": 1,
          "max": 5000
        },
        "value_range": {
          "min": 1,
          "max": 5000
        },
        "properties": {
          "connected": true,
          "weighted": false
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "isomorphism_constraint",
            "description": "构造的无向图 G_p 必须与给定的树 T 同构"
          },
          {
            "name": "permutation_constraint",
            "description": "输出的排列 p 必须是 1 到 n 的一个排列"
          },
          {
            "name": "lexicographical_maximization",
            "description": "如果存在多个好排列，输出字典序最大的一个"
          },
          {
            "name": "edge_constraint",
            "description": "对于每个 i ∈ (1, n]，找到最大的 j ∈ [1, i) 满足 p_i > p_j，然后连一条 i, j 之间的边；如果不存在这样的 j，则不连边"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "construction",
        "description": "构造满足特定条件的排列，若存在则输出字典序最大的一个，否则输出-1"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "topological_order",
            "description": "拓扑序不变量：在构造排列时，节点的顺序依赖于其在树中的拓扑结构，确保生成的图与给定树同构。",
            "properties": {}
          },
          {
            "name": "optimal_substructure",
            "description": "最优子结构：问题的最优解可以通过子问题的最优解组合得到，即通过递归或动态规划的方式构建字典序最大的排列。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：在构造排列的过程中，每个节点的状态（已处理/未处理）和其在排列中的位置是逐步确定的，并且这种状态转移满足一致性。",
            "properties": {}
          }
        ]
      }
    }
  ]
}