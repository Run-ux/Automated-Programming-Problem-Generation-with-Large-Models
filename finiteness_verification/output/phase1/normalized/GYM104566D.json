{
  "problem_id": "GYM104566D",
  "source": "icpc_gym",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "two_dimensional_array",
        "length": {
          "min": 1,
          "max": 100000
        },
        "value_range": {
          "min": 0,
          "max": 1
        },
        "properties": {
          "connected": true
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "non_intersecting_segments",
            "description": "所有线段不相交（即没有共同的单元格）",
            "formal": "∀ (r1, c1, r2, c2), (r3, c3, r4, c4) ∈ lines, (r1, c1, r2, c2) ∩ (r3, c3, r4, c4) = ∅"
          },
          {
            "name": "connected_components",
            "description": "黑色单元格通过共享边形成连通分量",
            "formal": "∀ (ra, ca), (rb, cb) ∈ black_cells, ∃ path (r1, c1), (r2, c2), ..., (rk, ck) 使得 (ri, ci) 和 (ri+1, ci+1) 共享边，且 (r1, c1) = (ra, ca), (rk, ck) = (rb, cb)"
          },
          {
            "name": "axis_aligned_lines",
            "description": "绘制的线段只能是水平或垂直的",
            "formal": "∀ (r1, c1, r2, c2) ∈ lines, r1 = r2 或 c1 = c2"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "enumeration",
        "description": "计算每个子网格中的黑单元格数量和连通分量数量"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：当前行的黑色单元格数量和连通分量数可以通过前一行的状态计算得出，满足动态规划的最优子结构性质。",
            "properties": {}
          },
          {
            "name": "interval_additivity",
            "description": "区间可加性：从第1行到第i行的黑色单元格数量可以通过前缀和的方式计算，即s_i = s_{i-1} + 新增的黑色单元格数量。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：从第i-1行到第i行的连通分量数的变化可以通过新增线条的影响进行状态转移，保持状态的一致性和正确性。",
            "properties": {}
          }
        ]
      }
    }
  ]
}