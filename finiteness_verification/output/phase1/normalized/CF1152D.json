{
  "problem_id": "CF1152D",
  "source": "codeforces",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "integer",
        "length": {
          "min": 1,
          "max": 1
        },
        "value_range": {
          "min": 1,
          "max": 1000
        },
        "properties": {}
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "matching_constraint",
            "description": "在给定的树结构中找到最大匹配（即最大的边集，使得没有两条边共享一个顶点）"
          },
          {
            "name": "modular_arithmetic",
            "description": "结果需要对 10^9 + 7 取模"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "maximize_count",
        "description": "求二分图的最大匹配数"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：最大匹配问题的解可以通过子问题的最优解来构建，即通过递归地解决较小规模的括号序列匹配问题来求解整个问题。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：在处理括号序列时，从一个状态转移到另一个状态的过程中，状态转移的一致性保证了算法的正确性。例如，当前状态下的最大匹配数可以由前一个状态的最大匹配数和当前字符决定。",
            "properties": {}
          }
        ]
      }
    }
  ]
}