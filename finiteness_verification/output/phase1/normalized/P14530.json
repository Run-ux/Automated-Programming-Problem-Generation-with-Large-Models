{
  "problem_id": "P14530",
  "source": "luogu",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "array",
        "length": {
          "min": 2,
          "max": 5000
        },
        "value_range": {
          "min": 97,
          "max": 122
        },
        "properties": {
          "inferred": true
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "subsequence_constraint",
            "description": "查询字符串的最长前缀必须是密码的一个（不一定连续的）子序列",
            "formal": "对于密码 P 和查询 Q，存在 1 ≤ k1 < k2 < ... < kL ≤ N，使得对于所有 1 ≤ i ≤ L，Q[i] = P[ki]"
          },
          {
            "name": "alphabet_constraint",
            "description": "密码和查询字符串只包含字母表的前 S 个字母",
            "formal": "P, Q ∈ {a, b, ..., S-th letter}"
          },
          {
            "name": "query_limit",
            "description": "每个测试点最多调用 query 函数 50000 次",
            "formal": "query_calls ≤ 50000"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "construction",
        "description": "构造一个满足给定条件的字符串"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "monotonicity",
            "description": "查询结果的单调性：随着查询字符串的变化，返回的最长前缀长度非严格递增",
            "properties": {
              "left_monotonic": false,
              "right_monotonic": true
            }
          },
          {
            "name": "optimal_substructure",
            "description": "最优子结构：密码的每个部分可以通过子问题的最优解组合得到",
            "properties": {}
          },
          {
            "name": "prefix_decomposability",
            "description": "前缀可分解性：通过查询不同长度的前缀，可以逐步确定密码的各个字符",
            "properties": {}
          }
        ]
      }
    }
  ]
}