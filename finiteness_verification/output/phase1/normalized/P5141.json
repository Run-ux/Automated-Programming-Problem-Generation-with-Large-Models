{
  "problem_id": "P5141",
  "source": "luogu",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "array",
        "length": {
          "min": 1,
          "max": 62
        },
        "value_range": {
          "min": 0,
          "max": 1
        },
        "properties": {
          "ordered": true
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "adjacency_difference",
            "description": "相邻节点取值不同（图着色约束）",
            "formal": "对于所有 i, 如果 p[i] == 1，则 q[i] 必须为 0"
          },
          {
            "name": "range_bound",
            "description": "选取元素的战斗力值在给定范围内",
            "formal": "a <= Fight(q) <= b"
          },
          {
            "name": "kth_largest_element",
            "description": "求解第 k 大的战斗力值",
            "formal": "Find the k-th largest value of Fight(q) in the range [a, b]"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "enumeration",
        "description": "求满足给定范围内的战斗力值的方案数，并输出第k大的战斗力值"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：问题的解可以通过子问题的解来构造，即当前行的站队方式取决于前一行的站队方式。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：从一个状态到另一个状态的转移规则是固定的，即当前行的状态由前一行的状态和当前行的限制条件决定。",
            "properties": {}
          },
          {
            "name": "interval_additivity",
            "description": "区间可加性：战斗力值可以通过前缀和的方式计算，即某一行的战斗力值可以由前几行的战斗力值累加得到。",
            "properties": {}
          }
        ]
      }
    }
  ]
}