{
  "connectivity": {
    "name": "connectivity",
    "description": "连通性/可达性约束，如连通图或可达要求",
    "aliases": [
      "reachability_constraint",
      "visit_all_nodes",
      "intra_region_connectivity",
      "bfs_traversal",
      "component_count",
      "connected_components",
      "connected_component",
      "goal_reachability",
      "multiple_fragments_same_node",
      "path_existence",
      "eulerian_cycle",
      "reachability",
      "segment_connectivity",
      "connected_subgraph",
      "target_reachability",
      "connected_regions",
      "accessibility_constraint",
      "goal_reach",
      "target_position_reachable",
      "biconnectivity",
      "transmission_continuity",
      "remaining_connectivity",
      "structural_stability",
      "single_plan_reachability",
      "station_connectivity",
      "graph_connectivity",
      "subgraph_connectivity"
    ],
    "examples": []
  },
  "acyclicity": {
    "name": "acyclicity",
    "description": "无环性约束，如 DAG 或森林结构",
    "aliases": [
      "tree_structure",
      "binary_search_tree",
      "rooted_tree",
      "directed_graph_structure",
      "binary_tree",
      "root_vertex_existence",
      "graph_structure",
      "complete_directed_graph",
      "tree_structure_constraint",
      "ancestry_relation",
      "directed_tree",
      "topological_ordering",
      "directed_acyclic_graph",
      "bfs_tree_rooted_at_two_vertices",
      "directed_graph",
      "binary_tree_structure",
      "no_three_collinear",
      "no_collinearity",
      "parent_child_dependency",
      "forest_after_cycle_removal",
      "pseudotree_structure",
      "vertex_cactus",
      "valid_tree",
      "dependency_graph",
      "dependency_constraint",
      "simple_undirected_graph",
      "undirected_graph",
      "ancestor_relation",
      "descendant_relation",
      "simple_graph",
      "forest_structure",
      "non_collinearity",
      "non_collinear_vertices",
      "parent_child_relation",
      "partial_order_constraint",
      "bst_property",
      "parent_child_order",
      "circular_dependency",
      "no_negative_cycles",
      "directed_edge",
      "simple_path",
      "partial_ordering"
    ],
    "examples": []
  },
  "planarity": {
    "name": "planarity",
    "description": "平面性约束，图需可平面嵌入",
    "aliases": [
      "triangulation_constraint"
    ],
    "examples": []
  },
  "bipartiteness": {
    "name": "bipartiteness",
    "description": "二部性约束，图为二部图",
    "aliases": [
      "bipartite_constraint",
      "bicolor_partition",
      "complete_bipartite",
      "latin_square",
      "bipartition_constraint",
      "bipartition_invariance",
      "binary_coloring",
      "bipartite_graph",
      "bipartite_edge_weight"
    ],
    "examples": []
  },
  "degree_bound": {
    "name": "degree_bound",
    "description": "度数上下界约束，如节点度限制",
    "aliases": [
      "edge_usage_limit",
      "edge_retention_limit",
      "min_branching_coefficient",
      "imbalance_condition",
      "imbalance_count",
      "exact_edge_count",
      "degree_sequence",
      "vertex_selection_limit",
      "integer_children_count",
      "column_weight_constraint",
      "edge_count_between_vertices",
      "other_children_constraint",
      "fork_constraint",
      "polynomial_degree_bound"
    ],
    "examples": []
  },
  "path_constraint": {
    "name": "path_constraint",
    "description": "路径约束，如路径长度/简单路径限制",
    "aliases": [
      "valid_path_output",
      "shortest_path_preservation",
      "triplet_path_constraint",
      "chain_length_constraint",
      "distinct_paths",
      "shortest_path",
      "grid_traversal",
      "maximal_path",
      "shortest_path_following",
      "trajectory_constraint",
      "passing_sequence",
      "path_query",
      "path_representation",
      "path_construction"
    ],
    "examples": []
  },
  "matching_constraint": {
    "name": "matching_constraint",
    "description": "匹配约束，如最大/完美匹配",
    "aliases": [
      "dangerous_battle_condition",
      "index_value_matching",
      "bipartite_matching",
      "voting_rule",
      "fixed_initial_pairing",
      "attacking_constraint",
      "pairwise_beating",
      "capture_constraint",
      "capture_condition",
      "pairwise_synergy",
      "pairwise_matching",
      "max_matching_size",
      "valid_combination",
      "defeat_condition",
      "color_matching",
      "maximal_matching",
      "final_set_match"
    ],
    "examples": []
  },
  "flow_constraint": {
    "name": "flow_constraint",
    "description": "流量/容量约束，如守恒或容量限制",
    "aliases": [
      "capacity_constraint",
      "propagation_constraint",
      "water_flow_from_root",
      "supply_demand_balance",
      "total_capacity_constraint",
      "input_output_balance",
      "energy_transfer_constraint",
      "transmission_constraint",
      "boundary_flow",
      "balance_constraint",
      "flow_balance"
    ],
    "examples": []
  },
  "coloring_constraint": {
    "name": "coloring_constraint",
    "description": "染色约束，如相邻不同色或色数限制",
    "aliases": [
      "edge_coloring",
      "color_change",
      "nested_brackets_coloring",
      "vertex_coloring"
    ],
    "examples": []
  },
  "spanning_constraint": {
    "name": "spanning_constraint",
    "description": "生成结构约束，如生成树/生成子图",
    "aliases": [
      "min_spanning_tree_weight",
      "min_steiner_tree",
      "min_spanning_tree",
      "mst_existence",
      "min_cost_tree"
    ],
    "examples": []
  },
  "ordering": {
    "name": "ordering",
    "description": "有序性约束，如单调、排序或字典序",
    "aliases": [
      "non_decreasing_sequence",
      "sorted_segments",
      "lexicographical_minimization",
      "ordered_segments",
      "lexicographical_order",
      "non_descending_order",
      "non_decreasing_subsequence",
      "ordering_constraint",
      "leftmost_priority",
      "monotonous_path",
      "priority_comparison",
      "lexicographical_ordering",
      "sorting_constraint",
      "dominance_constraint",
      "lexicographically_smallest",
      "fixed_variable_order",
      "strictly_increasing",
      "bfs_ordering",
      "non_decreasing_arrays",
      "sequence_ordering",
      "monotonicity",
      "stable_sorting",
      "lexicographic_ordering",
      "monotonic_cost",
      "kth_smallest",
      "strictly_increasing_sequence",
      "partial_sorting",
      "sorted_subarray_response",
      "increasing_indices",
      "sorted_target",
      "reverse_lexicographical_maximization",
      "parameter_ordering",
      "tie_breaking_rule",
      "lexicographical_maximality",
      "monotonic_sequence",
      "rank_calculation",
      "classification_order",
      "segment_ordering",
      "ranking_constraint",
      "tie_breaking",
      "ordered_collision_sequence",
      "time_ordered_events"
    ],
    "examples": []
  },
  "distinctness": {
    "name": "distinctness",
    "description": "唯一性约束，如元素互异或去重",
    "aliases": [
      "uniqueness_constraint",
      "distinct_leq_k",
      "distinct_elements_in_subsegments",
      "uniformity_constraint",
      "distinctness_symmetry",
      "distinct_selection",
      "uniformity_goal",
      "no_consecutive_repetition",
      "distinct_sequences",
      "distinct_assignment",
      "unique_edge",
      "time_travel_uniqueness",
      "non_empty_multiset",
      "distinct_indices",
      "exact_match_count",
      "frequency_uniqueness_constraint",
      "distinct_lucky_numbers",
      "path_distinctness",
      "transformation_cost_uniqueness",
      "distinct_pairs",
      "distinct_coordinates",
      "distinct_initial_health",
      "distinct_remainders",
      "distinct_query_elements",
      "distinct_strings",
      "distinct_arithmetic_progressions",
      "distinct_characters_in_query",
      "uniqueness_identification",
      "uniqueness_of_operations_count",
      "uniqueness_of_special_array",
      "unique_partition",
      "ambiguous_array",
      "procedure_uniqueness",
      "variable_uniqueness",
      "duplicate_names",
      "distinct_positions",
      "distinct_elements",
      "distinct_teams",
      "distinct_edges",
      "distinct_points",
      "unique_rounds",
      "pairwise_equality",
      "first_occurrence",
      "unique_subsequence",
      "distinct_designs",
      "no_double_gap_constraint",
      "distinct_vertex_set",
      "unique_hidden_position",
      "solution_uniqueness",
      "column_uniqueness",
      "row_uniqueness",
      "distinct_endpoints",
      "fixed_element_count",
      "unique_names",
      "unique_location_rule",
      "distinct_lines",
      "distinct_bases",
      "multiset_equality",
      "distinct_segments",
      "permutation_uniqueness",
      "cool_multiset_condition",
      "unique_points",
      "distinct_obstacles",
      "distinct_schemes",
      "unique_coordinates",
      "exact_match",
      "unique_set_recommendation",
      "count_alive",
      "distinct_modulo_values",
      "unique_triangle",
      "distinct_configurations",
      "distinct_solutions",
      "distinct_length_intervals",
      "single_use",
      "distinct_operations",
      "distinct_elevations",
      "distinct_internal_heights",
      "sequence_uniqueness",
      "distinct_trees",
      "unlabeled_nodes",
      "ratio_uniqueness",
      "no_repetition",
      "distinct_count",
      "distinct_sequence",
      "distinct_count_in_range",
      "unique_prefix_length",
      "cardinality_constraint",
      "distinct_intervals",
      "no_tie",
      "distinct_partition",
      "no_repeated_lines",
      "distinct_changes_constraint"
    ],
    "examples": []
  },
  "adjacency_relation": {
    "name": "adjacency_relation",
    "description": "相邻关系约束，如相等/差值/相邻互斥",
    "aliases": [
      "new_edges_between_common_neighbors",
      "adjacency_sum_odd",
      "edge_condition",
      "obstacle_avoidance",
      "undirected_graph",
      "circular_adjacency",
      "adjacent_intervals",
      "adjacent_pairs",
      "unordered_pairs",
      "street_alignment_constraint",
      "unidirectional_pairs",
      "adjacency_difference",
      "count_adjacent_pairs",
      "pairwise_comparison",
      "street_responsibility",
      "adjacent_pair_constraint",
      "alignment_constraint",
      "consecutive_selection",
      "consecutive_pages",
      "orthogonal_connectivity",
      "non_adjacency_constraint",
      "adjacency_sum_operation",
      "liberty_count",
      "no_adjacent_special_chars",
      "tangent_lines",
      "edge_constraint",
      "edge_representation",
      "boundary_relation"
    ],
    "examples": []
  },
  "frequency_bound": {
    "name": "frequency_bound",
    "description": "频次约束，如出现次数上界/下界",
    "aliases": [
      "max_bosses",
      "multiplicity_constraint",
      "target_value_frequency",
      "max_dangerous_battles",
      "disturbance_limit",
      "max_char_frequency",
      "threat_count",
      "one_change_per_interval",
      "replenishment_constraint",
      "frequency_multiplicity",
      "counting_constraint",
      "fixed_ones_count",
      "command_multiplicity",
      "divisor_occurrence",
      "max_value_occurrence",
      "skip_single_occurrence",
      "harvest_limit",
      "multiples_count",
      "even_frequency",
      "meal_count",
      "min_counting",
      "substring_count"
    ],
    "examples": []
  },
  "subsequence_constraint": {
    "name": "subsequence_constraint",
    "description": "子序列/子串约束，如包含或排除",
    "aliases": [
      "subsequence_validity",
      "substring_counting",
      "substring_concatenation",
      "substring_comparison",
      "interval_destruction",
      "subsequence_length",
      "count_subsequences",
      "subsequence_indices",
      "substring_selection",
      "substring_validity",
      "substring_match",
      "disjoint_subsequences",
      "substring_count",
      "contiguous_subsequence",
      "interval_modification",
      "subsequence_count_query"
    ],
    "examples": []
  },
  "permutation_constraint": {
    "name": "permutation_constraint",
    "description": "排列/置换约束，如逆序对或循环结构",
    "aliases": [
      "anagrammable_tree",
      "substring_shuffle",
      "power_of_permutation",
      "next_permutation",
      "substring_shift",
      "substring_rearrangement",
      "bitonic_permutation",
      "product_of_permutations",
      "swap_pairing",
      "pairwise_swap",
      "result_permutation",
      "permutation_equivalence"
    ],
    "examples": []
  },
  "range_bound": {
    "name": "range_bound",
    "description": "值域/范围约束，如元素上下界",
    "aliases": [
      "binary_string_length",
      "integer_coordinates",
      "positive_integer_constraint",
      "max_length",
      "boundary_constraint",
      "value_range",
      "value_set_constraint",
      "non_negative",
      "dimension_fit",
      "string_length",
      "inadequate_number_definition",
      "non_zero_coefficient",
      "rounding_constraint",
      "equal_length",
      "height_generation",
      "max_min_diff_leq_d",
      "odd_length",
      "string_length_bound",
      "memory_size",
      "node_location",
      "max_element_bound",
      "positive_elements",
      "uniform_height",
      "equal_height",
      "non_negative_height",
      "consecutive_days_constraint",
      "min_element_constraint",
      "value_definition",
      "weight_definition",
      "min_height",
      "array_length_power_of_two",
      "node_count_bound",
      "element_range_constraint",
      "matrix_size_constraint",
      "positive_integer_matrix",
      "positive_integers",
      "submatrix_size",
      "fixed_array",
      "fixed_value_constraint",
      "non_negative_integer_constraint",
      "length_constraint",
      "valid_query_range",
      "min_max_substring_length",
      "grid_boundary_constraint",
      "health_bound",
      "time_constraint",
      "max_min_difference",
      "upper_bound",
      "output_range",
      "positive_integer_amount",
      "element_range_bound",
      "non_negativity",
      "matrix_size",
      "grid_size",
      "non_negative_health",
      "non_zero_health",
      "max_min_diff_leq_sqrt_sum",
      "initial_cities_count",
      "max_min_diff_leq_k",
      "element_value_constraint",
      "max_value_in_interval",
      "upper_bound_constraint",
      "speed_range_constraint",
      "base_lower_bound",
      "non_negative_integers",
      "time_positive",
      "threshold_constraint",
      "base_bound",
      "string_length_constraint",
      "index_bound",
      "substring_length_bound",
      "max_min_boundary",
      "min_value_bound",
      "height_bound",
      "bit_sequence_length",
      "min_value_comparison",
      "range_constraint",
      "pattern_length_bound",
      "valid_range",
      "sequence_length",
      "digit_count",
      "text_length_bound",
      "integer_bound",
      "within_bound",
      "site_score_bound",
      "height_constraint",
      "insertion_position_range",
      "positive_integer",
      "max_floor_constraint",
      "day_bound",
      "month_bound",
      "year_bound",
      "positive_length",
      "index_range",
      "input_format",
      "ascii_range_constraint",
      "function_domain",
      "good_quantity_bound",
      "quantity_constraint",
      "height_threshold",
      "positive_integer_assignment",
      "interest_bound",
      "min_weeks_per_month",
      "character_modification_range",
      "bit_length_bound",
      "precision_constraint",
      "start_end_height",
      "size_bound",
      "fixed_range_boundaries",
      "min_value_in_range",
      "range_adjustment",
      "max_interval_length",
      "precision_bound",
      "valid_days_only",
      "dimension_constraint",
      "length_lower_bound",
      "subarray_length_constraint",
      "number_range",
      "integer_segment",
      "input_size_bound",
      "coefficient_bound",
      "evaluation_points_bound",
      "constant_bound",
      "valid_indices",
      "address_bound",
      "value_lower_bound",
      "parameter_bound",
      "time_interval_bound"
    ],
    "examples": []
  },
  "sum_constraint": {
    "name": "sum_constraint",
    "description": "和约束，如区间和/前缀和条件",
    "aliases": [
      "subset_sum",
      "subset_sum_equality",
      "union_length_sum_maximization",
      "submatrix_sum_leq_x",
      "score_increment",
      "mex_function",
      "sum_of_subtree_sizes",
      "encoding_cost",
      "substring_beauty",
      "correct_next_values",
      "missing_next_value",
      "next_value_constraint",
      "sum_weighted_frequencies",
      "initial_weight_sum_bound",
      "addition_constraint",
      "submatrix_min_sum",
      "column_sum_maximization",
      "max_value_sum",
      "subset_sum_minimization",
      "score_constraint",
      "substring_cost_calculation",
      "min_removal_for_sum_constraint",
      "min_removal_for_zero_sum",
      "min_weight_sum",
      "exact_change",
      "sum_to_one",
      "equal_partition_sum",
      "elementwise_sum",
      "subarray_cost",
      "max_geq_sum",
      "balance_constraint",
      "substring_cost_sum",
      "sum_of_values",
      "beauty_definition",
      "max_subarray_sum",
      "max_subarray_sum_bound",
      "non_zero_sum",
      "winnings_sum",
      "total_payment",
      "max_pair_sum",
      "score_adjustment",
      "subarray_sum_leq_u",
      "target_sum",
      "sum_of_products",
      "set_score_sum",
      "range_sum",
      "min_max_sum",
      "sum_condition",
      "score_calculation",
      "subarray_sum",
      "weight_sum_threshold"
    ],
    "examples": []
  },
  "divisibility": {
    "name": "divisibility",
    "description": "整除/同余约束，如 GCD/LCM",
    "aliases": [
      "gcd_constraint",
      "divisor_bound",
      "lcm_comparison",
      "size_multiple_of_four",
      "gcd_invariance",
      "power_of_two_constraint",
      "divisor_pair_constraint",
      "greatest_common_divisor",
      "divisibility_constraint",
      "factorization_multiplicity",
      "ratio_constraint",
      "lcm_sum_condition",
      "gcd_lcm_combination",
      "gcd_lcm_query",
      "gcd_condition",
      "gcd_relation",
      "composite_number_constraint",
      "divisor_constraint",
      "subset_divisibility",
      "prime_power_divisibility",
      "gcd_multiplication",
      "digit_sum_divisibility",
      "prime_power_bound",
      "value_multiples",
      "length_divisibility",
      "gcd_index_constraint"
    ],
    "examples": []
  },
  "parity": {
    "name": "parity",
    "description": "奇偶性约束",
    "aliases": [
      "odd_even_constraint",
      "binary_outcome",
      "odd_length",
      "submatrix_parity_constraint",
      "even_coordinates",
      "odd_enclosed_points",
      "truth_lie_constraint",
      "even_number_constraint",
      "degree_parity",
      "parity_constraint",
      "degree_parity_constraint"
    ],
    "examples": []
  },
  "linear_relation": {
    "name": "linear_relation",
    "description": "线性关系约束，如线性方程或不等式",
    "aliases": [
      "collinearity_constraint",
      "linear_combination",
      "value_comparison",
      "arithmetic_progression",
      "value_dependency",
      "equality_constraint",
      "finite_arithmetic_progressions",
      "line_structure",
      "coefficient_reference",
      "linear_equation_system",
      "equal_difference",
      "line_constraint",
      "production_function",
      "arithmetic_sequence_addition",
      "arithmetic_sequence"
    ],
    "examples": []
  },
  "modular_arithmetic": {
    "name": "modular_arithmetic",
    "description": "模运算约束，如取模结果限制",
    "aliases": [
      "expected_value_modulo",
      "cyclic_modulo_relation",
      "modular_inverse",
      "modulo_constraint",
      "subset_count_modulo",
      "modular_invariance",
      "circular_time_constraint",
      "cyclic_offset",
      "vasya_formula",
      "gcd_modulo",
      "xor_sum_zero",
      "xor_sum_recovery",
      "hash_value_constraint",
      "xor_operation",
      "expected_time_modulo",
      "pairwise_xor_bound",
      "xor_sum_reconstruction",
      "xor_aggregation",
      "bitwise_xor_operation",
      "xor_condition",
      "sum_modulo_prime",
      "xor_constraint",
      "value_modulo_constraint",
      "xor_trait",
      "value_modulo",
      "modular_inverse_pairs",
      "output_modulo",
      "degree_modulo",
      "runtime_modulo",
      "modulo_sum",
      "boolean_equation_satisfaction",
      "probability_modulo",
      "checksum_constraint",
      "leap_year_rule",
      "scheme_count_modulo",
      "modular_indexing",
      "operation_count_modulo",
      "sum_modulo",
      "prime_modulus",
      "output_modulo_constraint",
      "modulus_constraint",
      "odd_moduli",
      "modular_pairing",
      "polynomial_modulo",
      "modular_constraint",
      "hash_function",
      "distance_sum_modulo",
      "xor_indexing"
    ],
    "examples": []
  },
  "convexity": {
    "name": "convexity",
    "description": "凸性约束，如凸包或凸多边形",
    "aliases": [
      "circle_enclosure",
      "triangle_enclosure",
      "convex_hull"
    ],
    "examples": []
  },
  "distance_bound": {
    "name": "distance_bound",
    "description": "距离约束，如曼哈顿/欧氏距离限制",
    "aliases": [
      "manhattan_distance_constraint",
      "min_max_distance",
      "manhattan_distance_bound",
      "adjacent_difference",
      "euclidean_distance",
      "pairwise_distance_sum",
      "movement_constraint",
      "edge_weight_constraint",
      "max_distance_constraint",
      "weight_bound",
      "travel_time_constraint",
      "boundary_crossing_count",
      "boundary_condition",
      "path_length_bound",
      "proximity_constraint",
      "min_difference",
      "boundary_constraint",
      "attack_range",
      "edit_distance",
      "adjacency_difference",
      "weighted_edges",
      "edge_weight",
      "path_length",
      "similarity_constraint",
      "discrete_jump_constraint",
      "signal_power_bound",
      "pairwise_cost",
      "pythagorean_triple",
      "hamming_distance_bound",
      "edge_weight_condition",
      "distance_query",
      "pairwise_similarity",
      "pairwise_difference",
      "max_distance_query",
      "mex_distance_constraint",
      "max_distance_reduction",
      "manhattan_distance",
      "triangle_inequality",
      "triple_inequality",
      "distance_constraint",
      "segment_traversal_time",
      "max_height_reachable",
      "speed_limit",
      "max_distance_between_different_groups",
      "speed_constraint",
      "value_difference",
      "min_abs_difference",
      "distance_comparison",
      "pairwise_distance_constraint",
      "pairwise_difference_bound",
      "tolerance_constraint",
      "nonzero_distance_from_mirror",
      "safe_distance_from_crossing",
      "exposure_limit",
      "speed_bound",
      "total_length_bound",
      "interval_distance_constraint",
      "max_good_radius",
      "minimum_distance",
      "max_distance_in_component",
      "boundary_strength_constraint",
      "simple_cycle_weight_bound",
      "diameter_constraint",
      "car_travel_limitation",
      "distance_budget",
      "max_min_diff_leq_d",
      "edge_weight_function",
      "min_length",
      "collision_distance_bound"
    ],
    "examples": []
  },
  "intersection": {
    "name": "intersection",
    "description": "相交/重叠关系约束",
    "aliases": [
      "disjoint_segments",
      "intersection_constraint",
      "interval_overlap_exclusion",
      "non_overlapping_subsegments",
      "time_interval_exclusion",
      "non_intersecting_castles",
      "non_intersecting_rectangles",
      "non_intersection_within_type",
      "pairwise_non_intersecting",
      "collision_detection",
      "triple_intersection_empty",
      "subset_disjointness",
      "time_window_exclusion",
      "multiset_intersection_size",
      "non_intersecting_projections",
      "overlap_constraint",
      "non_overlapping",
      "non_crossing",
      "non_overlapping_selection",
      "non_overlapping_segments",
      "non_intersection",
      "common_elements",
      "disjoint_intervals",
      "interval_disjointness",
      "no_overlap_positions",
      "interval_avoidance",
      "non_overlapping_intervals",
      "non_intersecting_segments",
      "meeting_point",
      "overlap_allowed",
      "substring_overlap_allowed",
      "interval_overlap",
      "boundary_membership",
      "vertex_intersection_only",
      "crossing_constraint",
      "point_containment",
      "volume_overlap",
      "volume_intersection",
      "intersection_allowed"
    ],
    "examples": []
  },
  "orientation": {
    "name": "orientation",
    "description": "方向/朝向约束，如顺逆时针",
    "aliases": [
      "directional_movement",
      "turn_direction_constraint",
      "orientation_constraint",
      "initial_direction",
      "projection_direction",
      "takeoff_direction_constraint",
      "movement_direction",
      "velocity_direction",
      "velocity_vector",
      "direction_grouping",
      "speed_sign",
      "directional_constraint",
      "edge_direction",
      "directionality",
      "edge_directionality"
    ],
    "examples": []
  },
  "subset_constraint": {
    "name": "subset_constraint",
    "description": "子集约束，如子集选择或大小限制",
    "aliases": [
      "maximal_set_size",
      "set_operations",
      "count_non_empty_sequences",
      "subsequence_length",
      "big_enough_subset",
      "subset_removal",
      "total_substring_limit",
      "total_substrings_bound",
      "subset_switching",
      "subsequence_size",
      "maximal_selection",
      "minimum_selection_size",
      "meta_set_constraint",
      "minimum_element_count",
      "set_membership",
      "range_selection",
      "valid_subset",
      "subset_selection",
      "exact_subset_match",
      "subset_union"
    ],
    "examples": []
  },
  "partition": {
    "name": "partition",
    "description": "划分约束，如分组或等价类划分",
    "aliases": [
      "substring_partition",
      "partition_constraint",
      "equivalence_classes",
      "decomposition_constraint",
      "palindrome_partition",
      "subsequence_partition",
      "non_empty_partition",
      "power_of_two_partition",
      "partition_into_equal_subsequences",
      "subarray_partition",
      "partition_into_palindromes",
      "area_partition",
      "complete_partition",
      "segmentation",
      "subtree_partition",
      "equal_partition",
      "polygon_partition",
      "grouping_constraint",
      "grouping",
      "triple_partition",
      "partitioning_constraint",
      "subgroup_partition"
    ],
    "examples": []
  },
  "coverage": {
    "name": "coverage",
    "description": "覆盖约束，如区间或集合覆盖",
    "aliases": [
      "area_constraint",
      "region_coverage",
      "segment_coverage",
      "max_area_submatrix",
      "time_interval_availability",
      "non_empty_segments",
      "museum_availability_constraint",
      "coverage_constraint",
      "min_covering_set",
      "rectangular_union",
      "treasure_collection",
      "path_sum_coverage",
      "use_all_elements",
      "all_on_possible",
      "interval_coverage",
      "maximal_coverage",
      "substring_non_empty",
      "interval_profit_split",
      "availability_constraint",
      "non_empty_black_cells",
      "occupancy_constraint",
      "non_empty_string",
      "max_coverage",
      "line_coverage",
      "shaded_area_calculation",
      "subtree_coverage",
      "hemisphere_coverage",
      "volume_coverage",
      "edge_coverage",
      "influence_area_coverage",
      "interval_validity",
      "region_constraint",
      "interval_constraint",
      "grid_coverage",
      "area_union",
      "visibility_constraint",
      "binary_string_coverage",
      "odd_cycle_coverage",
      "subset_coverage",
      "point_coverage",
      "area_coverage",
      "color_coverage",
      "unique_coverage",
      "connected_component_coverage"
    ],
    "examples": []
  },
  "exclusion": {
    "name": "exclusion",
    "description": "互斥/禁止约束",
    "aliases": [
      "pairwise_exclusion",
      "no_multiple_edges",
      "no_self_loops",
      "rectangle_exclusion",
      "event_deletion",
      "invalid_substrings",
      "optional_exclusion",
      "exclusive_access",
      "max_exclusion",
      "boundary_exclusion",
      "final_position_exclusion",
      "index_exclusion",
      "unique_edge_between_nodes",
      "segment_exclusion",
      "palindrome_substring_prohibition",
      "no_multiple_edges_or_loops",
      "mutual_exclusion",
      "unknown_edges",
      "initial_position_exclusion",
      "fixed_point_exclusion",
      "no_parallel_edges",
      "no_self_loops_or_multiple_edges",
      "no_repeated_edges",
      "leading_zero_exclusion",
      "digit_exclusion",
      "pattern_exclusion",
      "no_initial_touching",
      "no_excess_blocks",
      "output_device_exclusion",
      "collinearity_exclusion",
      "unique_edge_removal",
      "edge_type_exclusion",
      "emergency_frequency_exclusion",
      "safety_condition",
      "source_destination_exclusion",
      "no_green_squares",
      "inequivalence_constraint",
      "subset_exclusion",
      "duplicate_exclusion",
      "range_exclusion",
      "set_exclusion",
      "divisibility_exclusion",
      "value_exclusion",
      "self_loop_and_parallel_edges",
      "obstacle_constraint",
      "impassable_nodes",
      "internal_exclusion",
      "source_sink_exclusion",
      "obstacle_avoidance",
      "elimination_constraint",
      "no_self_loops_or_parallel_edges",
      "deletion_constraint",
      "character_exclusion",
      "concurrency_exclusion",
      "edge_exclusion",
      "forbidden_positions"
    ],
    "examples": []
  },
  "inclusion": {
    "name": "inclusion",
    "description": "包含/必选约束",
    "aliases": [
      "subtree_inclusion",
      "complementary_selection",
      "concatenation_inclusion",
      "concatenation_constraint",
      "optional_usage",
      "range_inclusion",
      "lca_inclusion",
      "region_inclusion",
      "single_selection",
      "point_inclusion",
      "arrival_departure_inclusion",
      "containment_constraint",
      "landmark_inclusion",
      "addition_inclusion",
      "reciprocal_inclusion",
      "subtraction_inclusion",
      "no_further_division",
      "corner_inclusion"
    ],
    "examples": []
  },
  "operation_limit": {
    "name": "operation_limit",
    "description": "操作次数限制",
    "aliases": [
      "reset_difficulty",
      "process_termination",
      "replacement_limit",
      "cooldown_period",
      "replacement_bound",
      "operation_constraint",
      "replacement_constraint",
      "update_operations",
      "dynamic_update",
      "edge_addition_limit",
      "consecutive_operation",
      "termination_condition",
      "sequential_access",
      "sequential_operations",
      "reset_limit",
      "step_limit",
      "min_operations",
      "no_creation_deletion",
      "operation_cost",
      "min_discrete_jumps",
      "checkpoint_reset",
      "stage_limit",
      "recovery_constraint",
      "output_termination",
      "single_modification",
      "insertion_count",
      "final_guess_limit",
      "query_operations",
      "time_bound",
      "step_constraint",
      "query_time_bound",
      "expected_operations",
      "finite_steps_termination",
      "operation_count",
      "transfer_limit",
      "min_changes_required",
      "min_operations_to_equalize",
      "game_termination",
      "piece_limit",
      "minimize_switches",
      "activation_limit",
      "shepherd_movement_limit",
      "instruction_limit",
      "lifetime_bound",
      "finite_game_constraint",
      "bubble_sort_passes",
      "refill_constraint",
      "resource_limit",
      "min_steps",
      "deadline_constraint",
      "switch_limit",
      "time_limit",
      "adjustment_constraint",
      "single_ooblection_per_time",
      "device_limit",
      "reflection_limit",
      "traversal_limit",
      "refutation_speed",
      "edge_traversal_count",
      "minimize_removals",
      "dynamic_updates",
      "testcase_limit",
      "modification_limit",
      "minimize_operations",
      "action_limit",
      "modification_frequency",
      "robot_lifetime_bound",
      "fixed_time_limit",
      "response_limit",
      "reset_operation",
      "recharge_time",
      "step_bound",
      "guess_limit",
      "online_guess",
      "answer_once",
      "reset_after_withdraw",
      "restart_condition",
      "max_transformations",
      "processing_unit_limit",
      "time_complexity_constraint",
      "min_modification",
      "derivative_order_bound",
      "input_limit",
      "max_steps_bound",
      "update_frequency",
      "test_round_limit",
      "stack_index_bound",
      "stack_operation_limit",
      "modification_bound"
    ],
    "examples": []
  },
  "operation_type": {
    "name": "operation_type",
    "description": "操作类型限制，如仅交换/翻转/插入",
    "aliases": [
      "swap_operation",
      "swap_condition",
      "swap_validity",
      "single_element_removal",
      "overwriting",
      "move_options",
      "edge_addition",
      "command_set_constraint",
      "deletion_operation",
      "insertion_operation",
      "removal_constraint",
      "adjacent_swap",
      "special_player_behavior",
      "valid_move_constraint",
      "difficulty_update",
      "deterministic_status",
      "disjoint_swaps",
      "stack_operation",
      "valid_operation",
      "vehicle_movement_rule",
      "stack_operations",
      "flush_operation",
      "deletion_constraint",
      "removal_rule",
      "movement_rules",
      "edge_removal_and_addition",
      "operator_fixed",
      "insert_element",
      "edge_addition_rule"
    ],
    "examples": []
  },
  "state_transition": {
    "name": "state_transition",
    "description": "状态转移约束，如合法转移",
    "aliases": [
      "final_state",
      "resource_persistence",
      "position_tracking",
      "consistency_constraint",
      "landing_constraint",
      "activation_condition",
      "persistent_updates",
      "absorption_rule",
      "all_configurations",
      "position_update",
      "position_update_rule",
      "pixel_transition",
      "activation_deactivation_constraint",
      "valid_transition",
      "rolling_and_falling"
    ],
    "examples": []
  },
  "concurrency": {
    "name": "concurrency",
    "description": "并发/同步约束",
    "aliases": [
      "simultaneous_operations",
      "periodic_synchronization",
      "parallelization_constraint",
      "simultaneous_travel",
      "parallel_transmission",
      "parallel_execution",
      "simultaneous_exit",
      "concurrency_limit"
    ],
    "examples": []
  },
  "reversibility": {
    "name": "reversibility",
    "description": "可逆性约束",
    "aliases": [
      "operation_reversibility"
    ],
    "examples": []
  },
  "transformation": {
    "name": "transformation",
    "description": "变换/替换/映射规则约束",
    "aliases": [
      "response_constraint",
      "xor_transformation",
      "transformation_rule",
      "segment_modification",
      "leaf_value_zeroing",
      "subtree_operation",
      "string_multiplication",
      "weight_update_rule",
      "range_update",
      "function_definition",
      "binary_digit_transformation",
      "bitwise_or_response",
      "operation_rule",
      "transformation_constraint",
      "element_update",
      "subarray_reversal",
      "string_modification",
      "function_constraint",
      "update_constraint",
      "update_rule",
      "path_modification",
      "segment_copy_paste",
      "array_modification",
      "digit_wise_operation",
      "valid_substitution",
      "substring_replacement",
      "composition_constraint",
      "merge_rule",
      "rearrangement_cost",
      "conversion_rule",
      "shape_transformations",
      "point_update",
      "substring_modification",
      "value_update",
      "value_update_constraint",
      "value_modification",
      "update_operation",
      "point_modification",
      "query_modification",
      "update_element",
      "modification_rule",
      "edge_update",
      "function_composition"
    ],
    "examples": []
  },
  "palindrome": {
    "name": "palindrome",
    "description": "回文约束",
    "aliases": [
      "palindrome_constraint",
      "valid_parentheses_sequence",
      "valid_bracket_sequence",
      "palindrome_inclusion",
      "correct_bracket_sequence",
      "min_changes_to_palindromes",
      "palindrome_substring_count",
      "balanced_parentheses",
      "palindrome_even_length"
    ],
    "examples": []
  },
  "pattern_matching": {
    "name": "pattern_matching",
    "description": "模式匹配约束，如通配符",
    "aliases": [
      "wildcard_replacement",
      "fixed_pattern",
      "target_image_matching",
      "wildcard_inclusion",
      "substring_matching",
      "template_constraint"
    ],
    "examples": []
  },
  "alphabet_constraint": {
    "name": "alphabet_constraint",
    "description": "字符集约束，如字母表大小",
    "aliases": [
      "character_set",
      "binary_string",
      "case_sensitivity",
      "binary_state",
      "binary_representation",
      "alphabet_size_bound",
      "binary_array",
      "character_set_constraint",
      "base_representation",
      "case_transformation",
      "vowel_presence",
      "digit_constraint",
      "digit_set_constraint"
    ],
    "examples": []
  },
  "repetition": {
    "name": "repetition",
    "description": "重复性/周期性约束",
    "aliases": [
      "periodic_movement",
      "move_repetition",
      "periodic_schedule",
      "consecutive_ones_limit",
      "periodic_event",
      "period_partition",
      "periodicity",
      "periodicity_constraint",
      "periodic_excitation",
      "pattern_recurrence",
      "multiple_pattern_occurrences",
      "periodic_regeneration"
    ],
    "examples": []
  },
  "turn_based": {
    "name": "turn_based",
    "description": "回合制约束",
    "aliases": [],
    "examples": []
  },
  "optimal_play": {
    "name": "optimal_play",
    "description": "最优策略约束",
    "aliases": [
      "greedy_selection",
      "max_element_selection",
      "optimal_strategy",
      "champion_determination",
      "no_winner_condition",
      "winning_condition",
      "greedy_assignment",
      "random_greedy_failure",
      "strategy_selection",
      "adversarial_strategy"
    ],
    "examples": []
  },
  "query_limit": {
    "name": "query_limit",
    "description": "询问次数限制",
    "aliases": [
      "independent_queries",
      "lca_query",
      "query_type_1",
      "query_type_2",
      "no_duplicate_queries",
      "reachability_query_limit",
      "query_processing",
      "consistent_queries",
      "min_query_count",
      "query_type_constraint",
      "at_least_one_query_of_type_2",
      "query_constraint",
      "query_generation",
      "non_adaptive_queries",
      "query_response",
      "offline_query",
      "online_query",
      "character_query",
      "position_query",
      "output_limit",
      "online_queries"
    ],
    "examples": []
  },
  "probability_distribution": {
    "name": "probability_distribution",
    "description": "概率分布约束",
    "aliases": [
      "expected_value",
      "expected_value_calculation",
      "survival_probability",
      "expected_tries_constraint",
      "probability_bound",
      "probability_constraint",
      "cleaning_probability",
      "probability_product",
      "subset_probability",
      "expected_value_constraint",
      "uniform_distribution",
      "bonus_probability_distribution",
      "probability_calculation",
      "bet_outcome_probability",
      "initial_probability",
      "transition_probability"
    ],
    "examples": []
  },
  "independence": {
    "name": "independence",
    "description": "独立性约束",
    "aliases": [
      "independent_set",
      "independent_set_size",
      "independent_events",
      "query_independence",
      "independent_calculations",
      "point_selection_independence",
      "independent_groups",
      "subset_independence",
      "subtree_independence",
      "independent_set_constraint",
      "independent_set_count",
      "max_independent_set_size",
      "independent_motion",
      "unique_combination",
      "independent_set_size_bound"
    ],
    "examples": []
  },
  "decrease_only_constraint": {
    "name": "decrease_only_constraint",
    "description": "仅允许递减操作的约束，如数值只能减少不能增加",
    "aliases": [
      "decrement_only",
      "reduction_constraint",
      "debt_reduction",
      "positive_removal",
      "retrogress_bound",
      "monotonic_decreasing",
      "non_increasing",
      "monotonic_decrease",
      "monotonicity",
      "height_decrement"
    ],
    "examples": []
  },
  "local_maximum_count_constraint": {
    "name": "local_maximum_count_constraint",
    "description": "局部极大值个数的约束，如序列中局部最大点的数量限制",
    "aliases": [
      "local_maxima_count",
      "hump_count",
      "local_maxima"
    ],
    "examples": []
  },
  "fixed_start_node": {
    "name": "fixed_start_node",
    "description": "起点节点固定约束，要求路径或遍历必须从指定节点开始",
    "aliases": [
      "start_node_fixed",
      "starting_point_constraint",
      "initial_day_constraint",
      "start_city_constraint",
      "starting_position",
      "initial_position_constraint",
      "start_position",
      "root_fixed",
      "initial_activation",
      "predefined_nodes",
      "start_finish_constraint",
      "initial_position",
      "start_end_activation",
      "initial_position_fixed",
      "start_end_constraint",
      "unique_start_end",
      "initial_state",
      "common_start",
      "starting_node",
      "top_card_only",
      "initial_value_constraint",
      "fixed_starting_position",
      "fixed_initial_position",
      "initial_operation",
      "start_end_same_node",
      "directional_start",
      "fixed_endpoints",
      "leaf_start",
      "root_weight_fixed",
      "source_target_constraint",
      "single_robot_constraint",
      "root_constraint",
      "initial_selection_constraint",
      "root_parent_constraint",
      "initial_positioning",
      "root_fixed_position",
      "lead_position_constraint",
      "inorder_traversal_fixed",
      "start_position_bound",
      "start_end_same",
      "top_element_only"
    ],
    "examples": []
  },
  "random_position_constraint": {
    "name": "random_position_constraint",
    "description": "位置随机性约束，表示目标位置在一定范围内随机分布",
    "aliases": [
      "treasure_position_random",
      "lucky_number_constraint",
      "random_vacant_selection",
      "random_data",
      "operation_randomness"
    ],
    "examples": []
  },
  "optimization_objective": {
    "name": "optimization_objective",
    "description": "优化目标约束，如最小化或最大化某个函数值",
    "aliases": [
      "probability_minimization",
      "cost_function",
      "maximization_constraint",
      "step_minimization",
      "maximize_good_vertices",
      "max_mex_query",
      "maximize_denominator",
      "maximize_ratio",
      "minimization_constraint",
      "cost_minimization",
      "subset_optimality",
      "minimization",
      "distinct_visits_maximization",
      "minimize_max_nesting_depth",
      "extra_space_minimization",
      "winning_condition",
      "winning_condition_capture",
      "winning_condition_target_reach",
      "xor_cost_minimization",
      "median_maximization",
      "path_sum_minimization",
      "cost_constraint",
      "lis_maximization",
      "lis_minimization",
      "cost_comparison",
      "max_time_minimization",
      "min_total_cost",
      "cost_definition",
      "final_value",
      "distance_minimization",
      "minimize_max_value",
      "maximize_path_length",
      "inversion_minimization",
      "x_optimization",
      "cost_dependency",
      "minimize_quadratic_sum",
      "maximization",
      "median_constraint",
      "max_min_diff_maximization",
      "penalty_constraint",
      "sum_maximization",
      "minimize_max_prefix_function",
      "min_cost_path",
      "win_condition",
      "value_function",
      "maximize_k",
      "min_time_selection",
      "gcd_sum_maximization",
      "min_coins",
      "minimize_extra_elements",
      "minimize_total_weight",
      "min_max_xor_path_cost",
      "max_value_minimization",
      "mex_constraint",
      "max_value_after_operations",
      "diameter_maximization",
      "edge_weight_min",
      "max_value_calculation",
      "xor_optimization",
      "max_beauty_over_all_products",
      "minimize_filled_cells",
      "maximize_coins_under_fixed_operations",
      "bitwise_and_maximization",
      "triangle_maximization",
      "max_votes_winner",
      "min_exclusions_to_win",
      "undecided_vote_lowest",
      "min_max_optimization",
      "min_max_operations",
      "maximize_subset_sum",
      "max_cost_objective",
      "min_reliability_burnout",
      "minimal_solution",
      "max_usefulness_min_duration",
      "probability_maximization",
      "profit_constraint",
      "minimize_waste",
      "maximize_sum",
      "max_value_reported",
      "objective_function",
      "lexicographical_maximization",
      "cost_maximization",
      "min_waste",
      "maximize_sum_of_distances",
      "quality_metric",
      "edge_weight_sum_maximization",
      "optimal_path",
      "score_function",
      "winner_determination",
      "maximize_value",
      "expected_value_maximization",
      "operation_cost_minimization",
      "max_probability",
      "expected_profit_maximization",
      "min_cost",
      "minimize_ratio",
      "optimality_constraint",
      "minimax_decision",
      "optimization_constraint",
      "solution_bound",
      "maximize_m"
    ],
    "examples": []
  },
  "clique_cycle_constraint": {
    "name": "clique_cycle_constraint",
    "description": "团与环的组合约束，要求图中存在一个完全子图（团）同时构成一个环结构",
    "aliases": [
      "clique_cycle",
      "clique_size",
      "complete_graph",
      "triangle_counting"
    ],
    "examples": []
  },
  "report_generation_constraint": {
    "name": "report_generation_constraint",
    "description": "生成报告或输出的最终行必须满足特定格式或内容要求的约束",
    "aliases": [
      "final_line_report",
      "output_format",
      "output_constraint",
      "query_result_output"
    ],
    "examples": []
  },
  "coprime_constraint": {
    "name": "coprime_constraint",
    "description": "元素间互质关系约束，要求一组数两两互质或满足特定互质条件",
    "aliases": [
      "coprime_representation",
      "irreducible_fraction",
      "coprime_fraction",
      "prime_factorization_input",
      "coprime_count",
      "coprimality"
    ],
    "examples": []
  },
  "parentheses_invariance": {
    "name": "parentheses_invariance",
    "description": "括号移除后表达式结构或值保持不变的性质，常用于表达式等价性判断",
    "aliases": [
      "bracket_removal_invariance",
      "balanced_parentheses",
      "valid_parentheses_sequence",
      "parentheses_ordering",
      "valid_parentheses"
    ],
    "examples": []
  },
  "syntax_validity": {
    "name": "syntax_validity",
    "description": "表达式符合语法规则的约束，确保其为合法可解析的结构",
    "aliases": [
      "valid_expression",
      "validity_check",
      "valid_formula",
      "valid_log_sequence",
      "expression_result",
      "format_constraint",
      "program_validity",
      "expression_validity"
    ],
    "examples": []
  },
  "labeling_constraint": {
    "name": "labeling_constraint",
    "description": "对图或序列中边或节点进行标签分配的约束，要求标签满足特定规则或分布",
    "aliases": [
      "edge_labeling",
      "quantifier_assignment",
      "classification_rule",
      "edge_character_association",
      "consistent_renaming",
      "labeled_tree",
      "valid_numbering",
      "capital_assignment"
    ],
    "examples": []
  },
  "rectangle_shape": {
    "name": "rectangle_shape",
    "description": "表示对象为矩形形状的抽象约束，适用于描述具有矩形几何特征的实体或布局",
    "aliases": [
      "rectangular_castles",
      "safe_column_constraint",
      "shape_constraint",
      "grid_even_size",
      "bounding_box",
      "rectangle_constraint"
    ],
    "examples": []
  },
  "rectangular_layout": {
    "name": "rectangular_layout",
    "description": "表示元素排列成矩形结构的布局约束，常用于描述阵列、网格或对齐排列",
    "aliases": [
      "rectangular_formation",
      "square_matrix",
      "nested_rectangle",
      "subrectangle_constraint",
      "grid_structure",
      "rectangular_region",
      "container_structure",
      "subgrid_expansion",
      "grid_configuration",
      "rectangle_positioning"
    ],
    "examples": []
  },
  "recurrence_relation": {
    "name": "recurrence_relation",
    "description": "递推关系约束，要求序列或函数满足特定的递推公式，如斐波那契数列或线性递推",
    "aliases": [
      "nesting_constraint",
      "depth_calculation",
      "fibonacci_number",
      "growth_rule",
      "inductive_definition",
      "functional_equation",
      "polynomial_derivative"
    ],
    "examples": []
  },
  "field_generation": {
    "name": "field_generation",
    "description": "生成无限域中元素的抽象约束，适用于涉及代数结构或有限域扩展的场景",
    "aliases": [
      "infinite_field_generation"
    ],
    "examples": []
  },
  "merge_order_constraint": {
    "name": "merge_order_constraint",
    "description": "要求合并操作必须从左到右依次进行的顺序约束",
    "aliases": [
      "left_to_right_merging",
      "merging_sequence",
      "level_merge",
      "cascade_merge",
      "path_concatenation",
      "mergeable_intervals",
      "set_merge",
      "leaf_merging"
    ],
    "examples": []
  },
  "prefix_suffix_elimination": {
    "name": "prefix_suffix_elimination",
    "description": "允许移除前缀或后缀元素的变换约束，常用于字符串或序列处理",
    "aliases": [
      "prefix_suffix_removal",
      "token_removal_rule",
      "segment_removal",
      "prefix_on_constraint",
      "prefix_constraint",
      "fixed_point_removal",
      "palindrome_removal",
      "prefix_reversal",
      "string_expansion",
      "substring_reversal",
      "non_empty_prefix",
      "prefix_swapping",
      "prefix_matching",
      "last_token_generated"
    ],
    "examples": []
  },
  "window_constraint": {
    "name": "window_constraint",
    "description": "滑动窗口约束，表示在序列或数组上应用固定大小或可变大小的窗口进行处理或计算的抽象约束",
    "aliases": [
      "sliding_window",
      "range_query",
      "order_statistics_query",
      "query_range",
      "time_window",
      "generation_interval",
      "context_size",
      "range_kth_query",
      "sliding_window_min",
      "range_filter"
    ],
    "examples": []
  },
  "cycle_count_constraint": {
    "name": "cycle_count_constraint",
    "description": "对图中环的数量进行限制的约束，要求环的个数不超过指定上限",
    "aliases": [
      "cycle_count_limit",
      "circular_arrangement",
      "nontrivial_cycle",
      "simple_cycle_length",
      "hamiltonian_cycle",
      "cyclic_path",
      "return_to_origin",
      "time_travel_loop",
      "circular_graph",
      "circular_path",
      "closed_path",
      "ring_constraint",
      "hamiltonian_path"
    ],
    "examples": []
  },
  "operation_order": {
    "name": "operation_order",
    "description": "操作执行顺序的约束，要求特定操作必须按照指定顺序进行",
    "aliases": [
      "edge_processing_order",
      "cutting_order",
      "interaction_protocol",
      "removal_sequence",
      "order_flexibility",
      "non_adaptive_interactor",
      "access_order",
      "transformation_sequence",
      "elimination_process",
      "online_processing",
      "insertion_sequence",
      "elimination_order",
      "preorder_traversal",
      "sequential_execution",
      "operation_sequence",
      "sequential_decision",
      "dependency_ordering",
      "cutting_constraint",
      "edge_removal_sequence",
      "supervision_rule",
      "stacking_order",
      "priority_removal",
      "sequential_activation",
      "sequential_processing",
      "sequential_operations",
      "operation_separation",
      "consecutive_operation",
      "operation_sequence_dependency",
      "interaction_constraint",
      "online_operation",
      "cursor_movement_constraint"
    ],
    "examples": []
  },
  "zero_diagonal_constraint": {
    "name": "zero_diagonal_constraint",
    "description": "要求矩阵或图的主对角线元素均为零的约束",
    "aliases": [
      "diagonal_zero",
      "diagonal_constraint",
      "zero_element_identification"
    ],
    "examples": []
  },
  "symmetric_structure_constraint": {
    "name": "symmetric_structure_constraint",
    "description": "要求结构（如矩阵、图）具有对称性质的抽象约束",
    "aliases": [
      "symmetry",
      "nested_structure",
      "symmetric_sequence",
      "tree_isomorphism",
      "symmetric_pairs",
      "symmetry_constraint"
    ],
    "examples": []
  },
  "perfect_square_constraint": {
    "name": "perfect_square_constraint",
    "description": "要求乘积为完全平方数的抽象约束，常用于数论或组合优化场景",
    "aliases": [
      "perfect_square_product",
      "pairwise_product_not_square",
      "integer_area",
      "perfect_square_base",
      "polynomial_square_root"
    ],
    "examples": []
  },
  "out_of_bounds_constraint": {
    "name": "out_of_bounds_constraint",
    "description": "表示元素或操作超出定义域或有效范围的抽象约束，常用于描述越界、无效输入或非法状态",
    "aliases": [
      "outside_definition",
      "invalid_query_response",
      "impossibility_check",
      "impossible_recovery",
      "escape_condition",
      "invalid_input_handling",
      "impossible_conversion"
    ],
    "examples": []
  },
  "eigenvalue_spectrum_constraint": {
    "name": "eigenvalue_spectrum_constraint",
    "description": "对矩阵或线性算子的特征值谱施加约束，如特征值范围、重数或分布限制",
    "aliases": [
      "spectrum_constraint",
      "solution_space_dimension"
    ],
    "examples": []
  },
  "alternating_pattern_constraint": {
    "name": "alternating_pattern_constraint",
    "description": "序列或结构中元素/段交替变化的抽象约束，要求模式在不同类别间交替出现",
    "aliases": [
      "alternating_segments",
      "alternating_sum_zero",
      "wavy_number_constraint",
      "alternating_selection",
      "consecutive_digits",
      "alternating_sequence",
      "alternating_subarray",
      "alternating_serving",
      "balanced_sequence",
      "alternating_turns",
      "color_sequence",
      "alternating_moves",
      "alternating_state_transition",
      "alternating_operations"
    ],
    "examples": []
  },
  "non_self_intersecting_constraint": {
    "name": "non_self_intersecting_constraint",
    "description": "几何路径或曲线不允许严格自相交的抽象约束，适用于多边形、折线等形状",
    "aliases": [
      "no_strict_self_intersections",
      "edge_crossing_constraint",
      "non_self_query",
      "non_intersecting_diagonals",
      "polygon_simplicity",
      "no_antipodes"
    ],
    "examples": []
  },
  "geometric_angle_constraint": {
    "name": "geometric_angle_constraint",
    "description": "对几何图形中角度大小或关系施加的抽象约束，如角度范围、相等、互补或特定角度值限制",
    "aliases": [
      "angle_constraint",
      "turning_angle_constraint",
      "angle_coverage",
      "angle_bound",
      "angle_interval_probability"
    ],
    "examples": []
  },
  "revisiting_allowed": {
    "name": "revisiting_allowed",
    "description": "允许顶点或边被多次访问的抽象约束，适用于路径或遍历中无重访限制的场景",
    "aliases": [
      "revisitable_vertices_and_edges",
      "repetition_allowed",
      "initial_position_free",
      "empty_initial_final_state",
      "edge_repetition_allowed",
      "node_removal",
      "no_relocation",
      "failure_detection",
      "u_turn_limit",
      "leaf_deletion",
      "end_access_only",
      "infection_persistence",
      "excitation_non_persistence",
      "word_reuse",
      "self_loop_allowed",
      "reachability_removal",
      "no_immediate_backtracking",
      "path_backtracking_allowed",
      "local_processing",
      "edge_vertex_intersection_allowed",
      "arbitrary_removal",
      "unvisited_children_only",
      "random_walk",
      "reinfection"
    ],
    "examples": []
  },
  "path_disjointness_constraint": {
    "name": "path_disjointness_constraint",
    "description": "路径不相交约束，要求多条路径之间无公共顶点或边",
    "aliases": [
      "disjoint_paths",
      "tunnel_uniqueness",
      "no_three_path_intersection",
      "unique_path",
      "disjoint_boomerangs",
      "path_uniqueness",
      "distinct_paths",
      "bridge_constraint",
      "distinct_path_sets",
      "exposed_path"
    ],
    "examples": []
  },
  "path_length_product_constraint": {
    "name": "path_length_product_constraint",
    "description": "路径长度乘积约束，要求一组路径的长度乘积满足特定条件",
    "aliases": [
      "path_length_product"
    ],
    "examples": []
  },
  "tiled_pattern_constraint": {
    "name": "tiled_pattern_constraint",
    "description": "对多米诺骨牌等矩形单元在网格上铺放的抽象约束，要求满足不重叠、无间隙且符合特定布局规则",
    "aliases": [
      "domino_placement",
      "infinite_tiling"
    ],
    "examples": []
  },
  "maximum_tiling_count": {
    "name": "maximum_tiling_count",
    "description": "在给定区域内使用最多数量的多米诺骨牌进行完全覆盖的优化目标约束",
    "aliases": [
      "max_dominoes",
      "max_element_position",
      "max_loyalty",
      "max_value_mapping",
      "max_real_clues"
    ],
    "examples": []
  },
  "inversion_count_constraint": {
    "name": "inversion_count_constraint",
    "description": "对序列中逆序对数量施加的约束，要求逆序对总数满足特定条件或限制",
    "aliases": [
      "inversion_count",
      "count_inversions"
    ],
    "examples": []
  },
  "password_adaptation_constraint": {
    "name": "password_adaptation_constraint",
    "description": "密码根据上下文或条件动态调整的抽象约束，适用于自适应安全机制中的密码规则变化",
    "aliases": [
      "adaptive_password",
      "adaptive_interactor"
    ],
    "examples": []
  },
  "attribute_constraint": {
    "name": "attribute_constraint",
    "description": "对对象属性或特征施加的抽象约束，如技能等级、能力值等在特定范围或关系下的限制",
    "aliases": [
      "skill_constraint",
      "initial_value_and_color",
      "weight_assignment",
      "assignment_constraint",
      "strong_character",
      "bonus_attribute",
      "weighting_rule",
      "strength_assignment",
      "conditional_bonus",
      "strength_definition",
      "skill_requirement"
    ],
    "examples": []
  },
  "undefined_value_constraint": {
    "name": "undefined_value_constraint",
    "description": "对未知或未定义值的抽象约束，适用于处理缺失数据、占位符或未指定状态的场景",
    "aliases": [
      "unknown_value",
      "unknown_subset",
      "single_unknown_value",
      "unknown_next_element"
    ],
    "examples": []
  },
  "reflection_constraint": {
    "name": "reflection_constraint",
    "description": "反射边界约束，表示对象在遇到边界时按特定规则反射，常用于物理模拟或路径行为建模",
    "aliases": [
      "boundary_reflection",
      "periodic_boundary",
      "reflection_law",
      "angle_of_reflection",
      "bounce_condition"
    ],
    "examples": []
  },
  "value_increment": {
    "name": "value_increment",
    "description": "数值增加的抽象约束，适用于表示状态量（如生命值、分数）在特定条件下递增的场景",
    "aliases": [
      "health_gain",
      "nonzero_weights",
      "melting_rate_change",
      "increment_operation",
      "score_update",
      "increment_step"
    ],
    "examples": []
  },
  "reconstruction_constraint": {
    "name": "reconstruction_constraint",
    "description": "对数据或结构进行重建时施加的约束，要求重建结果满足特定一致性或可恢复性条件",
    "aliases": [
      "key_recovery",
      "refund_constraint",
      "sequence_reconstruction",
      "partial_reconstruction"
    ],
    "examples": []
  },
  "existence_requirement": {
    "name": "existence_requirement",
    "description": "要求特定元素或状态必须存在，适用于表示对象、节点或值在结构中不可缺失的抽象约束",
    "aliases": [
      "existence_constraint",
      "single_fixed_element",
      "feasibility",
      "fixed_elements",
      "unique_target",
      "feasibility_check",
      "existence",
      "target_identification",
      "feasibility_constraint",
      "fixed_element",
      "unique_source_target",
      "initial_condition",
      "single_hidden_element",
      "edge_existence_condition",
      "first_time_achievement",
      "initial_conditions",
      "initial_element_inclusion",
      "interval_edge_existence",
      "completion_condition",
      "target_constraint",
      "edge_existence",
      "solution_existence",
      "edge_existence_in_cut",
      "edge_necessity_in_cut",
      "valid_solution",
      "known_node_constraint",
      "target_removal",
      "non_empty_source"
    ],
    "examples": []
  },
  "accumulated_sum_constraint": {
    "name": "accumulated_sum_constraint",
    "description": "对序列或结构中元素的累积和施加的抽象约束，要求累计值满足特定条件或限制",
    "aliases": [
      "cumulative_effect",
      "sum_invariant",
      "sum_across_time",
      "sum_of_mex_values",
      "sum_operation",
      "fixed_payment",
      "damage_accumulation",
      "consumption_constant",
      "sequential_addition",
      "transmissibility_sum",
      "fixed_payment_amount",
      "sum_of_max_depths",
      "periodic_income",
      "damage_calculation",
      "cascade_effect",
      "weighted_sum",
      "value_accumulation",
      "cumulative_energy_bound",
      "sum_of_all_cases",
      "incremental_combination",
      "cumulative_penalty",
      "sum_i_definition",
      "cost_accumulation",
      "total_distance_sum"
    ],
    "examples": []
  },
  "cute_number_constraint": {
    "name": "cute_number_constraint",
    "description": "对数值施加的特殊定义约束，要求其满足特定数学性质或趣味性条件（如数字组合、位数特征等），常用于构造性问题中的非标准数值规则",
    "aliases": [
      "cute_number_condition"
    ],
    "examples": []
  },
  "binary_matrix_constraint": {
    "name": "binary_matrix_constraint",
    "description": "对矩阵元素仅取二值（0或1）的抽象约束，要求所有元素属于二元集合，常用于表示布尔状态、二进制掩码或二值化图像",
    "aliases": [
      "binary_matrix",
      "binary_array",
      "binary_adjacency_matrix",
      "binary_values",
      "binary_response",
      "fixed_bits",
      "binary_decision",
      "edge_weight_binary",
      "boolean_constraint"
    ],
    "examples": []
  },
  "terminal_vertex": {
    "name": "terminal_vertex",
    "description": "图中出度为零的节点，表示路径或流的终点，常用于表示不可再扩展的状态或汇聚点",
    "aliases": [
      "sink_node",
      "leaf_definition",
      "goal_state",
      "draw_condition",
      "goal_constraint",
      "final_state_constraint",
      "final_state",
      "last_stone_win"
    ],
    "examples": []
  },
  "tournament_structure_constraint": {
    "name": "tournament_structure_constraint",
    "description": "表示单败淘汰赛结构的抽象约束，要求每轮比赛后失败者被淘汰，最终产生唯一胜者，常用于模拟竞技或决策过程中的淘汰机制",
    "aliases": [
      "single_elimination_tournament",
      "station_winner_rule",
      "single_elimination",
      "knockout_condition"
    ],
    "examples": []
  },
  "similarity_constraint": {
    "name": "similarity_constraint",
    "description": "对元素间相似性程度施加的抽象约束，要求两两元素之间的相似度满足特定条件或限制，常用于聚类、匹配或排序场景",
    "aliases": [
      "substring_similarity",
      "subarray_similarity",
      "similarity_metric",
      "permutation_similarity",
      "subsequence_similarity"
    ],
    "examples": []
  },
  "k_mex_constraint": {
    "name": "k_mex_constraint",
    "description": "对序列中第k小的未出现非负整数（mex）施加的约束，要求其满足特定条件或限制，常用于构造性问题中的mex值控制",
    "aliases": [
      "mex_equality",
      "mex_value",
      "mex_function",
      "kth_smallest_constraint",
      "smallest_integer_constraint",
      "even_k_constraint",
      "mex_operation",
      "kth_smallest_frequency"
    ],
    "examples": []
  },
  "cyclic_shift_constraint": {
    "name": "cyclic_shift_constraint",
    "description": "对序列或结构施加的循环移位一次的抽象约束，要求元素整体向左或向右移动一个位置后仍满足特定条件",
    "aliases": [
      "cyclic_shift_once",
      "cyclic_advance",
      "cyclic_regeneration",
      "cyclic_replacement",
      "circular_line_constraint",
      "circular_structure",
      "circular_shift",
      "gear_rotation_rule",
      "boomerang_structure",
      "cyclic_ordering",
      "circular_range_update",
      "time_sequence",
      "toggle_effect",
      "return_to_start",
      "consecutive_rotation",
      "toroidal_wrap",
      "circular_partition",
      "cyclic_shift_operation",
      "toroidal_grid",
      "circular_path",
      "circular_ordering",
      "circular_arrangement",
      "cyclic_order",
      "reappearing_grass",
      "circular_player_turns",
      "circular_sequence_access",
      "circular_monotonicity",
      "cyclic_assignment",
      "circular_movement",
      "return_to_origin",
      "circular_sequence",
      "circular_permutation"
    ],
    "examples": []
  },
  "sequence_pattern_constraint": {
    "name": "sequence_pattern_constraint",
    "description": "对序列中元素排列模式或结构特征施加的抽象约束，要求满足特定规律性、周期性或可预测性条件",
    "aliases": [
      "sequence_property",
      "sequence_validity",
      "hyphen_placement",
      "growth_pattern",
      "string_structure",
      "event_sequence"
    ],
    "examples": []
  },
  "non_negative_pairwise_product": {
    "name": "non_negative_pairwise_product",
    "description": "要求序列或集合中任意两个元素的乘积非负，常用于约束数值关系的符号一致性",
    "aliases": [
      "pairwise_product_non_negative",
      "xor_sum_uniqueness",
      "non_zero_energy",
      "non_negative_step",
      "energy_calculation",
      "non_negative_balance",
      "non_negative_income",
      "positive_addition"
    ],
    "examples": []
  },
  "indegree_constraint": {
    "name": "indegree_constraint",
    "description": "对图中节点的入度数量施加的约束，要求每个节点的入边数量满足特定条件或限制",
    "aliases": [
      "incoming_edges_count",
      "external_entry"
    ],
    "examples": []
  },
  "permutation_sum_constraint": {
    "name": "permutation_sum_constraint",
    "description": "对排列中所有元素值的总和施加的抽象约束，要求其满足特定数值条件或限制",
    "aliases": [
      "sum_of_permutation_values"
    ],
    "examples": []
  },
  "level_uniformity_constraint": {
    "name": "level_uniformity_constraint",
    "description": "要求树中所有节点在同一深度层级上，或同一层的节点具有相同深度的抽象约束",
    "aliases": [
      "same_depth_constraint",
      "uniform_tree_depth",
      "exact_level",
      "subsegment_level",
      "min_segment_leveling",
      "layer_positioning",
      "depth_bound",
      "tree_height_bound",
      "child_height_constraint",
      "subtree_ordering",
      "depth_constraint",
      "k_depth_nodes"
    ],
    "examples": []
  },
  "path_xor_constraint": {
    "name": "path_xor_constraint",
    "description": "要求路径上所有元素的异或值为零的抽象约束，常用于路径性质判断或构造性问题中的异或平衡条件",
    "aliases": [
      "path_xor_zero",
      "output_xor",
      "xor_sum_zero",
      "xor_shortest_path",
      "xor_value",
      "xor_zero_constraint"
    ],
    "examples": []
  },
  "geometric_center_constraint": {
    "name": "geometric_center_constraint",
    "description": "对几何图形的质心或形心位置施加的抽象约束，要求其满足特定空间分布或计算条件",
    "aliases": [
      "centroid_constraint",
      "midpoint_constraint",
      "center_integer_coordinates",
      "centroid_definition",
      "vertex_position"
    ],
    "examples": []
  },
  "jump_operation_constraint": {
    "name": "jump_operation_constraint",
    "description": "对跳跃或瞬移操作施加的抽象约束，要求其满足特定规则或位置转移条件，常用于路径规划或状态转移中的非连续移动场景",
    "aliases": [
      "teleportation_constraint",
      "jump_response"
    ],
    "examples": []
  },
  "xor_subarray_sum_constraint": {
    "name": "xor_subarray_sum_constraint",
    "description": "对子数组中所有元素的异或值施加的约束，要求其满足特定条件或限制，常用于路径性质判断或构造性问题中的异或平衡条件",
    "aliases": [
      "xor_subarray_sum",
      "bit_change_count",
      "xor_sum",
      "xor_rectangle",
      "xor_target",
      "xor_sum_output"
    ],
    "examples": []
  },
  "star_graph_structure": {
    "name": "star_graph_structure",
    "description": "表示图中所有边均从一个中心顶点出发的抽象结构约束，适用于描述具有辐射状连接特征的网络或布局",
    "aliases": [
      "radial_line_constraint"
    ],
    "examples": []
  },
  "distance_uniformity_constraint": {
    "name": "distance_uniformity_constraint",
    "description": "要求树中所有叶子节点到根节点的距离保持一致的抽象约束，常用于平衡树或等深结构的构造与验证",
    "aliases": [
      "leaf_distance_uniformity",
      "closeness_score"
    ],
    "examples": []
  },
  "submatrix_transformation": {
    "name": "submatrix_transformation",
    "description": "对子矩阵施加的变换或操作规则约束，要求其满足特定的修改、更新或映射条件，常用于矩阵处理中的局部结构变化",
    "aliases": [
      "submatrix_operation",
      "range_repaint",
      "range_replacement",
      "grid_operation",
      "submatrix_addition",
      "range_update",
      "single_column_update",
      "dynamic_interval_modification",
      "rectangular_update",
      "submatrix_query",
      "range_update_addition",
      "range_update_assignment",
      "range_addition",
      "range_assignment",
      "range_copy",
      "range_reversal",
      "range_swap",
      "weight_update",
      "interval_update"
    ],
    "examples": []
  },
  "subset_size_minimum_constraint": {
    "name": "subset_size_minimum_constraint",
    "description": "要求子集大小不低于指定最小值的抽象约束，常用于组合优化或集合选择问题中对子集规模的下界限制",
    "aliases": [
      "minimal_subset_cardinality",
      "clause_literal_count",
      "partition_length_multiple",
      "two_piles_limit",
      "partition_size_lower_bound",
      "interval_selection_limit",
      "good_subset_condition",
      "min_group_size",
      "partition_size_constraint",
      "subset_even_size",
      "group_size_fixed",
      "cardinality_constraint",
      "min_group_count",
      "dictionary_size"
    ],
    "examples": []
  },
  "geometric_shape_constraint": {
    "name": "geometric_shape_constraint",
    "description": "对几何形状的匹配或适配性施加的抽象约束，要求对象在空间布局中满足特定形状契合条件，常用于描述物体排列、嵌套或填充时的几何兼容性",
    "aliases": [
      "geometric_fit",
      "geometric_relation",
      "boundary_matching",
      "arch_ground_constraint",
      "non_degenerate_triangle",
      "dimension_fit",
      "integer_sides",
      "triangle_vertex_constraint",
      "triangle_formation",
      "even_side_length",
      "bounding_box",
      "piece_shape"
    ],
    "examples": []
  },
  "truth_value_constraint": {
    "name": "truth_value_constraint",
    "description": "对逻辑值或陈述的真实性施加的抽象约束，要求其满足特定真值条件或一致性规则，常用于逻辑推理、验证或自洽性判断场景",
    "aliases": [
      "truthfulness"
    ],
    "examples": []
  },
  "information_security_constraint": {
    "name": "information_security_constraint",
    "description": "对信息保密性施加的抽象约束，要求数据或通信在传输或存储过程中保持机密，防止未授权访问",
    "aliases": [
      "confidentiality_condition",
      "query_decryption"
    ],
    "examples": []
  },
  "maximize_singleton_partition_size": {
    "name": "maximize_singleton_partition_size",
    "description": "要求将集合划分为尽可能多的单元素子集的优化目标约束，常用于最大化独立个体数量的组合问题",
    "aliases": [
      "maximize_single_element_classes",
      "substring_occurrence_maximization",
      "maximize_white_nodes"
    ],
    "examples": []
  },
  "non_zero_vector_constraint": {
    "name": "non_zero_vector_constraint",
    "description": "对向量施加非零的抽象约束，要求所有向量元素不全为零，常用于表示有效状态、非平凡解或排除零向量的场景",
    "aliases": [
      "non_zero_vectors",
      "non_zero_elements",
      "non_zero_velocity",
      "ray_target_non_zero"
    ],
    "examples": []
  },
  "injective_mapping": {
    "name": "injective_mapping",
    "description": "要求映射关系中每个输入唯一对应一个输出，且无重复输出的抽象约束，常用于表示单射函数或唯一匹配场景",
    "aliases": [
      "one_to_one_mapping",
      "function_mapping",
      "mapping_constraint",
      "unique_decoding",
      "index_mapping",
      "unique_pairing"
    ],
    "examples": []
  },
  "geometric_ratio_constraint": {
    "name": "geometric_ratio_constraint",
    "description": "对几何体的表面积与边长之间比例关系施加的抽象约束，要求其满足特定数学比例或函数关系，常用于立体几何中的尺寸匹配或优化问题",
    "aliases": [
      "surface_area_to_edge_length",
      "circle_diameter_constraint",
      "ratio_constraint"
    ],
    "examples": []
  },
  "suffix_length_constraint": {
    "name": "suffix_length_constraint",
    "description": "对序列或字符串中公共后缀长度施加的抽象约束，要求其满足特定长度条件或限制",
    "aliases": [
      "common_suffix_length",
      "prefix_suffix_length",
      "suffix_matching",
      "suffix_max",
      "suffix_dependency"
    ],
    "examples": []
  },
  "longest_increasing_subsequence_constraint": {
    "name": "longest_increasing_subsequence_constraint",
    "description": "对序列中最长严格递增子序列的长度或存在性施加的抽象约束，常用于动态规划或排序相关问题中的最优子结构分析",
    "aliases": [
      "longest_increasing_subsequence",
      "max_increasing_subarray_length",
      "max_subsequence_length",
      "longest_subsequence_query"
    ],
    "examples": []
  },
  "unrestricted_position": {
    "name": "unrestricted_position",
    "description": "表示位置选择不受特定限制的抽象约束，适用于允许任意位置放置元素的场景",
    "aliases": [
      "free_position_constraint",
      "pillar_position_constraint",
      "new_interval_placement",
      "city_selection",
      "free_meal_on_train",
      "valid_position",
      "point_location",
      "facility_location",
      "valid_placement",
      "flower_placement_condition",
      "venue_preference"
    ],
    "examples": []
  },
  "square_submatrix_constraint": {
    "name": "square_submatrix_constraint",
    "description": "对子矩阵的形状施加约束，要求其为正方形结构，即行数与列数相等，常用于矩阵处理或图像分析中的局部区域限制",
    "aliases": [
      "square_submatrix"
    ],
    "examples": []
  },
  "self_describing_property": {
    "name": "self_describing_property",
    "description": "序列中第i个元素的值等于序列中i出现的次数，常用于构造性问题中的自描述数列或递推关系",
    "aliases": [
      "self_describing_sequence"
    ],
    "examples": []
  },
  "non_empty_query": {
    "name": "non_empty_query",
    "description": "要求查询操作必须针对非空数据集或非空区间，防止无效查询或空结果的抽象约束",
    "aliases": [
      "query_nonempty",
      "non_empty_constraint",
      "output_message_on_empty_group",
      "input_availability",
      "min_value_availability",
      "non_empty_subset",
      "non_empty_solution",
      "non_empty_subsequence",
      "non_empty_selection",
      "non_empty_inputs"
    ],
    "examples": []
  },
  "reverse_ordering_constraint": {
    "name": "reverse_ordering_constraint",
    "description": "对序列或结构中元素的排列顺序施加逆序约束，要求其满足从后往前的特定排列规则或反转条件",
    "aliases": [
      "reversed_order",
      "no_u_turn",
      "trump_last",
      "reverse_circular_monotonicity"
    ],
    "examples": []
  },
  "logarithmic_sum_constraint": {
    "name": "logarithmic_sum_constraint",
    "description": "对序列或结构中元素的对数和施加的抽象约束，要求各元素取对数后求和满足特定条件或限制，常用于信息论、概率建模或优化问题中的对数尺度计算",
    "aliases": [
      "logarithmic_sum",
      "logarithmic_output"
    ],
    "examples": []
  },
  "pairwise_product_difference_constraint": {
    "name": "pairwise_product_difference_constraint",
    "description": "对序列或集合中任意两个元素的乘积之差施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的数值关系控制",
    "aliases": [
      "pairwise_product_difference"
    ],
    "examples": []
  },
  "consistency_constraint": {
    "name": "consistency_constraint",
    "description": "对数据或操作过程中状态的一致性施加的抽象约束，要求在多个步骤或实体间保持逻辑一致，防止矛盾或不一致的状态出现",
    "aliases": [
      "transaction_integrity",
      "velocity_invariance",
      "consistent_guesses",
      "recommendation_consistency",
      "consistent_answers",
      "duck_statement_consistency",
      "consistency_check",
      "solution_accuracy",
      "consistent_solution",
      "consistent_results",
      "balance_constraint",
      "unification_constraint"
    ],
    "examples": []
  },
  "color_count_constraint": {
    "name": "color_count_constraint",
    "description": "对图中使用的颜色数量施加精确限制的抽象约束，要求染色方案中恰好使用指定数量的颜色",
    "aliases": [
      "exact_coloring_count",
      "majority_color",
      "color_range",
      "subtree_color_count",
      "fixed_yellow_count",
      "color_tie_breaking",
      "valid_coloring_count"
    ],
    "examples": []
  },
  "initial_graph_size_constraint": {
    "name": "initial_graph_size_constraint",
    "description": "对初始图的规模（如节点数、边数）施加具体数值限制的抽象约束，常用于初始化阶段的结构定义",
    "aliases": [
      "initial_graph_size"
    ],
    "examples": []
  },
  "maximum_value_constraint": {
    "name": "maximum_value_constraint",
    "description": "对序列或结构中最大值的取值施加的抽象约束，要求其满足特定条件或限制，常用于构造性问题中的最大值控制",
    "aliases": [
      "max_value_equality",
      "max_pot_value",
      "max_score_limit",
      "max_element_retention",
      "max_value_winner",
      "target_amount",
      "final_score",
      "max_flow_target",
      "max_selection",
      "max_value_in_set",
      "max_function_value",
      "max_score_and_x",
      "unique_heaviest_element",
      "max_value_selection",
      "max_element_condition"
    ],
    "examples": []
  },
  "product_constraint": {
    "name": "product_constraint",
    "description": "对序列或集合中元素乘积施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的乘积关系控制",
    "aliases": [
      "multiplication_constraint",
      "product_subtree",
      "digit_product",
      "satisfaction_product"
    ],
    "examples": []
  },
  "maximize_perimeter": {
    "name": "maximize_perimeter",
    "description": "要求几何图形的周长达到最大值的优化目标约束，常用于计算几何或形状设计中的面积-周长权衡问题",
    "aliases": [
      "perimeter_maximization"
    ],
    "examples": []
  },
  "distance_cost_constraint": {
    "name": "distance_cost_constraint",
    "description": "对单位距离的代价施加约束，要求每公里成本保持一致或满足特定计算规则",
    "aliases": [
      "cost_per_km",
      "time_calculation",
      "directional_travel_time",
      "movement_cost",
      "edge_weight_formula",
      "crossing_cost",
      "translation_cost",
      "segment_cost_definition"
    ],
    "examples": []
  },
  "budget_uniformity_constraint": {
    "name": "budget_uniformity_constraint",
    "description": "要求预算在各部分或各阶段中保持均匀分配，防止不均衡使用",
    "aliases": [
      "uniform_budget",
      "resource_bound",
      "daily_spending_rule",
      "bet_amount_availability",
      "replenishment_constraint",
      "total_bonus_limit"
    ],
    "examples": []
  },
  "fixed_position_constraint": {
    "name": "fixed_position_constraint",
    "description": "对网格或结构中特定位置的元素值或状态施加固定不变的抽象约束，要求这些位置的值在问题求解过程中保持不变",
    "aliases": [
      "fixed_cells",
      "fixed_initial_placement",
      "fixed_shipment_size",
      "single_value_rule",
      "initial_configuration",
      "income_override",
      "initial_amount",
      "sequential_id_assignment",
      "fixed_output",
      "team_size_fixed",
      "initial_matrix_value",
      "initial_value_constraint",
      "initial_distribution",
      "fixed_entry",
      "initial_final_height",
      "start_end_at_zero",
      "initialization_constraint",
      "leaf_grounding",
      "power_supply_placement",
      "ray_origin_fixed",
      "cell_source_constraint",
      "fixed_output_nodes"
    ],
    "examples": []
  },
  "minimum_edge_count": {
    "name": "minimum_edge_count",
    "description": "要求图中边的数量不低于指定最小值的抽象约束，常用于组合优化或网络设计中的边数下界限制",
    "aliases": [
      "min_arrows",
      "min_additional_shipments",
      "edge_limit",
      "min_flights",
      "min_cut_capacity",
      "min_weight_movement"
    ],
    "examples": []
  },
  "minimize_max_min_difference": {
    "name": "minimize_max_min_difference",
    "description": "要求序列中最大值与最小值的差值尽可能小的优化目标约束，常用于最小化波动或范围的组合优化问题",
    "aliases": [
      "max_min_diff_minimized",
      "minimize_path_length",
      "distance_minimization",
      "stress_minimization",
      "min_max_path_cost",
      "minimax_distance",
      "min_max_optimization",
      "minimize_xor_sum",
      "score_difference_optimization",
      "min_variance",
      "sum_minimization",
      "access_cost_minimization"
    ],
    "examples": []
  },
  "prefix_coverage": {
    "name": "prefix_coverage",
    "description": "要求序列或结构中前缀部分覆盖特定范围或满足特定条件的抽象约束，常用于表示从起始位置开始的连续元素需满足完整性或可达性要求",
    "aliases": [
      "leftmost_segment",
      "prefix_constraint"
    ],
    "examples": []
  },
  "terminal_vertex_count_constraint": {
    "name": "terminal_vertex_count_constraint",
    "description": "对图中出度为零的节点（即汇点）数量施加的抽象约束，要求其满足特定计数条件或限制",
    "aliases": [
      "sink_node_count",
      "destination_constraint",
      "endpoint_constraint",
      "final_value_count",
      "final_value_constraint",
      "final_configuration",
      "final_position_constraint",
      "final_state_constraint",
      "success_condition",
      "output_state_determination",
      "end_node_constraint",
      "termination_condition"
    ],
    "examples": []
  },
  "counter_clockwise_orientation": {
    "name": "counter_clockwise_orientation",
    "description": "要求路径、多边形或方向序列按逆时针方向排列的抽象约束，常用于几何形状定向或遍历顺序控制",
    "aliases": [
      "counterclockwise_order"
    ],
    "examples": []
  },
  "logical_inference_constraint": {
    "name": "logical_inference_constraint",
    "description": "对推理过程或逻辑推导施加的抽象约束，要求在给定前提下结论必须一致且可推导，常用于逻辑题、形式系统或验证场景中的有效性判断",
    "aliases": [
      "inference_constraint",
      "condition_satisfaction",
      "logical_implication",
      "conditional_execution",
      "decision_rule"
    ],
    "examples": []
  },
  "pairwise_sum_constraint": {
    "name": "pairwise_sum_constraint",
    "description": "对序列或集合中任意两个元素的和施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的配对关系控制",
    "aliases": [
      "sum_of_pairs",
      "pairwise_combination",
      "adjacent_sum_prime",
      "non_adjacent_sum",
      "adjacent_sum_square"
    ],
    "examples": []
  },
  "prefix_zero_removal": {
    "name": "prefix_zero_removal",
    "description": "对序列或数值前导零的移除操作施加的抽象约束，要求在处理过程中忽略或消除开头的零值，常用于二进制表示、字符串规范化或数值标准化场景",
    "aliases": [
      "leading_zeros_removal",
      "no_leading_zeros",
      "leading_zero_allowance",
      "leading_zeros_allowed"
    ],
    "examples": []
  },
  "mean_median_constraint": {
    "name": "mean_median_constraint",
    "description": "对序列或数据集中均值与中位数相等的抽象约束，要求其满足特定数值关系或分布特性",
    "aliases": [
      "mean_median_equality",
      "median_target",
      "median_calculation"
    ],
    "examples": []
  },
  "axis_aligned_lines": {
    "name": "axis_aligned_lines",
    "description": "表示仅沿水平或垂直方向延伸的直线段，常用于网格布局或几何约束中的方向性限制",
    "aliases": [
      "horizontal_or_vertical_lines",
      "line_type_constraint",
      "axis_aligned_rectangle",
      "straight_line_path",
      "line_constraint",
      "line_representation",
      "straight_line",
      "grid_alignment",
      "non_straight_cut",
      "axis_parallel_lines",
      "rectangle_edge_constraint"
    ],
    "examples": []
  },
  "non_intersecting_segments": {
    "name": "non_intersecting_segments",
    "description": "要求一组线段之间无交点，适用于路径、边或几何对象的非重叠布局约束",
    "aliases": [
      "non_intersecting_lines",
      "interval_non_overlap",
      "disjoint_subsequences",
      "mutually_exclusive_intervals",
      "no_overlap_start_end",
      "non_overlapping_intervals",
      "rearrangement_non_overlap",
      "non_overlap",
      "disjoint_intervals",
      "disjoint_segments",
      "no_cross_edges",
      "non_overlapping_buildings",
      "no_overlap",
      "non_overlapping_subsequences",
      "disjoint_disks",
      "non_overlapping_circular_walls",
      "non_overlapping_straight_walls",
      "non_crossing_paths",
      "non_overlapping_initially",
      "non_overlapping_sequence",
      "non_overlapping",
      "crossing_minimization",
      "disjoint_components"
    ],
    "examples": []
  },
  "pairwise_acceleration_difference": {
    "name": "pairwise_acceleration_difference",
    "description": "对序列或结构中任意两个元素的加速度差值施加的抽象约束，要求其满足特定数值条件或限制，常用于物理模拟或运动控制中的加速度关系建模",
    "aliases": [
      "acceleration_difference"
    ],
    "examples": []
  },
  "geometric_volume_constraint": {
    "name": "geometric_volume_constraint",
    "description": "对几何体体积大小施加的抽象约束，要求其满足特定数值条件或限制，常用于立体几何中的尺寸匹配或优化问题",
    "aliases": [
      "volume_bound",
      "hypercube_addition"
    ],
    "examples": []
  },
  "step_size_modulo_constraint": {
    "name": "step_size_modulo_constraint",
    "description": "对移动或操作步长施加的模运算约束，要求步长满足特定整除条件，常用于路径规划或序列生成中的步进规则控制",
    "aliases": [
      "step_size_divisibility",
      "fixed_step_journey",
      "step_length_bound",
      "consecutive_jump_limit",
      "prime_step"
    ],
    "examples": []
  },
  "geometric_area_constraint": {
    "name": "geometric_area_constraint",
    "description": "对几何图形面积大小施加的抽象约束，要求其满足特定数值条件或限制，常用于平面几何中的面积匹配或优化问题",
    "aliases": [
      "area_calculation",
      "min_area",
      "positive_area",
      "region_size",
      "area_difference",
      "count_lattice_points",
      "region_weight",
      "area_positive"
    ],
    "examples": []
  },
  "minimum_index_constraint": {
    "name": "minimum_index_constraint",
    "description": "对序列或结构中最小索引位置的选取施加的抽象约束，要求选择满足特定条件的最小有效索引，常用于贪心策略或优先级选择场景",
    "aliases": [
      "min_index_selection",
      "min_pass_level",
      "initial_selection"
    ],
    "examples": []
  },
  "discrete_weight_constraint": {
    "name": "discrete_weight_constraint",
    "description": "对权重值施加离散化约束，要求其取值为特定离散集合中的元素，常用于表示量化后的权重或分段赋值",
    "aliases": [
      "weight_discretization"
    ],
    "examples": []
  },
  "substring_prime_constraint": {
    "name": "substring_prime_constraint",
    "description": "对子串中元素的数值或组合满足素数性质的抽象约束，要求子串对应的数值或其变换结果为素数，常用于构造性问题中的素数判定与筛选",
    "aliases": [],
    "examples": []
  },
  "majority_element_constraint": {
    "name": "majority_element_constraint",
    "description": "要求序列中存在一个元素出现次数超过一半的抽象约束，常用于构造性问题中的多数元素判定与性质分析",
    "aliases": [
      "majority_element",
      "majority_vote",
      "midpoint_majority",
      "mode_constraint",
      "majority_working"
    ],
    "examples": []
  },
  "string_length_constraint": {
    "name": "string_length_constraint",
    "description": "对字符串长度施加的抽象约束，要求其满足特定数值条件或限制，常用于字符串处理或匹配问题中的长度控制",
    "aliases": [
      "string_length_bound",
      "sequence_length",
      "binary_representation_length",
      "max_length",
      "substring_bounds",
      "binary_string_length"
    ],
    "examples": []
  },
  "piecewise_linear_constraint": {
    "name": "piecewise_linear_constraint",
    "description": "对分段线性函数施加的抽象约束，要求函数在不同区间内为线性关系，且整体满足连续性或斜率变化规则",
    "aliases": [
      "piecewise_linear_function"
    ],
    "examples": []
  },
  "pairwise_difference_constraint": {
    "name": "pairwise_difference_constraint",
    "description": "对序列或集合中任意两个元素的差值施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的数值关系控制",
    "aliases": [
      "subset_difference",
      "rating_difference_constraint",
      "length_difference",
      "difference_constraint",
      "even_difference_constraint",
      "comparison_constraint"
    ],
    "examples": []
  },
  "constant_value_constraint": {
    "name": "constant_value_constraint",
    "description": "要求序列或结构中所有元素取值相同，常用于表示恒定状态、统一赋值或均一化处理的抽象约束",
    "aliases": [
      "uniform_value",
      "fixed_function",
      "equality_constraint",
      "uniform_b_sequence",
      "value_equality",
      "same_height_constraint",
      "default_color_value",
      "fixed_values"
    ],
    "examples": []
  },
  "wave_propagation_constraint": {
    "name": "wave_propagation_constraint",
    "description": "表示某种波或扩散效应在空间中从源点向外传播的抽象约束，常用于模拟信号、能量或影响范围的扩展过程",
    "aliases": [
      "expansion_wave_effect",
      "infection_spread"
    ],
    "examples": []
  },
  "negative_value_constraint": {
    "name": "negative_value_constraint",
    "description": "对数值施加非正数（即小于或等于零）的抽象约束，常用于表示损失、衰减、负收益或状态下降的场景",
    "aliases": [
      "loss_condition",
      "loss_amount",
      "negative_weight"
    ],
    "examples": []
  },
  "stack_sortable_constraint": {
    "name": "stack_sortable_constraint",
    "description": "要求序列可以通过一个栈的压入和弹出操作实现排序的抽象约束，常用于判断序列是否为可栈排序序列",
    "aliases": [
      "stack_sortable",
      "stack_composition",
      "stack_operations",
      "stack_validity",
      "stack_operation"
    ],
    "examples": []
  },
  "bitwise_swap_operation": {
    "name": "bitwise_swap_operation",
    "description": "对二进制位进行交换操作的抽象约束，要求在特定位置上交换比特值，常用于位运算或数据重排场景",
    "aliases": [
      "bit_swap_operation",
      "color_reversal",
      "coordinate_swap"
    ],
    "examples": []
  },
  "substring_presence_constraint": {
    "name": "substring_presence_constraint",
    "description": "要求子串在序列或字符串中必须存在，常用于构造性问题中的子串存在性判定与路径或结构完整性验证",
    "aliases": [
      "substring_existence",
      "valid_substring_indices",
      "substring_occurrence",
      "substring_search"
    ],
    "examples": []
  },
  "floor_value_constraint": {
    "name": "floor_value_constraint",
    "description": "对数值施加向下取整操作的抽象约束，要求其满足特定取整规则或结果限制，常用于离散化处理、边界控制或整数规划中的取整条件",
    "aliases": [
      "floor_function"
    ],
    "examples": []
  },
  "maximum_destruction_count": {
    "name": "maximum_destruction_count",
    "description": "对可被破坏的单元格数量施加上限约束，要求在结构中最多破坏指定数量的格子，常用于网格类问题中的破坏范围控制",
    "aliases": [
      "max_destroyable_cells",
      "max_crossing_loss",
      "consecutive_loss_limit",
      "max_cells_constraint",
      "consecutive_destroy",
      "collision_limit"
    ],
    "examples": []
  },
  "unmarked_cell_presence": {
    "name": "unmarked_cell_presence",
    "description": "要求在网格或结构中至少存在一个未标记的单元格，适用于表示未处理、未访问或待操作状态的抽象存在性约束",
    "aliases": [
      "unmarked_cell_existence",
      "disappearance_constraint"
    ],
    "examples": []
  },
  "uncertainty_threshold_constraint": {
    "name": "uncertainty_threshold_constraint",
    "description": "对不确定性或怀疑因子施加的上限约束，要求其不超过指定阈值，常用于表示对结果可信度或置信度的限制",
    "aliases": [
      "skepticism_factor_bound"
    ],
    "examples": []
  },
  "non_negative_prefix_sum": {
    "name": "non_negative_prefix_sum",
    "description": "要求序列的前缀和始终非负，常用于路径或状态转移中防止负值累积的抽象约束",
    "aliases": [
      "prefix_sum_non_negative",
      "non_negative_sequence",
      "survival_constraint",
      "non_negative_balance",
      "score_non_negativity",
      "energy_depletion_constraint"
    ],
    "examples": []
  },
  "bitwise_closure": {
    "name": "bitwise_closure",
    "description": "对位运算操作施加闭包约束，要求在特定位操作下集合或值域保持封闭，即任意两个元素进行指定位运算后结果仍属于该集合",
    "aliases": [
      "bitwise_and_constraint",
      "xor_shift_invariant",
      "bitwise_subset_constraint"
    ],
    "examples": []
  },
  "maximum_win_count_constraint": {
    "name": "maximum_win_count_constraint",
    "description": "对参赛者在比赛中获胜次数施加的上限约束，要求每个参赛者的胜利次数不超过指定最大值，常用于竞技类问题中的胜负平衡控制",
    "aliases": [
      "max_wins_per_contestant"
    ],
    "examples": []
  },
  "invariance_under_translation": {
    "name": "invariance_under_translation",
    "description": "对结构或序列在平移变换下保持不变的抽象约束，要求其性质或值不随整体位置移动而改变",
    "aliases": [
      "translation_invariance",
      "value_preservation",
      "translation_equivalence",
      "consistent_encoding",
      "rotation_invariance"
    ],
    "examples": []
  },
  "quantile_distribution_constraint": {
    "name": "quantile_distribution_constraint",
    "description": "对数据分布中分位数位置施加的抽象约束，要求特定分位点满足数值或比例条件，常用于统计分析、数据划分或公平性控制场景",
    "aliases": [
      "quantile_constraint"
    ],
    "examples": []
  },
  "circular_boundary_constraint": {
    "name": "circular_boundary_constraint",
    "description": "要求对象或结构被一个闭合圆形边界包围的抽象约束，常用于几何布局、区域覆盖或环形路径中的空间限制",
    "aliases": [
      "encirclement_constraint",
      "circular_avenue",
      "enclosure_constraint"
    ],
    "examples": []
  },
  "cost_constraint": {
    "name": "cost_constraint",
    "description": "对操作或状态变化施加的代价或惩罚因子的抽象约束，要求其满足特定数值条件或限制，常用于优化问题中的成本控制与权衡",
    "aliases": [
      "penalty_factor",
      "cost_bound",
      "cost_function",
      "bet_payout_ratio",
      "resource_consumption",
      "edge_modification_cost",
      "effort_calculation",
      "minimum_required_cost",
      "loss_function",
      "cost_definition",
      "cost_calculation"
    ],
    "examples": []
  },
  "error_resilience_constraint": {
    "name": "error_resilience_constraint",
    "description": "对系统或结构在存在部分错误或损坏情况下仍能保持正确功能的抽象约束，要求其具备容忍一定程度故障或数据污染的能力",
    "aliases": [
      "corruption_tolerance",
      "single_error_tolerance",
      "error_bound",
      "redundancy_tolerance",
      "single_faulty_measurement",
      "malfunctioning_behavior"
    ],
    "examples": []
  },
  "subset_sum_modulo_constraint": {
    "name": "subset_sum_modulo_constraint",
    "description": "对子集元素和在模运算下的结果施加的抽象约束，要求其满足特定余数条件或限制，常用于数论或组合优化中的同余关系控制",
    "aliases": [
      "subset_sum_modulo",
      "subset_convolution",
      "sum_modulo"
    ],
    "examples": []
  },
  "subtree_count_constraint": {
    "name": "subtree_count_constraint",
    "description": "对树结构中子树出现次数施加的抽象约束，要求特定子树在整体结构中满足指定频次条件或限制",
    "aliases": [
      "subtree_frequency"
    ],
    "examples": []
  },
  "maximum_rainbow_count": {
    "name": "maximum_rainbow_count",
    "description": "对彩虹颜色种类或连续彩虹段数量施加的上限约束，要求其不超过指定最大值，常用于构造性问题中对多色序列或路径中色彩丰富度的控制",
    "aliases": [
      "max_k_rainbow"
    ],
    "examples": []
  },
  "ceil_value_constraint": {
    "name": "ceil_value_constraint",
    "description": "对数值施加向上取整操作的抽象约束，要求其满足特定取整规则或结果限制，常用于离散化处理、边界控制或整数规划中的取整条件",
    "aliases": [
      "ceiling_function",
      "rounding_up"
    ],
    "examples": []
  },
  "conjugate_diagram_constraint": {
    "name": "conjugate_diagram_constraint",
    "description": "对图或结构中子图的共轭关系施加的抽象约束，要求其满足特定对称性或变换规则，常用于组合数学或图论中的对偶结构分析",
    "aliases": [
      "subdiagram_conjugation"
    ],
    "examples": []
  },
  "uniform_velocity_constraint": {
    "name": "uniform_velocity_constraint",
    "description": "要求运动对象的速度在整个过程中保持恒定，常用于物理模拟或路径规划中的匀速运动建模",
    "aliases": [
      "constant_speed",
      "lane_speed_fixed"
    ],
    "examples": []
  },
  "velocity_range_constraint": {
    "name": "velocity_range_constraint",
    "description": "对运动对象的速度值施加上下界限制的抽象约束，要求其在指定范围内变化，常用于控制移动速率的合理区间",
    "aliases": [
      "walker_speed_range",
      "speed_limit",
      "speed_bound"
    ],
    "examples": []
  },
  "max_similarity_pairs_count": {
    "name": "max_similarity_pairs_count",
    "description": "对序列或集合中相似元素对的最大数量施加的约束，要求其满足特定数值条件或限制，常用于聚类、匹配或排序场景中的最大相似性配对控制",
    "aliases": [
      "count_max_similarity_pairs"
    ],
    "examples": []
  },
  "optional_interval": {
    "name": "optional_interval",
    "description": "允许区间为空或可选的抽象约束，适用于表示可忽略或非必需区间的场景",
    "aliases": [
      "empty_interval_option"
    ],
    "examples": []
  },
  "multiplicative_property_constraint": {
    "name": "multiplicative_property_constraint",
    "description": "对函数在乘法运算下保持封闭的抽象约束，要求其满足 f(mn) = f(m)f(n) 的性质，常用于数论或组合数学中的函数构造与分析",
    "aliases": [
      "multiplicative_function",
      "multiplicative_dependency"
    ],
    "examples": []
  },
  "ternary_operation": {
    "name": "ternary_operation",
    "description": "对三个操作数施加的抽象运算约束，要求其满足特定的三元函数关系或组合规则，常用于表达式求值、逻辑判断或数据处理中的三元操作场景",
    "aliases": [
      "triple_operation"
    ],
    "examples": []
  },
  "pairwise_operation_constraint": {
    "name": "pairwise_operation_constraint",
    "description": "对序列或结构中任意两个元素之间的操作施加的抽象约束，要求其满足特定规则或条件，常用于构造性问题中的成对关系控制",
    "aliases": [
      "pairwise_operation"
    ],
    "examples": []
  },
  "isomorphism_constraint": {
    "name": "isomorphism_constraint",
    "description": "对图结构之间同构关系施加的抽象约束，要求两个图在顶点和边的连接模式上完全一致，仅允许顶点标签或命名不同",
    "aliases": [
      "graph_isomorphism",
      "tree_isomorphism",
      "automorphism"
    ],
    "examples": []
  },
  "second_largest_value_constraint": {
    "name": "second_largest_value_constraint",
    "description": "对序列中第二大的元素值施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的次大值控制",
    "aliases": [
      "second_largest_element"
    ],
    "examples": []
  },
  "special_property_a_constraint": {
    "name": "special_property_a_constraint",
    "description": "对特定对象或结构施加的特殊属性A的抽象约束，适用于表示非标准、自定义性质的逻辑或数学规则",
    "aliases": [
      "special_property_A",
      "special_case_handling"
    ],
    "examples": []
  },
  "special_property_b_constraint": {
    "name": "special_property_b_constraint",
    "description": "对特定对象或结构施加的特殊属性B的抽象约束，适用于表示非标准、自定义性质的逻辑或数学规则",
    "aliases": [
      "special_property_B"
    ],
    "examples": []
  },
  "special_property_c_constraint": {
    "name": "special_property_c_constraint",
    "description": "对特定对象或结构施加的特殊属性C的抽象约束，适用于表示非标准、自定义性质的逻辑或数学规则",
    "aliases": [
      "special_property_C"
    ],
    "examples": []
  },
  "multiple_output_constraint": {
    "name": "multiple_output_constraint",
    "description": "对输出结果中存在多个有效或合法输出的抽象约束，要求系统或算法能够生成并满足多个独立的输出解，常用于非唯一解问题中的多解性控制与验证",
    "aliases": [
      "multiple_outputs"
    ],
    "examples": []
  },
  "distance_coloring_constraint": {
    "name": "distance_coloring_constraint",
    "description": "对图中节点或元素的着色施加曼哈顿距离约束，要求相邻节点的颜色差异满足特定曼哈顿距离条件，常用于网格布局或空间约束中的颜色分布控制",
    "aliases": [
      "manhattan_distance_coloring"
    ],
    "examples": []
  },
  "square_free_gcd": {
    "name": "square_free_gcd",
    "description": "要求一组数的最大公约数为无平方因子数的抽象约束，即其质因数分解中每个质数的指数均为1，常用于数论中的互质性与因子结构分析",
    "aliases": [],
    "examples": []
  },
  "subgraph_exclusion": {
    "name": "subgraph_exclusion",
    "description": "要求图中某个子图不被包含或禁止出现的抽象约束，常用于构造性问题中的结构排除或非存在性判定",
    "aliases": [
      "isomorphism_exclusion"
    ],
    "examples": []
  },
  "maximize_threat_level": {
    "name": "maximize_threat_level",
    "description": "要求在结构或序列中最大化威胁程度或危险值的抽象优化目标约束，常用于策略类问题中的风险评估与最优化场景",
    "aliases": [
      "threatening_maximization"
    ],
    "examples": []
  },
  "run_length_constraint": {
    "name": "run_length_constraint",
    "description": "对序列中连续相同元素的长度施加的抽象约束，要求其满足特定长度或分组规则，常用于压缩编码、模式识别或序列分段场景",
    "aliases": [
      "run_length_encoding",
      "consecutive_equal_subsequence"
    ],
    "examples": []
  },
  "distribution_uniformity_constraint": {
    "name": "distribution_uniformity_constraint",
    "description": "要求整体分布保持均匀，防止集中或不均衡的抽象约束，常用于资源、概率或数据在各部分间的平均分配控制",
    "aliases": [
      "total_distribution",
      "partition_balance",
      "equal_distribution",
      "evenly_distributed"
    ],
    "examples": []
  },
  "complement_graph_constraint": {
    "name": "complement_graph_constraint",
    "description": "对图的补图结构施加的抽象约束，要求边集在原图与补图之间互补，即任意两点间要么在原图中相连，要么在补图中相连，但不同时存在",
    "aliases": [
      "complementary_edges"
    ],
    "examples": []
  },
  "cost_of_reassignment": {
    "name": "cost_of_reassignment",
    "description": "对元素重新分配或调整过程中产生的代价施加的抽象约束，要求其满足特定数值条件或限制，常用于资源重配置、任务再分配等场景中的成本控制",
    "aliases": [
      "reassignment_cost",
      "repetition_cost",
      "modification_cost"
    ],
    "examples": []
  },
  "random_velocity_constraint": {
    "name": "random_velocity_constraint",
    "description": "对运动对象的速度值施加随机选择的抽象约束，要求其在一定范围内随机分布，常用于模拟不确定性或非确定性行为的场景",
    "aliases": [
      "random_speed_selection"
    ],
    "examples": []
  },
  "exponential_growth_constraint": {
    "name": "exponential_growth_constraint",
    "description": "对序列或结构中元素的指数增长关系施加的抽象约束，要求其满足特定的指数函数规律或增长率条件，常用于模拟自然增长、复利计算或动态系统中的非线性演化过程",
    "aliases": [
      "exponential_relation"
    ],
    "examples": []
  },
  "maximum_to_minimum_ratio_constraint": {
    "name": "maximum_to_minimum_ratio_constraint",
    "description": "对序列或结构中最大值与最小值的比值施加的抽象约束，要求其满足特定数值比例条件或限制，常用于优化问题中的极值比控制",
    "aliases": [
      "max_min_ratio",
      "max_min_diff_leq_d"
    ],
    "examples": []
  },
  "segment_count_upper_bound": {
    "name": "segment_count_upper_bound",
    "description": "对序列或结构中段的数量施加上限约束，要求其不超过指定的最大值k",
    "aliases": [
      "segment_count_leq_k",
      "piece_count"
    ],
    "examples": []
  },
  "interpolation_constraint": {
    "name": "interpolation_constraint",
    "description": "对数值或空间点之间插值过程施加的抽象约束，要求插值结果满足特定连续性、平滑性或精度条件，常用于地理信息、信号处理或几何建模中的数据补全与逼近",
    "aliases": [
      "elevation_interpolation"
    ],
    "examples": []
  },
  "statistical_variance_constraint": {
    "name": "statistical_variance_constraint",
    "description": "对数据集或序列中元素方差的抽象约束，要求其满足特定数值条件或限制，常用于统计分析、分布控制或优化问题中的离散程度管理",
    "aliases": [
      "variance_calculation",
      "minimize_variance"
    ],
    "examples": []
  },
  "maximize_area": {
    "name": "maximize_area",
    "description": "要求几何图形的面积达到最大值的优化目标约束，常用于计算几何或形状设计中的面积最大化问题",
    "aliases": [
      "max_sum_area"
    ],
    "examples": []
  },
  "self_similar_structure_constraint": {
    "name": "self_similar_structure_constraint",
    "description": "要求结构在不同尺度下具有自相似性，即局部与整体形态一致，常用于分形几何、递归结构或层级布局中的模式重复性控制",
    "aliases": [
      "fractal_pattern"
    ],
    "examples": []
  },
  "halving_operation": {
    "name": "halving_operation",
    "description": "对数值施加每次减半的抽象操作约束，要求其满足特定迭代规则或终止条件，常用于模拟衰减过程、二分搜索或递归结构中的值缩小行为",
    "aliases": [
      "value_halving"
    ],
    "examples": []
  },
  "minimum_diameter_constraint": {
    "name": "minimum_diameter_constraint",
    "description": "对图或几何结构中直径的最小值施加的抽象约束，要求其满足特定下界条件，常用于优化问题中的最短最大距离控制",
    "aliases": [
      "min_diameter",
      "min_fence_length",
      "diameter_minimization"
    ],
    "examples": []
  },
  "convergence_constraint": {
    "name": "convergence_constraint",
    "description": "要求树结构在多次变换或操作后趋于稳定状态的抽象约束，常用于表示递归更新、迭代算法或动态演化过程中的收敛性条件",
    "aliases": [
      "tree_convergence"
    ],
    "examples": []
  },
  "graph_operation_product": {
    "name": "graph_operation_product",
    "description": "对两个图进行图积运算的抽象约束，要求其满足特定的拓扑结构组合规则，常用于图论中的复合结构构造与性质分析",
    "aliases": [
      "graph_product",
      "line_graph_transformation"
    ],
    "examples": []
  },
  "division_by_zero_constraint": {
    "name": "division_by_zero_constraint",
    "description": "对除法运算中分母为零的情况施加禁止性约束，要求所有除法操作的分母必须非零，防止未定义行为",
    "aliases": [
      "division_by_zero_prohibition",
      "denominator_nonzero",
      "quotient_constraint"
    ],
    "examples": []
  },
  "interval_operation_constraint": {
    "name": "interval_operation_constraint",
    "description": "对区间上的算术或逻辑操作施加抽象约束，要求操作结果满足特定区间范围或运算规则",
    "aliases": [
      "interval_arithmetic",
      "query_interval",
      "interval_scheduling"
    ],
    "examples": []
  },
  "interval_representation_constraint": {
    "name": "interval_representation_constraint",
    "description": "对区间在输入或输出中的表示格式施加约束，要求其符合特定书写规范或结构形式",
    "aliases": [
      "interval_format_constraint"
    ],
    "examples": []
  },
  "logical_negation_constraint": {
    "name": "logical_negation_constraint",
    "description": "对逻辑取反操作施加抽象约束，要求其满足布尔值反转的语义规则，常用于表达式求值或条件判断",
    "aliases": [
      "negation_operation"
    ],
    "examples": []
  },
  "operator_precedence_constraint": {
    "name": "operator_precedence_constraint",
    "description": "对算术或逻辑运算符的执行顺序施加约束，要求表达式按照标准优先级规则进行求值",
    "aliases": [
      "standard_operator_precedence"
    ],
    "examples": []
  },
  "leaf_weight_constraint": {
    "name": "leaf_weight_constraint",
    "description": "对树结构中所有叶子节点的权重施加的抽象约束，要求其满足特定数值条件或限制，常用于平衡树、加权路径或子树求和问题中的叶子节点权重控制",
    "aliases": [
      "critical_leaf_node",
      "depth_based_cost",
      "subtree_centroid_sum",
      "leaf_node_ownership"
    ],
    "examples": []
  },
  "subtree_weight_difference": {
    "name": "subtree_weight_difference",
    "description": "对树结构中任意两个子树的权重差值施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的子树大小平衡或差异控制",
    "aliases": [],
    "examples": []
  },
  "delayed_access_constraint": {
    "name": "delayed_access_constraint",
    "description": "对资源或状态在特定时间后才可访问的抽象约束，要求其满足延迟生效或等待条件",
    "aliases": [
      "time_delayed_availability",
      "lazy_evaluation",
      "delayed_effect"
    ],
    "examples": []
  },
  "structural_invariance": {
    "name": "structural_invariance",
    "description": "对结构在变换或操作下保持不变的抽象约束，要求其拓扑、连接或层级关系不发生本质改变",
    "aliases": [
      "structure_constraint"
    ],
    "examples": []
  },
  "second_shortest_path_constraint": {
    "name": "second_shortest_path_constraint",
    "description": "要求在图中存在一条路径，其长度为严格第二短的抽象约束，常用于最短路径变体问题中的次优路径判定与构造",
    "aliases": [
      "second_shortest_path"
    ],
    "examples": []
  },
  "non_negative_edge_weight": {
    "name": "non_negative_edge_weight",
    "description": "对图中边的权重施加非负值的抽象约束，要求所有边权不小于零，常用于路径规划或网络流中的成本控制",
    "aliases": [
      "non_negative_road_cost",
      "edge_resistance",
      "positive_weights"
    ],
    "examples": []
  },
  "closest_pair_assignment": {
    "name": "closest_pair_assignment",
    "description": "要求在一组点或对象中，每个元素必须分配给最近的参考点或聚类中心，常用于聚类算法或最近邻搜索中的分配规则",
    "aliases": [
      "nearest_assignment"
    ],
    "examples": []
  },
  "submatrix_max_value_constraint": {
    "name": "submatrix_max_value_constraint",
    "description": "对子矩阵中元素的最大值施加的抽象约束，要求其满足特定数值条件或限制",
    "aliases": [
      "submatrix_max_value"
    ],
    "examples": []
  },
  "query_history_constraint": {
    "name": "query_history_constraint",
    "description": "对查询历史记录的访问或使用施加的抽象约束，要求其满足特定顺序、频率或状态依赖条件，常用于多轮交互或动态查询场景中的上下文一致性控制",
    "aliases": [
      "historical_query",
      "historical_max_query",
      "query_dependent_operations"
    ],
    "examples": []
  },
  "average_value_constraint": {
    "name": "average_value_constraint",
    "description": "对序列或结构中元素的平均值施加的抽象约束，要求其满足特定数值条件或限制，常用于表示均值控制、平衡性或统计目标",
    "aliases": [
      "average_update"
    ],
    "examples": []
  },
  "minimum_maximum_time_constraint": {
    "name": "minimum_maximum_time_constraint",
    "description": "对序列或结构中最小值与最大值之间的时间差施加的抽象约束，要求其满足特定时间范围或极值间隔条件，常用于时间序列分析、调度问题或动态系统中的最短最大时间跨度控制",
    "aliases": [
      "min_max_time"
    ],
    "examples": []
  },
  "color_readable_constraint": {
    "name": "color_readable_constraint",
    "description": "对颜色值的可读性施加的抽象约束，要求其满足特定的视觉可辨识或编码规范，常用于表示颜色在显示或传输过程中保持清晰可识别的条件",
    "aliases": [
      "rgb_readable"
    ],
    "examples": []
  },
  "interval_insertion_constraint": {
    "name": "interval_insertion_constraint",
    "description": "对区间插入操作施加的抽象约束，要求在特定位置或范围内插入元素时满足顺序、边界或非重叠等条件",
    "aliases": [
      "range_insertion"
    ],
    "examples": []
  },
  "sorted_xor_sum_constraint": {
    "name": "sorted_xor_sum_constraint",
    "description": "对已排序序列中所有元素异或结果施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的异或平衡与有序性控制",
    "aliases": [
      "sorted_xor_sum"
    ],
    "examples": []
  },
  "kth_largest_element": {
    "name": "kth_largest_element",
    "description": "对序列中第k大的元素值施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的次大值控制",
    "aliases": [
      "kth_largest"
    ],
    "examples": []
  },
  "path_length_constraint": {
    "name": "path_length_constraint",
    "description": "对路径长度施加固定值的抽象约束，要求路径的总长度必须等于指定数值，常用于路径规划或结构设计中的长度精确控制",
    "aliases": [
      "path_length_fixed",
      "shortest_path",
      "distinct_path_lengths"
    ],
    "examples": []
  },
  "minimum_set_cover_constraint": {
    "name": "minimum_set_cover_constraint",
    "description": "要求选择最少数量的集合来覆盖全集的抽象约束，常用于集合覆盖问题中的最小化集合选取",
    "aliases": [
      "min_set_cover"
    ],
    "examples": []
  },
  "geometric_lighting_constraint": {
    "name": "geometric_lighting_constraint",
    "description": "对几何结构中光照分布或照明条件施加的抽象约束，要求满足特定光照强度、方向或覆盖范围的规则，常用于三维建模、渲染或空间布局中的光照合理性控制",
    "aliases": [
      "illumination_constraint"
    ],
    "examples": []
  },
  "range_sort_constraint": {
    "name": "range_sort_constraint",
    "description": "对区间内元素进行排序的抽象约束，要求子数组或子序列在指定范围内按升序或降序排列",
    "aliases": [
      "range_sort"
    ],
    "examples": []
  },
  "range_xor_constraint": {
    "name": "range_xor_constraint",
    "description": "对区间内所有元素的异或值施加的抽象约束，要求其满足特定异或结果条件",
    "aliases": [
      "range_xor"
    ],
    "examples": []
  },
  "range_xor_sum_constraint": {
    "name": "range_xor_sum_constraint",
    "description": "对区间中所有元素的异或和施加的抽象约束，要求其满足特定数值条件或限制，常用于构造性问题中的异或平衡与区间控制",
    "aliases": [
      "range_xor_sum"
    ],
    "examples": []
  },
  "mex_minimization": {
    "name": "mex_minimization",
    "description": "对序列中第k小的未出现非负整数（mex）施加最小化约束，要求其满足特定数值条件或限制，常用于构造性问题中的mex值控制",
    "aliases": [],
    "examples": []
  },
  "prefix_suffix_matching": {
    "name": "prefix_suffix_matching",
    "description": "要求序列或字符串的前缀与后缀在内容或结构上完全相等的抽象约束，常用于构造性问题中的对称性判定与匹配控制",
    "aliases": [
      "prefix_suffix_equality",
      "prefix_count_constraint"
    ],
    "examples": []
  },
  "edge_length_fixed": {
    "name": "edge_length_fixed",
    "description": "对图中边的长度施加固定值的抽象约束，要求所有边的长度必须等于指定数值，常用于路径规划或结构设计中的长度精确控制",
    "aliases": [
      "fixed_length_edge"
    ],
    "examples": []
  },
  "immediate_consequence_constraint": {
    "name": "immediate_consequence_constraint",
    "description": "要求操作或事件的结果在执行后立即生效，不经过延迟或缓冲的抽象约束，常用于表示即时响应、瞬时变化或无延迟状态转移的场景",
    "aliases": [
      "immediate_effect"
    ],
    "examples": []
  },
  "prefix_exclusion": {
    "name": "prefix_exclusion",
    "description": "要求序列或字符串的前缀部分不包含特定模式或内容，常用于构造性问题中对前缀的禁止性控制",
    "aliases": [],
    "examples": []
  },
  "single_wildcard": {
    "name": "single_wildcard",
    "description": "表示在匹配或构造过程中允许使用一个通配符字符（如'?'）来代表任意单个字符的抽象约束，常用于模式匹配或灵活匹配场景",
    "aliases": [],
    "examples": []
  },
  "odd_length_constraint": {
    "name": "odd_length_constraint",
    "description": "对子区间或子序列的长度施加奇数限制的抽象约束，要求其长度必须为奇数，常用于构造性问题中的长度奇偶性控制",
    "aliases": [
      "odd_length_subinterval"
    ],
    "examples": []
  },
  "edge_importance_constraint": {
    "name": "edge_importance_constraint",
    "description": "对图中边的重要性或关键性施加的抽象约束，要求某些边在结构连通性、路径可达性或全局性质中具有决定性作用",
    "aliases": [
      "critical_edge"
    ],
    "examples": []
  },
  "node_query_value": {
    "name": "node_query_value",
    "description": "对图中节点的值进行查询操作的抽象约束，要求在特定条件下获取或验证节点的数值属性",
    "aliases": [
      "query_node_value"
    ],
    "examples": []
  },
  "tree_growth_constraint": {
    "name": "tree_growth_constraint",
    "description": "对树结构在生长过程中节点添加或扩展规则施加的抽象约束，要求满足特定的层级扩展、分支生成或递归构造条件",
    "aliases": [
      "tree_growth_rule"
    ],
    "examples": []
  },
  "monotonic_distance": {
    "name": "monotonic_distance",
    "description": "要求距离值在序列或路径中保持单调递增或递减的抽象约束，常用于表示路径长度、状态转移或空间位置中的连续变化趋势控制",
    "aliases": [
      "distance_monotonicity"
    ],
    "examples": []
  },
  "count_zero_elements": {
    "name": "count_zero_elements",
    "description": "对序列或结构中零值元素的数量施加的抽象约束，要求其满足特定计数条件或限制",
    "aliases": [
      "zero_count_constraint"
    ],
    "examples": []
  },
  "minimum_second_smallest_value_constraint": {
    "name": "minimum_second_smallest_value_constraint",
    "description": "对序列中第二小的元素值施加最小化约束，要求其满足特定数值条件或限制，常用于构造性问题中的次小值控制",
    "aliases": [
      "min_second_min_constraint"
    ],
    "examples": []
  },
  "range_query_max": {
    "name": "range_query_max",
    "description": "对滑动窗口或区间查询中最大值的抽象约束，要求在指定范围内求取并满足最大值条件",
    "aliases": [
      "query_range",
      "interval_query"
    ],
    "examples": []
  },
  "cycle_vertex_count_constraint": {
    "name": "cycle_vertex_count_constraint",
    "description": "对图中位于环上的顶点数量施加的抽象约束，要求其满足特定计数条件或限制",
    "aliases": [
      "vertex_in_cycles_limit"
    ],
    "examples": []
  },
  "power_sum_constraint": {
    "name": "power_sum_constraint",
    "description": "对序列或结构中元素的幂次和施加的抽象约束，要求各元素取特定幂次后求和满足特定条件或限制，常用于构造性问题中的幂和控制",
    "aliases": [
      "sum_of_powers"
    ],
    "examples": []
  },
  "tree_weight_constraint": {
    "name": "tree_weight_constraint",
    "description": "对树结构中节点或子树的权重定义施加的抽象约束，要求其满足特定计算规则或分布条件，常用于加权路径、子树求和或平衡树问题中的权重设定",
    "aliases": [
      "tree_weight_definition"
    ],
    "examples": []
  },
  "substructure_presence_constraint": {
    "name": "substructure_presence_constraint",
    "description": "要求在结构中存在特定子结构的抽象约束，常用于表示局部模式或组件必须存在的判定条件",
    "aliases": [
      "substructure_existence"
    ],
    "examples": []
  },
  "monotonic_width_constraint": {
    "name": "monotonic_width_constraint",
    "description": "要求结构中宽度值在序列或层级中保持单调递增或递减的抽象约束，常用于表示布局、树结构或路径中的宽度变化趋势控制",
    "aliases": [
      "monotonic_width"
    ],
    "examples": []
  },
  "temporal_dependency_constraint": {
    "name": "temporal_dependency_constraint",
    "description": "对操作或状态之间的时间依赖关系施加的抽象约束，要求某些事件必须在其他事件之后发生，常用于表示顺序执行、延迟触发或时间序列中的因果关系控制",
    "aliases": [
      "time_dependency"
    ],
    "examples": []
  },
  "minimum_difference_partition_constraint": {
    "name": "minimum_difference_partition_constraint",
    "description": "要求将集合划分为若干子集时，各子集内部元素间最小差值最大化，常用于优化划分方案以增强组内差异性。",
    "aliases": [
      "min_diff_partition"
    ],
    "examples": []
  },
  "maximum_distinct_elements_constraint": {
    "name": "maximum_distinct_elements_constraint",
    "description": "对序列或结构中不同元素的最大数量施加的抽象约束，要求其满足特定计数条件或限制，常用于构造性问题中的唯一性与多样性控制",
    "aliases": [
      "distinct_max_constraint"
    ],
    "examples": []
  },
  "suffix_lexicographical_minimality": {
    "name": "suffix_lexicographical_minimality",
    "description": "要求字符串的后缀在字典序中最小，常用于构造性问题中的后缀排序或最小表示判定",
    "aliases": [
      "suffix_minimality"
    ],
    "examples": []
  }
}