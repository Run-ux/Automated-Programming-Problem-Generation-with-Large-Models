{
  "bottleneck_path": {
    "name": "bottleneck_path",
    "description": "图中限制整体性能的最紧约束路径，通常指容量最小的边构成的路径",
    "aliases": [
      "edge_usage_limit",
      "distinct_sequence",
      "level_maximization",
      "cost_minimization",
      "expansion_speed_limit",
      "capacity_constraint",
      "min_turns_to_single_color",
      "diameter_calculation",
      "xor_cost_minimization",
      "height_reduction",
      "minimize_max_cost",
      "height_minimization",
      "shortest_path",
      "minimize_affected_roads",
      "shortest_path_tree",
      "min_cost_path",
      "minimax_path_cost",
      "optimal_path",
      "shortest_path_length",
      "shortest_path_coverage",
      "min_path_cost",
      "xor_shortest_path"
    ],
    "examples": []
  },
  "graph_connectivity": {
    "name": "graph_connectivity",
    "description": "图中节点之间的连通性特征，描述图是否连通或具有特定连通性属性",
    "aliases": [
      "connected_graph",
      "start_node_fixed",
      "target_node_random",
      "visit_all_nodes",
      "bfs_traversal_validity",
      "termination_condition",
      "connected_component",
      "path_validity",
      "village_connectivity",
      "valid_path",
      "reachability_constraint",
      "path_existence",
      "connected_component_constraint",
      "target_reachability",
      "reachability_condition",
      "connected_components",
      "connectivity_constraint",
      "forest_connectivity",
      "connected_region",
      "connectivity_requirement",
      "path_connectivity",
      "connectivity",
      "connected_regions",
      "reachability_guaranteed",
      "biconnectivity_requirement",
      "node_connectivity",
      "forest_structure",
      "connected_undirected_graph",
      "wall_connectivity",
      "node_existence",
      "tree_connectivity",
      "connect_operation_constraint",
      "join_operation_constraint"
    ],
    "examples": []
  },
  "gcd_constraint": {
    "name": "gcd_constraint",
    "description": "图中边权或节点值需满足最大公约数约束的条件",
    "aliases": [
      "compression_divisibility",
      "modular_inverse",
      "gcd_invariance",
      "compression_invariance",
      "divisibility_constraint",
      "gcd_divisibility",
      "gcd_normalization",
      "gcd_condition"
    ],
    "examples": []
  },
  "tree_structure": {
    "name": "tree_structure",
    "description": "一种无环连通图，具有层级关系的树形数据结构",
    "aliases": [
      "subtree_independence",
      "rooted_tree_symmetry",
      "heap_structure",
      "leaf_catch",
      "rooted_tree",
      "bfs_tree_constraint",
      "binary_tree_structure",
      "valid_tree_structure",
      "subtree_operation",
      "parent_child_sum_constraint",
      "rooted_tree_structure",
      "cousin_definition",
      "rooted_tree_orientation",
      "connected_acyclic_graph",
      "valid_tree",
      "tree_structure_preservation",
      "directed_tree_structure",
      "leaf_values_determine_all",
      "connected_tree",
      "rooted_tree_operations",
      "simplified_tree_structure",
      "parent_child_relationship",
      "divisor_tree_structure"
    ],
    "examples": []
  },
  "adjacent_difference": {
    "name": "adjacent_difference",
    "description": "相邻元素之间的差值约束或计算，常用于序列或数组中相邻项的差异分析",
    "aliases": [
      "range_inclusion",
      "adjacent_expansion",
      "adjacent_transition_probability",
      "subsegment_xor_constraint",
      "integer_difference",
      "min_pairwise_difference",
      "adjacency_definition",
      "adjacent_pairs",
      "binary_integer_ordering",
      "adjacent_segment_inspection",
      "range_constraint",
      "inversion_count_constraint",
      "permutation_inversion_count",
      "adjacent_colour_coverage",
      "adjacent_color_constraint",
      "adjacent_difference_sum_minimization",
      "layer_adjacency",
      "cyclic_difference_sum",
      "sequential_killing",
      "max_min_hand_difference",
      "adjacent_corner_matching",
      "adjacent_difference_count",
      "adjacent_fall_direction",
      "adjacent_spread",
      "adjacent_attack",
      "max_min_diff_leq_d",
      "permutation_distance",
      "adjacent_equality",
      "adjacency_constraint",
      "absolute_difference_increase",
      "ground_collision",
      "vertical_segment_collision",
      "adjacent_direction_difference",
      "direction_change_constraint",
      "adjacent_preference",
      "adjacent_threat",
      "digit_distance_constraint",
      "adjacent_elements",
      "adjacent_pair_constraint",
      "sequential_destruction",
      "adjacent_move",
      "adjacent_mine_count",
      "bidirectional_placement",
      "value_difference",
      "adjacent_movement",
      "adjacent_disturbance",
      "row_column_increment",
      "consecutive_identifiers",
      "height_difference_even",
      "adjacent_jump",
      "pairwise_difference",
      "adjacent_ratio_constraint",
      "adjacent_quarantine",
      "corner_adjacent_quarantine",
      "remove_odd_positions",
      "difference_constraint",
      "corner_height_constraint",
      "span_notches_per_chord",
      "adjacent_similarity",
      "pairwise_increasing",
      "teleport_cell_neighbors",
      "disconnected_pairs_zero",
      "length_difference",
      "adjacent_split",
      "adjacent_connection",
      "cutting_line_adjacency",
      "love_color_difference",
      "deletion_shift",
      "insertion_shift",
      "adjacent_profit_calculation",
      "related_nodes"
    ],
    "examples": []
  },
  "transformation_exclusion": {
    "name": "transformation_exclusion",
    "description": "在变换过程中排除特定映射关系的约束条件，常用于状态转换或函数变换中的禁止规则",
    "aliases": [
      "employee_removal",
      "subsequence_exclusion",
      "non_overlapping_castles",
      "event_uniqueness",
      "single_card_replacement",
      "transformable_to_target",
      "replacement_constraint",
      "edit_operations",
      "transformation_feasibility"
    ],
    "examples": []
  },
  "adjacent_sum_constraint": {
    "name": "adjacent_sum_constraint",
    "description": "相邻元素之和需满足特定奇偶性约束的条件，常用于序列中相邻项求和的奇偶性判断",
    "aliases": [
      "adjacent_sum_odd",
      "query_ordering",
      "rectangular_castles",
      "continuous_sequence",
      "sum_constraint",
      "interval_extension",
      "path_sum_function",
      "range_coverage",
      "adjacent_cost",
      "sorted_prefix_sum",
      "range_sum",
      "sum_zero_excluding_ends",
      "even_sum_constraint",
      "adjacent_sum_operation",
      "parity_constraint",
      "adjacent_passage_cost"
    ],
    "examples": []
  },
  "node_value_constraint": {
    "name": "node_value_constraint",
    "description": "节点取值需满足特定集合约束的条件，常用于图或树中节点值的取值范围限制",
    "aliases": [
      "node_value_set",
      "leaf_coverage",
      "element_range_constraint",
      "array_value_range",
      "B_element_upper_bound",
      "initial_value_constraint",
      "output_range_constraint",
      "positive_integers",
      "range_validity",
      "value_range",
      "element_range",
      "subarray_element_range",
      "value_range_constraint",
      "element_values",
      "element_bound",
      "valid_number_range",
      "element_upper_bound",
      "node_value_calculation",
      "single_node_update",
      "protected_node_constraint",
      "element_value_constraint"
    ],
    "examples": []
  },
  "constant_submatrix": {
    "name": "constant_submatrix",
    "description": "子矩阵中所有元素值相等的约束条件，常用于图像处理或矩阵变换中的均匀性要求",
    "aliases": [
      "uniform_submatrix_values",
      "indistinguishable_elements",
      "initial_intervals_equal",
      "element_equality",
      "same_color_same_value",
      "uniform_target",
      "single_element_range",
      "all_elements_to_zero",
      "zeroing_operations",
      "sub_rectangle_all_ones",
      "uniform_distribution",
      "solid_rectangle",
      "distinct_elements_in_submatrix",
      "uniform_coloring_operation",
      "shape_invariance",
      "uniformity_constraint",
      "grid_value_uniformity",
      "zero_padding",
      "uniform_weight_sequence",
      "subarray_equality",
      "zeroing_condition",
      "grid_value_equality",
      "zero_power_one"
    ],
    "examples": []
  },
  "substring_deletion_constraint": {
    "name": "substring_deletion_constraint",
    "description": "对连续子串删除操作施加的约束条件，常用于字符串变换中的删除规则限制",
    "aliases": [
      "consecutive_substring_removal",
      "valid_parentheses_sequence",
      "rectangular_merge",
      "consecutive_elements_limit",
      "segment_inversion",
      "remove_one_segment",
      "subarray_reversal_limit",
      "substring_reversal",
      "subarray_sum_exclusion",
      "subsequence_avoidance",
      "longest_consecutive_segment_removal",
      "palindrome_deletion",
      "single_character_removal",
      "consecutive_removal_limit",
      "string_deletion",
      "substring_exclusion",
      "subsequence_removal",
      "remove_one_interval",
      "pattern_deletion"
    ],
    "examples": []
  },
  "global_optimization_objective": {
    "name": "global_optimization_objective",
    "description": "目标为最大化整体得分的全局优化问题，常用于路径、分配或决策类问题中的目标函数设计",
    "aliases": [
      "maximize_total_score",
      "winning_condition",
      "cost_function",
      "objective_minimization",
      "maximize_universal_quantifiers",
      "minimize_function",
      "feasibility_check",
      "minimization_constraint",
      "minimize_sum_of_squares",
      "optimal_strategy",
      "maximization_constraint",
      "min_spanning_tree_weight_minimization",
      "maximize_matching",
      "reward_condition",
      "optimal_play",
      "minimize_winner_index",
      "cost_minimization",
      "game_win_condition",
      "maximize_minimize_objective",
      "sum_maximization",
      "expected_value_maximization",
      "satisfaction_ratio",
      "profit_calculation",
      "infinite_score_condition",
      "maximize_final_value",
      "maximize_characteristic_value",
      "satisfy_all_wishes",
      "cost_function_minimization",
      "optimality_requirement",
      "maximize_utility_minimize_duration",
      "win_condition",
      "victory_condition",
      "score_comparison",
      "minimize_cost",
      "minimize_time",
      "summary_result",
      "minimize_x",
      "maximize_participants",
      "objective_function",
      "maximize_net_gain",
      "score_calculation",
      "maximize_score",
      "maximize_expectation"
    ],
    "examples": []
  },
  "value_distribution_rule": {
    "name": "value_distribution_rule",
    "description": "对数值分配方式施加的规则约束，常用于评分系统中值的分布策略或映射逻辑",
    "aliases": [
      "score_assignment",
      "rounding_constraint",
      "distribution_index",
      "hash_value_consistency",
      "output_format",
      "threshold_check",
      "value_assignment",
      "global_assignment"
    ],
    "examples": []
  },
  "pairwise_interaction_constraint": {
    "name": "pairwise_interaction_constraint",
    "description": "描述两个元素之间交互行为的约束条件，常用于状态或事件间的同步与互斥规则",
    "aliases": [
      "meeting_condition",
      "swap_validity",
      "turn_based_game",
      "logical_and_constraint",
      "pairwise_cost",
      "pairwise_collision",
      "pairwise_usage",
      "pairwise_function_application",
      "synergy_bonus",
      "pairwise_combination",
      "function_application_constraint",
      "ordered_pair",
      "pairwise_equation_satisfaction"
    ],
    "examples": []
  },
  "edge_exclusion_constraint": {
    "name": "edge_exclusion_constraint",
    "description": "在图结构中排除特定边参与路径或连接的约束条件，常用于限制某些转移路径的存在",
    "aliases": [
      "no_meeting_in_edges",
      "no_self_loops",
      "non_intersecting_rectangles",
      "boundary_constraint",
      "edge_condition",
      "edge_existence_constraint",
      "blocked_zone",
      "edge_assignment",
      "no_replacement",
      "segment_exclusion",
      "boundary_reflection",
      "path_blockage",
      "boundary_fall_direction",
      "boundary_infection",
      "cut_must_be_new",
      "exclusion_zone",
      "boundary_avoidance",
      "bomb_exclusion",
      "path_avoidance",
      "boundary_blockage",
      "forbidden_node",
      "boundary_restriction",
      "repair_or_destroy",
      "obstacle_avoidance",
      "path_blockade",
      "node_exclusion",
      "marking_constraint",
      "edge_existence_condition",
      "edge_existence",
      "boundary_obstacles",
      "no_blockage",
      "subset_exclusion",
      "obstacle_removal_limit",
      "non_intersecting_edges",
      "self_loop_good",
      "forbidden_areas",
      "forbidden_intervals",
      "no_receiver_on_line",
      "forbidden_cells",
      "ray_endpoint_exclusion",
      "boundary_absorption",
      "unusable_element",
      "boundary_wall_constraint",
      "boundary_adjustment",
      "valid_edge_removal",
      "corner_exclusion_zone",
      "boundary_condition",
      "edge_exclusion"
    ],
    "examples": []
  },
  "parallel_operation": {
    "name": "parallel_operation",
    "description": "多个操作在同一时间点并行执行的约束或行为模式，常用于多线程、并发系统或同步策略设计",
    "aliases": [
      "simultaneous_action",
      "move_options",
      "operation_sequence",
      "query_independence_constraint",
      "non_adaptive_interactor",
      "turn_based_draw",
      "independent_cleaning_events",
      "adaptive_interactor",
      "lane_independence",
      "independent_walks",
      "synchronous_transition",
      "simultaneous_movement",
      "immediate_action",
      "coprocessor_batching",
      "single_movement_per_time_unit",
      "no_concurrent_aggregation",
      "independent_infection_probability",
      "parallel_operations",
      "simultaneous_operations",
      "simultaneous_move",
      "teleport_behavior",
      "independent_rounds"
    ],
    "examples": []
  },
  "substring_distinctness_constraint": {
    "name": "substring_distinctness_constraint",
    "description": "要求字符串中所有子串互不相同的约束条件，常用于字符串生成或编码中的唯一性要求",
    "aliases": [
      "distinct_substrings",
      "sequence_uniqueness",
      "substring_inclusion",
      "prefix_postfix_non_overlap"
    ],
    "examples": []
  },
  "substring_frequency_optimization": {
    "name": "substring_frequency_optimization",
    "description": "最大化特定子串在字符串中出现次数的优化目标，常用于模式匹配或文本生成任务",
    "aliases": [
      "substring_occurrences_maximization",
      "substring_counting",
      "frequency_multiplicity",
      "frequency_constraint",
      "frequency_upper_bound",
      "subsequence_maximization",
      "max_subarray_count",
      "subsequence_count",
      "max_substring_count",
      "subsequence_count_maximization",
      "subarray_frequency_query",
      "substring_max_count",
      "substring_pattern_count",
      "substring_occurrence",
      "substring_repetition_count"
    ],
    "examples": []
  },
  "pattern_matching_substitution": {
    "name": "pattern_matching_substitution",
    "description": "在字符串中使用通配符进行模式匹配并替换的规则，常用于模糊匹配或模板填充场景",
    "aliases": [
      "wildcard_replacement",
      "substring_replacement",
      "valid_substitution",
      "template_substitution",
      "encrypted_input_decryption",
      "transcription_mapping",
      "detection_constraint",
      "wildcard_matching",
      "generation_method_identification"
    ],
    "examples": []
  },
  "minimum_preference_requirement": {
    "name": "minimum_preference_requirement",
    "description": "要求序列或集合中至少包含一个符合特定偏好条件的元素，常用于选择策略或约束满足问题中的最低偏好保障",
    "aliases": [
      "at_least_one_preferred_element",
      "min_remaining_elements",
      "single_selection",
      "rating_floor",
      "at_least_one_one",
      "mandatory_selection",
      "min_max_buns",
      "k_min_elements",
      "min_reliability_elimination",
      "min_index_tie_breaker",
      "mandatory_resource_usage"
    ],
    "examples": []
  },
  "modulo_expected_value_constraint": {
    "name": "modulo_expected_value_constraint",
    "description": "对期望值施加模运算约束的条件，常用于概率分布或数值计算中对结果取模的限制",
    "aliases": [
      "expected_value_modulo",
      "sum_modulo_constraint",
      "expected_value_query",
      "modular_result",
      "modular_arithmetic",
      "expected_time_modulo",
      "move_length_divisibility",
      "lca_sum_modulo",
      "modular_sum_constraint",
      "expected_value_calculation",
      "modulo_consistency",
      "result_modulo",
      "range_sum_modulo",
      "modulo_constraint",
      "output_modulo",
      "expected_value",
      "expectation_calculation"
    ],
    "examples": []
  },
  "weight_proportional_probability": {
    "name": "weight_proportional_probability",
    "description": "概率值与权重成正比的分配规则，常用于基于权重的概率选择或采样机制",
    "aliases": [
      "probability_proportional_to_weight",
      "probability_constraint",
      "majority_vote",
      "cleaning_probability",
      "max_probability_selection",
      "probability_maximization",
      "independent_probability",
      "probability_dependent_repetition",
      "equal_opportunities",
      "probability_distribution",
      "max_probability",
      "probability_proportional_to_weights",
      "initial_probability",
      "survival_probability",
      "probability_sorting",
      "query_subset_probability"
    ],
    "examples": []
  },
  "preference_based_weight_modification": {
    "name": "preference_based_weight_modification",
    "description": "根据元素偏好程度动态调整其权重的规则，常用于优先级调度或自适应赋权系统",
    "aliases": [
      "weight_adjustment_based_on_preference",
      "trade_preference",
      "strong_recommendation",
      "group_preference",
      "language_preference"
    ],
    "examples": []
  },
  "weight_sum_constraint": {
    "name": "weight_sum_constraint",
    "description": "对初始权重总和施加上限约束的条件，常用于资源分配或初始化过程中的总量控制",
    "aliases": [
      "initial_weights_sum_limit",
      "sum_zero",
      "sum_of_function_values",
      "signal_power_bound",
      "one_count_constraint",
      "result_one_count_constraint",
      "zero_count_constraint",
      "non_negative_weights",
      "profit_division",
      "activation_cost",
      "coloring_value_sum",
      "initial_distribution",
      "sum_upper_bound",
      "total_capacity",
      "resource_limit",
      "penalty_limit",
      "total_weight_constraint",
      "total_bonus_limit",
      "berlaflot_reform_cost",
      "budget_constraint",
      "total_weight_limit"
    ],
    "examples": []
  },
  "weight_adjustment": {
    "name": "weight_adjustment",
    "description": "根据特定规则动态修改权重的行为或约束，常用于自适应系统中的权重更新机制",
    "aliases": [
      "weight_modification",
      "value_update",
      "adaptive_password_change",
      "value_function",
      "health_gain",
      "increment_operation",
      "update_value_range",
      "incremental_update",
      "point_update",
      "range_update",
      "element_modification",
      "dynamic_resource_usage",
      "update_element",
      "label_multiplication",
      "score_increment",
      "update_procedure",
      "value_modification_rule",
      "update_range",
      "edge_weight_modification",
      "resource_gain",
      "variable_modification",
      "path_weight_update",
      "node_update",
      "edge_weight_update",
      "modifiable_cost_constraint",
      "update_operation",
      "element_update",
      "component_value_update",
      "dynamic_weights",
      "set_update_rule",
      "update_constraint",
      "cumulative_updates",
      "variable_update_rule"
    ],
    "examples": []
  },
  "distinct_simple_paths": {
    "name": "distinct_simple_paths",
    "description": "图中所有简单路径互不相同的约束条件，常用于路径枚举或唯一性验证场景",
    "aliases": [
      "distinct_castles",
      "unique_tour_membership",
      "distinct_elements",
      "distinct_indices",
      "distinct_paths",
      "disjoint_paths",
      "unique_ladders",
      "distinct_states",
      "unique_path_segments",
      "frame_uniqueness_constraint",
      "distinct_sequences",
      "distinct_positions",
      "path_uniqueness",
      "unique_path_between_nodes",
      "distinct_cycles",
      "unique_path",
      "unique_action_sequence",
      "non_intersecting_paths",
      "edge_disjoint_paths",
      "unique_subgraphs",
      "simple_cycle_uniqueness",
      "distinct_chains",
      "distinct_paths_for_same_vertex"
    ],
    "examples": []
  },
  "path_length_constraint": {
    "name": "path_length_constraint",
    "description": "对简单路径长度施加特定限制的约束条件，常用于路径搜索或最短路径问题中的长度控制",
    "aliases": [
      "simple_path_length",
      "subsequence_length_fixed",
      "no_path_indicator",
      "no_out_of_bounds",
      "bounded_path_length",
      "path_length_fixed",
      "query_size_fixed",
      "subsequence_length",
      "movement_constraint",
      "jump_length_limit",
      "graph_traversal_constraint",
      "total_length_constraint",
      "total_length_equal_k",
      "subarray_length_fixed",
      "game_termination",
      "substring_length_constraint",
      "max_length_subsequence",
      "path_constraint",
      "minimal_length",
      "bounded_movement",
      "path_length_limit",
      "equal_path_length",
      "movement_length_constraint",
      "movement_limit",
      "interval_length_bound",
      "string_length_bound",
      "length_bound",
      "max_sequence_length",
      "substring_sum_length",
      "path_length_range",
      "termination_condition",
      "path_grammar_compliance",
      "sequential_edge_removal",
      "length_constraint",
      "path_coverage",
      "path_length_definition",
      "interval_length_constraint",
      "sequence_length_constraint",
      "range_length_fixed",
      "interval_length_fixed",
      "string_length_limit",
      "operation_sequence_length",
      "sequence_length_bound"
    ],
    "examples": []
  },
  "single_edge_operation": {
    "name": "single_edge_operation",
    "description": "仅允许一次边添加操作的约束或行为模式，常用于图构造或增量更新场景",
    "aliases": [
      "single_edge_addition",
      "single_operation_limit",
      "single_modification",
      "single_element_move",
      "single_use_noise",
      "add_one_edge",
      "single_element_modification",
      "single_operation",
      "single_removal_constraint",
      "single_bus_ride",
      "single_vehicle_constraint"
    ],
    "examples": []
  },
  "bipartite_matching": {
    "name": "bipartite_matching",
    "description": "一种在二分图中寻找最大匹配的算法问题，要求每条边连接两个不同集合的节点且无重复匹配，常用于任务分配或资源匹配场景",
    "aliases": [
      "bipartite_graph",
      "bipartite_partition",
      "bipartite_arrangement",
      "bipartite_constraint",
      "bipartition_mapping",
      "complete_assignment",
      "worker_machine_compatibility",
      "perfect_matching",
      "no_monochromatic_cycle",
      "bipartite_love"
    ],
    "examples": []
  },
  "pairwise_exclusion": {
    "name": "pairwise_exclusion",
    "description": "一对元素之间不能同时出现或共存的约束条件，常用于互斥选择、状态排除或冲突避免的场景",
    "aliases": [
      "pairwise_non_intersecting",
      "cell_color_change_rule",
      "disjoint_subsets",
      "adjacent_coprime_prohibition",
      "non_overlapping_shapes",
      "independent_tower_placement",
      "distinct_pairs",
      "self_assignment_exclusion",
      "pairwise_permutation",
      "permutation_constraint",
      "cute_number_condition",
      "equality_transform",
      "adjacent_exclusion",
      "elimination_rule",
      "exclusive_killing",
      "pairwise_distinct_constraints",
      "non_intersecting_segments",
      "dominance_constraint",
      "independent_selection",
      "non_friendship_value",
      "pairwise_swapping",
      "matching_constraint",
      "good_pairs_count",
      "pairwise_distinct",
      "exclusion_constraint",
      "non_overlapping_intervals",
      "instantaneous_lead",
      "exact_hit_detection",
      "assignment_exclusivity",
      "directional_eating",
      "non_conflicting_answers",
      "rectangles_non_overlap",
      "forbidden_triplets",
      "isolation_requirement",
      "knockout_condition",
      "pairwise_distinct_candidates",
      "disjoint_substrings",
      "distinct_min_exclusion",
      "non_intersecting_substrings",
      "non_intersecting_circles",
      "non_intersecting_lines",
      "non_intersecting_squares",
      "processor_exclusivity",
      "mutual_exclusion",
      "adjacent_difference_avoidance",
      "catch_condition",
      "no_overlap_movement",
      "disjoint_areas",
      "non_overlapping_constraint",
      "pairwise_connection",
      "exclusive_activation",
      "pairwise_penalty",
      "digit_exclusion",
      "single_cross_edge",
      "all_elements_attack",
      "pairwise_matching",
      "exclusive_resource_usage",
      "minimize_attack_pairs",
      "same_level_exchange",
      "non_attacking_constraint",
      "exclusive_operations",
      "disjoint_allocation",
      "disjoint_intervals",
      "pairwise_matching_limit",
      "mapping_constraint",
      "matching_rule",
      "disjoint_sets",
      "elimination_effect",
      "non_overlapping_placement",
      "no_position_swap",
      "pairwise_inversion_limit",
      "avoid_existing_elements",
      "non_attacking_placement",
      "pairwise_ordering",
      "non_overlapping_objects",
      "pairwise_disjoint",
      "valid_swap_pairs",
      "conditional_swap",
      "pairwise_selection",
      "capture_condition"
    ],
    "examples": []
  },
  "subset_sum_imbalance": {
    "name": "subset_sum_imbalance",
    "description": "子集元素之和不均衡的约束或状态，常用于集合划分或资源分配中对总和差异的衡量",
    "aliases": [
      "unbalanced_subset_sum",
      "subset_minimization",
      "partition_into_villages",
      "subset_partition",
      "positive_integer_partition",
      "coverage_constraint",
      "partition_beauty",
      "equal_partition",
      "set_operations",
      "subset_sum_constraint",
      "intersection_sum",
      "divisor_partition",
      "subset_sum_uniqueness"
    ],
    "examples": []
  },
  "node_degree_constraint": {
    "name": "node_degree_constraint",
    "description": "对图中节点度数施加上限约束的条件，常用于限制节点连接数量或网络密度",
    "aliases": [
      "degree_upper_bound",
      "degree_lower_bound",
      "prufer_vertex_constraint",
      "node_occupancy_limit",
      "trap_nodes_limit",
      "integer_children_count",
      "degree_constraint",
      "switch_occupancy_constraint",
      "group_liberties",
      "max_occupancy",
      "occupancy_limit",
      "degree_fixed",
      "out_degree_lower_bound",
      "in_degree_limit",
      "room_occupancy",
      "cell_occupancy_limit",
      "node_degree_lower_bound",
      "node_degree_upper_bound",
      "liberty_constraint"
    ],
    "examples": []
  },
  "polygon_convexity_constraint": {
    "name": "polygon_convexity_constraint",
    "description": "多边形所有内角均小于180度，且任意两点连线位于多边形内部的几何约束",
    "aliases": [
      "convex_polygon",
      "polygon_inequality",
      "perimeter_calculation",
      "positive_area",
      "obtuse_triangle",
      "enclosing_triangle_area",
      "polygon_convexity",
      "non_degenerate_triangle",
      "convexity_constraint",
      "convex_polygon_constraint",
      "convex_hull_inclusion",
      "convex_hull_coverage",
      "convex_hull_vertex_count"
    ],
    "examples": []
  },
  "orientation_constraint": {
    "name": "orientation_constraint",
    "description": "通过叉积符号判断三点相对位置关系（顺时针/逆时针）的几何方向性约束",
    "aliases": [
      "cross_product_sign",
      "directional_movement",
      "shape_rotation",
      "velocity_direction",
      "directional_movement_constraint",
      "movement_directionality",
      "angle_limit",
      "direction_constraint",
      "movement_direction_fixed",
      "word_orientation",
      "angle_constraint",
      "turning_angle_limit",
      "counterclockwise_order",
      "angle_coverage",
      "vertices_counter_clockwise_order",
      "ray_rotation_independence",
      "directional_move",
      "movement_directions"
    ],
    "examples": []
  },
  "coordinate_fixed_point": {
    "name": "coordinate_fixed_point",
    "description": "在几何或图结构中指定某个点的坐标为固定值的约束条件",
    "aliases": [
      "fixed_coordinates",
      "non_decreasing_coordinates",
      "street_coordinates_order",
      "precolored_nodes",
      "tuple_range",
      "fixed_elements",
      "coordinate_bounds",
      "bounded_position",
      "position_outside_box",
      "integer_coordinates",
      "grid_boundary",
      "fixed_direction",
      "coordinate_constraint",
      "fixed_shift",
      "coordinate_alignment",
      "initial_position_not_hole",
      "fixed_cells_unchanged",
      "initial_row_constraint",
      "valid_date",
      "boundary_alignment",
      "translation_vector_constraint",
      "fixed_position",
      "valid_day_constraint",
      "root_weight_fixed",
      "initial_value_constraint",
      "initial_position_agnostic",
      "fixed_displacement",
      "random_initial_value",
      "fixed_values",
      "initial_position_fixed",
      "fixed_position_on_collision",
      "initial_position_constraint",
      "initial_values",
      "predefined_values",
      "position_bound",
      "boundary_fixed_elements"
    ],
    "examples": []
  },
  "non_collinear_point_set": {
    "name": "non_collinear_point_set",
    "description": "集合中任意三个点不共线的几何约束，用于保证点集构成有效三角形或非退化形状",
    "aliases": [
      "no_three_collinear",
      "distinct_points",
      "distinct_coordinates",
      "non_collinear_points",
      "non_collinear_pivots",
      "collinearity_constraint",
      "no_three_in_a_line",
      "no_collinear_receivers",
      "vertices_non_collinear",
      "no_three_collinear_points"
    ],
    "examples": []
  },
  "query_count_constraint": {
    "name": "query_count_constraint",
    "description": "对查询操作次数施加上限的约束条件，常用于限制算法访问次数或资源消耗",
    "aliases": [
      "query_limit",
      "memory_size",
      "query_response",
      "reset_limit",
      "operation_count",
      "operation_limit",
      "query_type_constraint",
      "invalid_query_response",
      "distinct_indices_per_query",
      "max_queries_limit",
      "min_queries_required",
      "query_type_1_update",
      "query_type_2_reconstruction",
      "consistent_responses",
      "time_constraint",
      "query_compression",
      "consistent_queries",
      "limited_changes",
      "query_guarantee",
      "at_least_one_query_of_type_2",
      "range_query",
      "operation_sequence_count",
      "bounded_queries",
      "cumulative_queries",
      "query_type_a",
      "query_type_c",
      "query_permutation",
      "usage_limit",
      "input_count_bound",
      "operation_sequence_limit",
      "read_limit",
      "query_number_limit",
      "decoding_queries",
      "median_query_limit",
      "median_query_response",
      "answer_limit",
      "single_element_query",
      "query_gpa_and_stats",
      "instruction_limit"
    ],
    "examples": []
  },
  "source_node_fixed": {
    "name": "source_node_fixed",
    "description": "在图或路径问题中，起点节点被固定不可变的约束条件",
    "aliases": [
      "start_vertex_fixed",
      "initial_state",
      "consistent_endpoints",
      "variable_order_fixed",
      "initial_ordering",
      "single_source_single_target",
      "topological_ordering",
      "placement_order",
      "start_end_fixed",
      "initial_clean_position",
      "initial_position_fixed",
      "good_vertex_existence",
      "initial_vertex_constraint",
      "start_end_constraint",
      "fixed_initial_position",
      "initial_position",
      "single_father_constraint",
      "source_sink_rule",
      "start_end_validity",
      "tree_root_fixed",
      "single_start_position",
      "single_start_end",
      "root_fixed",
      "starting_node_fixed_value",
      "initial_position_constraint",
      "single_start_point",
      "fixed_start_node",
      "start_node_inclusion",
      "initial_node_constraint",
      "initialization_constraint",
      "path_to_root",
      "root_node_fixed",
      "variable_initialization",
      "initial_configuration",
      "valid_initial_and_target",
      "path_start_fixed",
      "start_point_inclusion",
      "entry_point_selection"
    ],
    "examples": []
  },
  "hierarchical_structure": {
    "name": "hierarchical_structure",
    "description": "一种具有层级包含关系的数据结构，其中元素或区域被嵌套在更大的结构内部，常用于表示包含关系或分层组织的场景",
    "aliases": [
      "nested_rectangle",
      "nested_sequence",
      "constellation_structure",
      "nested_structure",
      "nested_inclusion",
      "classification_hierarchy",
      "nested_subsequence_selection",
      "stacked_rectangles",
      "program_structure"
    ],
    "examples": []
  },
  "circular_sequence_constraint": {
    "name": "circular_sequence_constraint",
    "description": "序列元素按环形排列的约束条件，要求首尾元素在逻辑上相邻，常用于循环结构或周期性问题中的位置关系处理",
    "aliases": [
      "circular_arrangement",
      "cyclic_rotation",
      "periodic_state_transition",
      "cyclic_advance",
      "square_rotation_restriction",
      "rotation_operation",
      "circular_structure",
      "periodic_behavior",
      "periodic_string",
      "boundary_wraparound",
      "rectangles_rotation",
      "cyclic_permutation",
      "circle_through_points",
      "circular_shift",
      "circular_subsequence",
      "toroidal_board",
      "circular_permutation",
      "circular_graph",
      "circular_adjacency",
      "toroidal_grid_movement",
      "circular_partition",
      "cyclic_pattern",
      "layered_character_matching",
      "circular_bound",
      "rotation_invariance",
      "cyclic_preference",
      "relative_position_invariance",
      "lexicographically_minimal_rotation"
    ],
    "examples": []
  },
  "undirected_graph": {
    "name": "undirected_graph",
    "description": "一种边无方向性的图结构，任意两点间的连接不区分方向，常用于表示对称关系或双向通信网络",
    "aliases": [
      "graph_structure_constraint",
      "symmetric_edge_weights",
      "undirected_edges",
      "grid_layout"
    ],
    "examples": []
  },
  "weighted_graph": {
    "name": "weighted_graph",
    "description": "一种边具有权重值的图结构，用于表示不同连接之间的成本、距离或强度，常见于最短路径、最小生成树等算法问题",
    "aliases": [
      "weighted_edges",
      "edge_labeling",
      "grid_structure",
      "cost_matrix",
      "edge_weight_manhattan_distance"
    ],
    "examples": []
  },
  "maximum_exclusion_constraint": {
    "name": "maximum_exclusion_constraint",
    "description": "对元素或集合间排除关系施加最大数量限制的约束条件，常用于限制互斥项的最大数量",
    "aliases": [
      "max_exclusion",
      "max_selection",
      "activity_repetition_upper_bound",
      "merge_limit"
    ],
    "examples": []
  },
  "non_empty_subset": {
    "name": "non_empty_subset",
    "description": "要求子集不能为空的约束条件，常用于集合划分或选择问题中确保至少包含一个元素",
    "aliases": [
      "subset_non_empty",
      "subset_selection",
      "set_size_lower_bound",
      "frame_existence_constraint",
      "non_empty_substrings",
      "non_empty_string",
      "array_empty_condition",
      "non_empty_prefix",
      "substring_non_empty",
      "non_empty_classes",
      "existence_constraint",
      "interval_empty_check",
      "missing_elements",
      "non_empty_sets",
      "no_empty_houses",
      "at_least_one_empty_vertex",
      "subgraph_size_greater_than_one"
    ],
    "examples": []
  },
  "overlapping_interval_constraint": {
    "name": "overlapping_interval_constraint",
    "description": "多个区间在数值范围上存在交集的约束条件，常用于时间重叠、资源竞争或区间覆盖问题中的重叠判断与处理",
    "aliases": [
      "interval_overlap",
      "interval_sick_status",
      "intersection_condition",
      "interval_coverage",
      "interval_counting",
      "pairwise_intersection",
      "overlapping_pairs",
      "line_coverage",
      "arbitrary_intersection",
      "intersecting_sequences_validity",
      "intersection_of_cycles",
      "overlap_point_existence",
      "overlap_constraint",
      "segment_intersection",
      "interval_intersection",
      "intersection_constraint"
    ],
    "examples": []
  },
  "path_weight_constraint": {
    "name": "path_weight_constraint",
    "description": "对路径上所有边权重之和施加特定计算或约束规则的条件，常用于路径代价评估或最优化问题中的权重累积逻辑",
    "aliases": [
      "path_weight_formula",
      "path_resource_constraint",
      "move_sequence",
      "path_length_product_maximization",
      "xor_sum_zero",
      "ticket_cost_calculation",
      "travel_time_fixed",
      "manhattan_distance_constraint",
      "xor_of_answers",
      "manhattan_distance_minimization",
      "score_accumulation",
      "cost_definition",
      "distance_constraint",
      "state_transition_cost",
      "cost_calculation",
      "path_value_minimization",
      "bounded_delay",
      "distance_metric",
      "edge_value_sum",
      "total_distance_constraint",
      "path_time_calculation",
      "max_path_difference_leq_l",
      "flow_conservation",
      "path_cost_constraint",
      "weighted_sum_constraint",
      "distance_weighted_cost",
      "path_profit_comparison",
      "edge_weight_sum_maximization",
      "edge_weight_sum",
      "path_modulo_filter",
      "path_effort_sum",
      "path_xor_sum",
      "path_weight_update",
      "edge_traversal_cost",
      "edge_weight_formula",
      "heavy_path_decomposition"
    ],
    "examples": []
  },
  "directed_complete_graph": {
    "name": "directed_complete_graph",
    "description": "一种有向图，其中每对不同的顶点之间都存在两条方向相反的边，常用于表示完全连接的有向关系场景",
    "aliases": [
      "complete_directed_graph",
      "complete_graph",
      "directed_edges",
      "bidirectional_edges"
    ],
    "examples": []
  },
  "binary_edge_weight": {
    "name": "binary_edge_weight",
    "description": "图中边的权重仅取两个离散值（如0和1）的约束条件，常用于二值化图或布尔逻辑建模",
    "aliases": [
      "edge_label_binary",
      "binary_array",
      "binary_string_constraint",
      "binary_grid",
      "switch_state_binary",
      "binary_classification",
      "binary_edge_weights",
      "lowbit_function",
      "array_element_binary"
    ],
    "examples": []
  },
  "palindromic_path": {
    "name": "palindromic_path",
    "description": "路径的节点序列或边权序列呈回文结构的约束条件，常用于对称路径构造或模式识别问题",
    "aliases": [
      "path_palindrome",
      "range_flip",
      "bitonic_sequence",
      "palindrome_constraint",
      "palindrome_recognition",
      "symmetry_constraint",
      "path_reflection",
      "concatenation_palindrome",
      "path_reversal_equivalence"
    ],
    "examples": []
  },
  "edge_repetition_permissible": {
    "name": "edge_repetition_permissible",
    "description": "允许在路径或图中重复使用同一条边的约束条件，常用于非简单路径或循环遍历场景",
    "aliases": [
      "repeated_edges_allowed",
      "repeated_operations",
      "edge_deletion_addition",
      "bidirectional_traversal",
      "repetition_allowed",
      "redundancy_tolerance",
      "no_consecutive_edge_usage"
    ],
    "examples": []
  },
  "vertex_repetition_permissible": {
    "name": "vertex_repetition_permissible",
    "description": "允许在路径中重复访问同一顶点的约束条件，常用于非简单路径或周期性遍历问题",
    "aliases": [
      "repeated_vertices_allowed",
      "person_on_street",
      "vertex_deletion",
      "point_visit_check",
      "node_alive_condition",
      "mole_movement",
      "inactive_node",
      "no_self_intersection",
      "node_type_immutable",
      "no_revisit",
      "no_duplicate_vertices",
      "no_u_turn",
      "disintegration_condition",
      "revisit_required",
      "no_repeated_visit",
      "repeated_traversal",
      "no_tunnel_reuse",
      "self_avoidance",
      "non_reentry_constraint",
      "unique_visit",
      "one_visit_per_element"
    ],
    "examples": []
  },
  "turn_based_operation": {
    "name": "turn_based_operation",
    "description": "在回合制规则下，每回合执行特定操作并限制元素或状态的更新行为，常用于模拟轮流决策或顺序控制的场景",
    "aliases": [
      "element_removal_after_turn",
      "alternating_turns",
      "elimination_process",
      "turn_based_placement",
      "fixed_number_of_rounds",
      "attempt_reset",
      "finite_game_steps",
      "turn_continuation",
      "trade_sequence",
      "turn_based_game",
      "turn_based_selection",
      "bonus_round_condition",
      "operation_interrupt",
      "turn_order_fixed",
      "turn_based_combat",
      "precedence_constraint",
      "dependency_order",
      "turn_based_move",
      "turn_based_operations",
      "turn_based_removal",
      "exercise_order",
      "turn_based_alternation",
      "elimination_order",
      "turn_based_constraint",
      "pickup_delivery_order_constraint"
    ],
    "examples": []
  },
  "distinct_transformation_cost": {
    "name": "distinct_transformation_cost",
    "description": "在变换过程中，每种变换操作的代价必须互不相同，常用于区分不同操作路径或确保唯一性代价分配的约束条件",
    "aliases": [
      "unique_transformation_cost",
      "permutation_constraint",
      "unique_insertion",
      "permutation_validity",
      "permutation_invariant",
      "distinct_operations",
      "unique_translation"
    ],
    "examples": []
  },
  "alphabet_size_constraint": {
    "name": "alphabet_size_constraint",
    "description": "对字符串中允许使用的字符种类数量施加上限的约束条件，常用于限制输入符号集大小或编码空间",
    "aliases": [
      "character_set_limit",
      "allowed_characters",
      "character_set",
      "color_range",
      "digit_set_inclusion",
      "distinct_characters",
      "digit_set_constraint"
    ],
    "examples": []
  },
  "palindromic_substring_exclusion": {
    "name": "palindromic_substring_exclusion",
    "description": "禁止字符串中出现任何回文子串的约束条件，常用于字符串构造或模式避免问题",
    "aliases": [
      "no_palindromic_substring",
      "substring_start_end_same",
      "k_palindrome_recognition",
      "palindromic_representation",
      "concatenation_palindrome",
      "palindrome_constraint",
      "non_palindromic_constraint",
      "one_deletion_palindrome",
      "lyndon_decomposition"
    ],
    "examples": []
  },
  "substring_weight_constraint": {
    "name": "substring_weight_constraint",
    "description": "对字符串中任意子串的权重或代价施加特定计算或约束规则的条件，常用于子串代价评估或优化问题中的累积逻辑",
    "aliases": [
      "substring_cost",
      "substring_constraint",
      "substring_length_sum"
    ],
    "examples": []
  },
  "minimum_spanning_tree": {
    "name": "minimum_spanning_tree",
    "description": "在加权图中寻找总权重最小的生成树，确保所有节点连通且无环的最优子图",
    "aliases": [
      "mst_definition",
      "spanning_tree_cost",
      "minimum_spanning_tree_existence",
      "spanning_tree_formation",
      "spanning_tree_weight_sum"
    ],
    "examples": []
  },
  "simple_graph": {
    "name": "simple_graph",
    "description": "一种不包含自环和多重边的图结构，保证任意两点间最多存在一条边",
    "aliases": [
      "no_loops_or_multiple_edges",
      "simple_path",
      "no_self_loops_or_multiple_edges",
      "no_duplicate_edges",
      "no_self_loops",
      "no_multiple_edges",
      "no_parallel_edges",
      "no_self_loop_constraint",
      "simple_undirected_graph",
      "no_self_loops_or_parallel_edges",
      "no_loops",
      "no_multi_edges"
    ],
    "examples": []
  },
  "spanning_tree": {
    "name": "spanning_tree",
    "description": "图的一个子图，包含所有顶点且形成一棵树，即连通、无环且边数为顶点数减一",
    "aliases": [
      "spanning_tree_definition",
      "subgraph_definition",
      "spanning_subgraph_count"
    ],
    "examples": []
  },
  "grid_dimension_constraint": {
    "name": "grid_dimension_constraint",
    "description": "对网格结构的尺寸施加偶数约束，常用于棋盘类问题中行列数为偶数的条件要求",
    "aliases": [
      "grid_even_size",
      "grid_dimensions",
      "odd_dimension",
      "frame_size_constraint",
      "pixel_side_condition",
      "grid_size_bound",
      "even_vertex_count",
      "initial_empty_grid",
      "multiple_or_square",
      "grid_boundary"
    ],
    "examples": []
  },
  "distinct_solution_constraint": {
    "name": "distinct_solution_constraint",
    "description": "要求问题仅存在唯一解的约束条件，常用于解的唯一性验证或构造问题中的确定性保障",
    "aliases": [
      "unique_solution",
      "deterministic_status",
      "valid_solution_existence",
      "distinct_assignment",
      "uniquely_identifiable",
      "winner_determination",
      "unique_closest_target",
      "unique_labeling",
      "unique_topic_inquiry",
      "draw_condition",
      "exhaustive_selection",
      "valid_k_existence",
      "unique_selection",
      "unique_solution_constraint",
      "unique_gift_target",
      "guaranteed_identification",
      "unambiguous_mapping",
      "unique_identification",
      "no_solution_constraint",
      "no_winner_condition",
      "valid_sequence_existence",
      "distinct_solutions",
      "solution_count_limit",
      "s8_completeness",
      "correct_answer_required",
      "unique_shortest_path",
      "no_solution",
      "no_solution_output",
      "answer_uniqueness",
      "unique_love",
      "uniqueness_constraint",
      "unique_solution_existence"
    ],
    "examples": []
  },
  "distinct_modulo_values": {
    "name": "distinct_modulo_values",
    "description": "要求一组数在模某个数下的余数互不相同，常用于同余类划分或唯一性约束问题",
    "aliases": [
      "distinct_remainders",
      "distinct_values",
      "distinct_leq_k",
      "k_mex_definition",
      "column_distinct_leq_2",
      "distinct_digits",
      "prime_uniqueness",
      "equal_distribution_remainder",
      "digit_frequency_constraint",
      "even_k_constraint",
      "prime_bound",
      "mex_value_sum",
      "coprime_count",
      "even_frequency_elements",
      "distinct_z_values",
      "range_value_count",
      "mex_value_constraint",
      "mex_interval_constraint"
    ],
    "examples": []
  },
  "position_constraint": {
    "name": "position_constraint",
    "description": "对元素插入位置施加的约束条件，常用于序列构造或变换中对位置选择的限制",
    "aliases": [
      "insertion_positions",
      "cursor_movement",
      "index_order",
      "placement_determination",
      "subarray_start_index_bound",
      "good_index_definition",
      "row_column_selection",
      "frame_position_constraint",
      "path_insertion",
      "placement_rule"
    ],
    "examples": []
  },
  "non_zero_count_constraint": {
    "name": "non_zero_count_constraint",
    "description": "要求序列或矩阵中非零元素的数量满足特定条件的约束，常用于稀疏性控制或元素分布分析",
    "aliases": [
      "non_zero_elements",
      "non_zero_energy_nodes",
      "array_depletion",
      "non_zero_distance_constraint",
      "no_leading_zeros",
      "count_constraint",
      "nonzero_elements",
      "zero_exclusion",
      "leading_digit_non_zero",
      "zero_detection",
      "no_zero_weight_nodes"
    ],
    "examples": []
  },
  "edge_count": {
    "name": "edge_count",
    "description": "对图中边的总数施加特定数量限制的约束条件，常用于控制图的稀疏性或连接密度",
    "aliases": [
      "array_size_relation",
      "array_length_bound",
      "array_length_constraint",
      "binary_string_length",
      "transport_limit",
      "edge_limit",
      "additional_edges_limit",
      "initial_graph_size_limit",
      "edge_count_formula",
      "pixel_switch_limit",
      "edge_count_between_vertices"
    ],
    "examples": []
  },
  "state_transition_constraint": {
    "name": "state_transition_constraint",
    "description": "对状态在不同阶段间转移规则施加的约束条件，常用于多阶段决策或动态系统中状态演变的合法性判断",
    "aliases": [
      "phase_results_constraint",
      "sequential_dependency",
      "event_sequence_processing",
      "defeat_order_dependency",
      "function_iteration_constraint",
      "transformation_rule",
      "increment_on_lane_change",
      "operation_order_dependency",
      "transformation_sequence",
      "toggle_effect",
      "dependency_satisfaction",
      "update_sequence",
      "value_change_on_transition",
      "production_dependency",
      "dependency_constraint",
      "recursive_dependency",
      "operation_validity",
      "first_time_transition",
      "transition_condition",
      "level_transition",
      "transition_rule",
      "event_sequence",
      "transformation_rule_1",
      "transformation_rule_2",
      "operation_dependency",
      "control_flow_structure",
      "cell_state_update_rule",
      "state_transition_rules",
      "operation_order_constraint",
      "suffix_dependency"
    ],
    "examples": []
  },
  "divisor_frequency_constraint": {
    "name": "divisor_frequency_constraint",
    "description": "要求某个数在序列或集合中作为因子出现特定次数的约束条件，常用于数论问题或因子分布分析",
    "aliases": [
      "divisor_occurrence",
      "polynomial_divisibility",
      "prime_divisors_subset",
      "prime_factor_limit",
      "divisor_existence",
      "sum_of_proper_divisors",
      "prime_factorization",
      "prime_factor_constraint"
    ],
    "examples": []
  },
  "xor_sum_constraint": {
    "name": "xor_sum_constraint",
    "description": "对一组数值进行异或运算后结果需满足特定条件的约束，常用于路径、子数组或状态转移中的异或累积逻辑",
    "aliases": [
      "xor_aggregation",
      "xor_operation",
      "bitwise_xor_operation",
      "xor_optimization",
      "xor_bound",
      "checksum_constraint",
      "xor_sum_zero",
      "xor_result_constraint",
      "mod_xor_sum",
      "query_range_xor_max",
      "min_max_xor",
      "xor_sum_leq_x",
      "cycle_xor_zero",
      "output_xor_sum",
      "query_result_xor"
    ],
    "examples": []
  },
  "complete_subgraph": {
    "name": "complete_subgraph",
    "description": "图中任意两个顶点之间都存在边的子图结构，常用于表示完全连接的节点集合或团块",
    "aliases": [
      "clique_structure",
      "clique_constraint"
    ],
    "examples": []
  },
  "vertex_coloring_constraint": {
    "name": "vertex_coloring_constraint",
    "description": "对图中顶点着色时满足相邻顶点颜色不同的约束条件，常用于图着色问题中的合法性判断",
    "aliases": [
      "coloring_validity",
      "color_choice_constraint",
      "color_distribution",
      "coloring_completeness",
      "coloring_constraint",
      "color_connectivity",
      "no_duplicate_color_between_vertices",
      "bipartite_coloring",
      "labeling_constraint",
      "street_responsibility",
      "color_invariant",
      "position_coloring",
      "color_consistency",
      "grid_coloring",
      "vertex_coloring",
      "triangle_coloring"
    ],
    "examples": []
  },
  "weighted_vertex_coloring": {
    "name": "weighted_vertex_coloring",
    "description": "在顶点着色过程中，考虑顶点权重并最大化或最小化总着色代价的优化约束，常用于资源分配或优先级调度中的加权着色问题",
    "aliases": [
      "max_weight_coloring",
      "coloring_cost_function"
    ],
    "examples": []
  },
  "minimum_operation_count_constraint": {
    "name": "minimum_operation_count_constraint",
    "description": "要求操作次数最小化的约束条件，常用于优化变换或构造过程中的最少步骤问题",
    "aliases": [
      "min_operations_to_multitest",
      "min_changes_to_satisfy_constraints",
      "operation_count_fixed",
      "minimize_operations",
      "min_orders_worst_case",
      "min_operations_to_empty",
      "minimal_operations",
      "min_operations_to_uniform_color",
      "minimize_damage",
      "minimal_query_set",
      "min_operations",
      "minimize_selection",
      "minimum_change",
      "worst_case_optimization",
      "total_execution_time",
      "minimization_strategy",
      "operation_count_limit",
      "minimum_operations_constraint",
      "minimize_occupied_time",
      "max_operations_limit",
      "minimize_penalty",
      "min_modifications",
      "operation_limit"
    ],
    "examples": []
  },
  "subarray_partition_constraint": {
    "name": "subarray_partition_constraint",
    "description": "对数组进行子数组划分时施加的约束条件，确保划分满足特定结构或性质要求",
    "aliases": [
      "subarray_partition",
      "block_preservation",
      "subsequence_equality",
      "area_partition",
      "range_operation",
      "substring_partition",
      "sequence_partition",
      "partitioning_constraint",
      "decomposition_constraint",
      "interval_swap",
      "rectangular_sum_query",
      "interval_partition",
      "interval_subarray"
    ],
    "examples": []
  },
  "non_decreasing_sequence": {
    "name": "non_decreasing_sequence",
    "description": "序列中元素值不递减的约束条件，常用于保证序列的单调性或有序性",
    "aliases": [
      "monotonic_sequence",
      "non_decreasing_order",
      "monotonic_increasing",
      "total_ordering",
      "valid_output_sequence",
      "lexicographical_order",
      "sequential_allocation",
      "valid_sequence_constraint",
      "sequential_selection",
      "strict_ordering",
      "sequential_processing",
      "sequential_operations",
      "lexicographic_order",
      "order_matters",
      "sorted_input",
      "radius_ordering",
      "monotonic_increasing_x",
      "arithmetic_progression",
      "strictly_increasing",
      "sequential_actions",
      "sorted_output",
      "order_preservation",
      "lexicographic_comparison",
      "subarray_sorting",
      "interval_ordering",
      "lexicographic_ordering",
      "sequential_decision",
      "increasing_subarray_length",
      "comparator_nondecreasing_order",
      "sorted_order",
      "coordinate_ordering",
      "ascending_order",
      "permutation_sorting",
      "monotonic_increase",
      "correction_ordering",
      "student_ordering",
      "consecutive_sequence",
      "strictly_increasing_time",
      "arithmetic_progression_addition",
      "arithmetic_sequence_addition",
      "non_decreasing_non_increasing_sequence",
      "height_ordering",
      "time_ordering",
      "bases_increasing_order",
      "sequence_ordering",
      "output_ordering",
      "node_ordering",
      "sorted_stack_sequence",
      "stack_ordering",
      "monotonic_path",
      "non_decreasing_non_increasing_intervals",
      "non_decreasing_pace",
      "nonincreasing_order",
      "lexicographical_ordering",
      "index_ordering",
      "convex_hull_internal_empty",
      "character_position_ordering",
      "non_decreasing_addition",
      "relative_order_constraint",
      "digit_order",
      "sorted_or_reversed",
      "strictly_increasing_after_deletions",
      "sequential_ordering",
      "non_straight_rotation",
      "consecutive_numbers_in_row",
      "value_range_continuity",
      "arithmetic_sequence",
      "group_ordering",
      "output_sorted_sequence",
      "sorted_target"
    ],
    "examples": []
  },
  "subset_inclusion": {
    "name": "subset_inclusion",
    "description": "一个集合必须是另一个集合的子集的约束条件，常用于集合关系或包含性验证场景",
    "aliases": [
      "dimension_matching",
      "subsequence_inclusion",
      "subset_constraint",
      "multiset_usage",
      "exact_coverage",
      "interval_inclusion",
      "subset_removal_constraint",
      "substring_inclusion",
      "subset_partition",
      "coverage_constraint",
      "set_generation",
      "cell_inclusion",
      "contextual_inclusion",
      "region_inclusion",
      "no_containment",
      "partition_constraint",
      "consistent_subset",
      "no_extra_courses",
      "no_missing_courses",
      "resource_partitioning",
      "coverage_inclusion",
      "path_inclusion",
      "subtree_inclusion",
      "grouping_constraint",
      "containment_constraint",
      "permutation_inclusion",
      "forced_inclusion",
      "specific_elements_inclusion",
      "conditional_inclusion",
      "subset_relationship",
      "connected_subset_inclusion"
    ],
    "examples": []
  },
  "distinct_topic_count_constraint": {
    "name": "distinct_topic_count_constraint",
    "description": "要求每个学生涉及的主题数量互不相同，常用于学生主题分配或查询中的唯一性约束",
    "aliases": [
      "distinct_topics_per_student",
      "min_colorfulness",
      "distinct_difficulty"
    ],
    "examples": []
  },
  "cyclic_path_length_constraint": {
    "name": "cyclic_path_length_constraint",
    "description": "对环形路径长度施加特定限制的约束条件，常用于循环结构或周期性问题中的路径长度控制",
    "aliases": [
      "cycle_length_constraint",
      "time_window_constraint",
      "periodic_cost",
      "closed_path",
      "periodic_movement",
      "periodic_path",
      "periodicity_constraint",
      "cyclic_movement",
      "start_end_same_node",
      "cyclic_elimination",
      "reflection_limit",
      "circular_path_divisibility",
      "month_transition",
      "year_transition",
      "start_end_same",
      "cyclic_path",
      "hamiltonian_cycle",
      "cyclic_operations",
      "cycle_existence",
      "circular_path",
      "time_travel_constraint",
      "eulerian_circuit",
      "cycle_start_end",
      "return_to_initial_state"
    ],
    "examples": []
  },
  "character_transformation_rule": {
    "name": "character_transformation_rule",
    "description": "对字符进行翻转或变换操作的规则，常用于字符串构造或对称性处理中的字符状态改变",
    "aliases": [
      "character_flip",
      "swappable_characters",
      "flip_operation",
      "direction_replacement",
      "conversion_rule",
      "character_replacement",
      "variable_renaming"
    ],
    "examples": []
  },
  "substring_merge_operation": {
    "name": "substring_merge_operation",
    "description": "将多个子串按特定顺序连接形成新字符串的操作规则，常用于字符串拼接或序列重构问题",
    "aliases": [
      "substring_concatenation",
      "segment_folding",
      "concatenation_operation",
      "merge_operation",
      "concatenation_constraint",
      "string_composition",
      "concatenation_division"
    ],
    "examples": []
  },
  "lowest_common_ancestor_comparison": {
    "name": "lowest_common_ancestor_comparison",
    "description": "对两个节点在树结构中最低公共祖先的比较关系施加约束或判断条件，常用于路径查询、子树包含或层次关系验证问题",
    "aliases": [
      "lca_comparison",
      "ancestor_definition",
      "distinct_names_k_ancestors",
      "ancestor_range_query",
      "ancestor_relationship",
      "gift_target_ancestor",
      "move_ancestor_descendant",
      "lca_depth_sum",
      "ancestor_constraint"
    ],
    "examples": []
  },
  "substring_balance_constraint": {
    "name": "substring_balance_constraint",
    "description": "要求字符串中所有子序列的某种平衡属性（如左右括号数量相等、字符频次对称）的约束条件，常用于字符串构造或模式匹配中的对称性验证",
    "aliases": [
      "balanced_subsequences",
      "balanced_sequence",
      "line_balance",
      "subarray_dominance",
      "balanced_parentheses",
      "balanced_substrings",
      "valid_parentheses_subsequence",
      "parentheses_usage",
      "valid_parentheses_sequence"
    ],
    "examples": []
  },
  "even_number_constraint": {
    "name": "even_number_constraint",
    "description": "对数值集合中偶数元素的出现或分布施加约束的条件，常用于数论问题或序列构造中的奇偶性控制",
    "aliases": [
      "even_numbers",
      "even_digit_presence"
    ],
    "examples": []
  },
  "query_range_validity": {
    "name": "query_range_validity",
    "description": "对查询操作所作用的索引范围是否合法进行判断的约束条件，常用于确保查询在有效数据区间内执行",
    "aliases": [
      "valid_query_range",
      "valid_query_response",
      "interval_validity",
      "interval_query",
      "range_query",
      "range_validity",
      "query_validity",
      "query_interval_validity",
      "reference_validity",
      "validity_check",
      "query_boundaries",
      "range_start_valid",
      "dynamic_query_boundaries",
      "path_query_validity",
      "path_query"
    ],
    "examples": []
  },
  "edge_coloring": {
    "name": "edge_coloring",
    "description": "对图中边进行着色时，要求相邻边颜色不同的约束条件，常用于图着色问题中的边合法性判断或冲突避免场景",
    "aliases": [
      "edge_partition",
      "binary_coloring",
      "edge_coloring_constraint",
      "color_change_validity"
    ],
    "examples": []
  },
  "pairwise_gcd_constraint": {
    "name": "pairwise_gcd_constraint",
    "description": "对每一对元素的值施加最大公约数约束的条件，常用于数论问题中元素间互质性或公因数控制的场景",
    "aliases": [
      "pairwise_gcd",
      "movement_vector_coprime",
      "pairwise_coprime",
      "subset_sum_gcd"
    ],
    "examples": []
  },
  "triple_sum_constraint": {
    "name": "triple_sum_constraint",
    "description": "对三个元素之和施加特定数值约束的条件，常用于三元组组合、子数组或状态转移中的总和限制问题",
    "aliases": [
      "triple_combination_sum",
      "subsequence_triplets",
      "triple_selection",
      "triple_pattern_constraint"
    ],
    "examples": []
  },
  "complementary_edge_set": {
    "name": "complementary_edge_set",
    "description": "图中所有不存在于原图中的边构成的集合，常用于补图构造或边集对称性分析",
    "aliases": [
      "edge_complement",
      "non_tree_edge_set",
      "edge_grouping",
      "set_difference",
      "unique_edge_set"
    ],
    "examples": []
  },
  "distinct_permutation": {
    "name": "distinct_permutation",
    "description": "要求排列中所有元素的顺序互不相同，常用于排列生成或唯一性验证场景",
    "aliases": [
      "permutation_distinctness",
      "permutation_validity",
      "permutation_structure",
      "permutation_constraint",
      "permutation_invariance",
      "distinct_permutations",
      "initial_permutation",
      "permutation_length_odd"
    ],
    "examples": []
  },
  "edge_weight_decrease": {
    "name": "edge_weight_decrease",
    "description": "边权重在路径或操作过程中逐次减小的约束条件，常用于模拟损耗、衰减或递减过程中的图结构演化",
    "aliases": [
      "damage_decrement",
      "fuel_tank_usage_constraint",
      "element_decrease_limit",
      "capacity_constraint",
      "capacity_limit",
      "damage_transition",
      "damage_accumulation",
      "health_depletion",
      "health_depletion_condition",
      "weight_decrease",
      "fuel_consumption_rate",
      "edge_length_adjustment",
      "decay_constraint",
      "path_weight_increment"
    ],
    "examples": []
  },
  "beauty_minimization": {
    "name": "beauty_minimization",
    "description": "对某种美观性度量施加最小化约束的条件，常用于优化问题中追求结构或排列的视觉或逻辑美感",
    "aliases": [
      "total_angriness_minimization",
      "beauty_definition",
      "subsequence_beauty_query",
      "beauty_value_fixed",
      "happiness_definition",
      "max_beauty_per_difficulty",
      "quality_metric",
      "subset_beauty",
      "max_min_beauty"
    ],
    "examples": []
  },
  "operation_independence": {
    "name": "operation_independence",
    "description": "多个操作之间互不依赖、可并行执行的约束条件，常用于并发系统或独立决策场景中的行为模式建模",
    "aliases": [
      "independent_operations",
      "single_action_per_stop",
      "no_reassignment",
      "removal_strategy",
      "operation_sequence",
      "single_operation_per_position",
      "valid_removal",
      "non_overlapping_operations",
      "order_independence",
      "discard_on_full_hand",
      "independent_random_variables",
      "operation_constraints",
      "valid_operation",
      "valid_operations",
      "independent_selection",
      "independent_probability"
    ],
    "examples": []
  },
  "directed_acyclic_graph": {
    "name": "directed_acyclic_graph",
    "description": "一种有向图，其中不存在任何环路，常用于表示任务依赖、拓扑排序或因果关系的层次结构",
    "aliases": [
      "no_cycles",
      "acyclic_graph",
      "directional_transport",
      "acyclic_dependency",
      "text_non_looping",
      "acyclic_network",
      "topological_ordering",
      "partial_ordering",
      "topological_sequence",
      "acyclicity",
      "directed_graph",
      "directed_edge_constraint"
    ],
    "examples": []
  },
  "continuous_path_constraint": {
    "name": "continuous_path_constraint",
    "description": "路径中节点或边的连接必须保持连续性，不允许跳跃或中断的约束条件，常用于保证路径的完整性和逻辑连贯性",
    "aliases": [
      "path_continuity",
      "sliding_operation_validity",
      "adjacent_cells_path",
      "consecutive_trips",
      "move_validity",
      "continuous_time_constraint",
      "path_execution",
      "consecutive_selection",
      "grid_traversal",
      "grid_movement",
      "sequential_availability",
      "sequence_continuity",
      "path_sequence",
      "sequential_jumps",
      "task_continuity",
      "sequential_visit",
      "sequential_ignition",
      "consecutive_subset",
      "consecutive_subsequence",
      "contiguous_empty_space",
      "sequential_build",
      "non_empty_path",
      "sequential_action",
      "hypotenuse_continuity",
      "contiguous_range_validity",
      "move_constraint",
      "sequential_operations",
      "sequential_access",
      "segment_validity",
      "movement_constraint",
      "contiguous_subarray",
      "contiguous_subsequence",
      "simple_path_movement"
    ],
    "examples": []
  },
  "endpoint_node_constraint": {
    "name": "endpoint_node_constraint",
    "description": "对路径起点或终点节点施加特定属性或位置限制的约束条件，常用于图结构中端点的固定或唯一性要求",
    "aliases": [
      "terminal_platform",
      "path_graph_target",
      "sink_condition",
      "start_end_height_zero",
      "goal_reach",
      "endpoints_fixed",
      "mandatory_stops",
      "start_position_exclusion",
      "safe_zone_reach",
      "end_access_only",
      "target_reach",
      "complete_stop_at_endpoints",
      "start_end_at_zero",
      "return_statement_placement",
      "entry_exit_constraint"
    ],
    "examples": []
  },
  "prefix_sum_constraint": {
    "name": "prefix_sum_constraint",
    "description": "对前缀和序列施加一致性或特定数值约束的条件，常用于保证数组或序列中累积值满足预定规律或边界要求",
    "aliases": [
      "consistent_prefix_sum",
      "left_visibility",
      "visibility_constraint",
      "prefix_sum_equality",
      "prefix_numeric_constraint",
      "prefix_encoding",
      "subsequence_encoding",
      "prefix_sum_non_negative",
      "prefix_max",
      "power_accumulation",
      "range_sum_query",
      "prefix_constraint",
      "prefix_suffix_selection",
      "subarray_sum_positive",
      "global_addition",
      "sum_query"
    ],
    "examples": []
  },
  "distinct_operation_types_constraint": {
    "name": "distinct_operation_types_constraint",
    "description": "对操作类型数量施加上限的约束条件，常用于限制不同操作种类的多样性或避免过度复杂化操作序列",
    "aliases": [
      "operation_type_limit",
      "locked_elements_count",
      "availability_constraint",
      "no_repeat_selection",
      "single_candy_per_cell",
      "distinct_selection_limit",
      "swap_limit",
      "set_size_upper_bound",
      "unique_cards",
      "exactly_two_removals",
      "single_activation_constraint",
      "single_selection",
      "stamp_requirement",
      "one_per_type_limit",
      "operation_limit",
      "unique_edge_removal",
      "unique_fuse_usage",
      "distinct_threads",
      "medal_count_limit",
      "card_usage_limit",
      "selection_limit",
      "key_number_constraint",
      "operation_set_constraint",
      "distinct_pairs_leq_k",
      "operator_count",
      "distinct_selection",
      "target_selection_limit",
      "unique_key_usage",
      "modification_limit",
      "rearrangement_limit",
      "distinct_insertion",
      "method_count"
    ],
    "examples": []
  },
  "suffix_sum_constraint": {
    "name": "suffix_sum_constraint",
    "description": "对后缀和序列施加一致性或特定数值约束的条件，常用于保证数组或序列中累积值从末尾开始满足预定规律或边界要求",
    "aliases": [
      "right_visibility",
      "suffix_max",
      "last_character_extraction"
    ],
    "examples": []
  },
  "maximize_bitwise_or_sum": {
    "name": "maximize_bitwise_or_sum",
    "description": "对一组数值进行按位或运算后结果的总和施加最大化目标的优化约束，常用于在二进制表示下最大化信息覆盖或状态可达性的场景",
    "aliases": [
      "bitwise_or_sum_maximization",
      "xor_beauty_maximization",
      "bitwise_or_greater_than_max",
      "max_xor_value"
    ],
    "examples": []
  },
  "minimum_trailing_zeros": {
    "name": "minimum_trailing_zeros",
    "description": "要求序列或数值中末尾零的个数最小化的约束条件，常用于二进制表示或数字构造中的尾随零优化",
    "aliases": [
      "min_trailing_zeros"
    ],
    "examples": []
  },
  "minimum_weight_above_threshold": {
    "name": "minimum_weight_above_threshold",
    "description": "在一组权重中选择大于某个阈值的最小权重，并对其进行约束或优化的条件，常用于路径选择或资源分配中的下界控制",
    "aliases": [
      "min_weight_over_k",
      "min_total_weight",
      "minimum_total_weight",
      "minimize_unused_capacity",
      "depletion_threshold",
      "initial_fuel_constraint"
    ],
    "examples": []
  },
  "sum_of_minimum_weights": {
    "name": "sum_of_minimum_weights",
    "description": "对多个子集或路径中各自最小权重的总和施加约束或优化目标的条件，常用于多组选择中的累积代价最小化问题",
    "aliases": [
      "sum_of_min_weights",
      "min_weight_sum",
      "total_sum_invariant",
      "sum_of_max_element_functions",
      "sum_of_f_values",
      "subset_weight_sum"
    ],
    "examples": []
  },
  "adaptive_interactor": {
    "name": "adaptive_interactor",
    "description": "一种根据前序交互结果动态调整后续行为或策略的交互机制，常用于自适应算法或在线决策系统中",
    "aliases": [
      "alternating_optimization",
      "alternating_selection",
      "lru_replacement",
      "recent_element_priority",
      "priority_removal",
      "interactive_flush",
      "dynamic_array_modification",
      "alice_operation",
      "bob_operation",
      "parent_reassignment",
      "dynamic_update",
      "online_query_modification",
      "dynamic_sequence_operations",
      "online_query",
      "replacement_policy",
      "online_processing"
    ],
    "examples": []
  },
  "pairwise_success": {
    "name": "pairwise_success",
    "description": "一对元素之间成功匹配或达成目标状态的约束或条件，常用于成对关系中的有效性验证或成功判定场景",
    "aliases": [],
    "examples": []
  },
  "trial_limit": {
    "name": "trial_limit",
    "description": "对尝试次数施加上限的约束条件，常用于限制算法或过程的迭代次数以控制资源消耗或避免无限循环",
    "aliases": [
      "time_limit",
      "processing_limit",
      "attempt_limit",
      "max_walks_limit",
      "game_termination",
      "execution_limit",
      "round_limit"
    ],
    "examples": []
  },
  "non_negative_values": {
    "name": "non_negative_values",
    "description": "对数值集合中所有元素的取值施加非负性约束的条件，常用于限制输入或状态值的下界",
    "aliases": [
      "positive_values",
      "positive_elements",
      "non_negative_step",
      "coordinate_non_negative",
      "non_negative_flow",
      "non_negative_requirement",
      "capacity_flow_non_negative",
      "negative_condition",
      "non_negative_condition",
      "non_negative_balance",
      "positive_integers_only",
      "non_negative_integers",
      "non_negative_profit",
      "non_negative_score",
      "non_negative_solution",
      "integer_movement",
      "non_negative_capacity",
      "non_negative_initial_matrix",
      "non_negative_integer_score",
      "non_negative_interval",
      "non_negative_elements",
      "non_negative_sum",
      "cell_value_sign_constraint",
      "non_negative_coordinates",
      "positive_addition",
      "all_positive_constraint",
      "non_negative_weights",
      "non_negative_bet",
      "uninitialized_variable",
      "non_negative_constraint",
      "non_negative_inventory",
      "negative_energy_allowed",
      "positive_integer_constraint",
      "negative_result_adjustment",
      "input_positive_integer",
      "non_negative_integer_solution"
    ],
    "examples": []
  },
  "target_sequence": {
    "name": "target_sequence",
    "description": "在字符串或序列变换问题中，期望达到的最终目标状态或结果序列，常用于约束变换过程的终点条件",
    "aliases": [
      "target_string",
      "final_state_equality",
      "zero_target",
      "state_matching",
      "final_state_constraint",
      "collect_all_items",
      "correct_answer",
      "output_match_input"
    ],
    "examples": []
  },
  "operation_cost": {
    "name": "operation_cost",
    "description": "执行某项操作所需付出的代价或开销，常用于优化问题中对操作路径或策略的代价评估与最小化",
    "aliases": [
      "transformation_cost",
      "lives_loss_constraint",
      "character_replacement_cost",
      "switch_cost",
      "merge_cost",
      "cost_per_operation",
      "resource_consumption",
      "fixed_cost",
      "cost_calculation"
    ],
    "examples": []
  },
  "wave_propagation_constraint": {
    "name": "wave_propagation_constraint",
    "description": "描述波状扩散过程在网格或图结构中传播的约束条件，常用于模拟爆炸、信号或影响范围的扩散行为",
    "aliases": [
      "blast_wave_propagation",
      "infection_spread",
      "wave_propagation_condition",
      "expansion_wave_effect",
      "blast_radius_constraint",
      "chain_reaction",
      "simultaneous_explosion",
      "spreading_constraint",
      "signal_propagation"
    ],
    "examples": []
  },
  "cell_clearance_rule": {
    "name": "cell_clearance_rule",
    "description": "对网格中特定单元格清除操作施加的规则或约束，常用于状态重置、区域清理或路径释放场景",
    "aliases": [
      "clear_cells",
      "falling_death",
      "dead_group_removal",
      "stone_removal",
      "column_clearing",
      "row_clearing",
      "cluster_removal",
      "range_emptying"
    ],
    "examples": []
  },
  "distinct_bomb_locations": {
    "name": "distinct_bomb_locations",
    "description": "要求炸弹在网格或空间中放置位置互不相同的约束条件，常用于避免重复部署或冲突配置",
    "aliases": [
      "distinct_bomb_positions",
      "unique_placement",
      "unique_input_output_mapping",
      "key_treasure_distinctness"
    ],
    "examples": []
  },
  "lcm_equals_maximum": {
    "name": "lcm_equals_maximum",
    "description": "一组数的最小公倍数等于其中最大值的约束条件，常用于数论问题中关于整除性与最大值关系的特殊构造场景",
    "aliases": [
      "lcm_equals_max"
    ],
    "examples": []
  },
  "persistent_preference_constraint": {
    "name": "persistent_preference_constraint",
    "description": "一种状态或偏好一旦被接受则始终维持不变的约束条件，常用于模拟用户偏好、记忆机制或不可逆选择中的持续性行为",
    "aliases": [
      "once_liked_always_liked",
      "loyalty_definition",
      "unique_pairing_over_time",
      "event_persistence",
      "persistent_modification",
      "structure_preference"
    ],
    "examples": []
  },
  "valid_position_count": {
    "name": "valid_position_count",
    "description": "对有效位置数量施加约束或统计的条件，常用于网格或序列中满足特定规则的位置计数问题",
    "aliases": [
      "good_position_count",
      "subsequence_validity",
      "feasible_treasure_location",
      "move_legality",
      "valid_move_constraint",
      "position_count_leq_s",
      "valid_move"
    ],
    "examples": []
  },
  "submatrix_transformation": {
    "name": "submatrix_transformation",
    "description": "对子矩阵进行翻转、旋转或逆序等变换操作的抽象规则，常用于矩阵重构或对称性处理中的子区域状态改变",
    "aliases": [
      "submatrix_inversion",
      "submatrix_swap",
      "rectangular_cutting",
      "subgrid_match",
      "polygon_cutting",
      "reverse_even_positions",
      "transform_rule",
      "segment_inversion"
    ],
    "examples": []
  },
  "distinct_adjacent_nodes": {
    "name": "distinct_adjacent_nodes",
    "description": "要求每个节点的相邻节点在集合中互不相同，常用于避免重复邻接或确保邻接关系唯一性的图结构约束",
    "aliases": [
      "unique_adjacent_node",
      "no_initial_or_final_lead",
      "unique_edges",
      "unique_connection_constraint",
      "distinct_adjacent_points",
      "unique_parent",
      "distinct_rows_and_columns"
    ],
    "examples": []
  },
  "subtree_color_count": {
    "name": "subtree_color_count",
    "description": "对子树中不同颜色数量的约束或统计条件，常用于树结构中子树着色的多样性分析或计数问题",
    "aliases": [],
    "examples": []
  },
  "minimum_maximum_constraint": {
    "name": "minimum_maximum_constraint",
    "description": "对一组数值中最小值与最大值之间的关系施加特定约束的条件，常用于优化问题中对极值差或极值比例的控制",
    "aliases": [
      "min_max_relation",
      "min_max_element",
      "min_element_combination",
      "max_min_diff_leq_a",
      "max_min_diff_leq_d",
      "ratio_constraint",
      "min_max_cost",
      "min_max_distance",
      "minimize_max_min_diff",
      "min_max_ratio",
      "max_min_ratio",
      "min_max_impression",
      "min_max_displacement",
      "score_difference",
      "minimize_max_height"
    ],
    "examples": []
  },
  "maximize_sum_of_squared_distances": {
    "name": "maximize_sum_of_squared_distances",
    "description": "对一组点之间两两欧几里得距离的平方和施加最大化目标的优化约束，常用于几何布局或空间分布中的最大分散性设计",
    "aliases": [],
    "examples": []
  },
  "substring_replacement_rule": {
    "name": "substring_replacement_rule",
    "description": "在字符串中对子串进行替换操作的规则，常用于模式匹配、模板填充或文本重构中的替换逻辑",
    "aliases": [
      "replacement_rule",
      "digit_replacement",
      "range_replacement",
      "mumble_replacement",
      "substring_extraction",
      "substring_replacement"
    ],
    "examples": []
  },
  "order_statistics_constraint": {
    "name": "order_statistics_constraint",
    "description": "对序列中第k小元素施加的约束或选择条件，常用于顺序统计量问题中的位置选择与排序控制",
    "aliases": [
      "kth_smallest_constraint",
      "team_formation_order",
      "kth_smallest_element",
      "kth_largest_element",
      "vertex_selection_order",
      "kth_order_statistic",
      "median_query",
      "collision_ordering"
    ],
    "examples": []
  },
  "value_range_constraint": {
    "name": "value_range_constraint",
    "description": "对数值取值施加上限的约束条件，常用于限制变量或元素的最大可能值",
    "aliases": [
      "upper_bound_constraint",
      "area_upper_bound",
      "value_range_bound",
      "max_value_bound",
      "base_and_divisor_bound",
      "element_value_bound",
      "valid_year_range",
      "base_range",
      "representation_base_range",
      "year_range",
      "value_upper_bound",
      "value_range",
      "weight_range_constraint",
      "line_value_range",
      "threshold_condition",
      "score_threshold",
      "integer_range",
      "scaling_factor_range",
      "function_value_constraint",
      "elements_within_range",
      "nan_comparison",
      "threshold_constraint",
      "random_missing_values",
      "value_clamping",
      "height_upper_bound",
      "range_bound",
      "exponent_bound",
      "sequence_value_range",
      "value_range_limit",
      "element_bound",
      "input_bit_bound",
      "register_index_bound",
      "shift_value_bound"
    ],
    "examples": []
  },
  "alternating_sequence_constraint": {
    "name": "alternating_sequence_constraint",
    "description": "对序列中元素值呈现波浪形变化（即交替上升与下降）的约束条件，常用于构造具有特定波动模式的序列",
    "aliases": [
      "wavy_number_constraint",
      "alternating_sequence",
      "alternating_movement",
      "alternating_path",
      "alternating_elements",
      "oscillating_subsequence",
      "alternating_fixed_elements"
    ],
    "examples": []
  },
  "distinct_vertex_colorings": {
    "name": "distinct_vertex_colorings",
    "description": "要求图中所有顶点着色方案互不相同的约束条件，常用于计数问题或唯一性验证场景中的着色配置枚举",
    "aliases": [
      "distinct_colorings",
      "distinct_positions",
      "distinct_important_nodes",
      "all_unlocked_condition",
      "exact_k_colors",
      "distinct_values_per_node",
      "coloring_count_constraint",
      "distinct_vertices",
      "distinct_labels",
      "no_repetition",
      "distinct_levels",
      "distinct_destinations",
      "distinct_color_count",
      "color_count_query",
      "distinct_endpoints",
      "distinct_non_zero_colors_per_row_and_column"
    ],
    "examples": []
  },
  "substring_matching_constraint": {
    "name": "substring_matching_constraint",
    "description": "对字符串中子串与模式之间的匹配关系施加约束或判断条件，常用于模糊匹配、通配符匹配或模板填充场景中的匹配逻辑控制",
    "aliases": [
      "pattern_matching",
      "substring_match",
      "suffix_matching",
      "longest_common_prefix",
      "substring_matching",
      "string_similarity",
      "matching_characters",
      "research_recall",
      "prefix_suffix_match"
    ],
    "examples": []
  },
  "distinct_positions": {
    "name": "distinct_positions",
    "description": "要求序列或字符串中每个字符的位置在集合中互不相同，常用于保证字符分布的唯一性或避免重复位置的约束条件",
    "aliases": [
      "unique_character_position",
      "distinct_initial_positions",
      "unique_points",
      "distinct_elements",
      "unique_positions",
      "unique_element_indexing",
      "distinct_points",
      "initial_position_distinct",
      "unique_indexing",
      "distinct_start_positions",
      "distinct_coordinates",
      "unique_targets",
      "vertices_distinct",
      "distinct_holes",
      "unique_tiles",
      "row_column_uniqueness",
      "day_selection",
      "non_consecutive_selection",
      "position_uniqueness",
      "distinct_indices",
      "distinct_bottles",
      "unique_coordinates",
      "coordinate_uniqueness",
      "single_occupancy"
    ],
    "examples": []
  },
  "equal_segment_length": {
    "name": "equal_segment_length",
    "description": "要求多个线段或子序列长度相等的约束条件，常用于分块处理、对齐结构或均匀划分问题中的长度一致性控制",
    "aliases": [
      "line_length_equality",
      "equal_length",
      "equal_length_strings",
      "equal_partition_size",
      "equal_length_subarrays",
      "interval_uniformity",
      "rectangular_alignment",
      "same_height_constraint",
      "partition_length_equality",
      "array_length_equality"
    ],
    "examples": []
  },
  "delimiter_inclusion_constraint": {
    "name": "delimiter_inclusion_constraint",
    "description": "要求在字符串或序列中必须包含特定分隔符的约束条件，常用于格式验证、结构分割或分组逻辑中的必要元素存在性判断",
    "aliases": [
      "separator_inclusion",
      "hyphen_placement"
    ],
    "examples": []
  },
  "initial_state_connectivity": {
    "name": "initial_state_connectivity",
    "description": "在初始状态下，各状态之间必须保持连通性的约束条件，常用于多阶段系统或状态转移图中的初始连通性要求",
    "aliases": [
      "initial_connectivity_within_states",
      "empty_initial_final_state",
      "initial_stability",
      "initial_state",
      "initial_state_off",
      "initial_conditions",
      "initial_final_state",
      "initial_keys_availability",
      "initial_configuration_generation",
      "initial_configuration"
    ],
    "examples": []
  },
  "minimum_road_cost": {
    "name": "minimum_road_cost",
    "description": "对道路建设总成本施加最小化目标的约束条件，常用于路径规划或网络构建问题中的资源优化",
    "aliases": [
      "minimum_road_construction",
      "cost_minimization",
      "transport_cost_constraint"
    ],
    "examples": []
  },
  "valid_cell_only_constraint": {
    "name": "valid_cell_only_constraint",
    "description": "仅允许在有效单元格上进行操作或移动的约束条件，常用于网格类问题中排除无效位置的规则",
    "aliases": [
      "passable_cells_only",
      "piece_movement_rules",
      "stack_validity",
      "empty_tile_ignorance",
      "walkable_space",
      "bottle_id_validity"
    ],
    "examples": []
  },
  "subtree_string_distinctness": {
    "name": "subtree_string_distinctness",
    "description": "要求在树结构的每个子树中，所有字符串互不相同，常用于子树内字符串唯一性验证或去重约束",
    "aliases": [
      "distinct_strings_in_subtree",
      "subtree_coverage"
    ],
    "examples": []
  },
  "maximum_value_and_frequency": {
    "name": "maximum_value_and_frequency",
    "description": "对序列或集合中最大值及其出现次数施加联合约束或统计条件，常用于极值分析与频次控制问题",
    "aliases": [
      "max_value_and_count",
      "max_element_combination",
      "max_cost_selection",
      "bounded_change",
      "path_interestingness",
      "max_element_in_range",
      "sum_of_maxima",
      "max_value_count"
    ],
    "examples": []
  },
  "minimum_element_count_constraint": {
    "name": "minimum_element_count_constraint",
    "description": "对集合或子集中元素数量施加最小值限制的约束条件，常用于保证至少包含一定数量的元素以满足问题规模或结构要求",
    "aliases": [
      "min_element_count",
      "part_lower_bound",
      "team_size_fixed",
      "subset_size_constraint",
      "subset_size_limit",
      "min_value_constraint",
      "total_elements_fixed",
      "size_lower_bound",
      "k_not_greater_than_current_size",
      "at_least_one_element",
      "subset_size_fixed",
      "minimum_change_value",
      "activity_count_lower_bound",
      "total_elements_to_collect",
      "fixed_element_count",
      "min_distinct_values"
    ],
    "examples": []
  },
  "minimum_sum_constraint": {
    "name": "minimum_sum_constraint",
    "description": "对一组数值的总和施加最小化目标或下限约束的条件，常用于优化问题中确保总值不低于某个阈值或最小累积量",
    "aliases": [
      "min_sum_of_elements",
      "sum_constraint",
      "minimize_remaining_coverage",
      "min_waste_optimization",
      "modulo_sum_minimization",
      "sum_threshold",
      "min_addition_sum",
      "sum_threshold_constraint",
      "min_value_scoring"
    ],
    "examples": []
  },
  "product_divisibility_constraint": {
    "name": "product_divisibility_constraint",
    "description": "对多个数的乘积施加可被某数整除的约束条件，常用于数论问题中关于整除性与乘积性质的构造或验证场景",
    "aliases": [
      "product_divisibility",
      "divisibility_constraint"
    ],
    "examples": []
  },
  "minimum_product_constraint": {
    "name": "minimum_product_constraint",
    "description": "对一组数值的乘积施加最小化目标或下限约束的条件，常用于优化问题中确保乘积不低于某个阈值或最小累积量",
    "aliases": [
      "product_minimization"
    ],
    "examples": []
  },
  "balanced_flow_constraint": {
    "name": "balanced_flow_constraint",
    "description": "要求在图或网络中，每个节点的流入量与流出量相等，常用于模拟供需平衡、流量守恒或资源分配中的平衡性问题",
    "aliases": [
      "supply_demand_balance",
      "excess_water_to_sea",
      "flow_distribution",
      "fairness_constraint",
      "increment_decrement_balance",
      "no_leakage",
      "balance_constraint",
      "flow_conservation"
    ],
    "examples": []
  },
  "region_size_constraint": {
    "name": "region_size_constraint",
    "description": "对区域或子区域大小施加特定限制的约束条件，常用于网格、几何或划分问题中对面积、范围或尺寸的控制",
    "aliases": [
      "area_constraint",
      "area_sum_constraint",
      "geometric_coverage",
      "rectangular_coverage",
      "coverage_constraint",
      "region_size_fixed",
      "subarea_size_constraint",
      "rectangular_bound",
      "boundary_filled_cells",
      "bounded_area",
      "area_calculation"
    ],
    "examples": []
  },
  "maximum_distance_constraint": {
    "name": "maximum_distance_constraint",
    "description": "对路径或图中任意两点间最大距离施加特定限制的约束条件，常用于最远距离控制、网络覆盖范围或直径优化问题中的距离上限设定",
    "aliases": [
      "max_distance_classes",
      "max_distance_constraint",
      "distance_upper_bound",
      "distance_limit",
      "distance_to_farthest_treasure",
      "sum_of_distances_leq_r",
      "max_radius_definition",
      "snow_depth_limit",
      "distance_bound",
      "fixed_radius",
      "max_distance_to_nearest_point"
    ],
    "examples": []
  },
  "uniform_movement": {
    "name": "uniform_movement",
    "description": "物体或粒子在运动过程中保持速度大小和方向不变的约束条件，常用于物理模拟或路径规划中的匀速直线运动建模",
    "aliases": [
      "constant_velocity",
      "gravity_effect",
      "constant_speed",
      "axis_parallel_movement",
      "bounded_speed",
      "lid_movement_constraint",
      "instant_velocity_change",
      "fixed_step_size",
      "straight_line_path",
      "alignment_constraint",
      "no_downward_movement",
      "continuous_movement",
      "non_zero_velocity",
      "constant_speed_constraint",
      "straight_line_movement"
    ],
    "examples": []
  },
  "non_prime_digit_constraint": {
    "name": "non_prime_digit_constraint",
    "description": "对数字中非素数位（如0,1,4,6,8,9）的出现或分布施加约束的条件，常用于数位构造或数值特征分析中的非素数位控制",
    "aliases": [
      "non_prime_digits",
      "composite_number_constraint"
    ],
    "examples": []
  },
  "maximum_movement_constraint": {
    "name": "maximum_movement_constraint",
    "description": "对移动操作次数或范围施加上限的约束条件，常用于限制角色或实体在路径或网格中的最大移动步数或活动范围",
    "aliases": [
      "shepherd_movement_limit",
      "move_limit",
      "termination_condition",
      "segment_movement_limit",
      "move_sprint_range",
      "position_shift_limit",
      "movement_limit",
      "step_size_limit",
      "movement_constraint",
      "step_change_limit",
      "step_limit",
      "move_count_bound"
    ],
    "examples": []
  },
  "substring_divisibility_constraint": {
    "name": "substring_divisibility_constraint",
    "description": "要求字符串中任意子串的数值或其某种属性满足特定整除性条件的约束，常用于数位构造或字符串性质分析中的可除性判断",
    "aliases": [
      "substring_divisibility"
    ],
    "examples": []
  },
  "subtree_product_modulo": {
    "name": "subtree_product_modulo",
    "description": "对树结构中每个子树内所有节点值乘积在模某个数下的结果施加约束或计算的条件，常用于数论问题或递归结构中的模运算性质分析",
    "aliases": [
      "subtree_product"
    ],
    "examples": []
  },
  "pattern_filling_constraint": {
    "name": "pattern_filling_constraint",
    "description": "对序列或区域中填充模式施加的规则或约束，常用于构造具有特定重复、对称或周期性填充结构的问题",
    "aliases": [
      "filling_pattern",
      "grid_filling",
      "complete_filling",
      "submatrix_pattern_exclusion",
      "full_pattern_constraint",
      "sequential_filling"
    ],
    "examples": []
  },
  "distinct_subset_selection": {
    "name": "distinct_subset_selection",
    "description": "要求从集合中选择的子集在内容或结构上互不相同，常用于组合生成、唯一性验证或避免重复选择的场景",
    "aliases": [
      "subset_selection",
      "exact_k_elements",
      "distinct_query_sets",
      "distinct_datasets",
      "distinct_grouping_schemes",
      "set_equality",
      "single_hidden_element",
      "subset_prediction_limit",
      "subset_size_limit",
      "unique_selection",
      "distinct_subsets",
      "complete_readings",
      "partition_count",
      "unique_coverage",
      "bounded_selection",
      "distinct_keys",
      "subsequence_selection",
      "group_assignment",
      "distinct_combinations"
    ],
    "examples": []
  },
  "pairwise_sum_maximization": {
    "name": "pairwise_sum_maximization",
    "description": "对每一对元素的值之和施加最大化目标的优化约束，常用于成对关系中总和最大化的场景",
    "aliases": [
      "pairwise_sum_constraint",
      "maximize_pairs"
    ],
    "examples": []
  },
  "periodic_generation_constraint": {
    "name": "periodic_generation_constraint",
    "description": "对元素或事件在时间上以固定间隔生成的约束条件，常用于模拟周期性出现或定时触发的场景",
    "aliases": [
      "generation_interval",
      "renewal_period",
      "ldap_generation_rule",
      "point_generation_rule",
      "daily_growth_and_pruning"
    ],
    "examples": []
  },
  "maximum_lifetime_constraint": {
    "name": "maximum_lifetime_constraint",
    "description": "对实体或状态存在时间施加上限的约束条件，常用于限制对象存活时长或生命周期",
    "aliases": [
      "lifespan_limit",
      "death_time_calculation",
      "time_bound_disappearance",
      "deadline_constraint",
      "prediction_submission_deadline",
      "exposure_limit",
      "total_carry_time_limit",
      "time_measurement",
      "time_limit_per_mission"
    ],
    "examples": []
  },
  "permutation_count_modulo_constraint": {
    "name": "permutation_count_modulo_constraint",
    "description": "对排列数量在模某个数下的结果施加约束或计算的条件，常用于组合计数问题中关于排列总数的同余性分析",
    "aliases": [
      "permutation_count_modulo",
      "distinct_ways_modulo",
      "distinct_ways",
      "rearrangement_constraint"
    ],
    "examples": []
  },
  "longest_increasing_subsequence": {
    "name": "longest_increasing_subsequence",
    "description": "在序列中寻找长度最长的严格递增子序列的约束或目标，常用于动态规划、排序或序列分析问题中的最优子结构求解",
    "aliases": [
      "longest_increasing_subsequence_length",
      "lis_length_leq_2",
      "maximize_increasing_subsequence",
      "max_arithmetic_sequence_length",
      "lis_length_constraint"
    ],
    "examples": []
  },
  "closed_form_expression": {
    "name": "closed_form_expression",
    "description": "一种不依赖迭代或递归、直接通过数学公式表达问题解的抽象概念，常用于算法复杂度分析或闭式求解场景",
    "aliases": [
      "closed_form",
      "function_definition"
    ],
    "examples": []
  },
  "uniform_leaf_depth": {
    "name": "uniform_leaf_depth",
    "description": "要求树结构中所有叶子节点的深度相同，常用于平衡树或层级结构中的深度一致性控制",
    "aliases": [
      "leaf_depth_uniformity",
      "leaf_distance_constraint",
      "structure_stability"
    ],
    "examples": []
  },
  "single_node_start": {
    "name": "single_node_start",
    "description": "初始状态仅允许一个节点被激活或初始化的约束条件，常用于图或树构造中的起始点唯一性要求",
    "aliases": [
      "single_node_initialization",
      "initial_unlocked_element",
      "single_special_node"
    ],
    "examples": []
  },
  "maximum_tree_depth_constraint": {
    "name": "maximum_tree_depth_constraint",
    "description": "对树结构中节点最大深度施加最大化目标的优化约束，常用于构造高度最高的树或在层级结构中追求最大深度的场景",
    "aliases": [
      "tree_height_maximization",
      "height_limit",
      "depth_bound",
      "max_depth_difference"
    ],
    "examples": []
  },
  "string_edit_distance": {
    "name": "string_edit_distance",
    "description": "衡量两个字符串之间通过插入、删除或替换操作相互转换所需的最少编辑次数的抽象概念，常用于字符串相似性度量或序列对齐问题",
    "aliases": [
      "edit_distance"
    ],
    "examples": []
  },
  "maximize_lexicographical_order": {
    "name": "maximize_lexicographical_order",
    "description": "对序列或字符串的字典序进行最大化优化的目标约束，常用于构造在字典序上最大的合法排列或结果",
    "aliases": [
      "lexicographic_maximization",
      "lexicographically_smallest_solution",
      "lexicographical_maximization",
      "lexicographically_smallest_permutation",
      "lexicographically_smallest",
      "lexicographical_minimization",
      "lexicographical_sort",
      "lexicographical_order",
      "lexical_order_minimization"
    ],
    "examples": []
  },
  "stack_size_constraint": {
    "name": "stack_size_constraint",
    "description": "对数据结构中栈的大小施加上限约束的条件，常用于限制栈空间使用或防止溢出",
    "aliases": [
      "stack_limit",
      "stack_operations",
      "stack_height_limit",
      "empty_stack_condition"
    ],
    "examples": []
  },
  "minimum_distance_constraint": {
    "name": "minimum_distance_constraint",
    "description": "对任意两个对象（如边或点）之间的最小距离施加约束的条件，常用于避免碰撞、保证分离或控制空间分布的最小间距要求",
    "aliases": [
      "non_adjacent_edge_distance_min",
      "point_distance_min",
      "minimum_distance",
      "pairwise_distance_constraint",
      "collision_condition",
      "trajectory_collision",
      "nonzero_distance",
      "safe_distance_from_crossing",
      "equal_manhattan_distance",
      "distance_definition",
      "closeness_score_minimization",
      "centroid_distance_tolerance",
      "distance_constraint",
      "distance_metric",
      "max_edge_length_minimization",
      "manhattan_distance_convergence",
      "proximity_constraint",
      "collision_detection",
      "query_nearest_point",
      "distance_tolerance",
      "distance_reciprocal",
      "collision_limit",
      "manhattan_distance_bound",
      "query_distance_limit",
      "collision_distance_constraint"
    ],
    "examples": []
  },
  "logarithmic_sum_constraint": {
    "name": "logarithmic_sum_constraint",
    "description": "对一组数值的对数和施加特定约束或优化目标的条件，常用于信息熵、概率分布或加权求和中的对数尺度计算问题",
    "aliases": [
      "logarithmic_sum"
    ],
    "examples": []
  },
  "pairwise_product_maximization": {
    "name": "pairwise_product_maximization",
    "description": "对每一对元素的值之积施加最大化目标的优化约束，常用于成对关系中总乘积最大化的场景",
    "aliases": [],
    "examples": []
  },
  "first_occurrence_constraint": {
    "name": "first_occurrence_constraint",
    "description": "要求某个元素或字符在序列中首次出现的位置满足特定条件的约束，常用于位置定位或唯一性判断场景",
    "aliases": [
      "first_occurrence",
      "first_occurrence_preference"
    ],
    "examples": []
  },
  "distinct_substring_constraint": {
    "name": "distinct_substring_constraint",
    "description": "要求字符串中所有子串互不相同的约束条件，常用于字符串生成或编码中的唯一性要求",
    "aliases": [
      "unique_substring",
      "encoding_uniqueness",
      "distinct_palindromes",
      "distinct_strings",
      "uniqueness_of_table",
      "distinct_researches"
    ],
    "examples": []
  },
  "maximum_path_length_constraint": {
    "name": "maximum_path_length_constraint",
    "description": "对路径长度施加最大化目标的优化约束，常用于在图或网格中寻找最长可能路径的场景",
    "aliases": [
      "path_length_maximization",
      "maximize_steps",
      "max_crossing_losses",
      "bus_route_limit",
      "max_cost_route",
      "max_completion_time",
      "path_usage_limit",
      "max_path_constraint",
      "max_path_length",
      "ranking_by_finish_time"
    ],
    "examples": []
  },
  "maximum_edge_weight_constraint": {
    "name": "maximum_edge_weight_constraint",
    "description": "对图中所有边的权重施加上限约束，确保最大边权不超过指定值，常用于控制路径或网络中的最重连接",
    "aliases": [
      "equal_max_edge_weight",
      "capacity_constraint",
      "max_weight_constraint",
      "edge_weight_limit",
      "max_edge_weight_query"
    ],
    "examples": []
  },
  "maximum_branching_factor": {
    "name": "maximum_branching_factor",
    "description": "对树结构中节点最大分支数施加最大化目标的优化约束，常用于构造具有最多个子节点的树或在层级结构中追求最大分叉度的场景",
    "aliases": [
      "maximize_forks"
    ],
    "examples": []
  },
  "sequence_fibonacci": {
    "name": "sequence_fibonacci",
    "description": "一种按斐波那契规则生成的数列，其中每个元素等于前两个元素之和，常用于递推关系、动态规划或数列构造问题中的特定序列模式",
    "aliases": [
      "fibonacci_number"
    ],
    "examples": []
  },
  "finite_array_structure": {
    "name": "finite_array_structure",
    "description": "对有限长度数组结构施加的抽象约束，常用于限制数组规模或构造中元素数量的上限",
    "aliases": [
      "finite_phenomenal_arrays"
    ],
    "examples": []
  },
  "modulo_output_constraint": {
    "name": "modulo_output_constraint",
    "description": "对输出结果施加模运算约束的条件，常用于确保计算结果在特定同余类中或满足周期性要求",
    "aliases": [
      "modular_output",
      "modulo_constraint",
      "modular_product",
      "modular_arithmetic",
      "modular_evaluation",
      "modular_result",
      "modular_answer"
    ],
    "examples": []
  },
  "product_sum_constraint": {
    "name": "product_sum_constraint",
    "description": "对一组数值的乘积与和之间施加相等关系的约束条件，常用于数论问题或方程构造中的等式关系建模",
    "aliases": [
      "product_sum_equality",
      "non_divisibility_score"
    ],
    "examples": []
  },
  "maximum_minimum_area_constraint": {
    "name": "maximum_minimum_area_constraint",
    "description": "对划分区域中最大面积与最小面积之差施加最大化或最小化约束的条件，常用于几何分割或资源分配问题中的均衡性控制",
    "aliases": [
      "max_min_area",
      "maximize_min_set_size"
    ],
    "examples": []
  },
  "pairwise_divisibility_constraint": {
    "name": "pairwise_divisibility_constraint",
    "description": "对每一对元素的值施加可整除性约束的条件，常用于数论问题中元素间整除关系或因数结构的构造与验证场景",
    "aliases": [
      "pairwise_divisibility",
      "pairwise_sum_divisibility"
    ],
    "examples": []
  },
  "node_wait_time_constraint": {
    "name": "node_wait_time_constraint",
    "description": "对图中每个节点上停留时间施加的约束条件，常用于模拟等待、延迟或资源占用中的时间控制",
    "aliases": [
      "wait_time_on_each_node"
    ],
    "examples": []
  },
  "subsegment_permutation_count_minimization": {
    "name": "subsegment_permutation_count_minimization",
    "description": "要求在所有子段中，排列数量最小化的约束条件，常用于序列构造或组合优化问题中对排列多样性的控制与最小化",
    "aliases": [],
    "examples": []
  },
  "equal_area_partition": {
    "name": "equal_area_partition",
    "description": "将区域划分为若干子区域，每个子区域面积相等的约束条件，常用于几何分割或资源分配中的均衡性控制",
    "aliases": [
      "equal_area_subrectangles",
      "right_angle_triangle_area",
      "balanced_partitioning",
      "equal_partition"
    ],
    "examples": []
  },
  "integer_dimension_constraint": {
    "name": "integer_dimension_constraint",
    "description": "对矩形或网格的边长施加必须为整数的约束条件，常用于离散化建模或坐标系统中的整数位置要求",
    "aliases": [
      "integer_sides",
      "integer_coordinates",
      "integer_only_solution"
    ],
    "examples": []
  },
  "rectilinear_partition": {
    "name": "rectilinear_partition",
    "description": "将平面区域划分为多个矩形子区域的划分方式，要求所有子区域边界与坐标轴对齐，常用于布局设计或网格划分问题",
    "aliases": [
      "rectangular_division",
      "rectangular_orientation",
      "rectangular_packing",
      "axis_aligned_rectangles",
      "polygon_partition",
      "orthogonal_cuts"
    ],
    "examples": []
  },
  "floating_point_accuracy_constraint": {
    "name": "floating_point_accuracy_constraint",
    "description": "对浮点数计算中数值精度的约束条件，常用于控制近似误差或保证计算结果在特定有效位数范围内的要求",
    "aliases": [
      "real_number_precision",
      "output_precision",
      "relative_error_tolerance",
      "precision_requirement",
      "relative_error_bound",
      "fractional_output"
    ],
    "examples": []
  },
  "cooldown_period_constraint": {
    "name": "cooldown_period_constraint",
    "description": "对操作或事件之间必须间隔至少一个固定时间单位的约束条件，常用于防止重复触发或模拟冷却机制",
    "aliases": [
      "cool_down_constraint",
      "time_limit_per_resource",
      "cool_multiset_condition",
      "boarding_interval_constraint",
      "rest_move",
      "single_visit_per_day",
      "robber_no_stay"
    ],
    "examples": []
  },
  "periodic_encounter_constraint": {
    "name": "periodic_encounter_constraint",
    "description": "要求两个或多个实体在固定时间间隔内发生交互或相遇的约束条件，常用于周期性事件或同步行为建模",
    "aliases": [
      "fixed_interval_encounter",
      "synchronization_constraint",
      "time_synchronization_constraint"
    ],
    "examples": []
  },
  "range_selection_constraint": {
    "name": "range_selection_constraint",
    "description": "对选择区间或范围施加的约束条件，常用于限制可选索引、时间窗口或数值区间的选取范围",
    "aliases": [
      "interval_selection",
      "interval_modification",
      "range_restriction",
      "interval_addition",
      "interval_reduction",
      "interval_assignment",
      "interval_update",
      "subinterval_selection",
      "range_constraint"
    ],
    "examples": []
  },
  "fraction_modulo_constraint": {
    "name": "fraction_modulo_constraint",
    "description": "对分数在模运算下的不可约性施加约束的条件，常用于数论问题中关于同余类中分数表示的唯一性与简化要求",
    "aliases": [
      "irreducible_fraction_modulo",
      "irreducible_fraction",
      "coprime_fraction_modulo"
    ],
    "examples": []
  },
  "uniform_probability_distribution": {
    "name": "uniform_probability_distribution",
    "description": "对概率分布施加均匀性约束的条件，常用于随机选择、采样或生成过程中每个结果具有相等出现概率的场景",
    "aliases": [
      "uniform_random_distribution",
      "probability_distribution_validity",
      "probability_constraint",
      "uniform_random_selection",
      "probability_range",
      "probability_calculation",
      "random_combination",
      "fixed_probability",
      "uniform_distribution",
      "uniform_probability_selection",
      "initial_probability",
      "probability_distribution",
      "random_selection",
      "uniform_probability",
      "random_walk_probability"
    ],
    "examples": []
  },
  "hint_inference": {
    "name": "hint_inference",
    "description": "基于已有信息推断隐藏线索或逻辑关系的抽象约束，常用于解题过程中通过上下文或模式识别进行间接推理的场景",
    "aliases": [],
    "examples": []
  },
  "path_boundary_crossing": {
    "name": "path_boundary_crossing",
    "description": "路径在穿越多边形边界时需满足特定条件的约束，常用于几何路径规划或区域进出逻辑中的边界行为控制",
    "aliases": [
      "boundary_crossing",
      "state_boundaries",
      "non_crossing_move",
      "boundary_calculation"
    ],
    "examples": []
  },
  "path_in_polygon_region": {
    "name": "path_in_polygon_region",
    "description": "路径必须完全位于多边形内部区域内的约束条件，常用于图形区域内路径构造或安全区域访问问题",
    "aliases": [
      "path_within_polygon",
      "full_highway_traversal"
    ],
    "examples": []
  },
  "non_square_shape_constraint": {
    "name": "non_square_shape_constraint",
    "description": "要求图形或物体不为正方形的几何形状约束，常用于避免对称性或特定规则下的形状限制",
    "aliases": [
      "no_square_face"
    ],
    "examples": []
  },
  "volume_upper_bound_constraint": {
    "name": "volume_upper_bound_constraint",
    "description": "对体积大小施加上限约束的条件，常用于三维空间中对象尺寸或资源占用的控制",
    "aliases": [
      "volume_leq_n"
    ],
    "examples": []
  },
  "region_union_constraint": {
    "name": "region_union_constraint",
    "description": "对多个区域或子区域的并集施加特定几何或集合约束的条件，常用于多区域合并、覆盖范围计算或空间重叠分析中的并集性质控制",
    "aliases": [
      "area_union",
      "coverage_constraint",
      "segment_coverage",
      "complete_coverage",
      "union_size_query",
      "area_union_expectation"
    ],
    "examples": []
  },
  "path_category_uniformity": {
    "name": "path_category_uniformity",
    "description": "要求路径中所有元素或节点属于同一类别或类型，常用于路径构造或分类约束中的统一性控制",
    "aliases": [
      "same_category_per_path",
      "path_through_sponsored_stations",
      "category_consistency",
      "path_segment_type"
    ],
    "examples": []
  },
  "repeated_substring_inversion": {
    "name": "repeated_substring_inversion",
    "description": "在字符串中允许对子串进行重复翻转操作的约束条件，常用于字符串变换或对称性处理中的多次逆序操作",
    "aliases": [
      "repeated_string_inversions"
    ],
    "examples": []
  },
  "expression_validity_constraint": {
    "name": "expression_validity_constraint",
    "description": "对表达式在语法规则或逻辑结构上是否合法的判断条件，常用于验证数学表达式、逻辑公式或编程语法的正确性",
    "aliases": [
      "valid_expression",
      "expression_validity",
      "valid_sequence",
      "expression_evaluation",
      "validity_check"
    ],
    "examples": []
  },
  "no_local_extremum": {
    "name": "no_local_extremum",
    "description": "要求序列或数组中不存在局部极值点的约束条件，常用于避免峰值或谷值出现的平滑性控制问题",
    "aliases": [
      "local_extremum_avoidance",
      "no_change_constraint"
    ],
    "examples": []
  },
  "constructibility_constraint": {
    "name": "constructibility_constraint",
    "description": "对某种结构或配置是否可构造的约束条件，常用于判断给定规则下是否存在满足要求的解或实现方案",
    "aliases": [
      "known_composition"
    ],
    "examples": []
  },
  "distinct_edge_characters": {
    "name": "distinct_edge_characters",
    "description": "要求图中所有边的字符标识互不相同，常用于避免边标签重复或确保唯一性标识的约束条件",
    "aliases": [
      "unique_edge_characters",
      "edge_selection_uniqueness",
      "edge_uniqueness",
      "unique_edge"
    ],
    "examples": []
  },
  "fifo_operation_constraint": {
    "name": "fifo_operation_constraint",
    "description": "一种遵循先进先出原则的数据结构操作规则，常用于队列类问题中对元素插入与移除顺序的约束",
    "aliases": [
      "queue_operations",
      "queue_ordering"
    ],
    "examples": []
  },
  "piecewise_linear_function_constraint": {
    "name": "piecewise_linear_function_constraint",
    "description": "对分段线性函数形式的约束条件，常用于描述随时间或状态变化的非恒定速率或行为模式",
    "aliases": [
      "piecewise_linear_drain_rate"
    ],
    "examples": []
  },
  "maximum_average_constraint": {
    "name": "maximum_average_constraint",
    "description": "对一组数值的平均值施加最大化目标的优化约束，常用于在子数组或区间选择中追求最高均值的场景",
    "aliases": [
      "max_average_constraint",
      "range_sum_optimization",
      "interval_team_rating_maximization",
      "max_average_value"
    ],
    "examples": []
  },
  "v_diagram_structure": {
    "name": "v_diagram_structure",
    "description": "一种表示数据点间层次关系或决策路径的树状图结构，常用于动态规划、状态转移或分治算法中的可视化建模",
    "aliases": [],
    "examples": []
  },
  "median_positive_constraint": {
    "name": "median_positive_constraint",
    "description": "要求序列或集合的中位数为正数的约束条件，常用于优化问题中对中间值符号的控制",
    "aliases": [
      "positive_median",
      "median_constraint",
      "median_average_constraint"
    ],
    "examples": []
  },
  "sign_inversion_operation": {
    "name": "sign_inversion_operation",
    "description": "对数值或元素符号进行反转操作的规则，常用于变换过程中的符号翻转或对称性处理",
    "aliases": [
      "sign_flipping",
      "single_cell_flip",
      "independent_flip"
    ],
    "examples": []
  },
  "distinct_maximum_constraint": {
    "name": "distinct_maximum_constraint",
    "description": "要求序列或集合中最大值唯一出现的约束条件，常用于保证极值的唯一性或避免重复最大值",
    "aliases": [
      "unique_maximum",
      "unique_profit",
      "distinct_leaders"
    ],
    "examples": []
  },
  "speed_ratio_constraint": {
    "name": "speed_ratio_constraint",
    "description": "对两个实体或过程之间速度比值施加的约束条件，常用于比较不同操作、响应或传播速率的相对关系",
    "aliases": [
      "refutation_speed_ratio",
      "acceleration_deceleration_rate"
    ],
    "examples": []
  },
  "maximum_gcd_product_constraint": {
    "name": "maximum_gcd_product_constraint",
    "description": "对一组数中任意子区间内元素最大公约数与该区间乘积的乘积施加最大化目标的约束条件，常用于组合优化问题中关于区间内互质性与乘积规模的联合最大化",
    "aliases": [
      "range_max_gcd_product",
      "gcd_maximization",
      "interval_gcd_max"
    ],
    "examples": []
  },
  "stack_sortable": {
    "name": "stack_sortable",
    "description": "一种可以通过栈操作实现排序的序列，即能够通过一系列入栈和出栈操作将序列变为有序状态的抽象约束条件",
    "aliases": [],
    "examples": []
  },
  "maximize_sum_of_remaining_elements": {
    "name": "maximize_sum_of_remaining_elements",
    "description": "对序列或集合中未被移除元素的总和施加最大化目标的优化约束，常用于在删除部分元素后保留最大可能剩余值的场景",
    "aliases": [
      "maximize_remaining_sum",
      "maximize_trie_nodes"
    ],
    "examples": []
  },
  "recursive_sequence_constraint": {
    "name": "recursive_sequence_constraint",
    "description": "对序列中每个元素由前驱元素通过固定规则递推生成的约束条件，常用于动态规划、数列构造或算法状态转移中的递归关系建模",
    "aliases": [
      "recurrence_relation",
      "fibonacci_sequence_check",
      "sequence_doubling",
      "sequence_generation",
      "sequence_construction",
      "function_recursive_definition"
    ],
    "examples": []
  },
  "bridge_free_graph": {
    "name": "bridge_free_graph",
    "description": "图中不存在桥边（即删除任意一条边不会导致图的连通性断裂）的约束条件，常用于保证图的鲁棒性或强连通性分析",
    "aliases": [
      "no_bridges",
      "bridge_definition",
      "disconnection_constraint"
    ],
    "examples": []
  },
  "planar_graph_structure": {
    "name": "planar_graph_structure",
    "description": "一种可以在平面上绘制且边不交叉的图结构，常用于几何嵌入、地图着色或网络布局问题中的平面性约束",
    "aliases": [
      "planar_graph"
    ],
    "examples": []
  },
  "tournament_structure": {
    "name": "tournament_structure",
    "description": "一种通过逐轮淘汰方式决定最终胜者的比赛结构，每轮失败者被淘汰，常用于单败淘汰制的竞赛建模",
    "aliases": [
      "single_elimination_tournament"
    ],
    "examples": []
  },
  "priority_based_selection": {
    "name": "priority_based_selection",
    "description": "根据元素的强度或优先级决定其胜负关系的规则，常用于模拟竞争性选择或优胜劣汰机制",
    "aliases": [
      "strength_determines_winner",
      "target_selection",
      "schedule_ordering",
      "strength_selection",
      "parent_bonus_requirement"
    ],
    "examples": []
  },
  "tree_structure_isomorphism": {
    "name": "tree_structure_isomorphism",
    "description": "判断两棵树在结构上是否相同，即存在一种节点间的一一对应关系使得边的连接关系保持不变，常用于树形结构的等价性验证或同构判定问题",
    "aliases": [
      "tree_isomorphism",
      "tree_reconfiguration",
      "simplified_tree_isomorphism"
    ],
    "examples": []
  },
  "majority_element_constraint": {
    "name": "majority_element_constraint",
    "description": "要求序列中某个元素出现次数超过一半的约束条件，常用于判断是否存在主导性元素或构造满足多数性要求的解",
    "aliases": [
      "majority_element",
      "digit_majority",
      "majority_vote"
    ],
    "examples": []
  },
  "non_halfspace_constraint": {
    "name": "non_halfspace_constraint",
    "description": "要求路径或对象在运动过程中避免进入特定半空间区域的几何约束条件，常用于避障、安全区域控制或方向性限制场景",
    "aliases": [
      "half_space_avoidance",
      "line_avoidance",
      "hemisphere_containment",
      "boundary_avoidance"
    ],
    "examples": []
  },
  "maximum_cell_examination": {
    "name": "maximum_cell_examination",
    "description": "对网格或区域中被检查的单元格数量施加上限约束的条件，常用于限制搜索范围或计算资源消耗的场景",
    "aliases": [
      "max_cells_checking",
      "distinct_cells_maximization",
      "zero_stones_loss",
      "node_inclusion_limit",
      "facility_location_limit"
    ],
    "examples": []
  },
  "minimum_segment_length": {
    "name": "minimum_segment_length",
    "description": "要求线段或子序列长度不低于指定最小值的约束条件，常用于几何构造或分块处理中的最小尺寸控制",
    "aliases": [
      "triangle_side_length_lower_bound",
      "interval_length_geq_2",
      "segment_min_value_constraint"
    ],
    "examples": []
  },
  "prime_pair": {
    "name": "prime_pair",
    "description": "一对数均为素数的约束条件，常用于数论问题中关于素数对的构造或验证场景",
    "aliases": [
      "prime_pair_constraint"
    ],
    "examples": []
  },
  "minimum_edit_distance_sum": {
    "name": "minimum_edit_distance_sum",
    "description": "对一组字符串或序列的编辑距离之和施加最小化目标的优化约束，常用于多字符串匹配或近似对齐中的总误差最小化问题",
    "aliases": [
      "min_edit_distance_sum"
    ],
    "examples": []
  },
  "path_completion_constraint": {
    "name": "path_completion_constraint",
    "description": "要求路径必须完整执行至终点的约束条件，常用于保证任务或事件序列的结束状态达成",
    "aliases": [
      "complete_crossing",
      "failure_condition",
      "path_termination",
      "unreachable_code",
      "game_end_condition",
      "termination_condition",
      "game_termination",
      "path_coverage",
      "visit_at_least_one_other_node",
      "finish_time_calculation"
    ],
    "examples": []
  },
  "pairwise_sign_constraint": {
    "name": "pairwise_sign_constraint",
    "description": "对每一对元素的符号关系施加约束的条件，常用于数论或符号逻辑中元素间正负性匹配或排斥的场景",
    "aliases": [
      "sign_pairing_constraint"
    ],
    "examples": []
  },
  "time_interval_constraint": {
    "name": "time_interval_constraint",
    "description": "对两个事件或操作之间的时间间隔施加特定限制的约束条件，常用于时序控制、同步机制或延迟规则中的时间差管理",
    "aliases": [
      "time_difference_constraint",
      "delivery_time_constraint"
    ],
    "examples": []
  },
  "angle_range_constraint": {
    "name": "angle_range_constraint",
    "description": "对角度值的取值范围施加约束的条件，常用于几何构造或方向性控制中的角度区间限制",
    "aliases": [
      "angle_range",
      "angle_constraint"
    ],
    "examples": []
  },
  "dihedral_angle_constraint": {
    "name": "dihedral_angle_constraint",
    "description": "对两个平面之间夹角（二面角）施加特定约束的条件，常用于三维几何、分子结构或空间关系分析中的角度控制",
    "aliases": [],
    "examples": []
  },
  "angle_sum_constraint": {
    "name": "angle_sum_constraint",
    "description": "对一组角度之和施加特定数值或性质约束的条件，常用于多边形内角和、三角形性质或几何图形闭合性验证中的总和控制",
    "aliases": [
      "sum_of_angles"
    ],
    "examples": []
  },
  "division_modulo_constraint": {
    "name": "division_modulo_constraint",
    "description": "对整数除法运算结果的余数或商施加特定约束的条件，常用于数论问题中关于整除性与余数分布的控制",
    "aliases": [
      "integer_division"
    ],
    "examples": []
  },
  "stack_structure_composition": {
    "name": "stack_structure_composition",
    "description": "对栈结构中元素的组成方式或堆叠顺序施加的约束条件，常用于描述栈内元素排列、组合规则或构建逻辑的抽象概念",
    "aliases": [
      "stack_composition",
      "stack_operations",
      "undo_operations"
    ],
    "examples": []
  },
  "target_pattern_matching": {
    "name": "target_pattern_matching",
    "description": "要求目标图像或模式与输入内容在结构、形状或特征上完全匹配的约束条件，常用于图像识别、模板比对或生成任务中的精确对齐场景",
    "aliases": [
      "target_image_match"
    ],
    "examples": []
  },
  "reconstruction_constraint": {
    "name": "reconstruction_constraint",
    "description": "对从部分信息中恢复完整特征或结构的约束条件，常用于逆向工程、数据补全或模式重构问题中的完整性保障",
    "aliases": [
      "feature_recovery",
      "decoding_consistency",
      "complete_information_required"
    ],
    "examples": []
  },
  "node_type_uniformity": {
    "name": "node_type_uniformity",
    "description": "要求图中所有内部节点的类型保持一致，常用于保证结构或状态转移中的类型统一性",
    "aliases": [
      "internal_node_types"
    ],
    "examples": []
  },
  "convergence_to_single_value": {
    "name": "convergence_to_single_value",
    "description": "要求序列或系统状态在迭代或演化过程中最终收敛到唯一确定值的约束条件，常用于动态系统、数值逼近或迭代算法中的稳定态控制",
    "aliases": [
      "coalescence_stability",
      "convergence_stability"
    ],
    "examples": []
  },
  "modulo_accumulation": {
    "name": "modulo_accumulation",
    "description": "对一系列数值在模某个数下的累积结果施加约束或计算的条件，常用于同余类中累加过程的控制与分析",
    "aliases": [
      "modular_accumulation",
      "modular_arithmetic",
      "sum_modulo_constraint",
      "interval_modulo",
      "modular_sum",
      "path_sum_modulo",
      "range_sum_modulo",
      "expression_sum_modulo",
      "interval_modulo_sum",
      "pollution_accumulation",
      "cycle_product_even_constraint",
      "sum_modulo"
    ],
    "examples": []
  },
  "minimum_stability_constraint": {
    "name": "minimum_stability_constraint",
    "description": "对系统或序列在演化过程中保持最小稳定性状态的约束条件，常用于保证状态变化不剧烈或避免过早崩溃的场景",
    "aliases": [
      "min_stability_function",
      "stability_condition"
    ],
    "examples": []
  },
  "longest_non_decreasing_subarray": {
    "name": "longest_non_decreasing_subarray",
    "description": "在序列中寻找长度最长的非递减子数组的约束或目标，常用于动态规划、序列分析或单调性验证问题中的最优子结构求解",
    "aliases": [
      "monotonic_subarray_length",
      "maximal_contiguous_segment"
    ],
    "examples": []
  },
  "string_length_constraint": {
    "name": "string_length_constraint",
    "description": "对字符串长度施加上限或下限约束的条件，常用于限制编码、序列或数据表示的规模",
    "aliases": [
      "encoding_length_limit",
      "output_length",
      "store_value_length",
      "string_length_fixed"
    ],
    "examples": []
  },
  "product_of_edge_weights": {
    "name": "product_of_edge_weights",
    "description": "图中边权重乘积的约束或计算条件，常用于路径、子图或结构中权重累积的乘积性质分析",
    "aliases": [
      "product_of_weights",
      "product_constraint",
      "global_multiplication",
      "interval_multiplication"
    ],
    "examples": []
  },
  "isosceles_triangle_constraint": {
    "name": "isosceles_triangle_constraint",
    "description": "要求三角形中至少有两个边长度相等的几何约束条件，常用于等腰三角形构造或性质验证问题",
    "aliases": [
      "isosceles_triangle"
    ],
    "examples": []
  },
  "triangle_inequality_constraint": {
    "name": "triangle_inequality_constraint",
    "description": "要求任意三角形三边中任意两边之和大于第三边的几何约束条件，常用于判断三点能否构成有效三角形或路径合法性验证",
    "aliases": [
      "triangle_inequality"
    ],
    "examples": []
  },
  "rigidity_constraint": {
    "name": "rigidity_constraint",
    "description": "对结构或系统在受力或变形下保持形状不变的约束条件，常用于刚性体建模、几何稳定性分析或图结构中的刚性连接控制",
    "aliases": [],
    "examples": []
  },
  "path_connectedness": {
    "name": "path_connectedness",
    "description": "路径中所有节点属于同一连通分量的约束条件，常用于保证路径的连通性或内部一致性",
    "aliases": [
      "monochromatic_path",
      "empty_cell_connectivity",
      "connected_corridor",
      "connected_wall",
      "fragment_connectivity",
      "path_connectivity",
      "chain_definition",
      "path_in_tree",
      "path_inclusion_or_adjacency",
      "connected_group",
      "connected_subgraph"
    ],
    "examples": []
  },
  "color_change_limit": {
    "name": "color_change_limit",
    "description": "对颜色重置或重新着色操作次数施加上限的约束条件，常用于限制图或网格中颜色变更频率或资源消耗",
    "aliases": [
      "recolouring_limit",
      "recolor_operation_constraint",
      "black_to_white_constraint"
    ],
    "examples": []
  },
  "weight_threshold": {
    "name": "weight_threshold",
    "description": "对权重值施加上下限阈值约束的条件，常用于限制数值范围或资源分配中的权重边界控制",
    "aliases": [
      "cell_weight_definition",
      "bonus_threshold",
      "weight_requirements",
      "resource_limit",
      "capacity_upper_bound",
      "product_capacity_upper_bound"
    ],
    "examples": []
  },
  "distinct_subintervals": {
    "name": "distinct_subintervals",
    "description": "要求一组区间在数值范围上互不重叠且彼此独立的约束条件，常用于资源分配或时间片划分中的唯一性控制",
    "aliases": [
      "distinct_intervals",
      "interval_segment_count",
      "segment_count_leq_k",
      "interval_disjoint_union",
      "interval_non_overlap",
      "interval_pair_count"
    ],
    "examples": []
  },
  "minimum_set_cover": {
    "name": "minimum_set_cover",
    "description": "在集合覆盖问题中，要求选择最少数量的子集以覆盖全集的优化目标约束，常用于最小化资源消耗或操作次数的场景",
    "aliases": [
      "min_set_cover",
      "minimal_set_cover"
    ],
    "examples": []
  },
  "no_nested_intervals": {
    "name": "no_nested_intervals",
    "description": "禁止任意两个区间存在包含关系（即一个区间完全位于另一个区间内部）的几何或序列约束，常用于避免嵌套结构的构造问题",
    "aliases": [
      "nested_intervals_prohibited",
      "non_overlapping_rectangles"
    ],
    "examples": []
  },
  "transitive_closure_constraint": {
    "name": "transitive_closure_constraint",
    "description": "对关系传递性施加的抽象约束，确保若a与b相关、b与c相关，则a与c也必须相关，常用于偏序关系或依赖图中的闭包性质建模",
    "aliases": [
      "transitive_relation",
      "non_trivial_dependency",
      "redundancy_detection",
      "transitive_closure",
      "transitive_following",
      "transitive_connectivity"
    ],
    "examples": []
  },
  "distinct_directions": {
    "name": "distinct_directions",
    "description": "要求一组方向或斜率在集合中互不相同的约束条件，常用于几何构造或向量分析中的唯一性控制",
    "aliases": [
      "distinct_slopes"
    ],
    "examples": []
  },
  "potential_energy_function": {
    "name": "potential_energy_function",
    "description": "一种用于描述系统状态能量的数学函数，常用于优化问题中衡量配置优劣或状态稳定性",
    "aliases": [
      "energy_function",
      "energy_calculation"
    ],
    "examples": []
  },
  "maximum_energy_sum": {
    "name": "maximum_energy_sum",
    "description": "对一组能量值的总和施加最大化目标的优化约束，常用于在能量分配或状态选择中追求最大总能量",
    "aliases": [
      "max_energy_sum",
      "profit_definition"
    ],
    "examples": []
  },
  "distinct_tree_structure": {
    "name": "distinct_tree_structure",
    "description": "要求树结构在形态上互不相同，常用于树形结构的唯一性验证或同构判定问题中的非同构性约束",
    "aliases": [
      "unique_tree_identification",
      "unique_simplified_trees"
    ],
    "examples": []
  },
  "cubic_interval_modulo_constraint": {
    "name": "cubic_interval_modulo_constraint",
    "description": "对区间内元素立方值在模某个数下的结果施加约束或计算的条件，常用于数论问题中关于立方同余类的分析与构造",
    "aliases": [
      "interval_cubing_modulo"
    ],
    "examples": []
  },
  "minimum_path_length_constraint": {
    "name": "minimum_path_length_constraint",
    "description": "对路径长度施加最小化目标的优化约束，常用于在图或网格中寻找最短可能路径的场景",
    "aliases": [
      "path_length_minimization",
      "s8_min_cost_route",
      "minimum_path_after_key",
      "shortest_path",
      "min_cost_constraint",
      "path_length_lower_bound",
      "min_path_constraint",
      "path_length_at_least_two",
      "min_cost_path",
      "shortest_path_constraint",
      "shortest_length",
      "shortest_path_requirement"
    ],
    "examples": []
  },
  "distinct_pairwise_sums": {
    "name": "distinct_pairwise_sums",
    "description": "要求每一对元素的值之和在集合中互不相同，常用于组合优化或序列构造中对成对关系唯一性的控制",
    "aliases": [
      "pairwise_sum_uniqueness",
      "pairwise_distinct_pairs",
      "pairwise_distinct_elements",
      "distinct_pairs",
      "distinct_pair_selection"
    ],
    "examples": []
  },
  "minimum_probability_constraint": {
    "name": "minimum_probability_constraint",
    "description": "对概率值施加最小化目标的约束条件，常用于优化问题中确保概率不低于某个阈值或最小累积量",
    "aliases": [
      "probability_minimization"
    ],
    "examples": []
  },
  "activation_trigger_condition": {
    "name": "activation_trigger_condition",
    "description": "触发某项操作或状态激活的条件规则，常用于系统启动、事件响应或状态转换中的触发逻辑控制",
    "aliases": [
      "wake_up_condition",
      "unique_trigger",
      "action_condition",
      "activation_propagation",
      "key_pickup_constraint",
      "activation_order",
      "start_time_dependency",
      "conditional_jump",
      "unconditional_jump"
    ],
    "examples": []
  },
  "sequential_batch_processing": {
    "name": "sequential_batch_processing",
    "description": "要求一批操作必须按顺序执行，不允许并行或乱序处理的约束条件，常用于任务调度、流水线处理或依赖链控制中的顺序性保障",
    "aliases": [
      "batch_sequentiality",
      "sequential_execution",
      "sequential_launch",
      "operation_sequence",
      "non_simultaneous_operations"
    ],
    "examples": []
  },
  "diagonal_submatrix_increasing_constraint": {
    "name": "diagonal_submatrix_increasing_constraint",
    "description": "要求矩阵的主对角线子矩阵中元素值随位置递增的约束条件，常用于构造具有特定对角增长模式的子结构",
    "aliases": [
      "diagonal_submatrix_increment"
    ],
    "examples": []
  },
  "submatrix_increasing_constraint": {
    "name": "submatrix_increasing_constraint",
    "description": "要求子矩阵中所有元素按行或列方向呈现非递减趋势的约束条件，常用于分块区域中的单调性控制",
    "aliases": [
      "submatrix_increment",
      "kxk_square_red_constraint",
      "submatrix_query"
    ],
    "examples": []
  },
  "path_vertex_coloring": {
    "name": "path_vertex_coloring",
    "description": "对路径中每个顶点进行着色时，要求相邻顶点颜色不同的约束条件，常用于路径构造或图着色问题中的路径合法性判断",
    "aliases": [
      "path_coloring",
      "distinct_colors_on_path"
    ],
    "examples": []
  },
  "combined_constraint": {
    "name": "combined_constraint",
    "description": "对多个约束条件进行联合施加的抽象概念，常用于同时满足多种逻辑或数值限制的复杂问题建模",
    "aliases": [
      "feasibility_constraint",
      "collection_constraint"
    ],
    "examples": []
  },
  "insertion_constraint": {
    "name": "insertion_constraint",
    "description": "对在序列或结构中插入元素的操作施加的规则或约束条件，常用于控制插入位置、频率或与周围元素的关系",
    "aliases": [
      "factor_insertion",
      "insertion_operations"
    ],
    "examples": []
  },
  "path_reachability": {
    "name": "path_reachability",
    "description": "路径中任意节点或位置可达性的约束条件，常用于保证从起点到目标点存在有效路径的连通性要求",
    "aliases": [
      "position_reachability",
      "reachability_constraint",
      "path_existence",
      "shortest_path_existence"
    ],
    "examples": []
  },
  "speed_upper_bound_constraint": {
    "name": "speed_upper_bound_constraint",
    "description": "对物体或实体运动速度施加上限的约束条件，常用于控制移动过程中的最大速率以避免超速或资源过载",
    "aliases": [
      "velocity_upper_bound"
    ],
    "examples": []
  },
  "2x2_submatrix_constraint": {
    "name": "2x2_submatrix_constraint",
    "description": "要求在2×2子矩阵区域内满足特定结构或属性约束的抽象条件，常用于网格中局部区域的连通性、对称性或唯一性控制",
    "aliases": [
      "wall_in_2x2_region"
    ],
    "examples": []
  },
  "common_subsequence_non_empty": {
    "name": "common_subsequence_non_empty",
    "description": "要求两个或多个序列存在至少一个非空的公共子序列的约束条件，常用于序列匹配、相似性判断或模式识别中的非空交集验证",
    "aliases": [
      "non_empty_common_subsequence"
    ],
    "examples": []
  },
  "path_movement_pattern": {
    "name": "path_movement_pattern",
    "description": "对路径中节点或边的移动方式、方向变化规律或运动轨迹模式施加的抽象约束，常用于描述路径的动态行为特征或运动规则",
    "aliases": [
      "movement_pattern"
    ],
    "examples": []
  },
  "quadratic_equation_constraint": {
    "name": "quadratic_equation_constraint",
    "description": "对二次方程或二次表达式施加的约束条件，常用于数论、优化或代数问题中关于二次项系数、判别式或根的性质控制",
    "aliases": [
      "quadratic_constraint"
    ],
    "examples": []
  },
  "secondary_objective_minimization": {
    "name": "secondary_objective_minimization",
    "description": "对优化问题中次要目标函数施加最小化约束的抽象概念，常用于多目标优化中优先满足主目标后次优处理次要指标的场景",
    "aliases": [
      "secondary_minimization"
    ],
    "examples": []
  },
  "multiple_edges_per_pair": {
    "name": "multiple_edges_per_pair",
    "description": "允许图中任意两个顶点之间存在多条边的约束条件，常用于表示多重连接或并行路径的场景",
    "aliases": [
      "parallel_edges_allowed",
      "self_loop_allowed",
      "multiple_chess_pieces_per_vertex"
    ],
    "examples": []
  },
  "kth_smallest_path_length": {
    "name": "kth_smallest_path_length",
    "description": "要求路径长度为所有可能路径中第k小的约束条件，常用于在路径集合中选择特定排名的最短路径",
    "aliases": [
      "path_length_kth_smallest",
      "k_smallest_solutions",
      "top_k_constraint"
    ],
    "examples": []
  },
  "symmetry_avoidance_constraint": {
    "name": "symmetry_avoidance_constraint",
    "description": "要求结构或配置在变换操作中不包含旋转或反射对称性的抽象约束，常用于避免对称解或强制唯一性构造的场景",
    "aliases": [
      "no_rotation_or_reflection",
      "symmetry_constraint"
    ],
    "examples": []
  },
  "invertible_matrix_constraint": {
    "name": "invertible_matrix_constraint",
    "description": "要求矩阵在模运算或实数域上可逆的抽象约束，常用于线性代数问题中判断矩阵是否具有唯一解或可逆变换能力",
    "aliases": [
      "matrix_invertibility"
    ],
    "examples": []
  },
  "output_line_count_constraint": {
    "name": "output_line_count_constraint",
    "description": "对输出结果中行数施加特定限制的约束条件，常用于控制输出规模或格式要求的场景",
    "aliases": [
      "output_line_count",
      "query_result_format"
    ],
    "examples": []
  },
  "segment_tree_structure": {
    "name": "segment_tree_structure",
    "description": "一种用于高效处理区间查询和区间更新的二叉树数据结构，支持对数组或序列的子区间进行快速查询与修改操作",
    "aliases": [],
    "examples": []
  },
  "grouping_constraint": {
    "name": "grouping_constraint",
    "description": "对元素分组操作施加的抽象约束，要求分组满足特定包含或划分逻辑，常用于集合划分、资源分配或结构组织中的分组规则建模",
    "aliases": [
      "grouping_with_kang"
    ],
    "examples": []
  },
  "target_alignment": {
    "name": "target_alignment",
    "description": "要求目标位置或对象在空间或序列中满足特定对齐关系的抽象约束，常用于几何对齐、排列对齐或结构对齐问题中的位置一致性控制",
    "aliases": [
      "corner_alignment"
    ],
    "examples": []
  },
  "longest_substring_constraint": {
    "name": "longest_substring_constraint",
    "description": "要求字符串中存在一个长度最长的子串，常用于字符串构造或模式识别中的最大连续片段查找",
    "aliases": [
      "max_length_substring"
    ],
    "examples": []
  },
  "maximum_node_marking": {
    "name": "maximum_node_marking",
    "description": "对图中节点标记操作次数施加上限的约束条件，常用于限制状态标记或访问频率的场景",
    "aliases": [
      "node_marking_limit",
      "total_visit_limit",
      "visit_limit"
    ],
    "examples": []
  },
  "no_new_path_creation": {
    "name": "no_new_path_creation",
    "description": "禁止在路径或图结构中创建新的路径或连通分量，常用于限制新增连接或保持原有连通性结构的稳定性",
    "aliases": [
      "no_new_chains"
    ],
    "examples": []
  },
  "subsequence_hash_constraint": {
    "name": "subsequence_hash_constraint",
    "description": "对子序列的哈希值施加唯一性或特定匹配约束的抽象条件，常用于子序列识别、去重或模式匹配中的哈希一致性控制",
    "aliases": [
      "subsequence_hash"
    ],
    "examples": []
  },
  "circular_region_coverage": {
    "name": "circular_region_coverage",
    "description": "要求覆盖区域在环形或周期性结构中满足完整覆盖的抽象约束，常用于环形路径、周期性布局或循环区域中的覆盖完整性控制",
    "aliases": [
      "circular_coverage"
    ],
    "examples": []
  },
  "minimum_objective_constraint": {
    "name": "minimum_objective_constraint",
    "description": "对优化目标函数施加最小化约束的抽象概念，常用于多目标优化中优先满足次要目标的最小化需求或整体代价最小化场景",
    "aliases": [
      "minimization_constraint",
      "loss_minimization"
    ],
    "examples": []
  },
  "engagement_metric": {
    "name": "engagement_metric",
    "description": "用于衡量系统或交互过程中用户参与度、趣味性或吸引力的抽象度量，常用于评估体验质量或行为激励效果",
    "aliases": [
      "fun_factor_definition"
    ],
    "examples": []
  },
  "convex_hull_volume_constraint": {
    "name": "convex_hull_volume_constraint",
    "description": "对多边形或点集构成的凸包体积施加约束或计算的条件，常用于三维几何构造、空间分布分析或体积优化问题中的凸包大小控制",
    "aliases": [
      "convex_hull_volume"
    ],
    "examples": []
  },
  "factorial_modulo_constraint": {
    "name": "factorial_modulo_constraint",
    "description": "对阶乘结果在模某个数下的值施加约束或计算的条件，常用于数论问题中关于阶乘同余类的分析与构造",
    "aliases": [
      "factorial_modulo"
    ],
    "examples": []
  },
  "maximal_contiguous_segment_selection": {
    "name": "maximal_contiguous_segment_selection",
    "description": "从序列中选择所有最大连续段的抽象约束，常用于在二进制或标记序列中识别并选取最长的同色连续子段",
    "aliases": [
      "select_maximal_black_intervals"
    ],
    "examples": []
  },
  "edge_weight_definition": {
    "name": "edge_weight_definition",
    "description": "对图中边权重的具体定义或赋值规则施加的约束条件，常用于初始化、更新或构造过程中对边权的明确设定",
    "aliases": [
      "weight_definition"
    ],
    "examples": []
  },
  "maximum_sum_constraint": {
    "name": "maximum_sum_constraint",
    "description": "对子集元素之和施加最大化目标的优化约束，常用于在选择子集时追求最大总和的场景",
    "aliases": [
      "maximize_subset_sum",
      "range_query_max",
      "max_subarray_sum"
    ],
    "examples": []
  },
  "maximum_subtree_sum": {
    "name": "maximum_subtree_sum",
    "description": "对树结构中每个子树的元素之和施加最大化目标的优化约束，常用于在子树划分或路径选择中追求最大总和的场景",
    "aliases": [
      "subtree_sum_maximization"
    ],
    "examples": []
  },
  "grid_structure_isomorphism": {
    "name": "grid_structure_isomorphism",
    "description": "判断两个网格结构在形状、连接关系和布局上是否相同，即存在一种一一对应关系使得网格的拓扑结构保持不变，常用于网格类问题中的同构判定或等价性验证",
    "aliases": [
      "grid_isomorphism"
    ],
    "examples": []
  },
  "subtree_structure_constraint": {
    "name": "subtree_structure_constraint",
    "description": "对树结构中子树的形态、连接关系或属性施加的抽象约束条件，常用于保证子树满足特定结构或性质要求",
    "aliases": [
      "subtree_constraint"
    ],
    "examples": []
  },
  "minimum_value_constraint": {
    "name": "minimum_value_constraint",
    "description": "对数值集合中最小值施加特定约束或下限要求的抽象条件，常用于优化问题中确保最小值不低于某个阈值或最小累积量",
    "aliases": [
      "output_min_value"
    ],
    "examples": []
  },
  "symmetric_difference_sum_constraint": {
    "name": "symmetric_difference_sum_constraint",
    "description": "对多个集合的对称差集元素之和施加上限约束的条件，常用于集合运算中对差异总量的控制",
    "aliases": [
      "set_symmetric_difference_sum_leq_m"
    ],
    "examples": []
  },
  "minimum_ratio_constraint": {
    "name": "minimum_ratio_constraint",
    "description": "对一组数值中最小值与最大值之比施加最小化目标的优化约束，常用于优化问题中确保比例不低于某个阈值或最小累积量",
    "aliases": [
      "ratio_minimization"
    ],
    "examples": []
  },
  "element_count_constraint": {
    "name": "element_count_constraint",
    "description": "对集合或序列中元素总数施加特定限制的约束条件，常用于控制数据规模或结构大小",
    "aliases": [
      "total_elements",
      "array_length_bound"
    ],
    "examples": []
  },
  "distinct_value_count": {
    "name": "distinct_value_count",
    "description": "对数值集合中不同值的个数施加约束或统计的条件，常用于唯一性分析或多样性控制",
    "aliases": [
      "value_count",
      "distinct_values_constraint"
    ],
    "examples": []
  },
  "linear_equation_constraint": {
    "name": "linear_equation_constraint",
    "description": "对线性方程中变量系数或常数项施加特定约束或求解条件的抽象概念，常用于几何建模、坐标系变换或代数关系中的直线方程控制",
    "aliases": [
      "line_equation_constraint"
    ],
    "examples": []
  }
}