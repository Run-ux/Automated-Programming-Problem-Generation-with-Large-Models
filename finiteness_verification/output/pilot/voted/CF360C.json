{
  "problem_id": "CF360C",
  "source": "codeforces",
  "input_structure": {
    "type": "string",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "string",
          "length": {
            "min": 1,
            "max": 2000
          },
          "value_range": {
            "min": 97,
            "max": 122
          },
          "properties": {
            "charset": "a-z"
          }
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "string",
          "length": {
            "min": 1,
            "max": 2000
          },
          "value_range": {
            "min": 97,
            "max": 122
          },
          "properties": {
            "charset": "a-z"
          }
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "string",
          "length": {
            "min": 1,
            "max": 2000
          },
          "value_range": {
            "min": 97,
            "max": 122
          },
          "properties": {
            "charset": "a-z"
          }
        }
      }
    ],
    "length": {
      "min": 1,
      "max": 2000
    },
    "value_range": {
      "min": 97,
      "max": 122
    },
    "properties": {
      "charset": "a-z"
    }
  },
  "core_constraints": {
    "constraints": [
      {
        "name": "beauty_value_equals_k",
        "description": "字符串 t 相对于 s 的美丽值必须恰好等于 k",
        "confidence": "3/3"
      },
      {
        "name": "substring_lexicographically_larger",
        "description": "字符串 t 的子串 t[i..j] 必须在字典序上大于 s[i..j] 才能计入美丽值",
        "confidence": "3/3"
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "substring_lexicographically_larger",
              "description": "字符串 t 的子串 t[i..j] 必须在字典序上大于 s[i..j] 才能计入美丽值"
            },
            {
              "name": "beauty_value_equals_k",
              "description": "字符串 t 相对于 s 的美丽值必须恰好等于 k"
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "substring_lexicographically_larger",
              "description": "字符串 t 的子串 t[i..j] 必须在字典序上大于 s[i..j]，才能计入美丽值 k"
            },
            {
              "name": "beauty_value_equals_k",
              "description": "字符串 t 相对于 s 的美丽值必须恰好等于 k"
            },
            {
              "name": "substring_length",
              "description": "考虑的子串长度范围是从 1 到 n"
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "substring_lexicographically_larger",
              "description": "字符串 t 的子串 t[i..j] 必须在字典序上大于 s[i..j] 才能计入美丽值"
            },
            {
              "name": "beauty_value_equals_k",
              "description": "字符串 t 相对于 s 的美丽值必须恰好等于 k"
            }
          ]
        }
      }
    ]
  },
  "objective": {
    "type": "count",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "count",
          "description": "计算字符串t的数量，使得t相对于给定字符串s的美丽值恰好为k，并输出该数量对1000000007取模的结果"
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "count",
          "description": "计算美丽度恰好为k的字符串t的数量，结果对1000000007取模"
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "count",
          "description": "计算有多少个字符串t，使得它们相对于给定字符串s的美丽值恰好等于k，并输出该数量对1000000007取模的结果"
        }
      }
    ],
    "description": "计算字符串t的数量，使得t相对于给定字符串s的美丽值恰好为k，并输出该数量对1000000007取模的结果"
  },
  "invariant": {
    "name": "optimal_substructure",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "name": "optimal_substructure",
          "description": "问题的解可以通过子问题的解组合而成，即大问题的解依赖于其子问题的最优解。",
          "properties": {}
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "name": "optimal_substructure",
          "description": "问题的解可以通过子问题的解组合而成，即大问题的解依赖于其子问题的最优解。",
          "properties": {}
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "name": "optimal_substructure",
          "description": "问题的解可以通过子问题的解组合而成，即最优解包含子问题的最优解。",
          "properties": {}
        }
      }
    ],
    "description": "问题的解可以通过子问题的解组合而成，即大问题的解依赖于其子问题的最优解。"
  }
}