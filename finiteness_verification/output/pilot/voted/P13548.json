{
  "problem_id": "P13548",
  "source": "luogu",
  "input_structure": {
    "type": "weighted_undirected_graph",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "weighted_undirected_graph",
          "length": {
            "min": 4,
            "max": 200000
          },
          "value_range": {
            "min": 1,
            "max": 1000000000
          },
          "properties": {
            "connected": true,
            "weighted": true
          }
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "weighted_undirected_graph",
          "length": {
            "min": 4,
            "max": 200000
          },
          "value_range": {
            "min": 1,
            "max": 1000000000
          },
          "properties": {
            "connected": true,
            "weighted": true
          }
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "weighted_undirected_graph",
          "length": {
            "min": 4,
            "max": 200000
          },
          "value_range": {
            "min": 1,
            "max": 1000000000
          },
          "properties": {
            "connected": true,
            "weighted": true
          }
        }
      }
    ],
    "length": {
      "min": 4,
      "max": 200000
    },
    "value_range": {
      "min": 1,
      "max": 1000000000
    },
    "properties": {
      "connected": true,
      "weighted": true
    }
  },
  "core_constraints": {
    "constraints": [
      {
        "name": "connectivity",
        "description": "图必须连通（通过Berlaflot航班可以到达任何城市）",
        "confidence": "3/3"
      },
      {
        "name": "path_constraint",
        "description": "路径成本等于路径中最大边的成本（从城市t1到tk的路径成本等于该路径中所有边的最大成本）",
        "confidence": "3/3"
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "connectivity",
              "description": "图必须连通（通过Berlaflot航班可以到达任何城市）"
            },
            {
              "name": "path_constraint",
              "description": "路径成本等于路径中最大边的成本（从城市t1到tk的路径成本等于该路径中所有边的最大成本）",
              "formal": "cost(t1, tk) = max(cost(ti, ti+1)) for all i in [1, k-1]"
            },
            {
              "name": "connectivity",
              "description": "S8 Airlines连接所有未被Berlaflot连接的城市对，且通过S8 Airlines也可以到达任何城市"
            },
            {
              "name": "path_constraint",
              "description": "S8 Airlines的航班成本等于Berlaflot航线中的最小路径成本（对于每一对城市x和y，S8 Airlines的航班成本等于Berlaflot航线中的最小路径成本）",
              "formal": "cost_S8(x, y) = min(max(cost_Berlaflot(ti, ti+1))) for all paths from x to y"
            },
            {
              "name": "operation_limit",
              "description": "Berlaflot航班的新成本等于S8 Airlines航线中的最小路径成本（对于每一条Berlaflot航班，其新成本等于S8 Airlines航线中的最小路径成本）",
              "formal": "new_cost_Berlaflot(ai, bi) = cost_S8(ai, bi)"
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "connectivity",
              "description": "图必须连通（通过 Berlaflot 航班可以到达任意城市）"
            },
            {
              "name": "path_constraint",
              "description": "路径成本等于路径中最大边的成本（Berlaflot 和 S8 航班的路径成本计算方式）",
              "formal": "cost(t1, tk) = max(cost(ti, ti+1)) for all i in [1, k-1]"
            },
            {
              "name": "adjacency_relation",
              "description": "S8 航空公司提供所有未被 Berlaflot 航班连接的城市对之间的双向航班"
            },
            {
              "name": "path_constraint",
              "description": "S8 航班的成本等于 Berlaflot 航班中相应城市对的最小路径成本",
              "formal": "cost_S8(x, y) = min(max(cost_Berlaflot(ti, ti+1))) for all paths from x to y"
            },
            {
              "name": "transformation",
              "description": "Berlaflot 航班的新成本等于 S8 航班中相应城市对的最小路径成本",
              "formal": "new_cost_Berlaflot(ai, bi) = cost_S8(ai, bi)"
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "connectivity",
              "description": "图必须连通（通过 Berlaflot 航班可以到达任何城市）"
            },
            {
              "name": "path_constraint",
              "description": "路径成本等于路径中最大边的成本（Berlaflot 和 S8 航班的路径成本计算方式）",
              "formal": "cost(path) = max(cost(edge1), cost(edge2), ..., cost(edgek))"
            },
            {
              "name": "flow_constraint",
              "description": "S8 航班的成本等于 Berlaflot 航班路径中的最小最大边成本",
              "formal": "cost(S8(x, y)) = min(max(cost(Berlaflot(path))))"
            },
            {
              "name": "matching_constraint",
              "description": "每对城市之间要么有 Berlaflot 航班，要么有 S8 航班"
            }
          ]
        }
      }
    ]
  },
  "objective": {
    "type": "min_max",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "min_max",
          "description": "求每条边在新图中的最小瓶颈路径值"
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "min_max",
          "description": "求每条边在新图中的最小瓶颈路径值"
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "min_max",
          "description": "求每条边在新图中的最小瓶颈路径值"
        }
      }
    ],
    "description": "求每条边在新图中的最小瓶颈路径值"
  },
  "invariant": {
    "invariants": [
      {
        "name": "optimal_substructure",
        "description": "最优子结构：问题的最优解可以通过子问题的最优解组合得到，即最短路径问题中的路径成本由子路径的成本决定。",
        "confidence": "3/3",
        "properties": {}
      },
      {
        "name": "interval_mergeable",
        "description": "区间可合并性：在计算两个城市之间的最小成本路径时，可以将多个子区间的最优解合并以获得全局最优解。",
        "confidence": "3/3",
        "properties": {}
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：问题的最优解可以通过子问题的最优解组合得到，即最短路径问题中的路径成本由子路径的成本决定。",
              "properties": {}
            },
            {
              "name": "interval_mergeable",
              "description": "区间可合并性：在计算两个城市之间的最小成本路径时，可以将多个子区间的最优解合并以获得全局最优解。",
              "properties": {}
            },
            {
              "name": "symmetry",
              "description": "对称性：S8 航空公司的飞行成本计算是对称的，即从城市 x 到城市 y 的成本与从城市 y 到城市 x 的成本相同。",
              "properties": {}
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：问题的最优解可以通过子问题的最优解来构造。在本题中，任意两个城市之间的最短路径可以通过其子路径的最短路径来计算。",
              "properties": {}
            },
            {
              "name": "interval_mergeable",
              "description": "区间可合并性：通过合并子区间的最优解可以得到更大区间的最优解。在本题中，可以通过合并子路径的最短路径来计算整个路径的最短路径。",
              "properties": {}
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：问题的最优解可以通过子问题的最优解组合得到，即任意两个城市之间的最短路径可以通过中间城市的最短路径组合得到。",
              "properties": {}
            },
            {
              "name": "interval_mergeable",
              "description": "区间可合并性：在计算任意两点间的最小最大边权时，可以将路径划分为多个子路径，并通过合并这些子路径的结果来获得最终结果。",
              "properties": {}
            }
          ]
        }
      }
    ]
  }
}