{
  "problem_id": "P6774",
  "source": "luogu",
  "input_structure": {
    "type": "matrix",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "matrix",
          "length": {
            "min": 1,
            "max": 100000
          },
          "value_range": {
            "min": 1,
            "max": 100000
          },
          "properties": {
            "ordered": false
          }
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "matrix",
          "length": {
            "min": 1,
            "max": 100000
          },
          "value_range": {
            "min": 1,
            "max": 100000
          },
          "properties": {
            "ordered": false
          }
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "matrix",
          "length": {
            "min": 1,
            "max": 100000
          },
          "value_range": {
            "min": 1,
            "max": 100000
          },
          "properties": {
            "ordered": false
          }
        }
      }
    ],
    "length": {
      "min": 1,
      "max": 100000
    },
    "value_range": {
      "min": 1,
      "max": 100000
    },
    "properties": {
      "ordered": false
    }
  },
  "core_constraints": {
    "constraints": [
      {
        "name": "ordering",
        "description": "对于每对事件 (i, j)，如果 (x_i, y_i) ≤ (x_j, y_j)，则形成一次遗憾。",
        "confidence": "3/3"
      },
      {
        "name": "inclusion",
        "description": "每个时代用一个矩形表示，包含所有满足 (r_{i,1}, c_{i,1}) ≤ (x_j, y_j) ≤ (r_{i,2}, c_{i,2}) 的事件。",
        "confidence": "3/3"
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "ordering",
              "description": "对于每对事件 (i, j)，如果 (x_i, y_i) ≤ (x_j, y_j)，则形成一次遗憾。",
              "formal": "∀ i, j (1 ≤ i < j ≤ n), (x_i, y_i) ≤ (x_j, y_j) → 遗憾(i, j)"
            },
            {
              "name": "inclusion",
              "description": "每个时代用一个矩形表示，包含所有满足 (r_{i,1}, c_{i,1}) ≤ (x_j, y_j) ≤ (r_{i,2}, c_{i,2}) 的事件。",
              "formal": "∀ i (1 ≤ i ≤ m), 事件 j 被时代 i 包含 ↔ (r_{i,1}, c_{i,1}) ≤ (x_j, y_j) ≤ (r_{i,2}, c_{i,2})"
            },
            {
              "name": "operation_limit",
              "description": "每个时代的遗憾次数是该时代内所有事件形成的遗憾的总和。",
              "formal": "时代 i 的遗憾次数 = ∑ 遗憾(j, k) 其中 (j, k) 是时代 i 内的所有事件对"
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "ordering",
              "description": "对于每对事件 (i, j)，如果 (x_i, y_i) ≤ (x_j, y_j)，则形成一次遗憾。",
              "formal": "∀ i, j (1 ≤ i < j ≤ n), (x_i, y_i) ≤ (x_j, y_j) → 遗憾(i, j)"
            },
            {
              "name": "inclusion",
              "description": "每个时代用一个矩形表示，包含所有满足 (r_{i,1}, c_{i,1}) ≤ (x_j, y_j) ≤ (r_{i,2}, c_{i,2}) 的事件。",
              "formal": "∀ 时代 i, 事件 j, (r_{i,1}, c_{i,1}) ≤ (x_j, y_j) ≤ (r_{i,2}, c_{i,2}) → 事件 j 在时代 i 内"
            },
            {
              "name": "distinctness",
              "description": "事件的坐标 (i, p_i) 中的 p_i 是 1 到 n 的排列。",
              "formal": "p_i 是 1 到 n 的排列"
            },
            {
              "name": "custom_constraint",
              "description": "对于所有时代 i，有 c_{i,1} = 1, c_{i,2} = n。",
              "formal": "∀ 时代 i, c_{i,1} = 1 ∧ c_{i,2} = n"
            },
            {
              "name": "custom_constraint",
              "description": "任意两个不同时代所代表的矩形，要么是包含关系，要么是相离关系。",
              "formal": "∀ 时代 i, j (i ≠ j), 矩形 i 包含 矩形 j 或 矩形 i 与 矩形 j 相离"
            },
            {
              "name": "custom_constraint",
              "description": "最多有 50 对事件 (i, j) 不满足 (i, p_i) ≤ (j, p_j)。",
              "formal": "|{(i, j) | (i, p_i) ≰ (j, p_j)}| ≤ 50"
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "ordering",
              "description": "对于每对事件 (i, j)，如果 (x_i, y_i) ≤ (x_j, y_j)，则形成一次遗憾。",
              "formal": "∀ i, j ∈ [1, n], (x_i, y_i) ≤ (x_j, y_j) → 形成一次遗憾"
            },
            {
              "name": "inclusion",
              "description": "一个时代包含的事件必须满足其矩形范围内的坐标条件，即 (r_{i,1}, c_{i,1}) ≤ (x_j, y_j) ≤ (r_{i,2}, c_{i,2})。",
              "formal": "∀ 时代 i, 事件 j, (r_{i,1}, c_{i,1}) ≤ (x_j, y_j) ≤ (r_{i,2}, c_{i,2}) → 时代 i 包含事件 j"
            },
            {
              "name": "custom_constraint",
              "description": "对于所有时代 i，有 c_{i,1} = 1, c_{i,2} = n。",
              "formal": "∀ 时代 i, c_{i,1} = 1 ∧ c_{i,2} = n"
            },
            {
              "name": "custom_constraint",
              "description": "任意两个不同时代所代表的矩形，它们要么是包含关系（一个矩形在另一个矩形内，边界允许重合），要么是相离关系（两矩形不包含共同点，边界不允许重合）。",
              "formal": "∀ 时代 i, j (i ≠ j), 矩形 i 和 矩形 j 要么是包含关系，要么是相离关系"
            },
            {
              "name": "custom_constraint",
              "description": "最多有 50 对事件 (i, j) (1 ≤ i < j ≤ n) 不满足 (i, p_i) ≤ (j, p_j)。",
              "formal": "∃ 至多 50 对 (i, j) (1 ≤ i < j ≤ n), (i, p_i) ≰ (j, p_j)"
            }
          ]
        }
      }
    ]
  },
  "objective": {
    "type": "maximize_count",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "maximize_count",
          "description": "计算每个给定矩形区域内满足特定顺序关系的点对数量"
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "maximize_count",
          "description": "计算每个给定矩形区域内满足特定顺序关系的点对数量"
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "maximize_count",
          "description": "计算每个给定矩形区域内满足特定顺序关系的点对数量"
        }
      }
    ],
    "description": "计算每个给定矩形区域内满足特定顺序关系的点对数量"
  },
  "invariant": {
    "invariants": [
      {
        "name": "optimal_substructure",
        "description": "每个时代的遗憾次数可以通过子问题的解来计算。具体来说，可以通过动态规划或分治的方法，将大问题分解为小问题，并通过子问题的解来合成最终结果。",
        "confidence": "3/3",
        "properties": {}
      },
      {
        "name": "interval_additivity",
        "description": "通过前缀和可以计算区间内的遗憾次数。具体来说，可以通过维护一个前缀数组来快速计算某个时代内包含的所有事件形成的遗憾次数。",
        "confidence": "3/3",
        "properties": {}
      },
      {
        "name": "monotonicity",
        "description": "事件的坐标满足单调性，即对于任意两个事件 (i, p_i) 和 (j, p_j)，如果 i < j，则 x_i < x_j。这保证了事件在 x 轴上的顺序是固定的。",
        "confidence": "3/3",
        "properties": {
          "left_monotonic": true,
          "right_monotonic": false
        }
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "monotonicity",
              "description": "事件的坐标满足单调性，即对于任意两个事件 (i, p_i) 和 (j, p_j)，如果 i < j，则 x_i < x_j。这保证了事件在 x 轴上的顺序是固定的。",
              "properties": {
                "left_monotonic": true,
                "right_monotonic": false
              }
            },
            {
              "name": "interval_additivity",
              "description": "通过前缀和可以计算区间内的遗憾次数。具体来说，可以通过维护一个前缀数组来快速计算某个时代内包含的所有事件形成的遗憾次数。",
              "properties": {}
            },
            {
              "name": "optimal_substructure",
              "description": "每个时代的遗憾次数可以通过子问题的解来计算。具体来说，可以通过动态规划或分治的方法，将大问题分解为小问题，并通过子问题的解来合成最终结果。",
              "properties": {}
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：每个时代的眼泪大小可以通过其包含的事件子集计算得出，且该子集的遗憾次数是独立于其他时代的。",
              "properties": {}
            },
            {
              "name": "interval_additivity",
              "description": "区间可加性：通过前缀和可以高效计算任意区间的遗憾次数，即区间内的遗憾次数可以通过端点差值计算。",
              "properties": {}
            },
            {
              "name": "monotonicity",
              "description": "单调性：事件按坐标排序后，对于每个时代，其包含的事件范围是单调递增的，可以通过双指针或滑动窗口维护。",
              "properties": {
                "left_monotonic": true,
                "right_monotonic": true
              }
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：每个时代的遗憾次数可以通过其包含的事件子集计算得出，且该子集的遗憾次数是独立于其他时代计算的。",
              "properties": {}
            },
            {
              "name": "interval_additivity",
              "description": "区间可加性：在给定的时代矩形内，事件形成的遗憾次数可以通过区间端点的差值进行计算。",
              "properties": {}
            },
            {
              "name": "monotonicity",
              "description": "单调性：对于每个时代，其包含的事件集合随着时代矩形的变化而单调变化。",
              "properties": {
                "left_monotonic": true,
                "right_monotonic": true
              }
            }
          ]
        }
      }
    ]
  }
}