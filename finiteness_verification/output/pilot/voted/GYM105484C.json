{
  "problem_id": "GYM105484C",
  "source": "icpc_gym",
  "input_structure": {
    "type": "tree",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "tree",
          "length": {
            "min": 2,
            "max": 5000
          },
          "value_range": {
            "min": 1,
            "max": 4999
          },
          "properties": {
            "connected": true,
            "rooted": true
          }
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "tree",
          "length": {
            "min": 2,
            "max": 5000
          },
          "value_range": {
            "min": 1,
            "max": 4999
          },
          "properties": {
            "connected": true,
            "rooted": true
          }
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "tree",
          "length": {
            "min": 2,
            "max": 5000
          },
          "value_range": {
            "min": 1,
            "max": 4999
          },
          "properties": {
            "connected": true,
            "rooted": true
          }
        }
      }
    ],
    "length": {
      "min": 2,
      "max": 5000
    },
    "value_range": {
      "min": 1,
      "max": 4999
    },
    "properties": {
      "connected": true,
      "rooted": true
    }
  },
  "core_constraints": {
    "constraints": [
      {
        "name": "rooted_tree",
        "description": "树结构以顶点 1 为根，并且每个顶点的索引小于其所有子节点的索引",
        "confidence": "2/3"
      },
      {
        "name": "topological_sort",
        "description": "树的拓扑排序，对于所有 1 ≤ i < j ≤ n，顶点 p_j 不是顶点 p_i 的父节点",
        "confidence": "3/3"
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "topological_sort",
              "description": "树的拓扑排序，对于所有 1 ≤ i < j ≤ n，顶点 p_j 不是顶点 p_i 的父节点"
            },
            {
              "name": "rooted_tree",
              "description": "树结构以顶点 1 为根，并且每个顶点的索引小于其所有子节点的索引"
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "topological_sort",
              "description": "顶点的排列必须满足拓扑排序约束，即对于所有 1 ≤ i < j ≤ n，顶点 p_j 不是顶点 p_i 的父节点",
              "formal": "∀ 1 ≤ i < j ≤ n, p_j 不是 p_i 的父节点"
            },
            {
              "name": "position_constraint",
              "description": "每个顶点 i 在排列中的位置固定为 i，计算满足此条件的拓扑排序数量",
              "formal": "p_i = i"
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "topological_sort",
              "description": "顶点的排列必须满足拓扑排序约束，即对于所有 1 ≤ i < j ≤ n，顶点 p_j 不是顶点 p_i 的父节点"
            },
            {
              "name": "rooted_tree",
              "description": "给定的树是有根树，根节点为 1，并且每个节点的索引小于其所有子节点的索引"
            },
            {
              "name": "position_constraint",
              "description": "计算满足 p_i = i 的拓扑排序数量，即顶点 i 在排列中的位置固定"
            }
          ]
        }
      }
    ]
  },
  "objective": {
    "type": "enumeration",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "enumeration",
          "description": "求满足特定条件的排列数，对每个顶点计算其作为固定位置时的有效排列数量"
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "enumeration",
          "description": "求满足特定条件的排列数，对每个顶点计算其作为固定位置时的有效排列数量"
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "enumeration",
          "description": "对于每个顶点，计算满足特定条件的拓扑序数量"
        }
      }
    ],
    "description": "求满足特定条件的排列数，对每个顶点计算其作为固定位置时的有效排列数量"
  },
  "invariant": {
    "invariants": [
      {
        "name": "optimal_substructure",
        "description": "最优子结构：树的每个子树的拓扑排序数量可以独立计算，并且整个树的拓扑排序数量可以通过子树的结果组合得到。",
        "confidence": "3/3",
        "properties": {}
      },
      {
        "name": "topological_order",
        "description": "拓扑序不变量：对于任意节点，其在拓扑序中的位置必须在其所有祖先节点之后，且在其所有子节点之前。",
        "confidence": "3/3",
        "properties": {}
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：树的每个子树的拓扑排序数量可以独立计算，并且整个树的拓扑排序数量可以通过子树的结果组合得到。",
              "properties": {}
            },
            {
              "name": "topological_order",
              "description": "拓扑序不变量：对于任意节点，其在拓扑序中的位置必须在其所有祖先节点之后，且在其所有子节点之前。",
              "properties": {}
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：树的每个子树的拓扑序数量可以独立计算，并且整个树的拓扑序数量可以通过子树的拓扑序数量组合得到。",
              "properties": {}
            },
            {
              "name": "topological_order",
              "description": "拓扑序不变量：在给定的树中，每个节点的拓扑序位置受到其父节点和子节点的约束，满足DAG上的顺序依赖关系。",
              "properties": {}
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "topological_order",
              "description": "拓扑序不变量：在树的拓扑排序中，每个节点的子树节点必须出现在该节点之后",
              "properties": {}
            },
            {
              "name": "optimal_substructure",
              "description": "最优子结构：每个节点的拓扑序数量可以通过其子节点的拓扑序数量计算得出",
              "properties": {}
            }
          ]
        }
      }
    ]
  }
}