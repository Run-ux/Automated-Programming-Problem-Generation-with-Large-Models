{
  "problem_id": "CF496E",
  "source": "codeforces",
  "input_structure": {
    "type": "array",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "array",
          "length": {
            "min": 1,
            "max": 100000
          },
          "value_range": {
            "min": 1,
            "max": 1000000000
          },
          "properties": {
            "ordered": false
          }
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "array",
          "length": {
            "min": 1,
            "max": 100000
          },
          "value_range": {
            "min": 1,
            "max": 1000000000
          },
          "properties": {
            "ordered": false
          }
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "array",
          "length": {
            "min": 1,
            "max": 100000
          },
          "value_range": {
            "min": 1,
            "max": 1000000000
          },
          "properties": {
            "ordered": false
          }
        }
      }
    ],
    "length": {
      "min": 1,
      "max": 100000
    },
    "value_range": {
      "min": 1,
      "max": 1000000000
    },
    "properties": {
      "ordered": false
    }
  },
  "core_constraints": {
    "constraints": [
      {
        "name": "degree_bound",
        "description": "每个节点的度数（分配的任务数量）不超过给定的上限（度数约束）",
        "confidence": "2/3"
      },
      {
        "name": "coverage",
        "description": "所有元素必须被分配到某个节点（任务分配完整性约束）",
        "confidence": "3/3"
      },
      {
        "name": "range_bound",
        "description": "每个元素的区间必须完全包含在另一个元素的区间内（区间包含约束）",
        "confidence": "3/3"
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "range_bound",
              "description": "每个元素的区间必须完全包含在另一个元素的区间内（区间包含约束）",
              "formal": "∀i, j: c_i ≤ a_j ≤ b_j ≤ d_i"
            },
            {
              "name": "degree_bound",
              "description": "每个节点的度数（分配的任务数量）不超过给定的上限（度数约束）",
              "formal": "∀i: |{j | part_j assigned to actor_i}| ≤ k_i"
            },
            {
              "name": "coverage",
              "description": "所有元素必须被分配到某个节点（任务分配完整性约束）",
              "formal": "∀j: ∃i: part_j assigned to actor_i"
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "range_bound",
              "description": "每个元素的区间必须完全包含在另一个元素的区间内（部分分配约束）",
              "formal": "∀i, j: c_i ≤ a_j ≤ b_j ≤ d_i"
            },
            {
              "name": "flow_constraint",
              "description": "每个节点的出度不超过给定的上限（演员最多表演的剧目数量限制）",
              "formal": "∀i: |{j | actor i can perform part j}| ≤ k_i"
            },
            {
              "name": "coverage",
              "description": "所有元素必须被分配到某个节点（所有剧目必须被分配给某个演员）",
              "formal": "∀j: ∃i: actor i performs part j"
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "constraints": [
            {
              "name": "range_bound",
              "description": "每个元素的区间必须完全包含在另一个元素的区间内（区间包含约束）",
              "formal": "∀i, j: c_i ≤ a_j ≤ b_j ≤ d_i"
            },
            {
              "name": "degree_bound",
              "description": "每个节点的出度不超过给定的上限（度数约束）",
              "formal": "∀i: |{j | part_j assigned to actor_i}| ≤ k_i"
            },
            {
              "name": "coverage",
              "description": "所有元素必须被分配到某个节点（分配完整性约束）",
              "formal": "∀j: ∃i: part_j assigned to actor_i"
            }
          ]
        }
      }
    ]
  },
  "objective": {
    "type": "feasibility",
    "confidence": "3/3",
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "type": "feasibility",
          "description": "判断是否存在一种分配方案，使得每个部分都被分配给一个满足条件的演员"
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "type": "feasibility",
          "description": "判断是否存在一种分配方案，使得每个部分都被分配给一个满足条件的演员"
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "type": "feasibility",
          "description": "判断是否存在一种分配方案，使得每个部分都被分配给一个满足条件的演员"
        }
      }
    ],
    "description": "判断是否存在一种分配方案，使得每个部分都被分配给一个满足条件的演员"
  },
  "invariant": {
    "invariants": [
      {
        "name": "optimal_substructure",
        "description": "最优子结构：每个部分的分配依赖于之前部分的最优分配方案，且当前部分的最优分配不会影响之前的最优解。",
        "confidence": "3/3",
        "properties": {}
      },
      {
        "name": "interval_mergeable",
        "description": "区间可合并性：演员和部分的音域范围可以被合并处理，通过合并操作来简化问题规模。",
        "confidence": "3/3",
        "properties": {}
      },
      {
        "name": "greedy_choice",
        "description": "贪心选择性质：在满足条件的情况下，优先选择当前可用的演员进行分配，以确保局部最优解。",
        "confidence": "3/3",
        "properties": {}
      }
    ],
    "all_rounds": [
      {
        "round": 1,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：每个部分的分配依赖于之前部分的最优分配方案，且当前部分的最优分配不会影响之前的最优解。",
              "properties": {}
            },
            {
              "name": "greedy_choice",
              "description": "贪心选择性质：在满足条件的情况下，优先选择当前可用的演员进行分配，以确保局部最优解。",
              "properties": {}
            },
            {
              "name": "interval_mergeable",
              "description": "区间可合并性：演员和部分的音域范围可以被合并处理，通过合并操作来简化问题规模。",
              "properties": {}
            }
          ]
        }
      },
      {
        "round": 2,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：每个部分的分配可以基于已解决的子问题的最优解来构建，即如果一个演员可以演唱某个部分，则该部分的分配可以基于该演员已经分配的部分数量来决定。",
              "properties": {}
            },
            {
              "name": "greedy_choice",
              "description": "贪心选择性质：在满足条件的情况下，优先为当前可选的演员分配尽可能多的部分，以确保局部最优解能够导致全局最优解。",
              "properties": {}
            },
            {
              "name": "interval_mergeable",
              "description": "区间可合并性：通过将演员和部分的音域表示为区间，并利用区间合并的方法来高效地找到可行的分配方案。",
              "properties": {}
            }
          ]
        }
      },
      {
        "round": 3,
        "status": "success",
        "result": {
          "invariants": [
            {
              "name": "optimal_substructure",
              "description": "最优子结构：每个部分的分配依赖于其可行演员集合中的最优选择，且全局最优解由这些局部最优解组成。",
              "properties": {}
            },
            {
              "name": "greedy_choice",
              "description": "贪心选择性质：对于每个部分，优先选择当前可行演员中能承担最多剩余部分的演员进行分配，以确保尽可能多的部分被分配。",
              "properties": {}
            },
            {
              "name": "interval_mergeable",
              "description": "区间可合并性：通过维护一个数据结构（如线段树或平衡树），可以高效地查询和更新演员的可行区间，并在分配过程中动态维护这些区间。",
              "properties": {}
            }
          ]
        }
      }
    ]
  }
}