{
  "problem_id": "CF360C",
  "source": "codeforces",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "string",
        "length": {
          "min": 1,
          "max": 2000
        },
        "value_range": {
          "min": 97,
          "max": 122
        },
        "properties": {
          "ordered": false
        }
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "string",
        "length": {
          "min": 1,
          "max": 2000
        },
        "value_range": {
          "min": 97,
          "max": 122
        },
        "properties": {
          "ordered": false
        }
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "string",
        "length": {
          "min": 1,
          "max": 2000
        },
        "value_range": {
          "min": 97,
          "max": 122
        },
        "properties": {
          "ordered": false
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "subsequence_constraint",
            "description": "子串的字典序比较（t[i..j] 必须大于 s[i..j]）"
          },
          {
            "name": "ordering",
            "description": "字符串按字典序比较（字符按 ASCII 码值比较）"
          },
          {
            "name": "ordering",
            "description": "字符串 t 的美丽度相对于 s 恰好为 k（满足条件的子串对数等于 k）"
          },
          {
            "name": "modular_arithmetic",
            "description": "结果取模 1000000007（10^9 + 7）"
          }
        ]
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "subsequence_constraint",
            "description": "子串的字典序比较（t[i..j] 必须大于 s[i..j]）"
          },
          {
            "name": "exclusion",
            "description": "字符串 t 的美度必须恰好等于 k（即满足条件的子串对数为 k）"
          },
          {
            "name": "modular_arithmetic",
            "description": "结果需要取模 1000000007"
          }
        ]
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "ordering",
            "description": "字符串 t 的子串 [i..j] 必须在字典序上大于 s 的对应子串 [i..j]",
            "formal": "∀ i, j (1 ≤ i ≤ j ≤ n), t[i..j] > s[i..j]"
          },
          {
            "name": "ordering",
            "description": "字符串 t 的美丽值（相对于 s）必须等于 k，即满足字典序大于条件的子串对数为 k",
            "formal": "count(i, j | 1 ≤ i ≤ j ≤ n ∧ t[i..j] > s[i..j]) = k"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "enumeration",
        "description": "求满足特定条件的字符串数量（模10^9+7）"
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "enumeration",
        "description": "求满足特定条件的字符串数量（模10^9+7）"
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "enumeration",
        "description": "求满足特定条件的字符串数量（取模）"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：问题的解可以通过子问题的解来构建，即字符串 t 的美丽值 k 可以通过其子串的美丽值来计算。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：在动态规划过程中，当前状态的美丽值可以通过前一个状态的美丽值和当前字符的比较结果来确定。",
            "properties": {}
          }
        ]
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：问题的解可以通过子问题的解来构造，即字符串 t 的美丽值 k 可以通过其子串的美丽值来计算。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：在动态规划过程中，当前状态的美丽值依赖于前一个状态的美丽值和当前字符的选择。",
            "properties": {}
          }
        ]
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：问题的解可以通过子问题的解来构建，即字符串 t 的美丽值 k 可以通过其子串的美丽值来计算。",
            "properties": {}
          },
          {
            "name": "state_transition",
            "description": "状态转移不变量：动态规划中的状态转移方程保持一致性，当前状态的值依赖于前一个或多个状态的值。",
            "properties": {}
          }
        ]
      }
    }
  ]
}