{
  "problem_id": "CF1265E",
  "source": "codeforces",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "array",
        "length": {
          "min": 1,
          "max": 200000
        },
        "value_range": {
          "min": 1,
          "max": 100
        },
        "properties": {}
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "array",
        "length": {
          "min": 1,
          "max": 200000
        },
        "value_range": {
          "min": 1,
          "max": 100
        },
        "properties": {}
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "array",
        "length": {
          "min": 1,
          "max": 200000
        },
        "value_range": {
          "min": 1,
          "max": 100
        },
        "properties": {}
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "unknown",
            "description": "每个镜子告诉 Creatnx 他很美的概率为 p_i/100，其中 1 ≤ p_i ≤ 100。",
            "formal": "1 ≤ p_i ≤ 100"
          },
          {
            "name": "tree_must_be_complete_mirror",
            "description": "Creatnx 按顺序从第 1 个镜子开始询问，直到某个镜子告诉他很美为止。",
            "formal": "for i from 1 to n, ask mirror i until it says 'beautiful'"
          },
          {
            "name": "unknown",
            "description": "计算 Creatnx 变得快乐所需的期望天数，并对 998244353 取模。",
            "formal": "E(days) % 998244353"
          },
          {
            "name": "output_any_valid_root_or_minus_one",
            "description": "答案应表示为一个不可约分数 p/q，其中 p 和 q 是整数且 q 不是 998244353 的倍数。输出 x 使得 0 ≤ x < 998244353 且 x * q ≡ p (mod 998244353)。",
            "formal": "x = p * q^(-1) % 998244353, 0 ≤ x < 998244353, x * q ≡ p (mod 998244353)"
          }
        ]
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "unknown",
            "description": "每个镜子告诉Creatnx他很美的概率为p_i/100，其中1 ≤ p_i ≤ 100。",
            "formal": "1 ≤ p_i ≤ 100"
          },
          {
            "name": "tree_must_be_complete_mirror",
            "description": "Creatnx按顺序从第1个镜子开始询问，每天只问一个镜子。",
            "formal": "询问顺序为1, 2, ..., n"
          },
          {
            "name": "unknown",
            "description": "计算直到Creatnx感到快乐的期望天数，并将结果对998244353取模。",
            "formal": "结果 = (p * q^{-1}) % 998244353"
          }
        ]
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "unknown",
            "description": "每个镜子告诉 Creatnx 他很美的概率为 p_i/100，其中 1 ≤ p_i ≤ 100。",
            "formal": "1 ≤ p_i ≤ 100"
          },
          {
            "name": "tree_must_be_complete_mirror",
            "description": "Creatnx 按顺序从第 1 个镜子开始询问，直到某个镜子告诉他很美为止。",
            "formal": "for i from 1 to n, ask mirror i until a mirror says 'beautiful'"
          },
          {
            "name": "unknown",
            "description": "计算 Creatnx 变得快乐所需的期望天数，并对 998244353 取模。结果应表示为一个不可约分数 p/q，输出 x 使得 0 ≤ x < M 且 x * q ≡ p (mod M)。",
            "formal": "x = (p * q^(-1)) % 998244353"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "min_cost",
        "description": "求Creatnx变得开心所需的期望天数，结果需要对998244353取模"
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "min_days",
        "description": "计算Creatnx变得开心所需的期望天数，并输出该值对998244353取模的结果"
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "min_cost",
        "description": "计算Creatnx变得开心所需的期望天数，并输出该值对998244353取模的结果"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "name": "optimal_substructure",
        "description": "问题的解可以通过子问题的解组合而成，即每一天的期望天数可以基于前一天的结果进行计算。",
        "properties": {}
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "name": "optimal_substructure",
        "description": "问题的解可以通过子问题的解来构建，即当前镜子的期望天数依赖于后续镜子的期望天数。",
        "properties": {}
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "name": "optimal_substructure",
        "description": "问题的解可以通过子问题的解组合而成，即当前镜子的期望天数可以基于前一个镜子的期望天数计算得出。",
        "properties": {}
      }
    }
  ]
}