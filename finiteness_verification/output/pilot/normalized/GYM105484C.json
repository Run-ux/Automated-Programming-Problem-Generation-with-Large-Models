{
  "problem_id": "GYM105484C",
  "source": "icpc_gym",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "tree",
        "length": {
          "min": 2,
          "max": 5000
        },
        "value_range": {
          "min": 1,
          "max": 4999
        },
        "properties": {
          "connected": true,
          "rooted": true,
          "ordered": true
        }
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "tree",
        "length": {
          "min": 2,
          "max": 5000
        },
        "value_range": {
          "min": 1,
          "max": 4999
        },
        "properties": {
          "connected": true,
          "rooted": true,
          "ordered": true
        }
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "tree",
        "length": {
          "min": 2,
          "max": 5000
        },
        "value_range": {
          "min": 1,
          "max": 4999
        },
        "properties": {
          "rooted": true,
          "ordered": true
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "topological_order_constraint",
            "description": "对于所有 1 ≤ i < j ≤ n，顶点 p_j 不是顶点 p_i 的父节点。",
            "formal": "∀ 1 ≤ i < j ≤ n, parent(p_j) ≠ p_i"
          },
          {
            "name": "graph_is_tree",
            "description": "给定的树以顶点 1 为根，并且每个顶点的索引都小于其所有子节点的索引。",
            "formal": "root = 1, ∀ vertex v, index(v) < index(child(v))"
          },
          {
            "name": "topological_order_constraint",
            "description": "计算满足 p_i = i 的拓扑序的数量，结果对 998244353 取模。",
            "formal": "count topological orders where p_i = i, result % 998244353"
          }
        ]
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "topological_order_constraint",
            "description": "对于所有 1 ≤ i < j ≤ n，顶点 p_j 不是顶点 p_i 的父节点。",
            "formal": "∀ 1 ≤ i < j ≤ n, p_j 不是 p_i 的父节点"
          },
          {
            "name": "graph_is_tree",
            "description": "给定的树以顶点 1 为根，并且每个顶点的索引都小于其所有子节点的索引。",
            "formal": "树以 1 为根，且 ∀ i > 1, f_i < i"
          },
          {
            "name": "topological_order_constraint",
            "description": "对于每个 1 ≤ i ≤ n，计算满足 p_i = i 的拓扑序的数量，结果对 998244353 取模。",
            "formal": "计算满足 p_i = i 的拓扑序数量，结果对 998244353 取模"
          }
        ]
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "topological_order_constraint",
            "description": "对于所有 1 ≤ i < j ≤ n，顶点 p_j 不是顶点 p_i 的父节点。",
            "formal": "∀ 1 ≤ i < j ≤ n, p_j is not the parent of p_i"
          },
          {
            "name": "graph_is_tree",
            "description": "给定的树以顶点 1 为根，并且每个顶点的索引都小于其所有子节点的索引。",
            "formal": "The tree is rooted at vertex 1 and for all vertices i, f_i < i where f_i is the parent of i"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "count",
        "description": "计算给定树中满足条件的拓扑序数量，其中每个顶点i作为第i个位置的排列数，结果对998244353取模"
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "count",
        "description": "对于每个顶点i，计算满足条件p_i=i的拓扑序的数量，结果对998244353取模"
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "count",
        "description": "计算给定树中满足条件的拓扑序数量，其中每个顶点i作为第i个位置的拓扑序的数量"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "name": "optimal_substructure",
        "description": "问题的解可以通过子问题的解组合而成，即每个节点的拓扑排序数量可以由其子树的拓扑排序数量计算得出。",
        "properties": {}
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "name": "optimal_substructure",
        "description": "问题的解可以通过子树的解组合而成，即每个节点的解依赖于其子节点的解。",
        "properties": {}
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "name": "optimal_substructure",
        "description": "问题的解可以通过子问题的解组合而成，即每个节点的拓扑排序数量可以由其子树的拓扑排序数量计算得出。",
        "properties": {}
      }
    }
  ]
}