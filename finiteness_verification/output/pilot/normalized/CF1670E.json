{
  "problem_id": "CF1670E",
  "source": "codeforces",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "tree",
        "length": {
          "min": 2,
          "max": 131072
        },
        "value_range": {
          "min": 1,
          "max": 262143
        },
        "properties": {
          "connected": true
        }
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "tree",
        "length": {
          "min": 2,
          "max": 131072
        },
        "value_range": {
          "min": 1,
          "max": 262143
        },
        "properties": {
          "connected": true
        }
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "tree",
        "length": {
          "min": 2,
          "max": 131072
        },
        "value_range": {
          "min": 1,
          "max": 262143
        },
        "properties": {
          "connected": true
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "distinctness",
            "description": "所有节点和边的值必须是唯一的，且在范围 [1, 2n-1] 内",
            "formal": "∀ i, j ∈ {nodes ∪ edges}, i ≠ j → value(i) ≠ value(j), 1 ≤ value(i) ≤ 2n-1"
          },
          {
            "name": "path_constraint",
            "description": "选择一个根节点，使得从该根节点到任何节点或边的简单路径的最大成本（路径上所有节点和边的值的异或）最小化",
            "formal": "minimize(max(cost(root, v) for all nodes v and edges e)), where cost(u, v) = XOR(values on the path from u to v)"
          }
        ]
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "distinctness",
            "description": "所有节点和边的值必须是唯一的，且在范围 [1, 2n-1] 内。",
            "formal": "∀ i, j ∈ {nodes ∪ edges}, value(i) ≠ value(j) 且 1 ≤ value(i) ≤ 2n-1"
          },
          {
            "name": "path_constraint",
            "description": "选择一个根节点，使得从该根节点到任何节点或边的简单路径的最大成本最小化。路径的成本定义为路径上所有节点和边的值的按位异或结果。",
            "formal": "minimize(max(cost(root, v) for all v in nodes ∪ edges)), where cost(u, v) = XOR(values on the path from u to v)"
          }
        ]
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "distinctness",
            "description": "所有节点和边的值必须是唯一的，且在范围 [1, 2n-1] 内",
            "formal": "∀ i, j ∈ {nodes ∪ edges}, i ≠ j → value(i) ≠ value(j), 1 ≤ value(i) ≤ 2n-1"
          },
          {
            "name": "path_constraint",
            "description": "选择一个根节点，使得从该根节点到任何节点或边的简单路径的最大成本最小化。路径成本定义为路径上所有节点和边的值的异或和。",
            "formal": "minimize(max(cost(root, v) for all v in nodes ∪ edges)), where cost(u, v) = XOR(values on the path from u to v)"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "min_max",
        "description": "选择根节点并为每个节点和边分配值，使得从根节点出发到任意节点或边的路径的最大成本最小化"
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "min_max",
        "description": "选择一个根节点，并为每个节点和边分配唯一的整数值，使得从该根节点出发到任意节点或边的简单路径的最大成本（路径上所有节点和边的值的异或和）最小化"
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "min_max",
        "description": "选择根节点并为每个节点和边分配值，使得从根节点出发到任意节点或边的简单路径的最大成本（定义为路径上所有节点和边的值的异或和）最小化"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：树的任意子树的最优解可以组合成整棵树的最优解，通过递归或动态规划的方式求解。",
            "properties": {}
          },
          {
            "name": "symmetry",
            "description": "对称性：在树上进行节点和边的值分配时，可以通过对称变换（如旋转、翻转）来保持问题结构不变，从而简化问题。",
            "properties": {}
          },
          {
            "name": "divide_conquer",
            "description": "分治不变量：将大问题分解为子问题，每个子问题的解可以独立求解，并且这些子问题的解可以合并成原问题的解。",
            "properties": {}
          }
        ]
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：树的任意子树的最优解可以组合成整个树的最优解",
            "properties": {}
          },
          {
            "name": "symmetry",
            "description": "对称性：树中节点和边的值分配具有对称性质，使得从任意根节点出发的路径成本最小化",
            "properties": {}
          }
        ]
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "optimal_substructure",
            "description": "最优子结构：树的任意子树的最优解可以用来构建整棵树的最优解，即通过子树的最小化路径成本来确定整棵树的最小化路径成本。",
            "properties": {}
          },
          {
            "name": "symmetry",
            "description": "对称性：在树上进行节点和边的值分配时，可以通过对称变换（如节点与边的值交换）来保持问题结构不变，从而不影响最终结果。",
            "properties": {}
          }
        ]
      }
    }
  ]
}