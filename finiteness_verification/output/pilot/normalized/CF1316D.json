{
  "problem_id": "CF1316D",
  "source": "codeforces",
  "input_structure": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "matrix",
        "length": {
          "min": 1,
          "max": 1000
        },
        "value_range": {
          "min": -1,
          "max": 1000
        },
        "properties": {
          "inferred": true
        }
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "matrix",
        "length": {
          "min": 1,
          "max": 1000
        },
        "value_range": {
          "min": -1,
          "max": 1000
        },
        "properties": {
          "inferred": true
        }
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "matrix",
        "length": {
          "min": 1,
          "max": 1000
        },
        "value_range": {
          "min": -1,
          "max": 1000
        },
        "properties": {
          "inferred": true
        }
      }
    }
  ],
  "core_constraints": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "state_transition",
            "description": "每个节点根据其上的字符进行状态转移，直到到达终止状态（X）或无限循环。",
            "formal": "对于每个节点 (r, c)，根据字符 U, D, L, R 或 X 进行状态转移。"
          },
          {
            "name": "operation_limit",
            "description": "玩家在遇到 X 字符时停止移动，否则继续移动直到进入无限循环。",
            "formal": "如果当前节点的字符是 X，则停止；否则，根据字符指示的方向移动到下一个节点。"
          },
          {
            "name": "range_bound",
            "description": "玩家不能移出网格边界。",
            "formal": "所有移动必须保持在 1 ≤ r, c ≤ n 的范围内。"
          },
          {
            "name": "independence",
            "description": "给定的终止位置信息必须与生成的网格一致。",
            "formal": "对于每个起始节点 (i, j)，最终停止的位置 (x_j, y_j) 必须与网格中的路径一致。"
          }
        ]
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "state_transition",
            "description": "每个节点的转移规则必须是 U, D, L, R 或 X 之一，且根据规则移动到相邻节点或停留在当前节点"
          },
          {
            "name": "acyclicity",
            "description": "从任意节点出发，最终必须到达一个终止节点（X）或进入无限循环"
          },
          {
            "name": "range_bound",
            "description": "玩家在移动过程中不能移出边界"
          },
          {
            "name": "operation_limit",
            "description": "玩家在遇到 X 时停止移动"
          }
        ]
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "constraints": [
          {
            "name": "state_transition",
            "description": "每个节点根据其上的字符进行状态转移，直到到达终止状态（X）或无限循环。",
            "formal": "对于每个节点 (r, c)，根据字符 U, D, L, R 或 X 进行移动，直到遇到 X 或进入循环。"
          },
          {
            "name": "operation_limit",
            "description": "玩家在遇到 X 时停止移动，否则会一直移动直到进入无限循环。",
            "formal": "如果当前节点为 X，则停止；否则继续移动直到进入循环。"
          },
          {
            "name": "range_bound",
            "description": "玩家的移动不会超出网格边界。",
            "formal": "所有移动操作保证 (r, c) 在 [1, n] × [1, n] 范围内。"
          },
          {
            "name": "independence",
            "description": "给定的终止位置信息必须与生成的网格一致，即从每个起点出发，最终停在指定的位置或进入无限循环。",
            "formal": "对于每个起点 (i, j)，根据网格字符移动后，最终停在 (x_j, y_j) 或进入无限循环。"
          }
        ]
      }
    }
  ],
  "objective": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "type": "feasibility",
        "description": "判断是否存在一个满足给定条件的矩阵"
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "type": "feasibility",
        "description": "判断是否存在一个满足给定条件的矩阵"
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "type": "feasibility",
        "description": "判断是否存在一个满足给定条件的矩阵"
      }
    }
  ],
  "invariant": [
    {
      "round": 1,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "state_transition",
            "description": "状态转移不变量：每个单元格的指令决定了下一个单元格的状态，且这种状态转移是确定性的。",
            "properties": {}
          },
          {
            "name": "cycle_invariant",
            "description": "环不变量：如果存在一个循环路径，则该路径上的所有单元格将形成一个封闭的环，且玩家会在该环上无限循环。",
            "properties": {}
          },
          {
            "name": "topological_order",
            "description": "拓扑序不变量：对于非循环路径，可以构建一个有向无环图（DAG），其中每个节点表示一个单元格，边表示从一个单元格到另一个单元格的移动。在这样的图中，存在一个拓扑排序。",
            "properties": {}
          }
        ]
      }
    },
    {
      "round": 2,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "state_transition",
            "description": "状态转移不变量：每个单元格的指令决定了下一个单元格的状态，且这种状态转移是确定性的。",
            "properties": {}
          },
          {
            "name": "cycle_invariant",
            "description": "环不变量：如果存在一个环，则该环内的所有单元格将无限循环，不会进入阻塞区。",
            "properties": {}
          },
          {
            "name": "topological_order",
            "description": "拓扑序不变量：从任意起点出发，按照指令移动，最终要么到达一个阻塞区，要么进入一个环。这种顺序依赖关系可以看作是一种拓扑序。",
            "properties": {}
          }
        ]
      }
    },
    {
      "round": 3,
      "status": "success",
      "result": {
        "invariants": [
          {
            "name": "state_transition",
            "description": "状态转移不变量：每个单元格的状态（U, D, L, R, X）决定了下一个单元格的位置，且这种转移关系在整个游戏过程中保持一致。",
            "properties": {}
          },
          {
            "name": "cycle_invariant",
            "description": "环不变量：如果从某个单元格出发，最终会回到该单元格或进入一个循环路径，则该路径上的所有单元格都必须满足相同的转移规则，形成一个封闭的环。",
            "properties": {}
          },
          {
            "name": "topological_order",
            "description": "拓扑序不变量：在没有环的情况下，可以将所有单元格按照其转移方向进行拓扑排序，确保每个单元格的转移目标在其之后。",
            "properties": {}
          }
        ]
      }
    }
  ]
}